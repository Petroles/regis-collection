<?xml version="1.0" encoding="utf-8"?>
<add>
	<doc>
		<field name="docid">BR-TU.13003</field>
		<field name="filename">18812_arquivo7289_1.pdf</field>
		<field name="filetype">PDF</field>
		<field name="text">
 

 
Pós-Graduação em Ciência da Computação 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

“DESENVOLVIMENTO RIGOROSO COM  
UML-RT” 

 
Por 

 

Rodrigo Teixeira Ramos  
 

Dissertação de Mestrado 
 

 
 
 

 
 

Universidade Federal de Pernambuco 
posgraduacao@cin.ufpe.br 

www.cin.ufpe.br/~posgraduacao 
 
 

RECIFE, ABRIL/2005 



Universidade Federal de Pernambuco
Centro de Informa?tica

Rodrigo Teixeira Ramos

DESENVOLVIMENTO RIGOROSO COM UML-RT

Trabalho apresentado ao Programa de Po?s-graduac?a?o em

Cie?ncia da Computac?a?o do Centro de Informa?tica da Uni-

versidade Federal de Pernambuco como requisito parcial

para obtenc?a?o do grau de Mestre em Cie?ncia da Com-

putac?a?o.

Orientador: Augusto Cesar Alves Sampaio

Co-orientador: Alexandre Cabral Mota

Recife
Abril/2005





Aos meus pais pelo exemplo de cara?ter, fortaleza e bon-

dade.



AGRADECIMENTOS

... eu poderia suportar, embora na?o sem dor, que tivessem morrido todos

os meus amores, mas enlouqueceria se morressem todos os meus amigos!

Ate? mesmo aqueles que na?o percebem o quanto sa?o meus amigos e o

quanto minha vida depende de suas existe?ncias ... A alguns deles na?o

procuro, basta-me saber que eles existem. Esta mera condic?a?o me

encoraja a seguir em frente pela vida ... mas e? delicioso que eu saiba e

sinta que os adoro, embora na?o declare e na?o os procure ...

—VIN?ICIUS DE MORAES (Para voce?, com carinho)

Terminada mais esta etapa da grande jornada da vida, sinto-me grato a? diversas pes-
soas que contribu??ram direta ou indiretamente para o meu aprendizado e fortalecimento
durante estes dois anos de mestrado. A estas, manifesto, agora, meus profundos e sinceros
agradecimentos.

Sou grato a Deus por estar sempre presente em minha vida e por ter me honrado com
o afeto e o companheirismo de tantos amigos. Dentre eles, ressalto: os meus grandes
amigos Leonardo Cole e Danielly Cruz, que tanto me ajudaram em todas as horas com
sua amizade fraterna e sincera; Ma?rcio Dahia, que com seu bom grande humor me ajudou
a enfrentar alguns tediosos dias no Cin; e Fernando Trinta e Thiago Santos, que sempre
tomei como exemplos de disciplina e obstinac?a?o na busca de meus ideais. Agradec?o
tambe?m aos amigos Ma?rcio Corne?lio, Rafael Borges, Rohit Gheyi, Thiago Massoni pelas
enriquecedoras discusso?es.

Expresso meus agradecimentos aos professores Augusto Sampaio e Alexandre Mota
pela inu?meras ajudas e sugesto?es durante o meu mestrado. Mais do que orientadores, eles
foram bons e pre?stimos amigos durante todo este per??odo. Principalmente, sou grato a?
Augusto pela preocupac?a?o com a minha formac?a?o e pelos duradouros ensinamentos, que
levarei pelo restante da minha vida.

Por fim, e sobretudo, gostaria de manifestar minha especial gratida?o aos meus pais,
a quem devo na?o apenas esta conquista mas tudo o que sou, meus irma?os, e a? Sabrina,
minha namorada e amiga, pelo amor e pela confianc?a inabala?veis.

iv



RESUMO

Como outros me?todos visuais orientados a objetos, UML tem influenciado tremendamente
a pra?tica de modelagem na engenharia de software com ricos mecanismos de estruturac?a?o.
Pore?m, apesar de suas vantagens e adoc?a?o em larga escala, na pra?tica, a falta de uma
sema?ntica formal tem dificultado o desenvolvimento rigoroso baseado em modelos de
aplicac?o?es na?o triviais (aplicac?o?es que por sua natureza necessitam de e?nfase na especi-
ficac?a?o e na verificac?a?o de seus componentes). A raza?o para isto e? que transformac?o?es
de modelos podem na?o preservar a sema?ntica e, como consequ?e?ncia, o comportamento
do modelo. Este problema e? ainda mais se?rio em transformac?o?es que envolvem diferentes
viso?es do modelo.

Limitac?o?es similares podem ser encontradas durante o desenvolvimento com UML-
RT. Esta linguagem e? uma extensa?o conservativa de UML que prove? a noc?a?o de objetos
ativos (objetos com um comportamento pro?prio, independente do fluxo de execuc?a?o do
restante do sistema) para descrever aplicac?o?es concorrentes e distribu??das. Neste tipo de
desenvolvimento, transformac?o?es devem lidar simultaneamente com as diferentes viso?es
esta?ticas e dina?micas do modelo, representadas por seus diagramas e propriedades.

Por estes motivos, este trabalho propo?e uma sema?ntica para UML-RT, mapeando
suas construc?o?es em OhCircus, uma linguagem formal, orientada a objetos, que combina
CSP e Z, e que suporta o ca?lculo de refinamentos de Morgan. A partir desta sema?ntica,
bem como das noc?o?es e leis de refinamentos de OhCircus, e? poss??vel propor leis de trans-
formac?a?o de modelos pass??veis de demonstrac?a?o e que preservam o comportamento do
sistema.

Estas leis de transformac?a?o sa?o propostas em duas categorias: a primeira delas e? um
conjunto abrangente de leis ba?sicas que expressam pequenas mudanc?as nas principais
viso?es do modelo, como a declarac?a?o ou remoc?a?o de elementos do modelo; ja? a segunda
representa leis de transformac?a?o de maior granularidade, derivadas a partir da composic?a?o
de leis ba?sicas, como a decomposic?a?o de uma ca?psulas em ca?psulas operando em para-
lelo. Tais transformac?o?es derivadas podem ser vistas como refatoramentos (refactorings)
corretos sobre o modelo, facilmente aplica?veis durante um processo de desenvolvimento
rigoroso, sem que o desenvolvedor tenha conhecimento do formalismo que o suporta.

Finalmente, a abrange?ncia deste conjunto de leis e? discutida particularmente atrave?s
dos principais passos de uma estrate?gia de reduc?a?o de modelos UML-RT a um modelo
UML estendido com um u?nico objeto ativo, responsa?vel por todas as interac?o?es com o
ambiente e por conservar o comportamento dina?mico do sistema modelado. Este modelo
UML estendido pode ser visto como uma forma normal, e, portanto, nossa estrate?gia
pode ser vista como uma contribuic?a?o para uma estrate?gia mais global de completude
capturada por reduc?a?o a esta forma normal.

v



resumo vi

Palavras-chave: UML-RT, transformac?a?o de modelos, OhCircus, integrac?a?o de me?todos
formais



ABSTRACT

As other object-oriented visual methods, UML has tremendously influenced the software
engineering modeling practice with rich structuring mechanisms. Despite its strengths,
the rigorous development of non-trivial applications (those applications that, due their
complexity, need to emphasise the specification and verification of their components)
do not seem feasible without a formal semantics. The reason is that well-known model
transformations might not preserve behaviour. This problem is even more serious in
a model driven development, where transformations are as important as models, and
involve different model views.

Similar limitations can be found during the development with UML-RT. This language
is a conservative UML profile that includes active objects (objects with an execution flow
independent of the rest of the system) to describe concurrent and distributed applications.
In this kind of development, transformations have to simultaneously handle both static
and dynamic model views, represented by the diagrams and properties of the model.

For these reasons, this work proposes a semantics for UML-RT via mapping into
OhCircus, a formal object oriented language that combines CSP, Z and specification
statements, and also support Morgan’s refinement calculus. From this semantics and
the laws of OhCircus, we are able to propose and prove model transformation laws that
preserve the system behaviour.

Two groups of laws are proposed: the first one embodies a comprehensive set of laws
that govern small changes in the main model views, like introducing or removing a modelo
element; the second group presents more elaborated laws derived from the composition
of these basic laws, like decomposing a capsule into parallel component capsules. The
derived laws can be taken as precise model refactorings that are easily applied in a
rigourous development, without the developer directly dealing with the formalism that
supports them.

Finally, the comprehensiveness of the set of laws is particularly discussed through the
main steps of a reduction strategy of UML-RT models into a UML model extended with
a single capsule responsible for all the interactions with the environment; This capsule
is also responsible for maintaining the active behaviour of the modeled system. This
extended UML model can be regarded as a normal form, and, therefore, our strategy
can be regarded as a contribution to a completeness strategy captured by normal form
reduction.

Keywords: UML-RT, model transformations, OhCircus, formal method integration

vii



SUMA?RIO

Cap??tulo 1—Introduc?a?o 1

Cap??tulo 2—Linguagens de Modelagem 7

2.1 UML 1.x . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
2.2 ADLs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

2.2.1 ROOM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2.2.2 Wright . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2.2.3 ACME . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2.4 SDL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
2.2.5 ADLs e UML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11

2.3 UML-RT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
2.4 UML 2.0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
2.5 Concluso?es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18

Cap??tulo 3—Formalizac?a?o de UML-RT 19

3.1 OhCircus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3.1.1 Sintaxe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
3.1.2 Sema?ntica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

3.1.2.1 Expresso?es de Processos . . . . . . . . . . . . . . . . . . 25
3.1.3 Noc?o?es de Refinamento e Equivale?ncia . . . . . . . . . . . . . . . 26
3.1.4 Leis para refinamento de Processos . . . . . . . . . . . . . . . . . 27

3.2 Mapeamento . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
3.2.1 Mapeamento estrutural . . . . . . . . . . . . . . . . . . . . . . . . 30
3.2.2 Mapeamento comportamental . . . . . . . . . . . . . . . . . . . . 34

3.3 Concluso?es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38

Cap??tulo 4—Leis de Transformac?a?o para UML-RT 39

4.1 Leis Ba?sicas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
4.2 Leis Derivadas e Refatoramentos . . . . . . . . . . . . . . . . . . . . . . 53
4.3 Formalizac?a?o das Leis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57

4.3.1 Prova da Lei 4.20 . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
4.3.2 Prova da Lei 4.12 . . . . . . . . . . . . . . . . . . . . . . . . . . . 60

4.4 Concluso?es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62

viii



suma?rio ix

Cap??tulo 5—Normalizac?a?o e Aplicac?a?o das Leis 63

5.1 Estrate?gia de Normalizac?a?o . . . . . . . . . . . . . . . . . . . . . . . . . 63
5.2 Estudo de Caso . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
5.3 Concluso?es . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72

Cap??tulo 6—Concluso?es 74

6.1 Trabalhos relacionados . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
6.2 Trabalhos Futuros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79

Ape?ndice A—Sintaxe Completa de Ohcircus 81

Ape?ndice B—Leis de CSP 83

Ape?ndice C—Leis de Transformac?a?o para UML-RT Adicionais 85



LISTA DE FIGURAS

2.1 Caso de Uso do Sistema de Automac?a?o Industrial . . . . . . . . . . . . . 14
2.2 Modelo do Sistema de Automac?a?o Industrial . . . . . . . . . . . . . . . . 15

3.1 Especificac?a?o da ca?psula Storage . . . . . . . . . . . . . . . . . . . . . . . 20
3.2 Especificac?a?o da classe Piece . . . . . . . . . . . . . . . . . . . . . . . . . 24
3.3 Exemplo de uma pra?tica correta (a esquerda) e uma errada (a direita) da

conexa?o de subca?psulas . . . . . . . . . . . . . . . . . . . . . . . . . . . 33

5.1 Os dois sentidos de aplicac?a?o das leis . . . . . . . . . . . . . . . . . . . . 64
5.2 Passo ii da normalizac?a?o do Estudo de Caso . . . . . . . . . . . . . . . . 65
5.3 Passo iii da normalizac?a?o do Estudo de Caso . . . . . . . . . . . . . . . . 66
5.4 Primeiro modelo intermedia?rio do passo iv da normalizac?a?o do Estudo de

Caso . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67
5.5 Segundo modelo intermedia?rio do passo iv da normalizac?a?o do Estudo de

Caso . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
5.6 Modelo final da composic?a?o de ca?psulas no passo iv da normalizac?a?o do

Estudo de Caso . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
5.7 Arquitetura candidata do Estudo de Caso . . . . . . . . . . . . . . . . . 71
5.8 Identificac?a?o de ProcessorA e ProcessorB no Estudo de Caso . . . . . . . . 72
5.9 Identificac?a?o de Holon no Estudo de Caso . . . . . . . . . . . . . . . . . . 73

x



CAPI?TULO 1

INTRODUC?A?O

A noc?a?o de Engenharia de Software como a conhecemos, originou-se durante a de?cada de
60, quando a comunidade da cie?ncia da computac?a?o comec?ou a despertar interesse [13]
na necessidade pela produc?a?o de software baseado em fundamentos teo?ricos e disciplinas
pra?ticas, como as encontradas em ramos tradicionais e estabilizados da engenharia [62].
Preocupados com a rece?m instalada crise do software [11, 39], desejava-se um aumento
da qualidade de software, atrave?s de processos mais produtivos durante o seu desenvol-
vimento.

Hoje, esta produc?a?o de software tem caminhado para uma abordagem de desenvolvi-
mento dirigido a modelos (MDE - Model Driven Engineering) [87, 51], onde os artefatos
principais durante o desenvolvimento sa?o modelos, ao inve?s do co?digo em uma linguagem
de programac?a?o. Diferentemente da abordagem tradicional de que modelos sa?o utiliza-
dos somente para fins de documentac?a?o de aspectos interessantes durante a construc?a?o
de programas, implantadas indiretamente por diversos processos da engenharia de soft-
ware, o objetivo principal no desenvolvimento dirigido a modelos e? que o processo de
desenvolvimento e? dirigido pelas atividades de modelagem de software.

Durante o ciclo de vida deste processo, e? poss??vel aplicar diversos tipos de trans-
formac?a?o para se especializar ou reestruturar o modelo. Neste contexto, transformac?o?es
sa?o artefatos ta?o importantes quanto os pro?prios modelos, e te?m finalidades semelhantes
a transformac?o?es tradicionais de co?digo, como refactorings [33, 77] e refinamentos [67].
De fato, estes tipos de transformac?a?o tambe?m sa?o aplicados para resolver problemas rela-
cionados a? evoluc?a?o e manutenc?a?o [57] existentes em sistemas baseados em modelos [51].
Enquanto refactorings reestruturam o sistema para adicionar aspectos de qualidade (por
exemplo, atrave?s da aplicac?a?o de padro?es de projeto), preservando o seu comportamento,
refinamentos sa?o utilizados para concretizar o modelo (por exemplo, especializando-o para
uma plataforma espec??fica).

Em esforc?os recentes, a OMG (Object Management Group) [71] tem atestado o va-
lor de abordagens baseadas em modelos para o desenvolvimento de software, atrave?s da
padronizac?a?o de notac?o?es e interoperabilidade de ferramentas. Uma evide?ncia e? a espe-
cificac?a?o de MDA (Model-Driven Architecture) [65] e UML [81]. Enquanto UML tem
se tornado uma notac?a?o padra?o para a modelagem de sistemas, MDA te?m contribu??do,
entre outros benef??cios, com padro?es de interoperabilidade e portabilidade ao suporte
metodolo?gico do desenvolvimento dirigido a modelos, atrave?s de uma arquitetura de mo-
delos. MDA define uma arquitetura que separa a especificac?a?o das funcionalidades do
sistema da especificac?a?o de como elas sa?o implementadas. A especificac?a?o inicial e? estru-
turada como um modelo de plataforma independente (PIM), que pode ser refinado em
um ou mais modelos espec??ficos de plataforma (PSM).

Apesar de na?o possuir uma definic?a?o precisa, a noc?a?o geral de arquitetura na en-

1



introduc?a?o 2

genharia de software e? um pouco diferente da encontrada em MDA. Um consenso em
engenharia de software parece ser que uma arquitetura descreve um sistema em partes
com um alto n??vel de abstrac?a?o e atrave?s do relacionamentos entre estas partes. Em
MDA, a arquitetura do sistema e? vista como um conjunto de modelos durante o desen-
volvimento do sistema, que descrevem n??veis de abstrac?a?o distintos da modelagem, e o
relacionamento destes modelos e? realizado atrave?s de transformac?o?es. Atribuiremos neste
trabalho o conceito de arquitetura a um u?nico n??vel de abstrac?a?o do software, que pode
ser vista em termos da decomposic?a?o do sistema em componentes, suas propriedades, e
suas relac?o?es [6, 20], enquanto transformac?o?es sa?o utilizadas para relacionar o modelo dos
diferentes n??veis abstrac?o?es desta arquitetura; desta maneira, modelos e transformac?o?es
podem ainda assim representar os papeis sugeridos em MDA.

Neste sentido, arquiteturas podem ser representadas por modelos, e evoluir durante
um processo de desenvolvimento baseado em modelos, atrave?s da transformac?o?es. Pore?m,
a criac?a?o e utilizac?a?o de artefatos de software (modelos e transformac?o?es) na?o devem ser
baseadas no empirismo [45] para a produc?a?o de software de qualidade. Modelos sem
uma sema?ntica formal podem ser amb??guos e, consequ?entemente, na?o expressarem cor-
retamente suas propriedades. Por outro lado, transformac?o?es sem bases so?lidas podem
na?o garantir a preservac?a?o destas propriedades [26]. Isto se torna mais se?rio no desen-
volvimento de aplicac?o?es na?o triviais (por exemplo, concorrentes ou distribu??das), onde
a verificac?a?o e especificac?a?o destas propriedades se torna ainda mais dif??cil.

Normalmente, modelos sa?o expressos atrave?s de notac?o?es semi-formais como UML
e suas extenso?es, u?teis para especificar aspectos de um dom??nio especifico, ainda que
independentes de plataforma. Em particular, enfatizamos o uso de UML-RT [90] (UML
para tempo real), uma extensa?o conservativa de UML que prove? a noc?a?o de objetos
ativos [56] (objetos com um comportamento pro?prio, independente do fluxo de execuc?a?o
do restante do sistema) para descrever aplicac?o?es concorrentes e distribu??das.

Na literatura, diversos esforc?os [30, 12, 69] atacam este problema atrave?s da integrac?a?o
de notac?o?es informais (ou semi-formais), utilizadas para descrever estes modelos, com
linguagens formais, esperando que conceitos tradicionais da teoria da programac?a?o con-
duzam a um desenvolvimento de sistemas consistente, sem que, durante a sua evoluc?a?o,
propriedades, anteriormente definidas e verificadas, na?o sejam preservadas.

Estes trabalhos atribuem uma sema?ntica, definida pela linguagem formal, a? notac?a?o
informal. Assim, modelos podem ser mapeados para a linguagem formal sempre que se
deseje verificar sua consiste?ncia. Um inco?modo, pore?m, e? que, a cada nova transformac?a?o
do modelo, este mapeamento deve ser realizado e propriedades devem ser provadas para
se assegurar a consiste?ncia do modelo.

Uma pra?tica que pode assistir na soluc?a?o deste problema e? a criac?a?o de leis de trans-
formac?a?o de modelos, seguindo as mesmas diretrizes das leis da programac?a?o [46]. As leis
da programac?a?o sa?o leis que governam as propriedades ba?sicas da programac?a?o, e que
por este motivo sua aplicac?a?o pode ser utilizada para garantir a preservac?a?o de trans-
formac?o?es de programa; como as leis que governam a aritme?tica descrevem as operac?o?es
sobre nu?meros, leis de programac?a?o descrevem as propriedades dos construtores de pro-
gramas. Uma lei da aritme?tica, por exemplo, e?: 0 + x = x , que denota que o nu?mero 0
e? o elemento neutro (ou a identidade) para a operac?a?o de soma. Atrave?s da composic?a?o



introduc?a?o 3

de leis ba?sicas, e? poss??vel demonstrar propriedades mais complexas. Por exemplo, na
aritme?tica, a lei 2a?a = a, pode ser reescrita, passo-a-passo, atrave?s de leis ba?sicas para
se provar sua corretude; em particular, ela pode ser derivada das ba?sicas leis da a?lgebra
atrave?s dos seguintes passos: (a + a) ? a = a; a + (a ? a) = a; a + 0 = a; e a = a . Na
realidade, leis da programac?a?o podem tambe?m definir uma sema?ntica axioma?tica [98],
definindo propriedades sobre os construtores da linguagem atrave?s de axiomas e regras
de infere?ncia, da lo?gica simbo?lica, sendo tambe?m u?teis para provar propriedades de pro-
gramas [67].

Diversos paradigmas podem ser beneficiados atrave?s das leis de programac?a?o. Por
exemplo leis para programas que utilizam linguagens orientadas a objeto [9], imperati-
vas [46] e concorrente [80] podem ser u?teis para estabelecer uma base formal para pra?ticas
informais de desenvolvimento de software ja? existentes, como refactorings. Desta maneira,
desenvolvedores podem realizar suas tarefas sem explicitamente lidarem com formalismos,
mas baseados neles. Transformac?o?es complexas de co?digo podem ser explicadas atrave?s
da composic?a?o de leis ba?sicas de programac?a?o, utilizando uma interface ja? conhecida pelo
programador e livre de formalismos.

Apesar desta ser uma a?rea ainda incipiente, leis de modelagem podem trazer benef??cios
similares aos das leis da programac?a?o como, por exemplo, derivando-se refactorings para
modelos a partir de leis mais ba?sicas [37]. Este e? um dos objetivos fundamentais deste
trabalho: propor um desenvolvimento rigoroso baseado em modelos UML-RT. Este de-
senvolvimento e? rigoroso por garantir a consiste?ncia e preservac?a?o de propriedades do
sistema durante a fase de modelagem. Para garantir esta preservac?a?o de propriedades,
contribu??mos neste trabalho para o desenvolvimento rigoroso em UML da seguinte ma-
neira:

• Atribuic?a?o de uma sema?ntica formal a UML-RT, atrave?s do seu mapeamento sinta?tico
para a linguagem formal OhCircus [16];

• Proposic?a?o de um conjunto abrangente de leis ba?sicas de transformac?a?o para UML-
RT para auxiliar a criac?a?o de tarefas de modelagem consistentes, que preservam o
comportamento do modelo;

• Derivac?a?o de leis de projeto para UML-RT a partir das leis ba?sicas, com a finalidade
de aumentar sua aplicabilidade;

• Demonstrac?a?o da abrange?ncia das leis propostas atrave?s dos principais passos de
uma estrate?gia de normalizac?a?o;

• Aplicac?a?o destas leis durante o projeto de um estudo de caso para demonstrar sua
integrac?a?o com um processo de desenvolvimento pra?tico;

Propomos uma sema?ntica para os elementos de UML-RT atrave?s de seu mapeamento
para a linguagem formal OhCircus [16], uma linguagem orientada a objetos que combina
CSP [79], Z [95] e o ca?lculo de refinamentos de Morgan [67]; este mapeamento e? baseado
em resultados previamente obtidos [74]. Tanto em [74] como neste trabalho, focamos
no mapeamento dos novos elementos (classes ativas e outros construtores relacionados)



introduc?a?o 4

que UML-RT adiciona a UML. Consideramos conjuntamente as viso?es comportamentais
e estruturais de um modelo UML-RT.

Uma raza?o para a escolha de OhCircus e? que sua sema?ntica e? definida com base
na Unified Theory of Programming (UTP) [47], cujo modelo relacional tem se mostrado
conveniente para formalizar diversos paradigmas da programac?a?o. Outra vantagem e?
que OhCircus inclui os principais conceitos encontrados em UML-RT. Ao inve?s de, por
exemplo, CSP-OZ [31], OhCircus desacopla a ocorre?ncia de eventos de operac?o?es sobre o
estado, e e? projetada para suportar um ca?lculo de refinamento [67]. Leis de OhCircus te?m
inspirado a aplicac?a?o de diversas leis para UML-RT [83], e a prova de leis de transformac?a?o
para UML-RT atrave?s de nosso mapeamento sema?ntico [74]. Diferentemente de outros
trabalhos relacionados a? formalizac?a?o de UML [12, 69] e UML-RT [32, 25], este trabalho
considera conjuntamente as viso?es estrutural e comportamental do modelo.

Utilizando como base a sema?ntica atribu??da aos elementos de UML-RT, atrave?s de
seu mapeamento para OhCircus, propomos leis de transformac?a?o que preservam o com-
portamento do sistema. Focamos na proposic?a?o de leis ba?sicas, porque estas sa?o mais
facilmente provadas e permitem um desenvolvimento sistema?tico, onde leis ba?sicas podem
ser utilizadas para justificar leis mais complexas.

As leis propostas capturam pequenos passos consistentes que preservam tanto aspectos
esta?ticos quanto dina?micos do modelo (levando em conta conjuntamente propriedades
estruturais e comportamentais). Atrave?s da combinac?a?o de leis ba?sicas introduzimos
novas leis mais elaboradas. Tais leis sa?o capazes de capturar e formalizar algumas das
pra?ticas utilizadas em atividades de projeto, como no Processo Unificado da Rational
(RUP) [52], sendo esta uma outra contribuic?a?o importante deste trabalho. Atrave?s de
um estudo de caso, mostramos como um modelo concreto de projeto pode ser gerado a
partir de um modelo inicial e abstrato de ana?lise.

Como exemplo de lei ba?sica de transformac?a?o podemos citar a inserc?a?o, remoc?a?o ou
alterac?a?o de um elemento do modelo. Usualmente, estas leis alteram apenas uma das
viso?es do modelo, pore?m impondo condic?o?es para a sua aplicac?a?o com base com seu
relacionamento com as viso?es. Por lidarmos com leis que preservam o comportamento do
modelo, criamos leis de equivale?ncia entre modelos, que podem ser aplicadas em qualquer
direc?a?o (da esquerda para a direita, ou da direita para a esquerda); na realidade cada lei
pode ser vista como a definic?a?o conjunta de duas regras de transformac?a?o de modelo.

As leis propostas aqui esta?o baseadas nas ide?ias inicialmente reportadas em [83], que
apresenta algumas poucas leis de transformac?a?o de grande granularidade para UML-RT,
refletindo a importa?ncia de transformac?o?es na pra?tica de desenvolvimento.

Como na?o definimos leis para os elementos de UML, nosso trabalho pode ser conside-
rado suplementar a outros trabalhos que focam especificamente nestes elementos [41, 30,
38], ou a trabalhos que descrevem sucintamente leis para UML-RT [26, 85], sem expres-
sar os padro?es e as condic?o?es necessa?rios para sua aplicac?a?o. Transformac?o?es consistentes
entre classes no diagrama sa?o livremente permitidas, desde que estas na?o interfiram com
a interface esperada por ca?psulas que invoquem me?todos destas classes. Isto acontece
porque a comunicac?a?o entre objetos ativos em UML-RT e classes e? atrave?s da chamada
de me?todos e porque ca?psulas na?o compartilham classes entre si. Assim do ponto de vista
destas classes, ca?psulas sa?o simplesmente elementos externos que invocam seus servic?os.



introduc?a?o 5

Ale?m da avaliac?a?o das leis sob o ponto de vista de sua corretude e aplicabilidade, a
abrange?ncia do conjunto de leis proposto e? discutida particularmente atrave?s dos princi-
pais passos de uma estrate?gia de reduc?a?o de modelos em UML-RT a um modelo UML es-
tendido com um u?nico objeto ativo (Cap??tulo 5), responsa?vel por todas as interac?o?es com
o ambiente e por conservar o comportamento dina?mico do sistema modelado. Este mo-
delo UML estendido pode ser visto como uma forma normal, e, portanto, nossa estrate?gia
pode ser vista como uma contribuic?a?o para uma estrate?gia de completude capturada por
uma reduc?a?o a esta forma normal, semelhante a? estrate?gia apresentada em [9] para uma
linguagem de programac?a?o orientada a objetos. Nosso foco e? em um conjunto de leis para
diagramas de classe e estrutura de modelos; uma estrate?gia completa de normalizac?a?o
necessita de um grande nu?mero de leis para capturar transformac?o?es nos diagramas de
estados, que esta? fora do escopo deste trabalho.

Apesar de lidarmos, neste trabalho, com um subconjunto da linguagem UML-RT e
desta linguagem na?o ter sido criada por organizac?o?es de padronizac?a?o (como a OMG),
sendo mantida pelas empresas que suportam suas ferramentas [19], va?rios conceitos desta
linguagem esta?o diretamente presentes em outras linguagens para a descric?a?o de arquite-
turas ou de componentes. Assim, todas as contribuic?o?es que possam ser incorporadas ao
desenvolvimento usando UML-RT podem, a principio, ser adaptadas para o desenvolvi-
mento nessas linguagens.

Esta dissertac?a?o esta dividida em cinco cap??tulos, ale?m deste, e tre?s ape?ndices. O
conteu?do de cada um e? descrito a seguir:

• Cap??tulo 2: Neste cap??tulo, introduzimos os conceitos presentes na linguagem
UML-RT; ale?m disto contextualizamos esta linguagem em relac?a?o a algumas outras
linguagens de modelagem, indicando suas vantagens e desvantagens. Um exemplo
sobre como esta linguagem sera? utilizada na modelagem de um sistema rigoroso
tambe?m sera? apresentadao neste cap??tulo.

• Cap??tulo 3: Neste cap??tulo, introduzimos a linguagem formal OhCircus e apre-
sentamos os mapeamentos sema?nticos de um subconjunto expressivo das viso?es
estruturais e comportamentais de UML para esta linguagem formal.

• Cap??tulo 4: Neste cap??tulo, apresentamos, de uma maneira incremental, um con-
junto abrangente de leis ba?sicas de transformac?a?o para UML-RT e algumas leis
derivadas a partir deste conjunto. Ale?m disto, provamos algumas destas leis utili-
zando a sema?ntica proposta no Cap??tulo 3.

• Cap??tulo 5: Neste cap??tulo, aplicamos leis de transformac?a?o de modelos em UML-
RT a um estudo de caso: um sistema de automac?a?o industrial. As aplicac?o?es das leis
sa?o utilizadas em uma estrate?gia de normalizac?a?o de um ponto intermedia?rio do de-
senvolvimento deste estudo de caso, e no desenvolvimento deste ponto intermedia?rio
ate? um modelo de concreto, pro?ximo a? implementac?a?o. Durante este desenvolvi-
mento, as leis sa?o contextualizadas segundo as atividades de projeto, utilizando no
RUP.



introduc?a?o 6

• Cap??tulo 6: Neste cap??tulo, discutimos alguns trabalhos relacionados e futuros, e
apresentamos nossas considerac?o?es finais

• Ape?ndice A: Neste ape?ndice, mostramos a grama?tica completa da linguagem
OhCircus.

• Ape?ndice B: Neste ape?ndice, mostramos algumas leis de CSP utilizadas para a
prova das leis de UML-RT.

• Ape?ndice C: Neste ape?ndice, mostramos algumas leis restantes de transformac?a?o
para UML-RT na?o apresentadas no Cap??tulo 4.



CAPI?TULO 2

LINGUAGENS DE MODELAGEM

Neste cap??tulo, introduziremos alguns conceitos gerais de UML [81], e indicaremos os
motivos pelos quais ela e? inapropriada para o desenvolvimentos de componentes reativos
para sistemas software, cuja arquiteturas incluem aspectos concorrentes e distribu??dos.
Apesar da proposta para uma versa?o mais nova de UML (UML 2.0) possuir va?rias das
caracter??sticas deseja?veis para a modelagem destas arquiteturas, escolhemos a linguagem
UML-RT neste trabalho, por a considerarmos uma linguagem mais consolidada e que
conta (no momento) com um suporte mais amplo de ferramentas comerciais.

O projeto de arquitetura de tais sistemas distribu??dos e reativos tem como elemento
central a interac?a?o de seus componentes durante a execuc?a?o de algumas tarefas [54].
Como veremos a seguir, a versa?o atual da UML na?o possui va?rias caracter??sticas deseja?veis
para a especificac?a?o de componente de software [48], tampouco define explicitamente a
interac?a?o entre as interfaces destes componente.

Para se obter um contexto amplo de onde UML-RT esta inserida, explicaremos neste
cap??tulo varias linguagens de modelagens relacionadas, como descrito a seguir, a UML-
RT. Apesar de discutimos elas superficialmente, conseguimos trac?ar que influe?ncias elas
despertam umas nas outras. Na Sec?a?o 2.1 exibiremos alguns problemas relacionados
a? versa?o de UML 1.5. Na Sec?a?o 2.2 mostraremos algumas linguagens idealizadas para
a descric?a?o de arquiteturas utilizando componentes. Na Sec?a?o 2.3, introduziremos a
sintaxe da linguagem UML-RT, e como ela foi inspirada em UML e em tais linguagens
para descric?a?o de arquiteturas. Por fim, na Sec?a?o 2.4, discutiremos sobre a nova versa?o
de UML, reformulada com base em va?rias caracter??sticas encontradas em UML-RT.

2.1 UML 1.X

Desde a padronizac?a?o da Linguagem de Modelagem Unificada (UML) pelo OMG
(Object Management Group) em 1997, ela tem se tornado para a comunidade um padra?o
de facto para a especificac?a?o e modelagem de software.

UML prove? uma diversividade de te?cnicas para descrever aspectos estruturais e com-
portamentais de um sistema modelado. Diagramas de classe, objeto, componente e im-
plantac?a?o focam principalmente na estrutura do sistema, enquanto diagramas de estados
enfatizam no comportamento, tipicamente de componentes individuais. Diagramas de
atividades, sequ?e?ncia, colaborac?a?o e casos de uso tambe?m focam no comportamento,
pore?m adicionalmente referenciam elementos estruturais.

Diagramas de sequ?e?ncia e colaborac?a?o sa?o utilizados para descrever interac?o?es en-
tre componentes, expressando a ordem de ocorre?ncia de mensagens trocadas entre eles.
Devido a? sua expressividade limitada (por exemplo, eles na?o conseguem expressar alter-
nativas ou repetic?o?es), eles sa?o utilizados normalmente apenas para mostrar cena?rios de
utilizac?a?o do sistema.

7



2.1 uml 1.x 8

Devido a popularidade de UML, me?todos e pra?ticas de modelagem tem se desenvol-
vido enormemente. Diversas necessidades te?m requerido mudanc?as e extenso?es da atual
versa?o de UML, versa?o 1.5. Tais extenso?es te?m gerado novos profiles, ou culminado na
reestruturac?a?o da linguagem, UML versa?o 2.0. Podemos destacar alguns problemas na
atual versa?o de UML que tem gerado tais mudanc?as.

• Falta de uma sema?ntica formal

• Tamanho excessivo e multiplicidade de modelos.

• Suporte inadequado para o desenvolvimento baseado com componentes.

Sema?ntica Formal: UML e? conhecida como uma linguagem semi-formal, cuja ne-
cessidade de noc?o?es mais formais e? reconhecida em diversos trabalhos [30, 4, 58]. A
sema?ntica de seus elementos sinta?ticos e? imprecisa, o que gera problemas de comunicac?a?o
entre os membros do projeto de software. Ale?m disto, sem uma sema?ntica formal pre-
cisa na?o e? poss??vel automatizar ana?lises rigorosas de um modelo, tampouco executa?-lo
diretamente para testar seu comportamento; a u?nica maneira de se testar um sistema
modelado e? o codificando.

Atrave?s da atribuic?a?o de uma noc?a?o formal a seus elementos, pode-se prover suporte
a? verificac?a?o de propriedades do modelo, atribuir noc?o?es de equivale?ncia entre modelos,
e, consequ?entemente, realizar transformac?o?es seguras de seus elementos; reestruturando
o modelo sem alterar suas propriedades.

Tamanho Excessivo a Multiplicidade de Modelos: A versa?o atual de UML tem
sido vista por muitos como muito grande e complexa [22, 44, 7]. Seu tamanho excessivo
transforma seu aprendizado, aplicac?a?o e implementac?a?o dif??cil. Ale?m disto, a multiplici-
dade de seus modelos resulta numa quantidade excessiva de diagramas e s??mbolos para
expressar os aspectos estruturais e comportamentais do modelo. Tais diagramas na?o con-
seguem expressar isoladamente estes aspectos, resultando em problemas de produtividade
e consiste?ncia durante sua elaborac?a?o [22].

Suporte ao desenvolvimento baseado em componentes: Apesar de suas inu?me-
ras vantagens, UML tem diversas desvantagens quando comparado com linguagens para
descric?a?o de componentes [91]. Isto se deve ao fato de que diagramas de componentes em
UML na?o tem por finalidade representar a decomposic?a?o lo?gica de um sistema, durante
seu projeto, em subsistemas composicionais e reusa?veis. Em UML, um componente e? uma
unidade f??sica da implementac?a?o [81], sendo utilizado somente na fase de implantac?a?o.
Ale?m disto, UML na?o oferece o conceito de conexo?es como objetos de primeira ordem,
visto com um h??brido entre associac?a?o (associac?a?o entre classes) e uma depende?ncia entre
uma classe e a interface de outra classe. Tais interfaces na?o podem ser diretamente
utilizadas para descrever, em um n??vel de detalhes suficiente, as mu?ltiplas interac?o?es
entre componentes de software [20].

Va?rias abordagens utilizam UML no Desenvolvimento Baseado em Componentes
(CBD), pore?m esta linguagem na?o e? especializada para este tipo de desenvolvimento,
e certas extenso?es ao seu padra?o sa?o necessa?rias [20, 48]. Devidos aos problemas ja? des-
critos, abordagens naturais utilizando classes, interfaces, e subsistemas na?o contemplam



2.2 adls 9

adequadamente a especificac?a?o do comportamento de um componente [48]. Tais proble-
mas estimularam a criac?a?o de extenso?es de UML, a sua unificac?a?o com Linguagens de
Descric?a?o de arquitetura (ADLs) (Sec?a?o 2.2.5), ou mesmo a reformulac?a?o da linguagem
(Sec?a?o 2.4)

2.2 ADLS

Componentes prove?m um n??vel de abstrac?a?o mais alto que objetos. Usualmente,
eles podem ser vistos como caixas pretas que fornecem ou requerem um conjunto de
servic?os (representados por interface). Componentes que interagem podem assim ser
compostos para formar um componente com um maior n??vel de abstrac?a?o. A estrutura
destas composic?o?es sa?o o foco da arquitetura de software, que e? definida em [91], como:
“A arquitetura de um sistema de software define o sistema em termos de componentes
computacionais e de suas interac?o?es”.

Para a especificac?a?o de arquitetura de software, um grande nu?mero de Linguagens de
Descric?a?o de Arquitetura (ADLs) te?m sido propostas [64]. Esta especificac?a?o e? utilizada
para descrever a interac?a?o entre componentes, atrave?s de seu comportamento individual,
interfaces de comunicac?a?o internas e externas, ale?m da influe?ncia mu?tua entre estas in-
terfaces.

Em [64], ADLs te?m como caracter??sticas essenciais a definic?a?o expl??cita de componen-
tes, conexo?es e configurac?o?es de arquitetura e a possibilidade de modelagem de interfaces
de componentes; definidos com uma sema?ntica clara. Aspectos adicionais, relacionados a
estas noc?o?es podem ser deseja?veis, pore?m na?o essenciais. Seus benef??cios sera?o reconhe-
cidos, e demonstrados, em contextos de problema espec??fico (por exemplo, aspectos na?o
funcionais de tempo ou desempenho), pore?m sua ause?ncia na?o significa que a linguagem
na?o representa uma ADL.

Va?rias linguagens possuem uma sema?ntica formal para descrever o comportamento
de seus componentes e conexo?es, por exemplo, atrave?s de algebra de processos [3] ou
ma?quinas de estados finitas. Este tipo de sema?ntica reforc?a o uso da declarac?a?o de
propriedades arquiteturais, e assegura o mapeamento de arquiteturas de um n??vel de
abstrac?a?o para outro. Adicionalmente, e? deseja?vel que ADLs possibilitem refinamentos
consistentes e corretos de arquiteturas de sistemas abstratas em outras exequ???veis. Outros
aspectos deseja?veis sa?o a possibilidade de evoluc?a?o e de dinamismo da configurac?a?o de
arquiteturas de software. Enquanto o primeiro esta? relacionado a? adic?a?o e manutenc?a?o de
funcionalidade na arquitetura, o segundo aspecto se refere a? modificac?a?o da configurac?a?o
do sistema durante a sua execuc?a?o.

Va?rios ADLs sa?o considerados em respeitos a diferentes aspectos do desenvolvimento
baseado em componentes e arquitetura de software. A seguir ilustramos alguns ADLs que
tem uma suporte formal de sua descric?a?o ou influenciaram de alguma maneira mudanc?as
na versa?o de UML 2.0.



2.2 adls 10

2.2.1 ROOM

A Linguagem de Modelagem de Tempo Real Orientada a Objetos (ROOM) [89] utiliza
um variante do conceito de ”componente-porta-conector”para a arquitetura de compo-
nentes, descrita em [91, 23]. Tais conceitos de componentes, portas e conectores, sa?o
semelhantes a outros ADLs, e sa?o descritos como:

• Componentes: Um componente (ou atores): e? qualquer elemento que realiza al-
gum tipo de computac?a?o. A declarac?a?o deste descreve sua interface externa, seu
comportamento, e uma estrutura interna, utilizada para a composic?a?o de novos
componentes.

• Portas: um conjunto de portas definem as interfaces externas de um ator. Portas
sa?o os u?nicos locais por onde um ator oferece ou requisita servic?os; sendo portanto
bidirecional.

• Protocolos: Um protocolo define o conjunto de sinais permitidos na transmissa?o ou
recepc?a?o de mensagem entre componentes conectados. Qualquer porta associada a
um protocolo deve enviar os sinais de sa??da e receber os de entrada deste protocolo.

• Portas Conjugadas: Portas podem ser conjugadas com relac?a?o ao seu protocolo
associado, recebe os sinais de sa??da de seu protocolo e envia seus sinais de entrada.

• Conectores: Um conector estabelece uma conexa?o entre duas portas. Ele liga uma
porta de um componente a uma porta conjugada de outro componente com um
protocolo associado compat??vel (na maioria das vezes, o mesmo).

ROOM descreve principalmente dois tipos de diagramas. Diagramas de atores em
ROOM descrevem a decomposic?a?o hiera?rquica de um sistema de software em seus com-
ponentes, como tambe?m as conexo?es entre estes componentes; estes diagramas sa?o uti-
lizados para descrever a estrutura interna de componentes. ROOM Charts, por outro
lado, sa?o utilizados para descrever o comportamento de componentes e protocolos, sendo
derivados de StateCharts [43].

2.2.2 Wright

Wright [3] e? um ADL com suporte a? descric?a?o de componentes, conexo?es e composic?a?o
de componentes. Ela foca na especificac?a?o comportamental de componentes e conexo?es
atrave?s de uma notac?a?o formal baseada em CSP. As interfaces de eventos de cada compo-
nente misturam os eventos transmitidos e recebidos pelo componente, na?o distinguindo
servic?os fornecidos e requeridos.

Componentes podem ser descritos individualmente atrave?s de uma especificac?a?o expl??cita,
ou atrave?s da composic?a?o de outros componentes utilizando operadores de CSP, de uma
maneira bottom-up; caracterizando descric?a?o comportamental caixa branca. Atrave?s
deste formalismo, e? poss??vel realizar verificac?o?es de consiste?ncia e integridade da especi-
ficac?a?o; verificando, por exemplo, se esta? livre de deadlocks.



2.2 adls 11

2.2.3 ACME

O propo?sito de ACME [36] e? prover um formato para a troca de informac?a?o entre
ferramentas e ambientes de diferentes ADLs. Ele e? baseado em abstrac?o?es comuns exis-
tentes em ADLs, suportando diretamente componentes, conexo?es e sistemas (arquitetu-
ras). Para suportar qualquer ADL, ACME inclui uma sintaxe aberta para caracter??stica
baseada em propriedades definidas pelo usua?rio, com uma sema?ntica fora do escopo de
ACME. Atrave?s de extenso?es da linguagem, ACME e? capaz de descrever comunicac?a?o de
componentes atrave?s de eventos, podendo descrever sequ?e?ncias de eventos (traces), e uti-
lizar a notac?a?o de XML para descrever arquiteturas, focando apenas aspectos estruturais
do sistema.

2.2.4 SDL

A Linguagem de Especificac?a?o e Descric?a?o (SDL) [40] e? um padra?o da ITU-T, e aceito
pela ISO. SDL e? uma linguagem formal e orientada a objetos, com suporte a descric?a?o de
componentes ativos (processos) e passivos (dados), eventos de comunicac?a?o e composic?a?o
de componentes, ale?m de outras caracter??sticas inerentes a ADLs. Por ter uma base
formal utilizando ma?quinas de estados abstratas (ASM) [40], ela prove? uma especificac?a?o
na?o amb??gua de sistemas.

Apesar de, em SDL, canais de comunicac?a?o serem definidos explicitamente, interco-
nexo?es entre componentes sa?o especificados implicitamente no comportamento dos com-
ponentes (atrave?s do uso de canais comuns). Por esta raza?o, linguagens como esta sa?o
chamadas em [64] como linguagems de configurac?a?o in-line e estariam mais pro?ximas
de serem classificadas como linguagens de interconexa?o de mo?dulos (MIL) [73] do que
propriamente como ADLs.

2.2.5 ADLs e UML

Em [35], e? argumentado que UML na?o e? adequado para modelar a estrutura de
sistemas tipicamente utilizados em linguagens de descric?a?o de arquiteturas. O maior pro-
blema e? que nem todos os elementos encontrados em ADLs possuem um mapeamento
direto para os conceitos de modelagem encontrados em UML. Apesar disto, diversos
trabalhos [18, 82, 76] mapeiam os conceitos arquiteturais de ADLs em UML, geralmente
alterando o significados dos elementos de UML atrave?s de estereo?tipos; o “como” este ele-
mentos sa?o modificados na?o e? especificado, utilizando geralmente a sema?ntica associadas
a estes em seus contra-elementos em ADL. Estes trabalhos contribuem para a melhoria de
um aspecto deseja?vel de compreensa?o da arquitetura, atrave?s do mapeamento de ADLs
em linguagens mais populares e disseminadas na comunidade.

Em [18], os conceitos de ACME sa?o mapeados em UML atrave?s de estereo?tipos.
Devido a algumas especifidades da linguagem, nem todos os conceitos de ACME puderam
ser representados em UML. De forma similar, em [76], estes mecanismos de extensa?o
(estereo?tipos) sa?o utilizados para mapear os ADLs: Wright, Darwin [61], and Rapide [59].

Em [82, 18], o conceitos arquiteturais de ROOM sa?o mapeados em UML, atrave?s do
uso de estereo?tipos. Em [82] o papel de cada porta e? definido explicitamente por uma



2.3 uml-rt 12

classe, que implementa o comportamento associado ao seu protocolo em ROOM e rea-
liza uma interface com os servic?os associados a este este protocolo; portas conjugadas
realizam interfaces de protocolos conjugados. Este modelo facilita o uso de portas como
elementos de primeira classe, pore?m dificultam a heranc?a de comportamento dos proto-
colos e restrigem os servic?os dos protocolos a? simples chamadas de me?todos. Em [18] um
mapeamento menos detalhado e? realizado, indicando somente quais os conceitos arqui-
teturais de ROOM poderiam ser representados em UML, da mesma forma que em [82]
sinais de protocolos sa?o restringidos a me?todos de classes em UML.

Em [90], a integrac?a?o entre UML e ROOM e? realizada adicionando-se a UML elemen-
tos com uma nova sema?nticas. Sendo o resultado desta integrac?a?o uma linguagem mais
aceita pela comunidade, popularmente chamada de UML-RT. Tal linguagem cria novos
elementos (ca?psulas) para representar componententes de software em UML, reservando
componentes passivos para serem representados como classes ordina?rias. Os diagrams
de atores sa?o representados em extensa?o do diagrama de colaborac?a?o, enquanto ROOM
Charts sa?o representados por diagramas de estados espec??ficos para ca?psulas e protoco-
los. Apesar de conter em sua definic?a?o elementos para representar os papeis realizados
pelas portas (ordina?rias ou conjugadas), ela sugere uma notac?a?o mais compacta para a
representac?a?o destes papeis atrave?s de associac?o?es e sufixos no nome destas portas, como
a que e? empregada em suas ferramentas [19] e assumida por no?s na Sec?a?o 2.3.

Como vimos a integrac?a?o de ADLs e UML podem gerar novas extenso?es da UML
(profile de UML-RT), ou mesmo contribuem para a? reformulac?a?o de novas verso?es de
UML. Em [88], e? indicado que va?rias das caracter??sticas de modelagem arquitetural de
UML 2.0 sa?o derivadas de tre?s linguagem de de descric?a?o arquitetural, UML-RT [90] [61],
ACME [36] e SDL [40].

2.3 UML-RT

A especificac?a?o e projeto de sistemas distribu??dos e? uma tarefa complexa que envolve
a especificac?a?o de dados, comportamento, comunicac?a?o e de aspectos arquiteturais do
sistema. Com a finalidade de atender estes requisitos, UML e ROOM foram combinadas
na linguagem UML for Real-Time (UML-RT) [90]. Apesar de seu nome, UML-RT na?o
possui um suporte adequado para qualquer aplicac?a?o que envolva tempo real, na realidade
ela e? focada na modelagem de sistemas baseados em componentes e sistemas embarcados
qualificados como soft-real time (onde o tempo apesar de fazer parte da modelagem, na?o
e? um fator cr??tico). Sendo o enfoque deste trabalho a modelagem de componentes ativos,
sem lidar aspectos de tempo.

UML-RT e? considerada um extensa?o conservativa de UML, introduzindo apenas novos
elementos e diagramas (baseados nos conceitos de ROOM) que se inter-relacionam com os
elementos ja? existentes em UML. Quatro novos construtores sa?o introduzidos: ca?psulas,
protocolos, portas e conectores.

Ca?psulas descrevem componentes ativos, potencialmente concorrentes, do sistema,
que possuem uma estrutura interna e uma comportamento associado. Diferentes de atores
em ROOM, ca?psulas sa?o utilizadas primordialmente para descrever elementos ativos, com
um fluxo de dados independente do restante do sistema. Enquanto elementos passivos



2.3 uml-rt 13

sa?o descritos por classes em UML.
Assim, uma ca?psula tem ale?m de seu comportamento passivo definidos em seus

me?todos, o seu comportamento ativo definido por uma ma?quina de estados. Na rea-
lidade o comportamento das ca?psulas sa?o reativas, e dependem de est??mulos externos
para que alguma ac?a?o associada seja executada. Tais est??mulos sa?o originados pelo am-
biente, e so? podem ser transmitidos ou recebidos a uma ca?psula atrave?s de suas portas,
objetos definem um ponto de interac?a?o com a ca?psula. Portas realizam protocolos, que
definem o conjunto de sinais de entrada e sa??da de uma ca?psulas, que representam os
servic?os fornecidos e requeridos pela ca?psula. Um protocolo tambe?m define um fluxo
va?lido destes sinais atrave?s das portas. Conectores agem como canais de comunicac?a?o
f??sicos entre portas.

Um modelo em UML-RT e? formado por um conjunto de diagrama e propriedades, tal
qual em UML. Para que os elementos de ROOM fossem incorporados em UML-RT, alguns
diagramas foram estendidos: diagramas de classe, estado e estrutura (extensa?o de dia-
gramas de colaborac?a?o). Este conjunto de diagramas consegue representar inteiramente
as seguintes viso?es arquiteturais: dados, comportamento, configurac?a?o da arquitetura. A
fim de simplificar a especificac?a?o do modelo, iremos focar nosso trabalho somente nesta
viso?es; outros diagramas que indicam somente cena?rios de aplicac?a?o do sistema, como
diagramas de sequ?e?ncia na?o sera?o considerados. Expressaremos propriedades do sistema
diretamente na linguagem Circus 3; Eles poderiam ser alternativamente expressados em
OCL, pore?m um mapeamento entre OCL e Circus e? fora de nosso escopo. Neste traba-
lho, na?o consideraremos heranc?a, devido a sema?ntica de heranc?a de ca?psulas em UML-RT
ainda na?o ser bem-definida.

Os diagramas de classes de UML definem adicionalmente a declarac?a?o de ca?psulas
e protocolos. Ca?psulas podem ter associac?a?o para classes, ca?psulas, ou protocolos do
modelo. Uma associac?a?o com uma classe permite que a ca?psula possa utilizar me?todos e
atributos da classe; gerando como consequ?e?ncia um atributo do tipo da classe na ca?psula.
Enquanto uma associac?a?o entre ca?psulas e? utilizada para permitir que parte do compor-
tamento de uma ca?psula seja explicado a partir da composic?a?o de insta?ncias de outras
ca?psulas. Por fim, uma associac?a?o a um protocolo gera, como consequ?e?ncia, uma porta na
ca?psula. Estes relacionamentos sa?o vistos como agregac?o?es, onde o elemento de destino
da associac?a?o e? parte da ca?psula, e e? criado apenas apo?s a criac?a?o da ca?psula; refere?ncias
c??clicas entre ca?psulas na?o sa?o permitidas. Associac?o?es para ca?psulas, oriundas de classes
e protocolos tambe?m na?o sa?o permitidas.

Apesar de serem associadas como tipos da linguagem, ca?psulas na?o sa?o elementos de
primeira classe e por definic?a?o na?o podem ser atribu??das a nenhuma varia?vel de ambiente.
Sendo suas insta?ncias localizadas unicamente nos diagramas de estrutura que as conte?m; a
visa?o hiera?rquica representada por este diagrama descreve a visa?o extensional das ca?psulas
do sistema. Por o foco deste trabalho ser a modelagem de ca?psulas, e por na?o haver sentido
o compartilhamento de insta?ncias de ca?psulas em diferentes estrutura, assumiremos uma
sema?ntica de co?pia na passagem de para?metros de uma mensagem; classes na?o podem
ser compartilhadas entre ca?psulas. Como a principal aplicac?o?es deste trabalho e? no
desenvolvimento de sistemas distribu??dos, onde ca?psulas representam elementos pass??veis
de distribuic?a?o, consideramos que o compartilhamento de recursos entre ca?psulas deve ser



2.3 uml-rt 14

feitos explicitamente atrave?s da troca de mensagem entre elas utilizando uma sema?ntica
de co?pia. Esta e? uma abordagem comum em tecnologias para sistemas distribu??dos, como
RMI ou CORBA.

Para ilustrarmos a notac?a?o de UML-RT atrave?s de um exemplo, um estudo de caso,
utilizado tambe?m nos cap??tulos seguintes deste trabalho, de um sistema de automac?a?o
industrial e? utilizado. Este sistema e? utilizado para o processamento de pec?as industriais.
Tais pec?as sa?o inseridas no sistema por um operador e apo?s algum tempo sa?o recuperadas
do sistema por ele. Como pode ser visto na Figura 2.1, no diagrama de casos de uso do
sistema. Neste cap??tulo uma versa?o inicial do sistema e? apresentada (Figura 2.2), este
por sua vez sera? o ponto de partida da modelagem do sistema durante um processo de
desenvolvimento no Cap??tulo 5.2.

Figura 2.1. Caso de Uso do Sistema de Automac?a?o Industrial

Na Figura 2.2 e? apresentado (a esquerda) o diagrama de classes do sistema, neste
diagrama encontramos a declarac?a?o das ca?psulas Storage e ProdSys. A ca?psula Storage e?
um elemento de fronteira utilizado para armazenar pec?as industriais (representadas pela
classe Pieces). A ca?psula ProdSys tem como responsabilidade processar pec?as industriais.
Ale?m disto ProdSys representa todo o sistema, e, consequ?entemente, possui uma asso-
ciac?a?o com as outras ca?psulas do modelo. Na realidade as ca?psulas Storage e ProdSys
na?o foram identificadas ao acaso, elas representam elementos de ana?lise extra??dos a partir
dos casos de uso do sistema. Graficamente, a declarac?a?o destas ca?psulas e? representada
por uma caixa com um estereo?tipo Capsula e um s??mbolo em cima a? esquerda. Eles sa?o
formados por tre?s compartimentos, o primeiro indica a declarac?a?o de atributos, o segundo
o de me?todos e o terceiro o de portas, respectivamente de cima para baixo. Por exemplo,
a ca?psula ProdSys possui um atributo p para representar a pec?a que esta processando
no momento, um me?todo process para processar pec?as, e duas portas pi e po para inte-
ragir com as outras ca?psulas do sistema. Note que neste diagrama na?o e? indicado qual
insta?ncias de ca?psulas interagem entre si, isto e? descrito no diagrama de estrutura.

Estas ca?psulas tambe?m tem relacionamentos com protocolos, que sa?o utilizados para
dirigir a comunicac?a?o entre eles. Graficamente a declarac?a?o destes protocolos e? repre-
sentada por uma caixa com um estereo?tipo Protocol e um s??mbolo em cima a? esquerda.
Eles possuem dois compartimentos, o primeiro para descrever os sinais de entrada e o
segundo para os sinais de sa??da do protocolos, respectivamente de cima para baixo. O
protocolo STI governa inserc?a?o de pec?as em uma ca?psula (representado u?nicamente pelo
sinal input), enquanto STO a recuperac?a?o de pec?as (o sinal req e? utilizado para requerer
pec?as, enquanto o sinal output para enviar tais pec?as). Quando sinais sa?o utilizados para



2.3 uml-rt 15

Figura 2.2. Modelo do Sistema de Automac?a?o Industrial

enviar mensagens de dados eles possuem uma classe associada ao tipo do dado, quando
na?o o tipo associado e? void.

Por sua pro?pria natureza, ca?psulas prove?m um alto n??vel de information hiding. Como
seu mecanismo de comunicac?a?o e? realizado atrave?s da passagem de mensagens por suas
portas, todos os atributos e me?todos das ca?psulas sa?o vis??veis somente dentro do escopo
da ca?psulas; somente portas sa?o vis??veis externamente para serem conectadas a? portas
de outras ca?psulas. Este desacoplamento faz com que ca?psulas sejam altamente reuti-
liza?veis, em adic?a?o ca?psulas podem ser definidas hierarquicamente a partir da composic?a?o
de outras ca?psulas dentro de sua estrutura interna (representadas no diagrama de estru-
tura); cada uma delas com uma ma?quina de estados associada e um poss??vel estrutura
hiera?rquica compostas de outras ca?psulas. Chamaremos aqui, as insta?ncias de ca?psulas
dentro da estrutura outra como sub-ca?psulas ou ca?psulas componentes.

Assumimos que a comunicac?a?o entre duas ca?psulas conectadas e? s??ncrona (como o
modelo para UML-RT descrito em [8]), indicando que a ca?psula de destino de um sinal
sempre estara? pronto para recebe-lo. Condic?o?es de mapeamento de um modelo s??ncrono
para um ass??ncrono em UML-RT podem ser vistas em [8].

Um diagrama de estrutura estende o diagrama colaborac?a?o para indicar a interac?a?o en-
tre ca?psulas. Mostrando na?o somente depende?ncias entre objetos, como em um diagrama
de colaborac?a?o, mas indicando a configurac?a?o da arquitetura atrave?s da composic?a?o
hiera?rquica de ca?psulas, das conexo?es entre os pontos de interac?a?o de cada insta?ncia
de ca?psula da estrutura, dos protocolos associados a cada um destas conexo?es. Defi-
nindo assim a composic?a?o estrutural do modelo. A decomposic?a?o estrutural de ProdSys
e? mostrado na figura 2.2 (acima a? direita). Ele e? composto das insta?ncias sin, pro e son,
respectivamente das ca?psulas Storage, Processo e Storage. A ca?psula sin e? responsa?vel
por armazenar pec?as na?o processadas, son por armazenar pec?as processadas, e sys por



2.3 uml-rt 16

recuperar as pec?as oriundas de sin, processa-las e deposita?-las em son. Sendo estas as
representac?o?es gra?ficas para ca?psulas em um diagrama de estrutura. Pequenos quadrados
nas insta?ncias representam suas portas, onde os brancos indicam portas conjugadas (as
direc?o?es dos sinais sa?o invertidos em relac?a?o a definic?a?o do protocolo). Portas normais
devem ser conectadas a? portas conjugadas para que o sinais de sa??da de uma seja visto
como o sinal de entrada da outra. As portas mi e mo sa?o portas relay e servem unicamente
para interligar as portas si e so ao mundo externo; por esta raza?o elas na?o precisam ser
conjugadas. Enquanto as restantes sa?o portas finais e sa?o utilizadas para interligar os
diagramas de estados das ca?psulas ao ambiente externo. Para facilitar a visualizac?a?o da
arquitetura, a estrutura de todas as ca?psulas sa?o vis??veis, pore?m normalmente na?o se e?
poss??vel visualizar a partir do diagrama de estrutura de ProdSys o conteu?do e o tipo das
portas contidos no diagrama de estrutura de sub-ca?psulas.

O comportamento das ca?psulas e do protocolos do modelo e? descrito em termos de um
diagrama de estados em UML-RT, que especializa diagramas de estado de UML [70] para
adequa?-los aos conceitos de ROOM Charts [86]. Estritamente, por serem usados para
descrever objetos ativos, estes diagramas na?o possuem estados finais, tampouco suas
transic?o?es sa?o disparadas por eventos impl??citos; todos os eventos devem ser associados a
sinais externos. Assim como em UML, um diagrama de estados e? composto por transic?o?es
e estados; em geral, uma transic?a?o possui a formato p.e[g]/a, onde e e? um sinal de
entrada (ou um conjunto de sinais de entrada), p indica a porta de origem pelo qual o
sinal foi recebido, g e? uma guarda e a e? uma ac?a?o. O recebimento de um sinais de entrada
em um estado ativo e a avaliac?a?o da guarda correspondente como verdadeira disparam
uma transic?a?o. Como resultado, a ac?a?o correspondente e? executada e um novo estado e?
ativado.

Em UML, estados podem ser classificados como iniciais, escolha, compostos ou sim-
ples. Um estado inicial e? um estado transiente que indica o ponto de in??cio de uma
ma?quina de estados. Um estado composto agrupo outros estados, enquanto um estado
simples na?o possui nenhum outro dentro dele. Um estado de escolha corresponde aos
estados que envolvem uma decisa?o de qual caminho (estado) deve ser seguido (ativado)
em func?a?o de uma guarda associada ao estado; existem apenas duas transic?o?es de sa??da
do estado: uma e? disparada quando a guarda e? verdadeira, e outra quando a guarda e?
falsa. Estados compostos sa?o divididos em dois tipos: Or-States e And-States. Or-State
definem uma composic?a?o seque?ncial de estados, onde somente um deles e? ativado por vez,
enquanto And-States conte?m regio?es (separados por uma linha pontilhada) que executam
sequ?encias de estados em paralelo, e permitem que cada regia?o possua um estado ativo
por vez. And-States sa?o considerados como deciso?es de projetos; de fato eles podem ser
representados pela composic?a?o de duas ca?psulas que possui cada uma das regio?es como
ma?quina de estado. (ver Cap??tulo 4).

Para cada ma?quina de estados em UML-RT, assumimos que existe uma estado com-
posto que possui todos os outros; ele e? chamado de estado topo (ou S0 e seu estado inicial
e? implicitamente disparado quando a insta?ncia da ca?psula ( ou porta) e? criada. Em cada
estado composto transic?o?es sa?o associados diretamente a um ponto de junc?a?o (exibido
graficamente por um circulo preto) na borda do estado. Se na?o e? uma transic?a?o do ponto
de junc?a?o com destino em um sub-estado, o estado inicial sera? ativado; caso tenha destino



2.4 uml 2.0 17

a um sub-estado, este sera? ativado. Transic?o?es de sa??da de um estado composto podem
emanar de um sub-estado ou diretamente da borda do estado. O u?ltimo caso interrompe
o estado e seus sub-estados em qualquer situac?a?o; ac?o?es de entrada e sa??da (ac?o?es execu-
tadas antes do estado ser tornar ativo e inativo, respectivamente) sa?o sempre executadas
normalmente.

A Figura 2.2 (abaixo) apresenta o diagramas de estados das ca?psulas Storage, ProdSys
e dos protocolos STO e STI , eles sa?o denominados graficamente como os estados S0
dos respectivas ca?psulas. Nos dois primeiros casos o comportamento das ca?psulas sa?o
descritas por um estado composto do tipo Or-State, que executa sequ?encialmente seus
estados. Nenhum comportamento em ProdSys esta associado a? sua ma?quina de estados,
podendo ser explicado unicamente pela composic?a?o das sub-ca?psulas que compo?e. Na
ca?psula Storage, por exemplo, apo?s a sua criac?a?o, o estado inicial se torna ativo e ac?a?o
contendo o me?todo Storage() e? executada, isto e? equivalente a? execuc?a?o de um construtor
da ca?psula. Apo?s isto o estado Sa se torna ativo e espera pelos sinais req e input, quando
sinais chegarem e suas respectivas guardam forem avaliadas como verdadeiras as ac?o?es
associadas a estes estados sa?o executadas, retornando assim ao estado Sa; uma descric?a?o
mais detalhada sobre o comportamento da ma?quina de estado de Storage sera? descrita
no Cap??tulo 3.

No?s assumimos que eventos, guardas e ac?o?es sa?o expressas utilizando a notac?a?o de
OhCircus. Por exemplo, no diagrama de estados de ProdSys, a ac?a?o da transic?a?o inicial e?
representada pelo envio de um sinal req atrave?s da porta pi (pi.req), e o evento que dispara
a u?nica transic?a?o de sa??da de Sp e? expresso por pi?output.x, indicando que o recebimento
do sinal output atrave?s da porta pi, cujo valor e? atribu??do a uma varia?vel local x. A ac?a?o
desta transic?a?o executa um me?todo process() que modifica o valor de uma varia?vel p e
apo?s isto envia o evento po!input.p, que comunica o valor p pelo sinal input atrave?s da
porta po. Note o envio de sinais sempre esta? contido nas ac?o?es do diagrama de estado, e
que os prefixos ? e ! sempre esta?o relacionados a eventos que comunicam dados de entrada
e sa??da, respectivamente.

2.4 UML 2.0

A versa?o 2.0 de UML introduz novos conceitos a? versa?o 1.5 e altera outros ja? exis-
tentes1. Nesta sec?a?o, falamos dos conceitos da versa?o 2.0 referenciando minimamente o
metamodelo de UML (o nu?cleo da definic?a?o sema?ntica da linguagem). Apesar disto, para
apresentar os relacionamentos entre esses conceitos, precisamos descrever certos aspectos
do metamodelo, como em particular, o conceito de classificadores, um tipo que pode ter
insta?ncias; por exemplo, classes sa?o classificadores cujas as insta?ncias sa?o objetos. Este
conceito e? importante porque dois dos elementos de UML que vamos discutir, classes e
componentes, sa?o classificadores. Assim, quando descrevemos que um conceitos pode ser
aplicado a classificadores, estamos, consequ?entemente, descrevendo como eles podem ser
aplicados a? classes e componentes.

Esta versa?o combina va?rias caracter??sticas encontradas em alguns ADLs para espe-

01 Ate? a data de entrega desta dissertac?a?o a vera?o 2.0 de UML ainda na?o havia sido publicada como
uma versa?o oficial da OMG.



2.5 concluso?es 18

cificac?a?o de componente a? UML [88], como por exemplo decomposic?a?o hiera?rquica de
componentes. Todas estas caracter??sticas sa?o importantes para formar um novo conceito
de componentes, tratados agora como componentes de software ao inve?s de meros frag-
mentos f??sicos do software para propo?sitos de implantac?a?o. Isto indica que componentes
sa?o pedac?os modularizados, reutiliza?veis, e implanta?veis do software dispon??veis durante
o desenvolvimento, e durante a execuc?a?o do sistema.

Cada classificador (classes e componentes) podem ser compostos por outros elementos
contidos dentro da estrutura interna do classificador. Esta estrutura interna descreve
como os elementos podem ser compostos por outros elementos, chamados de partes ou
elementos conecta?veis. Estes na?o sa?o nunca classificadores, pore?m insta?ncias ou conjunto
de insta?ncias de classificadores. O relacionamento entre estes elementos e os de sua
estrutura interna e? a de agregac?a?o, no sentido que os as partes na?o podem existir sem os
elementos que as conte?m.

Adicionalmente esta estrutura indica como o componente interage com o ambiente
atrave?s de suas interfaces, ou portas. Interfaces e portas sa?o utilizadas para desacoplar
as insta?ncias do ambiente; onde, sob o ponto de vista a insta?ncia e? vista como uma caixa
preta com va?rios pontos de interac?a?o (interfaces ou portas). Interface se diferenciam
de portas, por oferecerem seus servic?os como me?todos. Enquanto portas oferecem seus
servic?os atrave?s de conjunto de sinais.

Ma?quinas de estados foram subdivididas em ma?quinas de estados comportamentais
e de protocolo. A primeira e? utilizada para o mesmo propo?sito que antes, descrever o
comportamento interno de uma classificadores, enquanto a segunda e? usada para definir
o comportamento abstrato associado a interfaces e portas.

2.5 CONCLUSO?ES

Apesar de UML-RT na?o ter sido criado por organizac?o?es de padronizac?a?o (como a
OMG), sendo mantida pelas empresas que suportam suas ferramentas, va?rios conceitos
desta linguagem esta?o diretamente presentes em outras linguagens para a descric?a?o de
arquiteturas (ADLS) ou de componentes (UML 2.0). Unido-os em uma u?nica lingua-
gem, que tem como vantagens, uma separac?a?o clara entre elementos ativos e passivos,
os quais possuem uma sema?ntica diferente para a passagem de mensagens, decomposic?a?o
hiera?rquica de seus componentes, e a definic?a?o expl??cita de inter-conexo?es e interfaces de
seus componentes.

Ale?m disto, possui um pequeno conjunto de diagrams, capazes de descrever os aspec-
tos estruturais e dina?micos do modelo. Desta forma, UML-RT e? uma linguagem enxuta
e? descritiva para a modelagem de componentes ativos. Apesar disto, possui como des-
vantagem, na?o poder descrever explicitamente conexo?es com diferentes comportamentos;
isto pode ser representado implicitamente atrave?s de componentes que funcionam como
adaptadores desta conexa?o. Apesar disto, esta linguagem na?o ser, neste aspectos, me-
nos representativa que outras linguagens para a descric?a?o de arquiteturas, e todas as
contribuic?o?es que possam ser incorporadas ao desenvolvimento em UML-RT podem ser,
consequ?entemente, futuramente aplicadas a UML 2.0, linguagem ainda na?o oficial sob
fase de elaborac?a?o pela OMG, .



CAPI?TULO 3

FORMALIZAC?A?O DE UML-RT

Neste cap??tulo, mostraremos a formalizac?a?o de UML-RT atrave?s de seu mapeamento
sinta?tico na linguagem de especificac?a?o OhCircus [16]. Com esta formalizac?a?o damos
significado aos elementos de UML-RT, em termos da sema?ntica de um subconjunto (Cir-
cus) de OhCircus.

A motivac?a?o para uso desta linguagem formal e? que ela oferece um ca?lculo de re-
finamentos que auxilia na prova de transformac?o?es de modelos em UML-RT usando o
mapeamento em OhCircus. Ale?m disto, objetos ativos e suas conexo?es podem ser facil-
mente representados atrave?s de processos e canais de comunicac?a?o de OhCircus.

Apresentamos, na Sec?a?o 3.1, uma breve introduc?a?o a? linguagem OhCircus, incluindo
noc?o?es de sua sintaxe, sema?ntica e ca?lculo de refinamentos. Como mostramos na Sec?a?o
3.1.2, a sema?ntica e o ca?lculo de refinamentos e? restrito ao subconjunto Circus, mas
isso e? suficiente para lidarmos com as construc?o?es que UML-RT adiciona a UML. Um
mapeamento de UML em OhCircus e? proposto em [10]. Na Sec?a?o 3.2, apresentamos o
mapeamento dos principais elementos de UML-RT em OhCircus.

3.1 OHCIRCUS

OhCircus e? uma linguagem orientada a objetos projetada para lidar com a especi-
ficac?a?o e o refinamento de sistemas concorrentes. OhCircus combina a a?lgebra de pro-
cessos CSP [79] com a linguagem baseada em modelos Z [95] com o intuito de capturar
aspectos relacionados ao estado e a? comunicac?a?o do sistema em uma mesma especificac?a?o,
como em [94].

Para expressar a comunicac?a?o de sistemas concorrentes, OhCircus inclui a noc?a?o de
processo, cujo estado e? definido por um esquema em Z e o comportamento por uma ac?a?o
na notac?a?o de CSP. A interac?a?o entre processos e? realizada somente atrave?s de canais,
utilizados para comunicar valores ou somente para a sincronizac?a?o.

Ale?m de sua utilizac?a?o para especificac?a?o de sistemas concorrentes e reativos, OhCir-
cus foi projetada para suportar uma teoria de refinamentos. O objetivo desta teoria e? dar
uma base so?lida ao desenvolvimento de sistemas concorrentes e distribu??dos, utilizando
um ca?lculo de refinamentos semelhante ao encontrado em [67].

3.1.1 Sintaxe

Da mesma maneira que especificac?o?es em Z, programas em OhCircus sa?o formados
por uma sequ?e?ncia de para?grafos:

Program ::= OhCircusParagraph?

Onde, OhCircusParagraph? denota um lista com zero ou mais elementos da categoria

19



3.1 ohcircus 20

sinta?tica OhCircusParagraph. Cada um destes para?grafos pode ser um para?grafo de Z (de-
notados aqui pela categoria sinta?tica Paragraph, conforme definido em [95]), ou a definic?a?o
de canais, grupo de canais, processos ou classes (denotados, respectivamente, pelas catego-
rias sinta?ticas ChannelDefinition, ChanSetDefinition OhProcessDefinition, ClassDefinition).

OhCircusParagraph ::= Paragraph
| ChannelDefinition | ChanSetDefinition
| OhProcessDefinition | ClassDefinition

Os principais construtores de OhCircus sa?o ilustrados atrave?s de uma parte da espe-
cificac?a?o do sistema de automac?a?o industrial (previamente introduzido na Sec?a?o 2.3); a
grama?tica completa de OhCircus pode ser encontrada no Ape?ndice A. Na Figura 3.1,
apresentamos a especificac?a?o da ca?psula Storage, utilizada para armazenar objetos da
classe Piece, atrave?s de um processo ChartStorage em OhCircus. Utilizaremos o mesmo
fonte da Figura 2.2 para identificadores (por exemplo, nomes de atributos, classes e
ca?psulas) encontrados diretamente no modelo em UML-RT.

O tamanho ma?ximo de armazenamento e? representado atrave?s de uma constante
positiva N , declarada no primeiro para?grafo da Figura 3.1.

| N : N
TSTI ::= input ? Piece ?
channel si : TSTI
TSTO ::= req | output ? Piece ?
channel so : TSTO
process ChartStorage =? begin

state StorageState =? [buff : seq Piece; size : 0..N | size = #buff ? N ]
StorageInit =? [StorageState? | buff? = ?? ? size? = 0]
insert =? [?StorageState; x ? : Piece | size &amp;lt;N ?

buff? = buff a ?x ?? ? size? = size + 1]
remove =? [?StorageState; x ! : Piece | size &gt; 0 ? x ! = head buff ?

buff? = tail buff ? size? = size ? 1]
Sa =? (size &amp;lt;N &amp;amp; si?input.x ? insert(x); Sa)

2 (size &gt; 0 &amp;amp; so.req ? (var x : Piece • x = remove(); so!output.x); Sa)
• StorageInit; Sa
end

Figura 3.1. Especificac?a?o da ca?psula Storage

Todos os canais utilizados por um processo devem ser declarados. As categorias
sinta?ticas Expression e Schema?Exp sa?o utilizadas para designar expresso?es em Z e ex-
presso?es de esquema definidas em [95]. A categoria sinta?tica N e? utilizada para identifi-
cadores va?lidos em Z.



3.1 ohcircus 21

ChannelDefinition ::= channel CDeclaration
CDeclaration ::= SimpleCDeclaration | SimpleCDeclaration; CDeclaration
SimpleCDeclaration ::= N+ | N+ : Expression | Schema?Exp

A declarac?a?o de uma canal e? composta por um nome e o valor comunicado pelo canal.
Caso o canal seja utilizado apenas para a sincronizac?a?o de processos, sem comunicac?a?o
de valor, a declarac?a?o contera? apenas o nome do canal, sem um tipo associado.

Uma mesma declarac?a?o pode introduzir mais de um canal, desde que tenham o mesmo
tipo. Neste caso, ao inve?s de um u?nico nome, temos uma lista de nomes de canais
separados por v??rgula.

Em nosso exemplo, o processo armazena e fornece objetos atrave?s dos canais si e
so, respectivamente. Os tipos TSTI e TSTO indicam que valores podem ser comunicados
por estes canais; neste exemplo, esses tipos sa?o declarados como tipos enumerados. Em
TSTO, req e? um construtor (de tipo) utilizado no exemplo para representar a requisic?a?o
de objetos do processo, e output um construtor utilizado para representar o fornecimento
dos objetos requisitados. E input, em TSTI, e? utilizado para representar o armazenamento
de objetos do tipo Piece.

A declarac?a?o de um processo e? composta por seu nome e sua especificac?a?o. Apesar de
OhCircus possibilitar a heranc?a de processos, (utilizando-se a palavra-chave extends),
esta caracter??stica na?o e? abordada neste trabalho.

OhProcessDefinition ::= process N =? [extends N] Process

Um processo pode ser explicitamente definido, ou pode ser definido em termos de
outros processos. Uma definic?a?o expl??cita de um processo e? delimitada pelas palavras-
chaves begin e end; ela e? formada por uma sequ?e?ncia de para?grafos do processo e uma
ac?a?o principal (no final da definic?a?o, apo?s o s??mbolo •), que define o comportamento do
processo. Um destes para?grafos e? utilizado para descrever o estado do processo atrave?s
da notac?a?o Z, apo?s a palavra-chave state.

Process ::= begin PParagraph?

[state Schema?Exp]
PParagraph?

[• Action]
end

| CompProcess

Em nosso exemplo, o processo ChartStorage encapsula dois componentes de estado no
esquema StorageState: uma lista de objetos e o tamanho desta lista.

Na definic?a?o expl??cita de um processo, ale?m da definic?a?o de seu estado e ac?a?o principal,
o seu corpo e? formado por para?grafos em Z e ac?o?es. Estes para?grafos sa?o utilizados para
estruturar a especificac?a?o e sa?o referenciados pela ac?a?o principal.

PParagraph ::= Paragraph | N =? ParAction | nameset N == NSExp

Uma ac?a?o pode ser um esquema, um comando guardado, uma invocac?a?o para uma
ac?a?o previamente definida, ou uma combinac?a?o de outras ac?o?es utilizando operadores de



3.1 ohcircus 22

CSP.

Action ::= Schema?Exp | CSPActionExp | Command | N

O corpo de para?grafos do processo ChartStorage e? formado por tre?s esquemas em Z
que modificam o estado: StorageInit, insert e remove. O esquema StorageInit especifica
a operac?a?o de inicializac?a?o do processo, definindo a sua lista de objetos como vazia. A
operac?a?o insert adiciona um objeto a? lista e atualiza o atributo size com seu novo tamanho,
enquanto a operac?a?o remove modifica o estado, removendo o primeiro elemento da lista
e decrementando o valor de size (ver Figura 3.1).

Assim como em Z, interrogac?o?es (?), exclamac?o?es (!) e apostrofos (?) sa?o utilizados
para decorar varia?veis de entrada, de sa??da ou com estado final (valor apo?s a operac?a?o),
respectivamente.

Tre?s ac?o?es primitivas de CSP esta?o dispon??veis em OhCircus: Skip, Stop e Chaos. A
ac?a?o Skip na?o comunica qualquer valor, tampouco alterar o estado: ela termina imedi-
atamente. A ac?a?o Stop representa deadlock, e a ac?a?o Chaos representa diverge?ncia. A
u?nica garantia em ambos os casos e? que o invariante do estado e? mantido.

CSPActionExp ::= Skip | Stop | Chaos
| Communication ? Action | Predicate &amp;amp; Action
| Action; Action | Action 2 Action | Action u Action
| Action |[ NSExp | CSExpression | NSExp ]| Action
| Action ||[NSExp | NSExp]|| Action
| Action \ CSExpression | µ N • Action | ...

Communication ::= N CParameter?

CParameter ::= ?N |?N : Predicate |!Expression | .Expression

Comunicac?o?es (representadas pela categoria sinta?tica Communication) em OhCircus
obedecem ao mesmo padra?o de CSP, pore?m guardas podem ser associadas a elas; a
categoria sinta?tica Predicate, utilizada para predicados em Z, e? definida em [95]. Por
exemplo, dado um predicado p em Z, se a condic?a?o p for verdade, a ac?a?o p &amp;amp; (c?x ? A)
recebe um valor atrave?s do canal c e o atribui a? varia?vel x no mesmo escopo, executando,
apo?s isto, a ac?a?o A. No entanto, se a condic?a?o p for falsa, esta ac?a?o e? bloqueada (refutada).
Isto possibilita que condic?o?es, como a guarda p, possam ser associadas a qualquer ac?a?o.

Todas as varia?veis livres precisam estar no mesmo escopo que uma ac?a?o. Todos
os componentes do estado esta?o em um escopo global para qualquer ac?a?o do processo.
Valores de entrada de canais introduzem novas varia?veis no escopo, e atribuem este valor a
elas; estas varia?veis na?o podem receber novas atribuic?o?es. Os operadores de composic?a?o
de CSP para ac?o?es de sequ?e?ncia (; ), escolha interna (u) e externa (2), paralelismo
(|[NSExp |CSExpression |NSExp]|), interleaving (||[NSExp | NSExp]||), e hiding (\) podem
ser utilizados para compor ac?o?es. Operadores de CSP para a definic?a?o de comunicac?a?o
e de recursividade (µ) tambe?m sa?o permitidos no n??vel de ac?o?es. Outros operadores de
composic?a?o de CSP podem ser encontrados na grama?tica de OhCircus (ver Ape?ndice A).

Em nosso exemplo, a ac?a?o principal inicializa o processo ChartStorage e oferece conti-
nuamente a escolha para o ambiente dos eventos si?input.x e so.req. Esta escolha pelo



3.1 ohcircus 23

ambiente e? definida atrave?s do operador de escolha externa (2). Tal escolha e? continua-
mente oferecida atrave?s do uso do operador de recursividade (µ).

Sa =? (size &amp;lt;N &amp;amp; si?input.x ? insert(x); Sa)
2 (size &gt; 0 &amp;amp; so.req ? (var x : Piece • x = remove(); so!output.x); Sa)

• StorageInit; Sa

O processo somente aceita input se existir espac?o para armazenar o novo objeto; o
sinal e? guardado por size &amp;lt;N . Caso a guarda seja satisfeita, o objeto e? adicionado a? lista
atrave?s da operac?a?o insert, que tambe?m incrementa a varia?vel size. A ac?a?o si?input.x ?
insert(x) e? escrita no estilo de CSP. Nesta ac?a?o, a varia?vel x e? declarada dinamicamente
com o tipo dado pelo canal si e com o valor correspondente ao comunicado atrave?s do
mesmo. O evento so.req somente e? habilitado caso o processo contenha algum objeto em
sua lista; caso esta condic?a?o seja verdadeira, o retorno de uma ac?a?o remove() (o objeto
inicial da lista buff) e? atribu??do a uma varia?vel x, seguido do envio do valor de x atrave?s
do evento so!output.x.

No n??vel de ac?o?es, os operadores de paralelismo e interleaving sa?o levemente diferentes
daqueles de CSP. Com a intenc?a?o de evitar conflitos no acesso a?s varia?veis em escopo, estes
operadores de ac?o?es precisam declarar dois conjunto que particionam todas as varia?veis em
escopo: componentes de estado, varia?veis locais e de entrada. O operador de paralelismo
de OhCircus segue uma abordagem alfabetizada, adotada em [79]. Quando processos
sa?o postos em paralelo, o conjunto de eventos em que eles sincronizam necessitam ser
explicitamente especificado; eventos que na?o sa?o listados ocorrem independentemente.
Por exemplo, no paralelismo A1 |[ ns1 | cs | ns2 ]| A2, as ac?o?es A1 e A2 sincronizam nos
canais do conjunto cs. A ac?a?o A1 pode modificar somente os valores das varia?veis em
ns1; similarmente, a ac?a?o A2 pode modificar valores das varia?veis em ns2. As ac?o?es
compostas pelo operador de interleaving se comportam de maneira similar ao operador
de paralelismo em relac?a?o a?s suas partic?o?es.

Apo?s definidos explicitamente, os processos podem ser combinados utilizando-se ope-
radores de CSP para formar novos processos.

CompProcess ::= N | Proc; Process | Process \ CSExpression
| Process 2 Process | Process u Process |
| Process ||| Process | Process |[ CSExpression ]| Process |...

Dois Processos P1 e P2 podem ser combinados, por exemplo, em sequ?e?ncia (P1; P2),
onde o processo P2 executa apo?s o te?rmino com sucesso da execuc?a?o de P1, ou em paralelo
P1|[cs]|P1, sincronizando sobre eventos de cs; seguindo uma abordagem alfabetizada como
a adotada em [79].

No nosso exemplo do sistema de automac?a?o (Sec?a?o 2.3), o processo que representa
a ca?psula MAIN e? definido pela composic?a?o paralela de todos os processos do sistema
(ca?psulas), sincronizando em seus canais de comunicac?a?o, como apresentado na Sec?a?o 3.2.
Por exemplo, de maneira simplificada, os processos relativos a?s insta?ncias das ca?psulas
Storage e Processo sa?o compostos utilizando o operador de paralelismo Storage[so := c2]|[{|
c2 |}]|Processo[pi := c2]. Neste caso, para que os dois processos sincronizem em um canal
de comunicac?a?o comum c2, os canais so e pi devem ser renomeados para c2.



3.1 ohcircus 24

A sintaxe para a definic?a?o de classe e? expressa por seu nome, sua super classe atrave?s
da cla?usulas extends, e seus atributos e me?todos delimitados pelas cla?usula begin e
end. Por na?o abordarmos heranc?a neste trabalho, toda classe devera? omitir a cla?usula
extends. Assim como em processos, a definic?a?o de atributos e me?todos de uma classe
consiste em uma sequ?e?ncia de para?grafos, onde o para?grafo com a cla?usula state iden-
tifica o esquema de estado da classe com seus componentes de estado (atributos). O
esquema de estado de uma classe e? definido em Z assim como os estados de um processo,
pore?m inclui qualificadores (public, protected, private e logical) na declarac?a?o de
seus componentes. Caso um atributo na?o seja qualificado, este e? assumido como privado.

ClassDefinition ::= class N =? [extends N]begin CParagraph?

[state StateSchema] CParagraph?

[initial Schema?Exp] CParagraph?
end

CParagraph ::= Paragraph | Qualifier N =? ParametrisedCommand
Qualifier ::= public | protected | private | logical

A cla?usula initial introduz o construtor da classe. Este na?o e? introduzido para ser
um me?todo, apenas para definir a criac?a?o da classe, na?o devendo ter em sua especi-
ficac?a?o varia?veis de sa??da. Me?todos (categoria sinta?tica CParagraph) sa?o declarados como
para?grafos em Z, diferenciando-se pore?m pela possibilidade de utilizarem qualificadores
de acesso, indicando em que escopo podem ser chamados.

Na Figura 3.2, a especificac?a?o de Piece e? descrita atrave?s de um para?grafo com o
estado da classe e tre?s para?grafos com operac?o?es. O esquema de estado e? composto de
um u?nico componente data, representado por uma sequ?e?ncia de naturais de tamanho
100. O para?grafo PieceInit representa o construtor da classe Piece, inicializando todos os
valores de data com 0. Os me?todos setData e getData sa?o utilizados somente para alterar
e recuperar o valor do componente data.

class Piece =? begin
state PieceState =? [data : seq N | #data = 100]
initial PieceInit =? [PieceState? | ran data? = {0}]
public setData =? [?StorageState; d? : seq N | data? = d?]
public getData =? [?StorageState; r ! : seq N • r ! = data]

end

Figura 3.2. Especificac?a?o da classe Piece

3.1.2 Sema?ntica

Apesar de utilizamos OhCircus para o mapeamento de um subconjunto compreens??vel
de UML-RT (Sec?a?o 3.2), classes do sistema sa?o semanticamente vistas, aqui, apenas como
registros na?o compartilhados de dados, representados em Z. Na?o sendo necessa?rio assim



3.1 ohcircus 25

abordar todas as caracter??sticas de orientac?a?o a objetos de UML. A sema?ntica de classes
para UML em Z (e portanto para UML-RT) e? considerada em diversos trabalhos [30, 12,
69]. Como este trabalho foca apenas na definic?a?o sema?ntica dos elementos que UML-RT
adiciona a? UML, a utilizac?a?o de um subconjunto de OhCircus (Circus) que na?o utiliza
orientac?a?o a objetos e? satisfato?ria para a finalidade deste trabalho..

O modelo sema?ntico de Circus e? baseado na Teoria Unificada da Programac?a?o (UTP)
[47]. A UTP e? um framework no qual a teoria de relac?o?es sa?o utilizadas como uma base
unificada para a cie?ncia da programac?a?o, atrave?s de seus diferentes paradigmas: proce-
dural e declarativo, sequ?encial e paralelo, acoplado e distribu??do, e hardware e software.

Programas, projetos, e especificac?o?es sa?o interpretados como relac?o?es entre uma ob-
servac?a?o inicial e subsequ?ente, que pode ser uma observac?a?o intermedia?ria ou final, do
comportamento da execuc?a?o de um programa. Leis do ca?lculo relacional podem ser uti-
lizadas como ferramental de prova.

Desta maneira, ide?ias, como composic?a?o sequ?encial, condicional, na?o-determinismo,
e paralelismo sa?o compartilhadas por diferentes teorias. Em cada teoria, varia?veis de
observac?a?o sa?o identificadas para descrever seus aspectos mais importantes, e sub-teorias
sa?o criadas a partir de restric?o?es do relacionamento entre estas varia?veis de observac?a?o.
Um exemplo e? a pro?pria linguagem Circus, que estende a teoria de CSP para processos
reativos. Em Circus a definic?a?o de um processo, por exemplo, possui ambientes para ar-
mazenar informac?o?es de canais e varia?veis em escopo, componentes de estado, para?grafos
e processos que compo?e.

Neste trabalho, na?o entramos no detalhe da sema?ntica de processos ou canais em
Circus; a sema?ntica completa de Circus pode ser encontrada em [100]. Entretanto,
mostramos como os operadores de composic?a?o de processos, podem ser representados
atrave?s de processos simples, cuja sema?ntica e? apresentada em [100].

3.1.2.1 Expresso?es de Processos Expresso?es de processos utilizam operadores de
CSP para combinar processos existentes. A sema?ntica de uma expressa?o R op Q, onde op
e? uma operac?a?o bina?ria qualquer em CSP, exceto paralelismo e interleaving, e? definida
da seguinte forma.

R op Q = begin
state State =? R.st ? Q.st
R.pps ? Q.st
Q.pps ? R.st
• R.act op Q.act

end

O estado dos processos R e Q sa?o denotados por R.st e Q.st, respectivamente. De uma
maneira similar, a notac?a?o R.pps e Q.pps sa?o utilizadas para se referir aos para?grafos
na definic?a?o dos processos R e Q. Suas ac?o?es principais sa?o denotadas com R.act e
Q.act. As operac?o?es do processo composto sa?o formadas pelos esquemas de R.pps ? Q.st
e Q.pps ? Q.st. O termo R.pps ? Q.st indica que as operac?o?es em R.pps na?o podem
alterar os componentes do estado em Q.st; para garantir isto, e? adicionado a? operac?a?o a
expressa?o ?Q. Similarmente, Q.pps na?o altera os componentes em R.st.



3.1 ohcircus 26

Como discutido na Section 3.1.1, os operadores de paralelismo e interleaving para
ac?o?es sa?o levemente diferentes daqueles utilizados para processos; no n??vel de ac?o?es,
partic?o?es com todas as varia?veis no escopo precisam ser declaradas. Por esta raza?o,
um novo operador R.pps ?PAR Q.st e? utilizado na definic?a?o de paralelismo e interleaving.
Este operador libera as operac?o?es em R.pps para alterar todas as varia?veis de ambiente,
utilizando ?Q ao inve?s da expressa?o ?Q. Apesar disto, esta permissa?o e? ignorada, ja? que
os componentes de estado de Q.st esta?o declarados na mesma partic?a?o utilizada pelas
ac?o?es de Q.act; de forma similar, R.st pertencem a? partic?a?o utilizada pelas ac?o?es de
R.act. Assim a sema?ntica do operador de paralelismo e? definida como segue.

R |[ cs ]| Q = begin
state State =? R.st ? Q.st
R.pps ?PAR Q.st
Q.pps ?PAR R.st
• R.act |[ ns1 | cs | ns2 ]| Q.act

end

Na definic?a?o do operador de paralelismo, R.st esta? contido em ns1, e Q.st em ns2. O
operador de interleaving e? definido de forma similar.

A sema?ntica do operador de hiding e? mais simples: os para?grafos do processo sa?o
inclu??dos sem alterac?o?es, somente a ac?a?o principal e? modificada para esconder os canais
usados como argumento do hiding.

R \ cs = begin
state R.st
R.pps
• R.act \ cs

end

A sema?ntica de outros operadores pode ser encontrada em [99]

3.1.3 Noc?o?es de Refinamento e Equivale?ncia

Uma das noc?o?es centrais na UTP e? a de refinamento, que e? definida em termos de
implicac?a?o: uma implementac?a?o P satisfaz uma especificac?a?o S se, e somente se, [P ? S ],
onde os colchetes denotam o quantificador universal sobre o alfabeto utilizado por P e S ,
como em [21]; o alfabeto deve ser o mesmo para a implementac?a?o e para especificac?a?o.
A noc?a?o de equivale?ncia, e? igual a? demonstrac?a?o do refinamento em ambas as direc?o?es;
na UTP, [P = S ] se e somente se [P ? S ] e [S ? P ].

Em Circus (e, portanto, em OhCircus), a noc?a?o ba?sica de refinamento para ac?o?es e
dada pela Definic?a?o 3.1 [15].

Definic?a?o 3.1 (Refinamento de Ac?o?es) Para ac?o?es A1 e A2 no mesmo espac?o de es-
tados, A1 vA A2 se e somente se [A1 ? A2]. 2

Processos, que possuem seus estados privados, possuem uma definic?a?o levemente di-
ferente. A ac?a?o principal de um processo define seu comportamento. Por esta raza?o,



3.1 ohcircus 27

refinamento de processos e? definido em termos de refinamento de ac?o?es de blocos lo-
cais. A seguir, P1.st e P1.act denotam o estado local e a ac?a?o principal do processo P1;
similarmente para o processo P2.

Definic?a?o 3.2 (Refinamento de Processos) P1 vP P2 se e somente se (?P1.st; P1.st?
• P1.act) vA (?P2.st; P2.st? • P2.act) 2

As ac?o?es P1.act e P2.act podem agir em diferentes espac?os de estado. As ac?o?es destes
processos sa?o comparadas ignorando-se seus componentes de estado; o espac?o de estado
conte?m somente as varia?veis observadas na UTP.

Como dito anteriormente, o estado de um processo e? privado, permitindo que seus
componentes sejam modificados durante um refinamento, atrave?s de refinamento de da-
dos [68]. Em [17], a te?cnica de simulac?a?o aplicada em Z foi adotada para lidar com
processos e ac?o?es. Uma simulac?a?o e? uma relac?a?o entre os estados de dois processos que
satisfazem um conjunto de propriedades.

Definic?a?o 3.3 (Forwards Simulation) Uma forwards simulation entre as ac?o?es A1 e
A2 de processos P1 e P2, com um estado local L, e? uma relac?a?o R entre P1.st, P2.st, e L,
satisfazendo.

• (Aplicabilidade) ?P2.st; L • (?P1.st • R)

• (Corretude) ?P1.st; P2.st; P2.st?; L • R ? A2 ? (?P1.st?; L? • R? ? A1) 2

Neste caso, no?s escrevemos A1 ?P1,P2,R,L A2. Uma forwards simulation entre P1 e P2
e? uma forwards simulation entre suas ac?o?es principais.

Como destacado em [17], diferentemente da definic?a?o usual de forwards simulation,
na Definic?a?o 3.3 na?o existe um requisito de aplicabilidade em relac?a?o a?s pre?-condic?o?es.
Isto se deve ao fato de que ac?o?es sa?o totais. Se uma ac?a?o e? executada fora de sua pre?-
condic?a?o, ela diverge; pore?m, seu comportamento na?o e? arbitra?rio, ja? que o invariante de
estado e? implicitamente mantido, e novas sincronizac?o?es arbitra?rias podem ser observadas,
mas observac?o?es passadas na?o sa?o afetadas. Ale?m disto, nenhuma condic?a?o especifica e?
imposta em sua inicializac?a?o: qualquer inicializac?a?o de estado precisa ser explicitamente
inclu??da na ac?a?o principal.

Um teorema em [17] indica que se existe uma relac?a?o de forwards simulation existe
tambe?m uma relac?a?o de refinamento. Uma estrate?gia de refinamento para Circus foi
definida em [17]. Esta estrate?gia, pode envolver va?rias iterac?o?es com tre?s passos: refi-
namento de dados, refinamento de ac?o?es, e refinamento de processos. Os dois primeiros
passos sa?o utilizados para reorganizar a estrutura de um processo, alterando-se seus com-
ponentes de estados e suas ac?o?es. O terceiro passo e? utilizado para refinar (tipicamente,
decompor) processos, preservando o comportamento.

3.1.4 Leis para refinamento de Processos

Leis para o refinamento de processos lidam simultaneamente com estado e comporta-
mento. Nesta sec?a?o, apresentaremos duas leis para o refinamento de processos; mais leis
podem ser encontradas em [17].



3.1 ohcircus 28

A primeira lei indica que podemos introduzir novos processos em uma especificac?a?o,
assumindo que eles na?o sejam utilizados. Como na introduc?a?o de novas varia?veis em uma
linguagem imperativa, o fato de o processo na?o ser utilizado e? suficiente para garantir
que sua introduc?a?o na?o afeta os demais processos.

Lei 3.1 Introduc?a?o de declarac?a?o de processo

cp = pd cp

desde que: o processo declarado em pd na?o seja referenciado nem declarado na
sequ?e?ncia de para?grafos do programa em Circus cp. 2

Apesar desta lei expressar uma propriedade simples, sua importa?ncia se torna evidente
em sua composic?a?o com outras leis.

A lei a seguir e? aplicada para particionar um processo cujos componentes de estado
podem ser divididos em dois conjuntos, de uma maneira tal que cada um deles possui seu
pro?prio conjunto de para?grafos, que na?o interfere no outro. A forma geral e? apresentada
pelo P abaixo.

process P =? begin
state State =? Q.st ? R.st
Q.pps ? R.st
R.pps ? Q.st
• F (Q.act, R.act)

end

Como na definic?a?o da expressa?o de processos (Sec?a?o 3.1.2.1), o estado do processo P
e? definido pela conjunc?a?o de outros dois esquemas Q.st e R.st. Ale?m disto, os para?grafos
de P sa?o tambe?m particionados de maneira que os para?grafos em Q.pps na?o alteram os
componentes de R.st; de uma maneira similar, os para?grafos em R.pps na?o alteram os
componentes em Q.st. Quando dois conjuntos de para?grafos satisfazem estas condic?o?es,
dizemos que eles sa?o disjuntos com respeito a R.st e Q.st. Finalmente, a ac?a?o principal
de P e? definida como uma composic?a?o F das ac?o?es Q.act e R.act, onde F e? um contexto
(func?a?o sobre processos) envolvendo operadores de CSP que podem ser utilizados na
composic?a?o de processos.

A Lei 3.2, apresentada abaixo, transforma um processo particionado P (como definido
acima) em tre?s processos, onde os dois primeiros incluem as partic?o?es dos estados e dos
para?grafos de P , e o terceiro processo e? definido em termos dos dois primeiros, utilizando
a mesma func?a?o F que define a ac?a?o principal de P .

Lei 3.2 (Decomposic?a?o de processo) Seja qd e rd declarac?o?es dos processos Q e R,
determinados por Q.st, Q.pps, e Q.act, e R.st, R.pps, e R.act, respectivamente, e pd a
declarac?a?o do processo P . Enta?o:

pd = (qd rd process P =? F (Q, R))

desde que: Q.pps e R.pps sejam disjuntos com respeito a R.st e Q.st, respectivamente.
2



3.2 mapeamento 29

3.2 MAPEAMENTO

Nesta sec?a?o, atribu??mos significado sema?ntico aos elementos de UML-RT atrave?s de
seu mapeamento sinta?tico para OhCircus. Esta traduc?a?o prove? um mapeamento tanto
da visa?o estrutural quanto comportamental dos elementos de UML-RT para OhCircus.

Em nossa estrate?gia de mapeamento, o destino da traduc?a?o e? uma especificac?a?o em
Circus que possui o significado do modelo original. Classificadores de UML-RT com um
comportamento associado (ca?psulas e protocolos) sa?o mapeados em processos, e portas
em canais.

Como mencionado anteriormente, o mapeamento de classes ja? foi considerado por
diversos autores [12, 29, 10], e esta? fora do escopo deste trabalho. Assumimos que classes
em UML podem ser mapeadas diretamente em classes de OhCircus, como exposto em [10].
Ale?m disto, assumimos um modelo em UML-RT mais concreto, onde associac?o?es sa?o
diretamente interpretadas como atributos de classe, e invariantes devem ser locais ao
escopo da classe. Apesar destas considerac?o?es serem decididas somente durante o projeto
do modelo, a antecipac?a?o dessas deciso?es sa?o comumente realizadas na concretizac?a?o do
modelo e sa?o justificadas atrave?s de refinamentos de modelo UML, como apresentado
em [10].

Aqui somente associac?o?es unidirecionais sa?o utilizadas, indicando um atributo da
classe, e na?o relacionamentos entre todas as insta?ncias da classe. Assim, restric?o?es sobre
estas associac?o?es sa?o confinadas dentro dos invariantes de classe (ou ca?psula). Ale?m
disto, invariantes podem incluir somente refere?ncias para varia?veis no escopo da classe
(ou ca?psula), descrita por atributos da classe (ou ca?psula) ou por atributos de classes
acessados via navegac?a?o.

Consideramos tanto uma visa?o intensional quanto extensional do modelo. A visa?o
intencional e? mapeada diretamente nos elementos sinta?ticos de UML-RT. A visa?o exten-
sional e? implicitamente definida pelo diagrama de estrutura de suas ca?psulas; eles conte?m
o conjunto de todas as insta?ncias de ca?psulas. Para lidar com a sua estrutura hiera?rquica
em Circus, assumimos que todas as insta?ncias de ca?psulas, portas e conectores te?m um
u?nico nome no modelo.

Iniciamos o mapeamento a partir dos protocolos do modelo, e , em seguida, a ca?psula
que representa todo o sistema; incrementalmente, cada componente de ca?psula e? mapeado
para Circus, seguindo uma apresentac?a?o top-down. No exemplo de automac?a?o industrial
(Figura 2.2), a ca?psula mais externa e? ProdSys.

Quando mapeamos elementos declarados em uma lista (como os sinais de um pro-
tocolo, e atributos e me?todos de uma ca?psula), por convenc?a?o destacamos um de seus
elementos, apresentamos seu mapeamento, e invocamos uma meta-func?a?o (TL()) para
traduzir os outros elementos da lista. Por simplicidade, assumimos que TL() e? sobrecar-
regada (overloaded ), para cada tipo de lista (atributos, me?todos, sinais, portas, insta?ncias
de ca?psula). Na pra?tica, obviamente, cada lista de elementos pode ser vazia, pore?m evi-
tamos este caso trivial, assumindo que ela possui pelo menos um elemento.



3.2 mapeamento 30

3.2.1 Mapeamento estrutural

Uma declarac?a?o de um protocolo em UML-RT encapsula definic?o?es de elementos de
comunicac?a?o (sinais) e um comportamento de controle (diagrama de estados). Em Oh-
Circus, isto gera dois elementos: um processo sem estado que captura o comportamento
do protocolo e um canal para representar os elementos de comunicac?a?o. Em relac?a?o aos
sinais, um poss??vel mapeamento poderia ser feito introduzindo-se um canal para cada um
dos sinais do protocolo. Ao inve?s disto, no?s utilizamos um u?nico canal para comunicar
todos os sinais de um protocolo. Este canal comunica valores de um tipo enumerado,
onde cada um de seus construtores representa um sinal. Utilizar um u?nico canal facilita
o mapeamento de ca?psulas apresentado a seguir. Por exemplo, quando nos referimos
aos sinais envolvidos em uma sincronizac?a?o ou mudanc?a de nome (renaming), e? mais
conveniente utilizar um u?nico canal.

TP ::= i ?T (I) ?| o | TL(incomes) | TL(outgoings)
channel chanP : TP
process P =? begin •H(SP) end

O protocolo P e? mapeado no processo de mesmo nome e no canal chanP. Em nomes
com ??ndice subscrito, como chanP acima, no?s assumimos que P e? um nome que devera?
ser substitu??do pelo nome do protocolo sendo mapeado. Desta forma, o mapeamento do
protocolo STO no estudo de caso (Figura 2.2) gera um canal correspondente chanSTO.
O canal chanP comunica valores de tipo enumerado TP; cada valor representa um sinal.
Sinais sem para?metros, como o sinal de sa??da o acima, sa?o traduzidos em constantes;
sinais parametrizados sa?o mapeados em construtores de tipos de dados (como i). O tipo
do para?metro e? traduzido em seu tipo correspondente em OhCircus pela func?a?o T (). Os
sinais restantes (incomes e outgoings) sa?o mapeados pela func?a?o TL(), como previamente
explicado.

O comportamento do protocolo P e? representado por H(SP), onde SP representa o
estado que encapsula todos os outros estados do diagrama de estados de P. Note que,
apesar do diagrama de estados de um protocolo poder ser sempre representado por um
estado S0, preferimos destacar todo o comportamento de P em um subestado SP, onde
o comportamento de H(S0) e? equivalente ao de H(SP). A func?a?o H(), que traduz um
diagrama de estados em ac?o?es de OhCircus, e? definida na Sec?a?o 3.2.2.

Em nosso exemplo da Figura 2.2, o mapeamento do protocolo STO possui o formato
a seguir. O comportamento do protocolo e? definido pelo processo homo?nimo P e seus
elementos de comunicac?a?o (sinais) sa?o definidos pelo canal chanSTO que comunica valores
do tipo enumerado TSTO, explicado anteriormente na Sec?a?o 3.1.1. A ac?a?o principal de
STO e? expressa pela aplicac?a?o da func?a?o H ao seu estado mais externo S0.

TSTO ::= req | output ?T (Piece) ?
channel chanSTO : TSTO
process STO =? begin •H(S0) end



3.2 mapeamento 31

Ca?psulas sa?o definidas tambe?m como processos, com me?todos definidos em esquemas
de operac?o?es e atributos mapeados em esquemas de estado em Z (o estado do processo).
Cada porta gera um canal com o mesmo tipo de dados do canal correspondente ao seu
protocolo, e tem seu comportamento descrito pelo processo obtido do mapeamento de
seu protocolo sincronizado com o obtido do diagrama de estados da ca?psula. Observe
que, em UML-RT, o tipo de uma porta e? o pro?prio protocolo. Em OhCircus, o tipo de
um canal originado por uma porta e? um tipo enumerado que representa seus sinais (como
explicado no mapeamento de protocolos).

channel p : TP; TL(ports); TL(ports?)
process ChartC =? begin

state Cstate =? [a : T (A); TL(atts) | InvC]
m =? [?Cstate ; x : T (X);

TL(params) | Prem ? Postm]
TL(meths)
•H(Sc)

end

No mapeamento acima, o processo ChartC lida com as viso?es representadas pelos
diagramas de classe e estado, encapsulando todas as ac?o?es que manipulam os atributos
privados da ca?psula C. Na ca?psula C acima, os compartimentos correspondem a? listas
de atributos, me?todos e portas. Enta?o, a, m e p sa?o aqueles que destacamos. O atributo
a e? mapeado para um atributo do estado de ChartC com seu tipo correspondente em
OhCircus, dado por T (A); os outros atributos atts sa?o mapeados pela func?a?o TL(), como
explicado previamente. O invariante InvC se origina da nota em UML-RT no contexto
a? esquerda, e assume-se que este ja? esteja descrito em OhCircus. O me?todo m() e?
mapeado para uma operac?a?o que pode modificar qualquer componente do estado, e cujos
para?metros sa?o mapeados em atributos do esquema. Como o invariante InvC, assume-se
que a pre?- e a po?s-condic?a?o Prem e Postm sejam escritas em OhCircus(ver Sec?a?o 2.3).
Similarmente a func?a?o TL() mapeia os outros me?todos meths. A porta p e? mapeada
para um canal com o mesmo tipo TP do canal ChanP utilizado pelo protocolo P. A ac?a?o
principal de ChartC e? expressa por H(SC), que representa o mapeamento dos diagramas
de estado da ca?psula C, definido na Sec?a?o 3.2.2

Em nosso exemplo da Figura 2.2, o mapeamento da ca?psula SysProd e? representado
pelo processo ChartSysProd. Definido por um estado com um u?nico componente p, uma
operac?a?o process que realiza um processamento qualquer em p e uma ac?a?o principal, que



3.2 mapeamento 32

sera? exibida na Sec?a?o 3.2.2.

channel pi, mo : TSTO
channel po, mi : TSTI
process ChartSysProd =? begin

state SysProdstate =? [p : Piece]
process =? [?SysProdstate | ? i ? ran p?.data | i 6= 0 • p.data(i) = fat(i)]
...
•H(S0)

end

De fato, a declarac?a?o dos atributos e me?todos de SysProd sa?o bastantes simples,
a complexidade maior desta ca?psula se encontra em seu diagrama de estrutura. Um
mapeamento mais elaborado da declarac?a?o dos me?todos e atributos da ca?psula Storage
podem ser encontrados na Sec?a?o 3.1.1.

Para a formalizac?a?o de ca?psulas, precisamos considerar tambe?m diagramas de estru-
tura. O mapeamento que lida com a visa?o correspondente a este diagrama, representa
o comportamento observado por C considerando as restric?o?es impostas pelo comporta-
mento de suas portas aos seus respectivos canais de comunicac?a?o. E? necessa?rio considerar
tambe?m, em paralelo, o comportamento de todas as ca?psulas conectadas a sua estrutura.

channel k : TP; TL(cons)
chanset cc =? {| k |}?{|cons|}
chanset hchan =? cc ?{|ports? |}?{|portsB |}?{|portsCap |}
process StructC =? ((ChartC |[ cc ]| (P[chanP := k] |[ cc]|

(TL(ports) |[ cc ]| TL(ports?)))) |[ cc]|
((StructCin[q, portsCin := k, cons]) |[ cc]|
TL(cal )))[k, cons := p, ports] \ hchan

No processo (StructC), o comportamento de ChartC e? sincronizado com o comporta-
mento de todas as portas da ca?psula C; destacamos aqui a porta p, cujo comportamento
e? representado pelo processo P. O canal chanP utilizado por P necessita ser renomeado
com o nome do conector (k) que liga a porta p a outras portas no sistema. As outras
portas sa?o similarmente mapeadas atrave?s da func?a?o TL(). No?s destacamos o compo-
nente de ca?psula b (do tipo B) da lista dos outros componentes Cal, que tem o nome de
todas as suas portas pu?blicas (q e portsB) alterados para o das conexo?es associadas a eles
(k e cons); portsB representa a lista de portas pu?blicas de B. Apo?s paralelizar todos os
componentes no diagrama de estrutura C, uma func?a?o injetiva e? necessa?ria para alterar o
nome de conexo?es a?s portas pu?blicas associadas a elas ([m, cons := p, ports]). Ale?m disto
e? necessa?rio esconder os canais associados a conexo?es, portas protegidas de C, e portas
pu?blicas de B e de Cal, vis??veis somente no diagrama de estrutura de C.

Em nosso exemplo da Figura 2.2, o mapeamento do diagrama de estrutura da ca?psula
SysProd e? representado por um processo StructSysProd.



3.2 mapeamento 33

channel k, m : TSTI
channel l, n : TSTO
chanset cc =? {| k, m, l, n |}
chanset hchan =? cc ?{| pi, po|}
process StructSysProd =? (ChartSysProd[pi, po := l, m] |[ cc ]| STI[chanSTI := k] |[ cc]|

STI[chanSTI := n] |[ cc ]| STO[chanSTO := l] |[ cc]|
STO[chanSTO := m] |[ cc ]| StructStorage[si, so := k, l] |[ cc]|
StructStorage[si, so := m, n])[k, n := mi, mo] \ hchan

O processo StructSysProd e? composto pelo paralelismo de ChartSysProd, dos processos que
representam suas portas e daqueles que representam suas subca?psulas, sincronizados nos
canais associados a?s conexo?es internas de SysProd (k, m, l, n ). No processo ChartSysProd, as
portas pi e po sa?o renomeadas nas conexo?es l e m, respectivamente. As portas pi, po, mi
e mo de SysProd sa?o representadas pelos processos STI[chanSTI := k], STI[chanSTI := n],
STO[chanSTO := l] e STO[chanSTO := m], respectivamente; cada um deles formados pelo
respectivo processo do protocolo relativo a? porta e renomeados pelas conexo?es associadas
a ela. As subca?psulas sin e son sa?o representadas pelos processos StructStorage[si, so := k, l]
e StructStorage[si, so := m, n] respectivamente; estes sa?o formados pelo processo associado
a ca?psula Storage (da qual sa?o insta?ncias), renomeada pelos respectivos canais de suas
conexo?es no diagrama SysProd.

Devido a representarmos conexo?es entre portas atrave?s da sincronizac?o?es entre pro-
cessos, necessitamos assumir que portas devem estar conectadas entre si no menor n??vel
de estrutura que as contenha. Na realidade, esta suposic?a?o e? uma boa pra?tica de projeto
pois evita indirec?o?es e reduz a complexidade do modelo. Na Figura 3.3, as insta?ncias de
ca?psulas b e c devem ser conectadas no menor n??vel de estrutura em StrM que os conte?m,
neste caso o diagrama de estrutura de A.

Figura 3.3. Exemplo de uma pra?tica correta (a esquerda) e uma errada (a direita) da conexa?o
de subca?psulas

Na Figura 3.3, o mapeamento das subca?psulas B e C do contexto a? esquerda teria o
formato (StructB[q := k]) |[ k ]| (StructC[p := k]), enquanto o contexto do lado direito teria
uma formato semelhante ao (StructB[q := q

?] |[ k ]| StructC[p := p?])[q, q? := k, k]. Como
a func?a?o [q, q? := k, k] na?o e? injetiva (as duas portas sa?o renomeadas em uma mesma
porta), ela na?o distribui pelo operador de paralelismo (Ver Lei B.1, no Ape?ndice B) e
difere o comportamento do mapeamento dos dois contextos (apesar de em UML-RT eles
possu??rem um mesmo comportamento).

Diferentemente de ca?psulas e protocolos, classes sa?o mapeadas em classes em OhCir-
cus. Estas classes tem o mapeamentos de seus elementos semelhante ao mapeamentos
de atributos e me?todos de uma ca?psula, definidos como para?grafos em Z.



3.2 mapeamento 34

class A =? begin
state Astate =? [b : T (B); TL(aatts) | InvA]
m =? [?Astate ; x : T (X);

TL(params) | Prem ? Postm]
TL(ameths)

end

Como assumimos que classes na?o possui um comportamento expl??cito associado, ne-
cessitamos apenas mapear a visa?o de uma classe em diagrama de classes em OhCircus.
Na classe A acima, os compartimentos correspondem a? listas de atributos e me?todos.
Enta?o, b, m sa?o aqueles que destacamos. O atributo b e? mapeado para um atributo do
estado de A com seu tipo correspondente em OhCircus, dado pela classe B; os outros
atributos aatts sa?o mapeados pela func?a?o TL(), como explicado previamente. O invari-
ante InvA se origina da nota em UML-RT no contexto a? esquerda, e assume-se que este
ja? esteja descrito em OhCircus. O me?todo m() e? mapeado para uma operac?a?o que pode
modificar qualquer componente do estado, e cujos para?metros sa?o mapeados em atributos
do esquema. Como o invariante Y, assume-se que a pre?- e a po?s-condic?a?o Prem e Postm
sejam escritas em OhCircus. Similarmente a func?a?o TL() mapeia os outros me?todos
ameths.

3.2.2 Mapeamento comportamental

Nosso mapeamento dos diagramas de estado de ca?psulas e protocolos em OhCircus
e? baseado no trabalho reportado em [69], que apresenta a formalizac?a?o de diagramas de
estado em CSP. No entanto, e? necessa?rio estende?-lo para considerar ac?o?es de OhCircus,
lidar com paralelismo (And-States) e estados compostos com mu?ltiplos pontos iniciais.

Seja M uma ma?quina de estados e SM o conjunto de estados de M . O conjunto de
eventos de M e? denotado por EM , e suas ac?o?es e guardas booleanas por AM e GM , res-
pectivamente. Ale?m disto, SIM denotara? o conjunto de estados inicias, SChM o conjunto
de estados de escolha, SSM o conjunto de estados simples e SCoM o conjunto de estados
compostos de SM .

Como um diagrama de estados pode ser identificado como um estado composto que
conte?m todos os outros, seu mapeamento de estados pode ser visto como o de um u?nico
estado. Assim, podemos indicar este mapeamento por uma func?a?o H que leva um estado
a sua representac?a?o em OhCircus.

H : SM ? CSPAction

No?s assumimos que uma ac?a?o em AM e? expressa por uma chamada de me?todos,
e, portanto, na?o precisa ser traduzida. Como outros predicados, guardas em AM sa?o
escritas utilizando a sintaxe de OhCircus. Como portas possuem um canal associado em
OhCircus com o seu nome, e sinais sa?o expressos pelos valores do tipo destes canais, um
sinal e de uma porta p pode ser diretamente escrito pelo casamento de padra?o de eventos
em OhCircus identificado, correspondente ao sinal e.



3.2 mapeamento 35

Cada padra?o aplicado a? func?a?o de mapeamento de estados H(·) gera um equac?a?o
distinta. No lado esquerdo de cada equac?a?o, ilustramos o padra?o de aplicac?a?o como um
template para um tipo de estado espec??fico.

Nossa primeira traduc?a?o corresponde ao estado inicial. Este possui somente uma
transic?a?o de sa??da, e nenhuma ac?a?o de entrada ou sa??da. Da??, seja Ai um estado inicial,
com Ai ? SIM , act() a ac?a?o de sua transic?a?o de sa??da, e A1 o destino desta transic?a?o,
enta?o:

H(Ai) = act(); H(A1)

Para um estado de escolha, a traduc?a?o e? como segue. Seja Ac um estado de escolha,
com Ac ? SChM , que tem somente duas transic?o?es e uma guarda g (estas transic?o?es na?o
possuem evento e sa?o disparadas de acordo com a avaliac?a?o de g), enta?o:

H(Ac) = (g &amp;amp; act1(); H(A1)) u (¬ g &amp;amp; act2(); H(A2))

Em relac?a?o a um estado simples, sua traduc?a?o corresponde a? ac?a?o de processo abaixo.
Seja As um estado simples, com As ? SSM , AC o estado composto que o conte?m, com
AC ? SCOM , tls sua lista de transic?o?es de sa??da e p.e[g]/act() uma das transic?a?o destacada
desta lista, enta?o:

H(As) = entryAs(); ((g &amp;amp; p.e ? exitAs(); act(); H(A1))
2 ((noteventAC ? exitAs(); exiteventAC ? SKIP )
2 TL(tls)))

Quando o estado As e? ativado, ele executa a ac?a?o de entrada entryAs() e espera por
um novo sinal oriundo do ambiente (a escolha externa captura esta decisa?o). Destacamos
aqui a transic?a?o disparada pelo sinal e da porta p, dentre a lista de transic?o?es tls. O
evento p.e e? executado somente quando sua guarda g for satisfeita. Caso isto ocorra, a
ac?a?o de sa??da exitAs() e a ac?a?o act() associada a? transic?a?o disparada, sa?o executadas, e
o estado A1 torna-se ativo. Ale?m de esperar por sinais que disparem suas transic?o?es de
sa??da, um estado simples pode ficar inativo pelo disparo de uma transic?a?o de sa??da (de
grupo) do estado composto que o conte?m; neste caso, um evento de notificac?a?o noteventAC,
onde AC representa o estado composto, e? disparado para garantir que a ac?a?o de sa??da de
As seja executada antes da ac?a?o de sa??da de AC. Apo?s a execuc?a?o da ac?a?o de sa??da de
As, um evento exiteventAC e? enviado, permitindo que a ac?a?o de sa??da do estado AC seja
executada.

Para mapear estados compostos, e? necessa?rio apenas a apresentac?a?o da traduc?a?o
de um estado composto do tipo And-State. Como suas regio?es concorrentes sa?o dadas
pela composic?a?o sequ?encial de estados (tal qual um Or-State), a traduc?a?o de um estado
composto do tipo Or-State pode ser visto por um And-State com uma u?nica regia?o. Seja



3.2 mapeamento 36

AC e EAC estados compostos pertencentes a? SCOM , onde EAC e? o estado composta que
conte?m AC e AC um And-State com as seguintes regio?es r1 e r2, Ai1 e Ai2 ? SIM os estados
iniciais das regio?es de AC, A1 e A2 ? SM estados contido em EAC, e [R] uma func?a?o
de renomeac?a?o que substitui um canal associado a uma porta a? um canal associado a
conexa?o que esta porta esta? conectada, enta?o:

H(AC) = entryAC(); (H(Ai1)[R] |[ Cstate1 | cc | Cstate2]|
H(Ai2)[R] |[ Cstate1 ? Cstate2 | cc | Cstate3]|

2 (g1 &amp;amp; p1.e1 ? noteventAC ? exiteventAC ? exitAC();
act1(); H(A1))

2 (TL(tls))
2 (g2 &amp;amp; p2.e2 ? exiteventAC ? exitAC(); act2(); H(A2))
2 (noteventEAC ? noteventAC ? exiteventAC ? exitAC();

exiteventEAC ? SKIP ))

Quando o And-State AC e? ativado, ele executa a ac?a?o de entrada entryAC(), e depois
o estado inicial de cada uma de suas regio?es. Para que as regio?es r1 e r2 sincronizem
adequadamente suas ac?o?es, e? necessa?rio renomear os canais associados a?s portas conec-
tadas em StrM pelos canais em cc correspondentes a suas conexo?es, atrave?s da func?a?o
R. Assim sinais de sa??da de uma regia?o podem ser sincronizados a? sinais de sa??da de
outra. Assumimos que as ac?o?es dos estados r1 e r2 podem modificar somente valores de
varia?veis em Cstate1 e Cstate2, respectivamente, enquanto a ac?a?o de sa??da e as associadas a?s
transic?o?es de sa??da de state2 modificam somente valores de varia?veis em state3. O estado
da ca?psula conte?m a unia?o de Cstate1, Cstate2 e Cstate3. E a qualquer momento, o estado
AC pode receber um evento externo e interromper os subestados de r11 e r2, deixando-os
inativos.

Um estado composto pode ficar inativo de tre?s formas: atrave?s de uma transic?a?o de
sa??da com origem no pro?prio (transic?o?es de grupo), com origem em um de seus subestados,
ou com origem em um de seus superestados. Nos dois primeiros casos, o comportamento
associado a? transic?a?o e? descrito em AC, enquanto no u?ltimo este comportamento e? descrito
em EAC. E em todos eles, eventos de notificac?a?o sa?o criados para garantir que a ordem
de execuc?a?o das ac?o?es de sa??da dos estados seja realizada do estado mais interno ao mais
externo, que conte?m os demais. A lista de transic?o?es localizadas no dois primeiros casos
e? representada aqui por tls, onde foram destacadas aquelas disparadas pelos sinais p1.e1
e p1.e1, respectivamente, para o primeiro e o segundo caso.

Quando o estado AC recebe o evento p1.e1 e avalia a guarda g como verdadeira, um
evento noteventAC e? enviado para solicitar que todos os subestado ativos executem suas
ac?o?es de sa??da. Quando uma notificac?a?o exiteventAC chega, a ac?a?o de sa??da de AC e?
finalmente executada, seguida pela ac?a?o act1 da transic?a?o. Apo?s este conjunto de ac?o?es,
o estado A1 torna-se enta?o ativo. Transic?o?es que emanam de um subestado, atrave?s
de um ponto de junc?a?o de AC se comportam de forma similar. Este tipo de junc?a?o
e? mapeado como um subestado transiente final de AC, e, portanto, na?o possui qualquer
ac?a?o associada. Assim, AC na?o necessita esperar pela execuc?a?o de qualquer ac?a?o de sa??da,
e na?o precisa lidar com o evento noteventAC. No entanto o evento exiteventAC e? necessa?rio



3.2 mapeamento 37

para sincronizar com este pseudo-estado de sa??da de AC. Para um ponto de junc?a?o F ,
sua traduc?a?o corresponde a H(F ) = exiteventAC ? SKIP . As outras transic?o?es de sa??da
de AC em tls podem ser similarmente traduzidas pela func?a?o TL(tls), que mapeia a lista
tls de transic?o?es da mesma similar a? transic?o?es disparadas pelos eventos p1.e1 e p1.e1, que
destacamos aqui.

Assim como estados simples, estados compostos podem estar inclusos dentro de outros
estados compostos; no contexto anterior, AC e? um subestado de EAC. Nesta situac?a?o, AC
pode a qualquer momento receber uma notificac?a?o noteventEAC indicando a ocorre?ncia
de uma transic?a?o de sa??da em EAC. Quando este evento e? recebido, AC precisa enviar o
evento noteventAC para seus subestados ativos a fim de que eles executem suas ac?o?es de
sa??da antes de sua pro?pria ac?a?o (exitAC). Quando AC receber exiteventAC, a ac?a?o exitAC
e? executada, e enta?o exiteventEAC e? enviado para que EAC execute sua pro?pria ac?a?o de
sa??da.

Em nosso exemplo da Figura 2.2, o mapeamento do comportamento do protocolo STO
sera? definido por um processo homo?nimo, cuja ac?a?o principal e? dada pelo mapeamento
do estado S0, que conte?m todos os outros.

process STO =? begin
Sb =? chanSTO.req ? Sc
Sc =? chanSTO.output ? Sa
• Sb

end

Na ma?quina de estados de um protocolo, na?o encontramos ac?o?es ou guardas, sendo
representado apenas pela ordem dos eventos no canal associados a ele, que em STO e?
representado por chanSTO. Como podemos notar, a? excec?a?o do estado inicial, cada um
dos estados de STO e? representado por uma para?grafo no corpo do processo (Sb e Sc). A
ac?a?o principal de STO (• Sb) e? igual ao comportamento correspondente ao mapeamento
do estado inicial STO, cuja transic?a?o tem como destino o estado Sb.

Diferentemente de protocolos, as ma?quinas de estados de ca?psulas possuem ac?o?es e
guardas, como e? visto no mapeamento associado a? ac?a?o principal de ChartSysProd (abaixo)
e ChartStorage (ver Sec?a?o 3.1.1) .

...
Sp =? pi?output.x ? p = x; process(); po!input.x; Sp
• pi.req ? Sp

Na ac?a?o principal de ChartSysProd, pi.req correspondente a? ac?a?o da transic?a?o inicial
de SysProd, que possui como destino o estado Sp. Este estado e? representado por um
para?grafo de mesmo nome e oferece um u?nico evento pi?output.x, o qual dispara a u?nica
transic?a?o de Sp em SysProd. A ac?a?o executada apo?s este evento e? a mesma descrita na
Figura 2.2, que utiliza uma notac?a?o semelhante para a chamada de me?todos e o envio de
sinais.

Como desejamos neste trabalho um mapeamento puramente sinta?tico, na?o lidamos
com histo?ria em estados. Ja? que para isto dever??amos atribuir varia?veis a todos estados



3.3 concluso?es 38

compostos do modelo, criando uma representac?a?o sema?ntica de cada um deles. Esta
varia?vel seria utilizada para guardar a u?ltima configurac?a?o de subestados ativos antes
que uma transic?a?o de sa??da fosse disparada. Assim, quando um estado composto se
tornasse ativo novamente, essa configurac?a?o seria restaurada.

3.3 CONCLUSO?ES

Atrave?s do mapeamento de UML-RT para OhCircus, possibilitamos a atribuic?a?o de
uma sema?ntica a UML-RT atrave?s de sua integrac?a?o com uma notac?a?o formal. Como con-
sequ?e?ncia, podemos provar propriedades de um modelo em UML-RT atrave?s de demons-
trac?o?es de sua especificac?a?o em OhCircus, e, portanto, a preservac?a?o de comportamento
de um modelo durante a aplicac?a?o de leis transformac?a?o em UML-RT.



CAPI?TULO 4

LEIS DE TRANSFORMAC?A?O PARA UML-RT

Neste cap??tulo, focamos em leis de transformac?a?o que expressam pequenas reestruturac?o?es
de um modelo em UML-RT, sem que haja alterac?a?o do comportamento do sistema mo-
delado. Particularmente, concentramo-nos nos elementos adicionais que UML-RT adici-
ona a UML (ca?psulas, protocolos e portas) e em seus relacionamentos, complementando
assim outros trabalhos que lidam somente com elementos de UML (como classes e inter-
faces) [41, 30, 38]. Observe que como ca?psulas na?o compartilham classes, e que como a
comunicac?a?o entre ca?psulas e classes e? atrave?s da chamada de me?todos, transformac?o?es
num modelo de classes, sem mudar suas interfaces com as ca?psulas a que dependem, sa?o
livremente permitidas.

Focamos, principalmente, em leis que envolvem as viso?es relacionadas a? declarac?a?o
de elementos do modelo e a? configurac?a?o de sua arquitetura, representados pelos dia-
gramas de classe e estrutura. Ale?m disto, algumas leis relacionadas a? declarac?a?o do
comportamento de elementos (leis para diagramas de estado) sa?o exibidas, pore?m em
uma quantidade necessa?ria para descrevermos a abrange?ncia de nossas leis quanto as
duas viso?es citadas; esta abrange?ncia sera? discutida no Cap??tulo 5.

Algumas transformac?o?es ba?sicas (criac?a?o, remoc?a?o ou alterac?a?o de elementos) sa?o re-
alizadas, usualmente, em elementos isolados do modelo. Outras transformac?o?es sa?o uti-
lizadas para substituir elementos. Assim, noc?o?es de equivale?ncia, extra??das da sema?ntica
de OhCircus, permitem que as leis lidem simultaneamente com os aspectos esta?ticos e
dina?micos do modelo, preservando o comportamento observado, atrave?s de mudanc?as em
seus diagramas de classe, estado e estrutura.

A raza?o para lidarmos com diagramas de estrutura e? porque eles representam in-
terac?o?es entre ca?psulas que na?o sa?o expressas por outros diagramas; por isto, eles devem
ser considerados para que o comportamento global do sistema gerado seja preservado.

Inicialmente, apresentamos algumas leis ba?sicas (Sec?a?o 4.1) que sa?o usadas em se-
guida para justificar leis mais elaboradas (Sec?a?o 4.2). A partir da composic?a?o destas leis
ba?sicas, e? poss??vel criar transformac?o?es utilizadas usualmente durante a ana?lise e projeto
do sistema, como refactorings. Apesar de nosso propo?sito maior ser a sistematizac?a?o do
desenvolvimento em UML-RT, utilizando transformac?o?es de modelo, a partir do mape-
amento de modelos em UML-RT para OhCircus (Cap??tulo 3) obtemos o benef??cio de
utilizar uma sema?ntica formal, bem como leis de refinamento de OhCircus, para provar a
corretude de algumas das leis de transformac?a?o apresentadas neste cap??tulo (Sec?a?o 4.3).

4.1 LEIS BA?SICAS

Cada lei e? definida por uma equac?a?o, onde os termos descrevem o contexto dos ele-
mentos do modelo antes e apo?s a aplicac?a?o da lei. A aplicac?a?o de uma lei pode ser feita

39



4.1 leis ba?sicas 40

em qualquer um dos sentidos (partindo-se do termo da esquerda ou da direita), pore?m
obedecendo-se as condic?o?es impostas para aplicac?a?o da lei no sentido desejado.

A relac?a?o entre os dois termos e? representada na lei por uma relac?a?o de equivale?ncia
de modelos (uma seta bidirecional) com um subscrito M, que representa o contexto do
restante do modelo. A noc?a?o de equivale?ncia utilizada e? baseada na sema?ntica de OhCir-
cus, que e? definida na Unifying Theories od Programming [47]. Na realidade, apenas um
subconjunto de OhCircus (Circus) tem uma sema?ntica completamente definida. Apesar
das leis propostas na?o modificarem M, algumas das leis impo?em condic?o?es sobre algu-
mas viso?es deste modelo, que por esta raza?o sa?o explicitamente apresentadas durante a
lei: ClsM representa as declarac?o?es de ca?psulas, protocolos e classes em M, composto por
seu conjunto de diagramas de classe; StrM simboliza a estrutura (ou a configurac?a?o da
arquitetura) de M, expresso pelos diagramas de estrutura de suas ca?psulas. Um terceira
visa?o do modelo, StaM, representa a declarac?a?o do comportamento, isolado, de todas
as ca?psulas e protocolos do sistema, expresso por suas respectivas ma?quinas de estado.
Apesar de, dinamicamente, estas ma?quinas de estados se comunicarem, de acordo com as
conexo?es expressas em StrM, elas sa?o independentes entre si. Por esta raza?o, usualmente,
o diagrama de estados de cada um destes elementos sera? explicitamente mostrado nos
termos da leis, ao inve?s de recorrermos a StaM; para um elemento A, indicaremos seu
diagrama de estados como S0 de A.

Diagramas e anotac?o?es descrevendo propriedades (invariantes, pre?- e po?s-condic?o?es)
do modelo sa?o apresentadas nas leis quando necessa?rio. Em alguns casos, existe o interesse
que somente uma parte (auto-contida) destes diagramas seja mostrada; neste caso, uma
linha pontilhada na borda dos diagrama e? utilizada. Adicionalmente, relacionamentos
entre os elementos apresentados no diagrama podem existir, mesmo que na?o explicitados.

Leis relacionadas a? declarac?a?o de elementos, usualmente, sa?o responsa?veis por criar
novos elementos em um modelo UML-RT. Em geral, elas possuem como condic?a?o para
a introduc?a?o de um elemento (aplicac?a?o da esquerda para a direita da lei) que este na?o
possua o mesmo nome de outro elemento ja? utilizado no modelo, e para a remoc?a?o de
um elemento (aplicac?a?o da direita para esquerda) que o elemento na?o seja utilizado pelo
restante do modelo.

A primeira lei estabelece quando e? poss??vel introduzir uma nova ca?psula ao modelo.
Observe que apesar do contexto no lado esquerdo da lei estar vazio, o M subscrito fixa o
contexto para aplicac?a?o da lei.

Lei 4.1 Declarar Ca?psula

Condic?o?es:

(?) ClsM na?o possui a declarac?a?o de nenhum elemento, no mesmo pacote, chamado A.



4.1 leis ba?sicas 41

(?) Nenhuma ca?psula em M tem uma relac?a?o com a ca?psula A em qualquer diagrama.

Usamos o s??mbolo (?) antes de uma condic?a?o para indicar que ela e? requerida somente
para aplicac?o?es da lei da esquerda para a direita. Similarmente, utilizamos (?) para
indicar que a condic?a?o e? necessa?ria somente para aplicac?o?es da lei da direita para a
esquerda, e usamos (?) para indica que a condic?a?o e? necessa?ria em ambas as direc?o?es.

A condic?a?o para remover a ca?psula A (aplicac?a?o da lei da direita para esquerda) e?
que nenhuma outra estende, tem uma associac?a?o em ClsM ou e? conectada com ela em
StrM. Em relac?a?o a? aplicac?a?o da lei da esquerda para a direita, ja? que em UML (e, por
sua vez, em UML-RT) na?o e? permitido que dois elementos possuam o mesmo nome em
um mesmo pacote (contexto local), existe uma condic?a?o expressando que a declarac?a?o de
nova ca?psula em StrM deve possuir sempre um novo nome no modelo. Assumimos que
atts, meths e ports representam, respectivamente, os conjuntos de atributos, me?todos e
portas da ca?psula.

Nas duas direc?o?es de aplicac?a?o da lei, a ca?psula A na?o esta? associada a nenhuma outra
no modelo, portanto, a apresentac?a?o do diagrama de estrutura e o de estados e? irrelevante.
Na realidade, estes diagramas podem possuir qualquer conteu?do, que obedec?a a?s condic?o?es
da lei.

Apesar de sua simplicidade, esta lei e? bastante importante, ja? que uma ca?psula so?
pode fazer parte da arquitetura do sistema modelado, caso ela tenha sido declarada pre-
viamente. Semelhante a? Lei 4.1, as leis C.1 e C.2 apresentadas no Ape?ndice C capturam
a introduc?a?o de protocolos e classes em ClsM.

A pro?xima lei estabelece quando podemos adicionar ou remover uma associac?a?o entre
ca?psulas. Assumimos que, quando uma ca?psula A e? criada, e? criado tambe?m seu diagrama
de estrutura; este diagrama conte?m as insta?ncias de todas as ca?psulas com as quais A
possui uma associac?a?o.

Lei 4.2 Introduzir Associac?a?o Ca?psula-Ca?psula

Condic?o?es:

(?) Na?o existe outra insta?ncia de ca?psula chamada b no diagrama de estrutura de A.
(?) A insta?ncia b da ca?psula B na?o esta? conectada a nenhuma outra na estrutura de A,

inclusive a? insta?ncia a que a conte?m.



4.1 leis ba?sicas 42

Na Lei 4.2, a aplicac?a?o da esquerda para a direita gera como resultado uma associac?a?o
entre as ca?psulas A e B. Como consequ?e?ncia, uma nova insta?ncia de B e? criada no
diagrama de estrutura de A, em qualquer contexto de StrM onde uma insta?ncia a de A
aparec?a. Nesta lei, o conjunto de portas aports e bports sa?o representados por portas
mu?ltiplas em StrM; na realidade, estes conjuntos podem possuir uma ou mais portas
distintas com diferentes cardinalidades e tipos. Pode ainda haver conexo?es envolvendo as
portas de A e B, na?o explicitado na lei.

Relativo a? sema?ntica de um ca?psula isolada em StrM, esta e? vista como processo em
OhCircus que na?o comunica com nenhum outro na especificac?a?o e que possivelmente
estara? sempre bloqueada. Como o comportamento de ca?psulas e? descrito por ma?quinas
de estado que na?o possuem um estado final, um sistema em UML-RT e? representado
em OhCircus por um processo que nunca termina, e que, por esta raza?o, na?o tera? seu
comportamento alterado pela inserc?a?o de uma nova ca?psula isolada do restante do modelo.

A pro?xima lei estabelece quando e? permitido adicionar ou remover me?todos em uma
ca?psula.

Lei 4.3 Introduzir Me?todo

Condic?o?es:

(?) Na?o existe um me?todo chamado m em A.
(?) O me?todo m na?o e? utilizado por outro me?todo em meths, nem tampouco no diagrama de

estados de A, ou em um predicado de A.

A Lei 4.3 e? similar ao refatoramento para adicionar me?todos em classe [33], possuindo
restric?o?es quanto ao nome do me?todo e quanto ao seu uso. Da direita para a esquerda,
o me?todo m na?o pode ser utilizado por outro me?todo, ac?a?o do diagrama de estados ou
predicado (invariante, pre?- ou po?s-condic?a?o) de A. Ale?m disto, o padra?o da lei possui
como condic?o?es impl??citas que os tipos de dados D e R ja? existam em M. Note que eliminar
um me?todo de uma ca?psula e? bem mais simples do que de uma classe, pois me?todos em
uma ca?psula sa?o inerentemente privados.

A seguir, e? apresentado um caso espec??fico de uma lei que introduz um atributo em
uma ca?psula, como consequ?e?ncia da criac?a?o de uma associac?a?o da ca?psula com uma
classe.

Como outras leis que introduzem novos elementos, a Lei 4.4 possui em suas condic?o?es
de aplicac?a?o restric?o?es quanto ao nome e ao uso do elemento introduzido (neste caso a
associac?a?o b). Assumimos que a introduc?a?o de uma associac?a?o b entre uma ca?psula A e
uma classe B introduz implicitamente um atributo b em A, por esta raza?o a existe?ncia
de uma condic?a?o que indica que na?o pode haver outro atributo chamados b em A.



4.1 leis ba?sicas 43

Lei 4.4 Introduzir Associac?a?o Ca?psula-Classe

Condic?o?es:

(?) Na?o ha? um atributo chamado b em A.
(?) O atributo b na?o e? utilizado por nenhum me?todo, diagrama de estados ou predicado de

A.

Apesar da Lei 4.4 ser espec??fica para classes, uma lei ana?loga para a introduc?a?o de
atributos (possivelmente de tipos primitivos) pode ser facilmente deduzida a partir dela.

A pro?xima lei estabelece quando podemos adicionar ou remover uma associac?a?o entre
um protocolo e uma ca?psula. Como consequ?e?ncia da introduc?a?o desta associac?a?o, e? criada
uma insta?ncia deste protocolo (porta) na ca?psula.

Lei 4.5 Introduzir Associac?a?o Ca?psula-Protocolo

Condic?o?es:

(?) Na?o existe outra porta chamada p na ca?psula A.
(?) A porta p na?o e? utilizada no diagrama de estados de A; na?o existe conexa?o ligada a p em

StrM.

Em uma visa?o geral, a Lei 4.5 e? similar ao refactoring “Adicionar Atributo” [33];
portas, apesar de sua declarac?a?o em um compartimento diferente, podem ser vistas como
atributos de uma ca?psula. Por esta raza?o, a lei possui como condic?a?o que na?o pode haver
duas ou mais portas com um mesmo nome em uma ca?psula. Para se remover uma porta
e? necessa?rio que esta na?o seja usada no diagrama de estados (assumimos que ac?o?es para
o envio de sinais na?o podem estar localizados em me?todos da ca?psula); nem tampouco
a porta pode ser usada na conexa?o com outras ca?psulas em StrM. Note que portas sa?o
criadas como consequ?e?ncia da associac?a?o entre ca?psulas e protocolos, sendo visualmente
vista tanto no diagrama de classes quanto no diagrama de estrutura; por simplicidade, o
conjunto de portas ports e? mostrado no diagrama de estrutura como uma porta mu?ltipla.



4.1 leis ba?sicas 44

Devido a condic?a?o da lei de que a porta p nunca e? utilizada no diagrama de estados de
A, enta?o a apresentac?a?o deste diagrama e? desnecessa?ria.

A pro?xima lei estabelece quando e? permitido adicionar ou remover sinais de sa??da em
um protocolo.

Lei 4.6 Introduzir Sinal de Sa??da

Condic?o?es:

(?) Na?o existe sinal chamado s no protocolo X.
(?) Nenhum diagrama de estados em StaM usa o sinal s.

Semelhante a? Lei 4.5, a Lei 4.6 possui uma restric?a?o quanto ao uso do nome do novo
elemento (sinal) em seu contexto local (protocolo) e quanto ao uso deste elemento nos
diagramas de estado do modelo. A primeira condic?a?o indica que na?o existe previamente
nenhum sinal s de entrada ou sa??da em X no modelo do lado esquerdo. A segunda condic?a?o
indica que o sinal s na?o e? utilizado nos diagramas de estado do protocolo X ou de nenhuma
ca?psula com uma porta de tipo X. Note que apesar de s possuir um para?metro do tipo
de dado D, este pode ser inclusive void. Em geral, ha? uma condic?a?o impl??cita de que D
deve ser um tipo va?lido em ClsM.

Apesar do sinal s estar localizado no mesmo compartimento de sinais de sa??da de X,
uma lei ana?loga para um sinal de entrada possui as mesmas condic?o?es que a Lei 4.6. A
u?nica diferenc?a entre estas leis e? o compartimento de localizac?a?o do sinal, o qual indica o
seu sentido. A lei para introduzir um sinal de entrada esta? no Ape?ndice C (na Lei C.4).

A pro?xima lei captura o incremento da multiplicidade da associac?a?o entre um proto-
colo e uma ca?psula e, consequ?entemente, o respectivo incremento da multiplicidade da
porta que representa esta relac?a?o.

Lei 4.7 Incrementar Multiplicidade da Associac?a?o Ca?psula-Protocolo

Condic?o?es:

(?) O nu?mero de conexo?es em StrM envolvendo a porta p e? inferior a? sua multiplicidade.



4.1 leis ba?sicas 45

A condic?a?o relativa a? quantidade de conexo?es envolvendo uma porta e? uma restric?a?o
da pro?pria linguagem UML-RT. A Lei 4.7, apesar de sua simplicidade, e? muito importante
para sincronizac?a?o de ca?psulas em diagramas de estrutura (Lei 4.8).

A pro?xima lei estabelece quando e? permitido se conectar duas ca?psulas. Apesar de
suas similaridades com outras leis, esta lei afeta (exclusivamente) o diagrama de estrutura
do modelo.

Lei 4.8 Introduzir Conexa?o

Condic?o?es:

(?) A sequ?e?ncia de sinais aceitos por b e c e? inalterada; r e s devem ser insta?ncias de mesmo
um protocolo.

(?) A quantidade de conexo?es ligadas a? r e s e? inferior a multiplicidade destas porta.

A Lei 4.8 indica que duas ca?psulas somente podem ser conectadas se o seu compor-
tamento for inalterado: a sequ?e?ncia de sinais aceitos por ambas as ca?psulas (sinais que
disparam suas transic?o?es), atrave?s das portas r e s, na?o deve ser mudada. A linha ponti-
lhada em StrM indica que nada e? dito quanto a?s conexo?es das portas r e s com o restante
do modelo, ambas podendo, portanto, possuir conexo?es com outras ca?psulas em StrM.
Note a condic?a?o quanto a? sequ?encia de sinais atrave?s de b e c e? uma condic?a?o dina?mica,
e que na?o pode ser verificada sintaticamente. Para a insta?ncia de ca?psula a, temos que
verifica se todos os sinais provenientes da porta s de b, que sejam aceitos por a, sejam
sincronizados com outra ca?psula c? no modelo, de forma que o paralelismo de c? com b
sincronizada em r e? equivalente a c?; o mesmo acontece para insta?ncia de ca?psula b e os
sinais provenientes de r.

Em um caso mais simples desta lei, na?o existem outras portas conectadas a r ou
s. Neste caso, para que o comportamento de A ou B na?o seja alterado, a ma?quina de
estados destas ca?psulas na?o devem possuir transic?o?es disparadas pelos novos sinais prove-
nientes desta conexa?o. Uma condic?a?o menos restritiva, que ainda conserva as condic?o?es
de aplicac?a?o da Lei 4.8, e? que pelo menos uma das portas r ou s na?o e? utilizada em sua
ca?psula; isto e?, na?o e? utilizada pelo diagrama de estado de sua respectiva ca?psula.

No caso mais complexo, estas portas esta?o conectadas a porta de outras ca?psulas do
modelo; o que acarretaria um condic?a?o impl??cita, no lado esquerdo, de que a multipli-
cidade desta portas comportassem a nova conexa?o c. Neste caso, para que a sequ?e?ncia
de sinais recebidos fosse inalterada, todos novos sinais que trafeguem por c devem esta
sincronizados a outros sinais enviados ou recebidos nessas outras ca?psulas do modelo.
Desta maneiras, apo?s a aplicac?a?o da esquerda para a direita, as ca?psulas continuam a
aceitar e enviar os mesmos sinais que outrora, incluindo o valor de seus dados, sem que
isto gere uma mudanc?a na comunicac?a?o ou deadlock.

A pro?xima lei indica quando uma ca?psula pode substituir outra na arquitetura do
sistema, afetando, exclusivamente, o diagrama de estrutura do modelo.



4.1 leis ba?sicas 46

Lei 4.9 Substituic?a?o de ca?psula

Condic?o?es:
(?) B e C possuem as assinaturas dos conjuntos de portas b1, .., bN e c1, .., cN e o seus com-

portamentos, quando visto em relac?a?o este conjunto de portas, equivalentes.

A Lei 4.9 possui como condic?a?o de aplicac?a?o que as ca?psulas B e C possuam compa-
tibilidade de assinatura e comportamento. A compatibilidade de assinatura indica que
existe uma relac?a?o de bijec?a?o entre o conjunto de portas de cada uma das ca?psulas, isto
e?, cada porta de B possui uma porta correspondente, distinta e do mesmo protocolo em
C, e vice e versa. A compatibilidade de comportamento indica que insta?ncias de B e C
possuem o mesmo comportamento observado e que a substituic?a?o de uma pelo outra no
sistema na?o podera? ser notada. A verificac?a?o desta compatibilidade e? claramente uma
condic?a?o dina?mica, mas pode ser simplificada, verificando-se uma regia?o da ma?quina de
estados de C que seja equivalente a uma regia?o da ma?quina de estado de B. A equivale?ncia
das ma?quinas de estados e? comprovada pela conservac?a?o da sequ?e?ncia dos sinais aceitos e
enviados por cada um das portas de uma ca?psula e sua correspondente na outra ca?psula;
um trabalho que lida com a equivale?ncia de ma?quinas de estado pode ser encontrado
em [34].

Apesar desta lei ser bastante semelhante a? Lei 4.8, ela na?o pode ser justificada a
partir de diversas aplicac?o?es da Lei 4.8 sem que na?o introduzamos deadlock ao modelo.
A Lei 4.9 so? poderia ser derivada a partir da Lei 4.8, caso cada um das portas da ca?psula
que sera? substitu??da estivesse associada a uma regia?o da ma?quina de estados da ca?psula
que na?o utilizasse as outras portas da ca?psula. Um exemplo desta configurac?a?o pode ser
encontro na Lei 4.20.

Na lei a seguir, e? poss??vel verificar sob que condic?o?es uma relay port pode ser criado.
Este tipo de porta serve apenas como uma ponte para conexo?es de fora da estrutura de
uma ca?psula com portas protegidas dentro desta estrutura.

Lei 4.10 Criar Relay Port

Condic?o?es:
(?) O protocolo associado a? porta p possui uma ma?quina de estados determin??stica.

Para que a inserc?a?o da nova porta na comunicac?a?o de a na?o altere o comportamento
do sistema, devemos garantir que o diagrama de estados do protocolo associado a? porta
inserida e? determin??stica.

A pro?xima lei expressa como uma insta?ncia de uma ca?psula pode ser inserida para
intermediar a comunicac?a?o de outras duas ca?psulas.



4.1 leis ba?sicas 47

Lei 4.11 Inserir Ca?psula para Intermediar Comunicac?a?o

Condic?o?es:

(?) A sequ?e?ncia de sinais transmitidos pela conexa?o k e? a mesma que a transmitida
pelas conexo?es k1 e k1.

No lado direito da Lei 4.11, a ca?psula C aceita e envia os mesmo sinais que poderiam
ser transmitidos atrave?s de k. Esta e? uma condic?a?o dina?mica, e indica que a ma?quina de
estado de XC na?o pode ser mais restritiva que a ma?quina de estados de X. Em sua forma
mais geral, todos os sinais de entrada do protocolo X sa?o aceitos por r e reenviados a
partir de s; similarmente, os sinais de sa??da de X sa?o aceitos por s e reenviados a partir de
r. Destacamos aqui, somente os sinais i e o de X, enquanto outras transic?o?es internas de
Sxz sa?o responsa?veis pelos demais sinas do protocolo para que a condic?a?o seja satisfeita.

A condic?a?o de aplicac?a?o desta e? uma condic?a?o dina?mica, e na?o pode ser verificada sin-
taticamente. Para demonstrarmos a condic?a?o precisamos provar que todo sinal recebido
por r deve ser enviado atrave?s de s, e vice-versa. Apesar de leis responsa?veis por alterar
somente o diagrama de estados do modelo na?o serem o foco deste trabalho, apresentare-
mos a seguir algumas leis relacionadas a esta visa?o. Algumas outras transformac?o?es em
digramas de estados podem ser encontradas em [34, 96]

A pro?xima lei expressa como a associac?a?o entre duas ca?psulas pode ser movida para
outra ca?psula.



4.1 leis ba?sicas 48

Lei 4.12 Encapsular Ca?psula

Condic?o?es:

(?) Nenhum nome de porta em cps? coincide com um nome em csp; em todo contexto em StrM
onde existir uma insta?ncia de C, a porta t? estara? conectada a? porta t de uma insta?ncia
de B.

(?) Na?o existe uma porta chamada t? em C.
(?) O protocolo T e todos protocolos associados a?s portas em bps e aps? possuem uma ma?quina

de estados determin??stica.

No lado direito da Lei 4.12, como consequ?e?ncia da mudanc?a da associac?a?o b de A para
C, a insta?ncia b e? transferida para o diagrama de estrutura de C. Assim, a insta?ncia b
passa a se comunicar diretamente com as outras insta?ncias na estrutura de c e necessita
de um conjunto de portas cps? em c para ter acesso ao mundo externo; todas as conexo?es
que existiam em bps passam a se conectar a? cps?. A porta t? deixa de ter utilidade no
modelo.

A aplicac?a?o da direita para a esquerda desta lei mostra como a hierarquia de um
diagrama de estrutura pode ser dissolvida passo-a-passo, atrave?s da mudanc?a das asso-
ciac?o?es entre ca?psulas. Note que apesar da hierarquia de ca?psulas indicar uma ordem na
criac?a?o destas ca?psulas (ca?psulas mais externas seriam criadas antes das mais internas),
na?o ha? garantia quanto a? ordem de execuc?a?o de suas ac?o?es iniciais. Desta forma, uma
estrutura plana de ca?psulas, sem prioridades quanto a? criac?a?o, teria o mesmo compor-
tamento que uma estrutura hiera?rquica. De fato, esta hierarquia e? usada somente para
agrupar conceitos ou computabilidade em processos de execuc?a?o.

Devido a lei incorporar novas portas no modelo, ela possui uma condic?a?o de aplicac?a?o
de que o comportamento destas portas e, consequ?entemente, seus protocolos, sa?o de-
termin??sticos. Desta maneira a conexa?o de uma nova porta em StrM na?o ira alterar



4.1 leis ba?sicas 49

o comportamento do modelo. Apesar desta ser uma condic?a?o dina?mica, na pra?tica, e?
facilmente verificada por que, normalmente, protocolos na?o te?m ma?quinas de estados
associadas.

Semelhante a? Lei 4.12, as leis C.5 e C.6 apresentadas no Ape?ndice C capturam dois
outros poss??veis padro?es para a mudanc?a de uma associac?a?o entre ca?psulas.

A lei a seguir indica que um conjunto de portas utilizadas na comunicac?a?o entre duas
ca?psulas podem ser combinadas em apenas duas portas, cujos tipos compreendem os
sinais e o comportamento do conjunto original.

Lei 4.13 Compor Protocolos

Condic?o?es:

(?) X e Y na?o possuem sinais com nomes em comum.
(?) Sx utiliza somente os sinais em xincomes e xoutgoings; Sy utiliza somente os sinais em

yincomes e youtgoings.

(?) Sa e Sb sa?o isomo?rficos a Saz e Sbz, respectivamente, exceto que todas as ocorre?ncias de
p e q em Sa sa?o trocadas por pq em Saz; similarmente, r e s sa?o trocadas por rs em Sbz.

No lado esquerdo Lei 4.13, utilizac?o?es redundantes dos protocolos X e Y sa?o sim-
plificadas para utilizarem um u?nico protocolo XY, como consequ?e?ncia a quantidade de
associac?o?es e portas no modelos sa?o reduzidas. As ma?quinas de estados das ca?psulas
que utilizam tais protocolos continuam a descrever o mesmo comportamento, pore?m uti-
lizando novas portas, associadas a? protocolo XY. Em sentido contra?rio, a lei pode ser
utilizada para aumentar a reusabilidade do protocolo XY, dividindo-o em dois novos pro-
tocolos X e Y. Note que a visa?o StaM e? representada nesta lei atrave?s dos diagramas de
estado de das ca?psulas e protocolos envolvidas na lei. Esta Lei possui como condic?a?o de
aplicac?a?o que todos estados dos diagramas de estado de A, C, X, e Y estejam encapsulados



4.1 leis ba?sicas 50

dentro de um estado composto que representa toda a ma?quina de estados; Sa, Sc, Sx, e
Sy, respectivamente. Este formato pode ser alcanc?ado atrave?s da aplicac?a?o da Lei 4.15.

A pro?xima lei estabelece sob que condic?o?es podemos mover o comportamento de um
protocolo para as ca?psulas que possuem uma associac?a?o com este protocolo.

Lei 4.14 Mover Comportamento Protocolo-Ca?psulas

Condic?o?es:

(?) As ma?quinas de estados em Sx e Sxz sa?o isomo?rficas, exceto que toda transic?a?o a[]\
disparadas por um sinal de entrada na maquina de estados de X e? representada por uma
transic?a?o r?a.x[]\s!a.x; similarmente toda transic?a?o b[]\ disparadas por um sinal de sa??da
X e? representada por uma transic?a?o s?b.y[]\r!b.y.

No lado esquerdo da Lei 4.14, toda comunicac?a?o com a ma?quina de estados de A1 pela
porta q1 e? filtrada pela ma?quina de estados de X, que governa o fluxo de comunicac?a?o
por esta porta; o mesmo acontece nas outras ca?psulas do sistema que utilizam portas do
tipo X. No lado direito da Lei 4.14, toda comunicac?a?o com a ma?quina de estados de A1
por uma porta q1 e? sincronizada com as portas r e s, restringindo seu comportamento da
mesma maneira que X o fazia no lado esquerdo da lei; similarmente, o mesmo acontece
para outras ca?psulas AN que utilizem X. Atrave?s desta lei, e? poss??vel retirar todas as
regras do modelo situadas nos protocolos e move?-las paras as ma?quinas de estado das
ca?psulas.

A pro?xima Lei mostra que um conjunto de estados sempre pode ser visto como um
u?nico estado que, por sua vez, engloba todos os outros.



4.1 leis ba?sicas 51

Lei 4.15 Encapsular estados

No lado direito da Lei 4.15 toda a subma?quina de estados de Sa, do lado esquerdo,
esta contida em Sc; Sa, do lado esquerdo, e? isomo?rfica a Sc. Esta lei server apenas para
reestruturar o diagrama de estados de A, sem alterar seu comportamento. Assumimos
que li e lo representam respectivamente as transic?o?es de sa??da e entrada de Sa, e que tanto
Sa quanto Sb podem ser compostos de outros estados.

A pro?xima lei mostra como a substituic?a?o de ac?o?es em um diagrama de estados de
uma ca?psula pode na?o alterar o comportamento observado desta ca?psula. Apesar desta
lei ser relativa apenas a ac?o?es de transic?o?es, podemos assumir que ac?o?es de sa??da ou
entrada de estados podem sempre ser reescritas como ac?o?es em transic?o?es de sa??da ou
entrada destes estados.

Lei 4.16 Reescrever Ac?a?o de Transic?a?o

Condic?o?es:

(?) act1 ? act2; g1 ? g2

Na Lei 4.16, apenas uma parte dos diagramas de estado de A e? apresentado, expressado
pela linha pontilhada no diagrama. A equivale?ncia entre ac?o?es (act1 ? act2) indica que
atributos ou para?metros utilizados por outras ac?o?es no diagrama de estados na?o tera?o seus
valores alterados apo?s a reescrita das ac?o?es, nem tampouco o comportamento observado
da ca?psula sera? alterado. Como, no contexto deste trabalho, ac?o?es sa?o escritas na notac?a?o
de Circus, a equivale?ncia de ac?o?es pode ser determinada utilizando-se a noc?a?o de leis
reportada em [15]. Esta condic?a?o e?, claramente, sema?ntica. Ja? que diagramas de estados
de protocolos na?o possuem ac?o?es, esta? impl??cito nesta lei que o diagrama apresentado e?
de uma ca?psula A de M.

Devido a esta lei na?o interferir em nenhuma declarac?a?o de ClsM, nem tampouco alterar
suas conexo?es em StrM, a apresentac?a?o dos diagramas de classe e estrutura e? desnecessa?ria.

A pro?xima lei estabelece quando e? poss??vel criar uma nova regia?o um AND-State de
uma ma?quina de estados. Uma condic?a?o para a aplicac?a?o da lei e? que a ca?psula seja
formada por partic?o?es. Uma partic?a?o de uma ca?psula e? composto por uma tupla com
fragmentos de cada um dos conjuntos de elementos declarados em uma ca?psula (atributos,
me?todos, predicados, portas e ma?quina de estado), estes fragmentos podem referenciar



4.1 leis ba?sicas 52

somente outros elementos da tupla, e na?o podem ser referenciados por nenhum outro
elemento declarado na ca?psula. Assim, uma ca?psula particionada e? fracamente coesa,
cujas partic?o?es na?o compartilham elementos entre si.

Lei 4.17 Criar Regia?o

Condic?o?es:

(?) A ca?psula A e? formada por duas partic?o?es: ?aatts, ainv, ameths, Sa, aports? e ?batts, binv,
bmeths, Sb, bports?; as portas em bports na?o devem estar conectadas a nenhuma outra
ca?psula em StrM.

(?) As portas em bports na?o esta?o conectadas a outras portas em StrsfM .

A Lei 4.17 indica que uma nova regia?o pode ser adicionada a uma ca?psula caso ela na?o
interfira no comportamento das regio?es restantes da ca?psula. No lado direito da Lei 4.17
a ma?quina de estados de A e? formado por um AND-State composto por duas regio?es (que
conte?m os estados Sa e Sb), que interagem entre si ou com o ambiente. Ale?m disto, nas
ac?o?es em Sa, somente atributos aatts e os me?todos ameths (que podem referenciar somente
atributos em aatts) sa?o usados; analogamente, ac?o?es de Sb utilizam somente atributos
batts e me?todos bmeths (que referenciam somente atributos de batts). O invariante de A
e? a conjunc?a?o ainv ? binv, onde ainv inclui somente varia?veis livres en aatts, e binv somente
em batts. Finalmente, as portas em aports so? podem ser referenciadas em Sa e bports
em Sb. Quando uma ca?psula obedece estas condic?o?es, no?s dizemos que ela esta? semi
particionada. Neste caso, existem duas semi partic?o?es: ?aatts, ainv, ameths, Sa, aports? e
?batts, binv, bmeths, Sb, bports?.

A pro?xima lei estabelece como uma ac?a?o do diagrama de estados de uma ca?psula pode
ser isolado em uma nova partic?a?o da ca?psula.



4.2 leis derivadas e refatoramentos 53

Lei 4.18 Isolar Ac?a?o

Condic?o?es:
(?) A ca?psula A na?o possui a declarac?a?o de nenhuma porta, chamada p ou q; a u?nica varia?vel

local utilizada pela ac?a?o F e? a varia?vel d do tipo D.

(?) O estado Sw na?o possui subestados;
(?) A ac?a?o F na?o utiliza atributos em aatts que sejam utilizados por outras ac?o?es na ma?quina

de estados de A

Na lado direito da Lei 4.18, o acesso a? ac?a?o F passa a ser realizado atrave?s de um
sinal reqf de requisic?a?o a? porta p, ao inve?s de executa-lo diretamente. Esta requisic?a?o e?
capturada por uma outra partic?a?o na ca?psula, que processa a ac?a?o F e envia o retorno
deste processamento atrave?s do sinal resf. Um caso mais simples desta lei e? quando F e?
igual a um me?todo m em ameths, onde m deve possuir um para?metro de tipo D e retorno
de tipo R

4.2 LEIS DERIVADAS E REFATORAMENTOS

Diferentemente das leis apresentadas na sec?a?o anterior, nesta sec?a?o consideramos leis
de maior granularidade, usualmente aplicadas durante a ana?lise e projeto de sistemas
de software. Transformac?o?es de modelo como estas podem ser justificadas a partir da
composic?a?o sequ?encial de leis ba?sicas, aplicadas passo-a-passo. As condic?o?es de aplicac?a?o
destas leis sa?o criadas a partir da composic?a?o das condic?o?es de aplicac?a?o das leis ba?sicas
que as formam.

As transformac?o?es apresentadas aqui podem ser consideradas refatoramentos de mo-
delos (refactorigs) [96], por serem usadas para reestruturar o modelo e por manterem o
comportamento do sistema modelado inalterado apo?s sua aplicac?a?o. Mostramos, nesta
sec?a?o, somente um pequeno conjunto destas leis, focando naquelas que sa?o mais impor-
tantes para a descric?a?o dos principais passos da estrate?gia de normalizac?a?o de um modelo
em UML-RT (Sec?a?o 4.2). Apo?s a apresentac?a?o de cada lei, sera?o realizadas justificativas
informais sobre a derivac?a?o destas transformac?o?es a partir das mais ba?sicas; algumas
provas formais sera?o apresentadas na Sec?a?o 4.3.



4.2 leis derivadas e refatoramentos 54

Em um processo de desenvolvimento, e? comum identificar uma classe (ou ca?psula)
durante a ana?lise que depois, durante o projeto, ira? ser representada por mais do que uma
u?nica abstrac?a?o. Enta?o, e? importante uma transformac?a?o para promover esta abstrac?a?o
escondida em uma classe ou ca?psula do modelo.

Leis para extrac?a?o de dados de uma classe ou de uma ca?psula sa?o bem semelhantes.
Mostramos apenas a lei para extrac?a?o de dados a partir de uma ca?psula. Este tipo de lei,
por exemplo, facilita que sistemas sejam modelados como componentes e, apo?s um certo
esta?gio do desenvolvimento, classes sejam extra??das destes componentes (ou ca?psulas).

Lei 4.19 Extrair Classe

Condic?o?es:

(?) bmeths, binv, bpre e bpost acessam somente me?todos em bmeths ou atributos em batts.
(?) Nenhuma ca?psula, exceto A, utiliza B.
(?) A estrutura interna de Sa e? isomo?rfica a Sax e os me?todos em amths? possuem a mesma

assinatura e o corpo dos me?todos em ameths, exceto que me?todos em bmeths e atributos
em batts sa?o acessados a partir de b.

No lado esquerdo da Lei 4.19, a ca?psula A e? representada pelo conjuntos de atributos
aatts e batts, de me?todos ameths e bmeths e de portas ports. A ma?quina de estados de
A e? representada por um estado Sa que engloba todos os outros estados da ma?quina de
estado, e tem acesso a qualquer elemento descrito anteriormente. O invariante de A e? a
conjunc?a?o ainv ? binv, e a pre?- e po?s-condic?o?es dos me?todos de A sa?o expressos por apre,
bpre, apost e bpost. Os elementos batts, bmeths, bpre e bpost sa?o fortemente coesos, e na?o
fazem refere?ncia a nenhum outro elemento de A; estes sa?o os elementos que podem ser
extra??dos para uma nova classe. Na lado direito da Lei 4.19, toda ac?a?o em Sax, me?todo
de ameths? ou predicado (ainv?, apre? ou apost?) que anteriormente acessava um atributo i
de batts ou me?todo m de bmeths devera? ser reescrita para acessa?-los como b.i ou b.j.

Note que como B e? uma nova abstrac?a?o no modelo, pode-se desejar que esta esteja
livre de certas regras impostas ao contrato de A. Desta forma, pode-se atribuir qualquer
invariante binv a B, tal que ainv ? binv seja aceita?vel pelo contrato de A. Da mesma forma
pre?- e po?s-condic?o?es indeseja?veis em B devem ser colocadas em me?todos em ameths que
deleguem todas as suas ac?o?es a me?todos em bmeths.

A justificativa da Lei 4.19 a partir de leis mais ba?sicas e? feita aplicando-se a Lei 4.4
para se introduzir o atributo b em A, do tipo de uma classe B (criada a partir da Lei C.2)



4.2 leis derivadas e refatoramentos 55

como descrita na Lei 4.19, e aplicando-se a Lei 4.16 para se reescrever as ac?o?es da ma?quina
de estados de A em ac?o?es equivalentes que utilizam b. Por fim, atributos e me?todos na?o
utilizados mais em A podem ser removidos aplicando-se as Leis 4.3 e 4.4. Um exemplo
de uma lei de transformac?a?o para a extrac?a?o de classes a partir de uma ca?psula pode ser
visto em [83]; esta lei mostra a extrac?a?o de um atributo, representando um conjunto de
classes, para uma classe que mediara? o acesso a este conjunto.

A lei a seguir decompo?e uma ca?psula A no paralelismo de insta?ncias de ca?psulas (B
e C) com o propo?sito de diminuir sua complexidade e de, potencialmente, aumentar seu
reuso.

Lei 4.20 Decomposic?a?o Paralela de uma Ca?psula

Condic?o?es:

(?) ?batts, binv, bmeths, (b1, b2), Sb? e ?catts, cinv, cmeths, (c1, c2, Sc? particionam A;
(?) As ma?quinas de estado Sb e Sc sa?o isomo?rficas a? Sb? e Sc?, respectivamente, exceto que

todas as ocorre?ncias de b1 e c2 em sa?o substitu??das respectivamente, por b
?
1 e c

?
2; os

protocolo X e Z possuem uma ma?quina de estados determin??stica.

Analogamente a? Lei4.17, a Lei 4.20 requer que a ca?psula A seja particionada, onde
cada partic?a?o deve ser auto-contida e fazer uso somente dos atributos e me?todos da
partic?a?o. Ale?m disto, as u?nicas portas utilizadas em uma partic?a?o sa?o aquelas que ela
conte?m.

No lado esquerdo da Lei 4.20, a ma?quina de estado de A e? formada por um AND-
State, composto de duas regio?es. Cada uma destas regio?es possui um estado que engloba
todos os outros (Sb e Sc), que interagem entre si (comunicac?a?o interna) atrave?s das
portas conjugadas b2 e c1 (como capturado pelo diagrama de estrutura). As outras
duas portas (b1 e c2) sa?o utilizadas para comunicac?o?es externas dos estados Sb e Sc,
respectivamente. As portas b1 e b2 sa?o utilizadas somente pelo estado Sb, enquanto Sc
faz uso somente das portas c1 e c2. Como dito, anteriormente, as ac?o?es de Sb utilizam
somente atributos e me?todos de batts e bmeths; analogamente Sc faz uso somente de
catts e cmeths. Finalmente, o invariante de A e? a conjunc?a?o binv ? cinv, onde binv inclui
somente batts como varia?veis livres, e cinv inclui somente catts.



4.2 leis derivadas e refatoramentos 56

O efeito da decomposic?a?o e? criar duas novas ca?psulas componentes, b e c, uma para
cada partic?a?o, e redimensionar a ca?psula original A para agir como um mediador. Em
geral, o novo comportamento de A ira? depender da forma particular da decomposic?a?o. A
Lei 4.20 captura uma decomposic?a?o paralela. No lado direito da lei, A na?o possui uma
ma?quina de estados, delegando completamente seu comportamento original para B e C
atrave?s de conexo?es com componentes destes tipos no diagrama de estrutura.

Em relac?a?o ao diagrama de estrutura no lado direito da lei, ele mostra como A en-
capsula b e c. Quando a e? criada, ele automaticamente cria insta?ncias de b e c, que
executam concorrentemente. As portas pu?blicas b1 e c2 sa?o preservadas em A, e, assim,
sua interface com o ambiente externo. A ca?psula B tem como porta pu?blica uma imagem
de b1, chamada b

?
1. Apesar desta porta ser pu?blica em B, ela somente e? vista dentro

do diagrama de estrutura de A. O papel desta porta e? possibilitar que B receba sinais
externos recebidos por A atrave?s de b1, como e? capturado pela conexa?o entre b

?
1 e b1

no diagrama de estrutura de A. Analogamente, c2 e b
?
2 te?m o mesmo relacionamento,

relativo a?s ca?psulas A e C. As portas internas b2 e c1 foram movidas para as ca?psulas B
e C, respectivamente, e realizam os mesmo pape?is que antes.

A justificativa da Lei 4.20 a partir das leis ba?sicas pode ser feita movendo-se, no lado
direito da lei, passo-a-passo o comportamento de B e C para A. Inicialmente movemos
o comportamento de B para uma outra ca?psula A?, que futuramente ira? substituir A. O
primeiro passo e? desencapsular o componente de ca?psula b (Lei 4.12) da estrutura de
A. Criar outra ca?psula A? (Lei 4.1) com os atributos (batts), invariante (binv), me?todos
(bmeths) e portas (b1 e b2) de B, e enta?o, inserir uma insta?ncia a

? de A? em todo contexto
de StrM em que uma insta?ncia de A aparece (Lei 4.2). Em seguida, b e? substitu??do por a

?

atrave?s da aplicac?a?o da Lei 4.9, ja? que as ma?quinas de estados de B e A? sa?o isomo?rficas.
Finalmente, b e? removida de StrM (Lei 4.2).

Para se mover o comportamento de C para A?, os atributos catts, os me?todos cmeths
e as portas c1 e c2 sa?o adicionados a? A

? (Leis 4.3 e 4.5). Enta?o, uma regia?o e? adicionada
ao digrama de estados de A? com o estado Sc (Lei 4.17). Ja? que Sc na?o compartilha
nenhum elemento (atributo, me?todo ou porta) com Sb, o comportamento de A continua
inalterado. No passo seguinte, o componente de ca?psula c e? desencapsulado (Lei 4.12) do
diagrama de estrutura de A, substitu??da por a? (Lei 4.9), e removida de StrM (Lei 4.2),
seguindo um processo semelhante ao que aplicado a? insta?ncia de c.

No final, A na?o e? mais utilizada no sistema, podendo ser retirada do modelo (Lei 4.1),
e assim A? pode ter seu nome renomeado para A (Lei C.3), obtendo assim o mesmo
contexto apresentado no lado esquerdo da Lei 4.20.

Motivado por pra?ticas ja? existentes de desenvolvimento, precisamos de uma lei que
transforma classes, possivelmente encontradas durante a ana?lise, em ca?psulas, durante o
projeto.



4.3 formalizac?a?o das leis 57

Lei 4.21 Transformar Classe em Ca?psula

Condic?o?es:

(?) Todos os atributos batts sa?o privados.
(?) Nenhuma outra ca?psula, ale?m de A, possui uma relac?a?o com B.

A Lei 4.21 transforma uma classe B (lado esquerdo), que na?o tem nenhum compor-
tamento associado (diagrama de estados), em uma ca?psula (lado direito), que inclui um
diagrama de estados que lida com as requisic?o?es para a chamada de seus me?todos.

O comportamento das chamadas de me?todos em B e? preservado por um diagrama de
estados que simula uma comunicac?a?o sincronizadas com o protocolo cliente. Enta?o, todos
os servic?os (me?todos pu?blicos) da classe sa?o acess??veis a partir de um novo protocolo XB.
Note que o construtor da classe B transforma-se na ac?a?o da transic?a?o inicial de diagrama
de estados da nova ca?psula B.

A justificativa desta lei em func?a?o de leis ba?sicas pode ser feita, no lado esquerdo da
Lei 4.21, aplicando-se a Lei 4.19 para incluir a classe B na ca?psula A, em seguida aplica-se
as leis 4.17 e 4.18 para criar uma nova partic?a?o em A com os atributos em batts, me?todos
bmeths, m() e B().

Apo?s particionar A, a Lei 4.20 pode ser aplicada para decompor a ca?psula A em duas
ca?psulas, onde uma destas e? a ca?psula B. Enta?o, o componente b do tipo B sera? desen-
capsulado da estrutura de A (Lei 4.12) para que obtenhamos StrM como e? apresentado
no lado esquerdo da Lei 4.21. Finalmente uma regia?o vazia sera? criada em A(Lei 4.17),
e, atrave?s da aplicac?a?o da Lei 4.20, a ca?psula A podera? ter a mesma declarac?a?o que no
lado esquerdo da Lei 4.21.

4.3 FORMALIZAC?A?O DAS LEIS

Baseado no mapeamento sema?ntico apresentado na Sec?a?o 3.2, podemos transformar
os modelos em UML-RT presentes nos dois lados de uma lei de transformac?a?o para a
notac?a?o OhCircus. A partir da sema?ntica de Circus e de seu ca?lculo de refinamentos, e?
poss??vel verificar a validade das leis de transformac?a?o para UML-RT. Ao inve?s de recorrer



4.3 formalizac?a?o das leis 58

diretamente a? sema?ntica de Circus podemos utilizar leis de refinamento [84] para realizar
sua prova; na realidade, va?rias das leis para UML-RT foram inspiradas por leis em Circus.

4.3.1 Prova da Lei 4.20

Para provar esta lei, lidamos inicialmente com as viso?es descritas pelos diagramas
de classe e estado. O mapeamento destas viso?es da ca?psula A, do lado esquerdo da lei,
como um processo em Circus e? obtido utilizando-se a segunda regra de mapeamento
apresentada na Sec?a?o 3.2.1 e a u?ltimo regra da Sec?a?o 3.2.2. Escrevemos as duas partic?o?es
usando o operador ?, como na Lei 3.2. De fato, a Lei 4.20 foi inspirada pela Lei 3.2
de Circus. Assim, as viso?es representadas pelo processo ChartA sa?o equivalentes a? sim-
ples composic?a?o paralela de ChartB e de ChartC. Estritamente, os atributos e me?todos
batts, catts, bmeths e cmeths precisam ser mapeados utilizando a func?a?o TL; aqui no?s
omitiremos sua aplicac?a?o para manter a legibilidade.

process ChartA =? begin
state State =? [batts ? catts | InvB ? InvC]
bmeths ? catts
cmeths ? batts
•H(SB)[b2 := k] |[ batts | {| k, b1, c2 |} | catts]|)H(SC)[c1 := k]

end

Aplicando as func?o?es identidade [b1 := b
?
1][b

?
1 := b1] e [c2 := c

?
2][c

?
2 := c2] a? ac?a?o principal de

ChartA, obtemos:

•H(SB)[b1 := b?1][b?1,b2 := b1,k] |[ batts|{|k,b1,c2 |}|catts]|)H(SC)[c2 := c?2][c?2,c1 := c2,k]

A partir da Lei 3.2, obtemos a igualdade:

ChartA = ChartB[b
?
1,b2 := b1,k] |[{| k, b1, c2 |} ]| ChartC[c?2,c1 := c2,k]

onde ChartB e ChartB sa?o declarados como:

process ChartB =? begin state State =? [batts | InvB] bmeths •H(SB)[b1 := b?1] end
process ChartC =? begin state State =? [catts | InvC] cmeths •H(SC)[c2 := c?2] end

Agora, considerando a parte estrutural da ca?psula A, obtemos o processo StructA em
Circus, como e? apresentado abaixo.

StructA =? (ChartA[b2, c1 := k, k] |[{|k,b1,c2 |}]| X[chanX := b1] |[{|k,b1,c2 |}]|
Y[chanY := k] |[{|k,b1,c2 |}]| Y[chanY := k] |[{|k,b1,c2 |}]| Z[chanZ := c2])\{|k|}

O diagrama de estrutura de B, C e A, no lado direito da lei, sa?o mapeados de maneira
similar. Para se evitar confuso?es entre as duas ocorre?ncias de A na lei, iremos nos referir
a? ocorre?ncia no lado esquerdo simplesmente como A, e a? do lado direito como A?.



4.3 formalizac?a?o das leis 59

Struct?A =? ((StructB[b
?
1, b2 := m, k ] |[{| k |} ]| StructC[c?2, c1 := n, k ]) |[{| k |}]|

(X[chanX := m] |[{| k |} ]| Z[chanZ := n]))[m, n := b1, c2] \ {| k |}
StructsB =? ChartB |[{|b2,b?1 |}]|X[chanX := b?1] |[{|b2,b?1 |}]|Y[chanY := b2]
StructC =? ChartC |[{|c1,c?2 |}]|Y[chanY := c1] |[{|c1,c?2 |}]|Z[chanZ := c?2]

Enta?o, queremos provar que StructA tem o mesmo comportamento de StructA? , onde
o u?ltimo inclui em sua estrutura StructB e StructC.

StructA
= [1. Pela definic?a?o de StructA]

(ChartA[b2, c1 := k, k] |[{|k,b1,c2 |}]| X[chanX := b1] |[{|k,b1,c2 |} ]| Y[chanY := k]
|[{|k,b1,c2 |}]| Y[chanY := k] |[{|k,b1,c2 |}]| Z[chanZ := c2])\{|k|}

= [2. Expandindo ChartA ]
(ChartB[b

?
1,b2 := b1,k] |[{|k,b1,c2 |}]|ChartC[c?2,c1 := c2,k] |[{|k,b1,c2 |}]| X[chanX := b1]

|[{|k,b1,c2 |} ]| Y[chanY := k] |[{|k,b1,c2 |}]| Y[chanY := k] |[{|k,b1,c2 |}]| Z[chanZ := c2]) \ {| k |}
= [3. Aplicando a Lei B.6 para X[chanX := b1] e Z[chanZ := c2]]

(ChartB[b
?
1,b2 := b1,k] |[{|k,b1,c2 |}]| X[chanX := b1] |[{|k,b1,c2 |}]| X[chanX := b1] |[{|k,b1,c2 |}]|

Y[chanY := k] |[{|k,b1,c2 |} ]| ChartC[c?2,c1 := c2,k] |[{|k,b1,c2 |}]| Y[chanY := k] |[{|k,b1,c2 |}]|
Z[chanZ := c2] |[{|k,b1,c2 |}]| Z[chanZ := c2]) \ {| k |}

= [4. Reorganizando os processos utilizando as leis B.4 e B.4]
(ChartB[b

?
1,b2 := b1,k] |[{|k,b1,c2 |}]| X[chanX := b1] |[{|k,b1,c2 |}]| Y[chanY := k] |[{|k,b1,c2 |}]|

ChartC[c
?
2,c1 := c2,k] |[{|k,b1,c2 |}]| Y[chanY := k] |[{|k,b1,c2 |} ]| Z[chanZ := c2] |[{|k,b1,c2 |}]|

X[chanX := b1] |[{|k,b1,c2 |}]| Z[chanZ := c2]) \ {| k |}
= [5. Aplicando as func?o?es de substituic?a?o indentidade [k := b2][b2 := k], [k := c1][c1 := k],

e distribuindo [k := b2] e [k := c1] atrave?s da Lei B.1 ]
(((ChartB[b

?
1 := b1] |[{|b2,b1,c2 |}]| X[chanX := b1] |[{|b2,b1,c2 |}]| Y[chanY := b2])[b2 := k]

|[{|k,b1,c2 |}]| ((ChartC[c?2 := c2] |[{|c1,b1,c2 |}]| Y[chanY := c1] |[{|c1,b1,c2 |}]| Z[chanZ := c?2])
[c1 := k] |[{|k,b1,c2 |}]| X[chanX := b1]) |[{|k,b1,c2 |} ]| Z[chanZ := c2])) \ {| k |}

= [6. Aplicando a func?a?o de substituic?a?o indentidade [c2,b1 := c
?
2,b

?
1][c

?
2,b

?
1 := n,m]

[n,m := c2,b1], e distribuindo [c2,b1 := c
?
2,b

?
1][c

?
2,b

?
1 := n,m] atrave?s da Lei B.1 ]

(((ChartB |[{|b2,b?1,n|}]|X[chanX := b?1] |[{|b2,b?1,n|}]|Y[chanY := b2])[b?1,b2 := m,k]
|[{|k,m,n|}]| ((ChartC |[{|c1,m,c?2 |}]| Y[chanY := c1] |[{|c1,m,c?2 |}]| Z[chanZ := c?2])
[c?2,c1 := n,k] |[{|k,m,n|} ]| X[chanX := m]) |[{|k,m,n|} ]| Z[chanZ := n])[m,n := b1,c2]) \ {| k |}

= [7. Utilizando a Lei B.7 para restringir as sincronizac?o?es sobre os canais n e m]
(((ChartB |[{|b2,b?1 |}]|X[chanX := b?1] |[{|b2,b?1 |}]|Y[chanY := b2])[b?1,b2 := m,k] |[{|k,m,n|}]|
((ChartC |[{|c1,c?2 |}]|Y[chanY := c1] |[{|c1,c?2 |}]|Z[chanZ := c?2])[c?2,c1 := n,k] |[{|k,m,n|}]|
X[chanX := m]) |[{|k,m,n|}]| Z[chanZ := n])[m,n := b1,c2]) \ {| k |}

= [8. Utilizando a definic?a?o de StructB e StructC ]
((StructB[b

?
1,b2 := m,k] |[{|k,m,n|}]| (StructC[c?2,c1 := n,k] |[{|k,m,n|}]|

X[chanX := m]) |[{|k,m,n|} ]| Z[chanZ := n])[m,n := b1,c2]) \ {| k |}
= StructA?

Durante a prova, tre?s leis condicionais sa?o utilizadas. A condic?a?o da Lei B.6 (Passo
3) e? claramente satisfeita porque os processos X e Z sa?o obtidos de dos protocolos X e Z,
que, na Lei 4.20, assume-se que sa?o determin??sticos. A condic?a?o da Lei B.7 (Passo 7) e?
satisfeita ja? que que os processos ChartB, X[chanX := b

?
1] e Y[chanY := b2] na?o utilizam o



4.3 formalizac?a?o das leis 60

canal n; similarmente, os processos ChartC, Y[chanY := c1] e Z[chanZ := c
?
2] na?o utilizam

m. A condic?a?o da Lei B.1 (passos 5 e 6) e? satisfeita ja? que as seguintes func?o?es de
renomeac?a?o utilizadas na distribuic?a?o sa?o injetivas: [k := b2], [k := c1] e [c2,b1 := n,m].

4.3.2 Prova da Lei 4.12

No lado esquerdo da Lei 4.12, em toda ocorre?ncia de uma insta?ncia da ca?psula C, existe
sempre uma insta?ncia b da ca?psula B conectada a uma de suas subca?psulas d da ca?psula
d : D. A ca?psula A representa o contexto onde esta configurac?a?o existe. A lei indica que
apo?s sua aplicac?a?o, em seu lado direito, o comportamento de C e de qualquer contexto
em que aparec?a (A) sera? inalterado, caso b passe a ser um componente do diagrama de
estrutura de C.

Para provar esta lei, precisamos lidar apenas com a visa?o estrutural do modelos (StrM),
ja? que as u?nicas reestruturac?o?es da lei que podem afetar o comportamento do sistema
sa?o mudanc?as realizadas nas conexo?es do diagrama de estrutura de C e A. De fato a
visa?o intencional das insta?ncias de ca?psulas em Circus desconsidera as associac?o?es no
diagrama de classes do modelo, mapeando unicamente a ocorre?ncias destas insta?ncias em
StrM. Apesar da remoc?a?o da porta t

?, no lado esquerdo da lei, e da adic?a?o do conjunto de
portas p?, no lado direito da lei, estas portas sa?o somente utilizadas na visa?o estrutural
para interconectar portas de componentes de ca?psula em diferentes estruturas, e nenhuma
necessidade de prova quando a? sua declarac?a?o e? necessa?ria.

Devido a? condic?a?o de que a u?nica insta?ncia de C e? o componente c em A, nossa de-
monstrac?a?o precisa mostrar apenas a igualdade do comportamento de A no lado esquerdo
e direito da lei. Para se evitar confuso?es entre as duas ocorre?ncias de A e C na lei, ire-
mos nos referir a?s ocorre?ncia no lado esquerdo simplesmente como A e C, e a?s do lado
direito como A? C?; note que B e D continuam inalterados em ambos os lados da lei.
Assim, o comportamento da ca?psula A seria dado por StructA, atrave?s da terceira regra
de mapeamento da Sec?a?o 3.2.1.

StructA =? (TL(aps) |[{|x,w,y |}]| TL(aps?) |[{|x,w,y |}]| StructB[bps,t := x,w] |[{|x,w,y |}]|
StructC[cps,t

? := y,w]) [x,y := aps?,aps] \ {| w |}

Similarmente, o mapeamento de B, C, C? e A? sa?o dados por:

StructB =? ChartB |[{| bps,t |} ]| TL(bps) |[{| bps,t |} ]| T[chanT := t]
StructC =? (T[chanT := k] |[{| k,z |} ]| TL(cps) |[{| k,z |} ]| StructD[dps, s := z, k])

[z, k := csp, t?]
StructC? =? (StructB[bps,t := x

?,w] |[{| x?,w,z |}]| TL(cps) |[{| x?,w,z |}]|
StructD[dps,s := z,w]) [z,x

? := csp,cps?] \ {| w |}
StructA? =? (TL(aps) |[ x , y ]| TL(aps?) |[ x , y ]| StructC? [cps, cps? := y, x])

[x, y := aps?, aps]

Como veremos na prova abaixo, o comportamento do processo StructA sera? igual ao
do StructA? , de fato a u?nica mudanc?a entre sera? na ordem da composic?a?o paralela de
StructB e StructC, e na renomec?a?o de seus canais.

StructA



4.3 formalizac?a?o das leis 61

= [1. Expandindo StructA]
(TL(aps) |[{|x,w,y |}]| TL(aps?) |[{|x,w,y |}]| StructB[bps,t := x,w] |[{|x,w,y |}]|
StructC[cps,t

? := y,w]) [x,y := aps?,aps] \ {| w |}
= [2. Expandindo StructC]

(TL(aps) |[{|x,w,y |}]| TL(aps?) |[{|x,w,y |}]| StructB[bps,t := x,w] |[{|x,w,y |}]|
((T[chanT := k] |[{| k,z |} ]| TL(cps) |[{| k,z |}]| StructD[dps, s := z, k]) [z, k := csp, t?])
[cps,t? := y,w]) [x,y := aps?,aps] \ {| w |}

= [3. Restrigindo w aos processos que o usam, aplicando as leis B.7 e B.2]
(TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| (StructB[bps,t := x,w] |[{| x,w,y |}]|
((T[chanT := k] |[{| k,z |}]| TL(cps) |[ k,z ]| StructD[dps,s := z,k]) [z, k := csp, t?])
[cps, t? := y, w]) \ {| w |}) [x, y := aps?, aps]

= [4. Aplicando os renamings [t? := k] e [k := w]]
(TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| (StructB[bps,t := x,w] |[{| x,w,y |}]|
((T[chanT := w] |[{| w,z |}]| TL(cps) |[{| w,z |}]| StructD[dps,s := z,w]) [z := csp])
[cps := y]) \ {| w |}) [x,y := aps?,aps]

= [5. Inserindo a func?a?o indentidade [x := x?][x? := cps?][cps? := x] ]
((TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| (StructB[bps,t := x,w] |[{| x,w,y |}]|
((T [chanT := w ] |[{| w,z |}]| TL(cps) |[{| w,z |}]| StructD[dps,s := z,w]) [z := csp])
[cps := y]) \ {| w |}) [x := x?][x? := cps?][cps? := x]) [x,y := aps?,aps]

= [6. Aplicando os renamings [x := x?], [x? := cps?]e[cps? := x]]
(TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| ((StructB[bps,t := x?,w] |[{| x?,w,y |}]|
(T[chanT := w ] |[{| w,z |}]| TL(cps) |[{| w,z |}]| StructD[dps,s := z,w]) [z,x? := csp,cps?])
[cps, cps? := y,x]) \ {| w |}) [x,y := aps?,aps]

= [7. Aplicando B.7 para espandir o canal x ]
(TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| ((StructB[bps,t := x?,w] |[{| x?,w,y |}]|
T[chanT := w ] |[{| x?,w,z |}]| TL(cps) |[{| x?,w,z |}]| StructD[dps,s := z,w]) [z,x? := csp,cps?])
[cps, cps? := y,x] \ {| w |}) [x,y := aps?,aps])

= [8. Restringindo w atrave?s da Lei B.7]
(TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| (((StructB[bps,t := x?,w] |[{| x?,y |} ]| T[chanT := w ])
|[{| x?,w,z |}]| TL(cps) |[{| x?,w,z |}]| StructD[dps,s := z,w]) [z,x? := csp,cps?])
[cps, cps? := y,x] \ {| w |}) [x,y := aps?,aps]

= [9. Expandindo StructB ]
(TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| ((((ChartB |[{| bps,t |} ]| TL(bps) |[{| bps,t |}]|
T[chanT := t])[bps,t := x

?,w] |[{| x?,y |} ]| T[chanT := w ]) |[{| x?,w,z |}]| TL(cps) |[{| x?,w,z |}]|
StructD[dps,s := z,w]) [z,x

? := csp,cps?]) [cps, cps? := y,x] \ {| w |}) [x,y := aps?,aps]
= [10. Usando a Lei B.1 para distribuir o renaming [bps,t := x,w]]

(TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| ((((ChartB |[{| bps,t |} ]| TL(bps) |[{| bps,t |}]|
T[chanT := t] |[{| bps,t |} ]| T[chanT := t]))[bps,t := x?,w] |[{| x?,w,z |}]| TL(cps) |[{| x?,w,z |}]|
StructD[dps,s := z,w]) [z,x

? := csp,cps?]) [cps, cps? := y,x] \ {| w |}) [x,y := aps?,aps]
= [11. Usando a Lei B.6 para T[chanT := t] ]

(TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| ((((ChartB |[{| bps,t |} ]| TL(bps) |[{| bps,t |}]|
T[chanT := t]))[bps,t := x

?,w] |[{| x?,w,z |}]| TL(cps) |[{| x?,w,z |}]| StructD[dps,s := z,w])
[z,x? := csp,cps?]) [cps, cps? := y,x] \ {| w |}) [x,y := aps?,aps]

= [12. Pela definic?a?o de StructB ]



4.4 concluso?es 62

(TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| ((StructB[bps,t := x?,w] |[{| x?,w,z |}]| TL(cps)
|[{| x?,w,z |}]| StructD[dps,s := z,w]) [z,x? := csp,cps?]) [cps, cps? := y,x] \ {| w |})
[x,y := aps?,aps]

= [13. aplicando a Lei B.3 para mover \ {| w |} ]
(TL(aps) |[{| x,y |}]| TL(aps?) |[{| x,y |}]| ((StructB[bps,t := x?,w] |[{| x?,w,z |}]| TL(cps)
|[{| x?,w,z |}]| StructD[dps,s := z,w]) [z,x? := csp,cps?] \ {| w |}) [cps, cps? := y,x])
[x,y := aps?,aps]

= [14. Aplicac?a?o da definic?a?o de StructC? ]
(TL(aps) |[ x , y ]| TL(aps?) |[ x , y ]| StructC? [cps, cps? := y, x]) [x, y := aps?, aps]

= [15. Segundo a definic?a?o de StructA? ]
StructA?
Durante a prova, tre?s leis condicionais sa?o utilizadas. A condic?a?o da Lei B.6 (Passo

11) e? claramente satisfeita porque o processo T e? obtido do protocolo T, que, na Lei 4.12,
assume-se que e? determin??stico. A condic?a?o da Lei B.7 (passo 3,7,8) e? satisfeita ja? que
que nos passos onde e? aplicada os processos na?o utilizam os canais x, w e y. A condic?a?o
da Lei B.1 (Passos 10) e? satisfeita ja? que a func?o?es de renomeac?a?o [bps,t := x,w] utilizadas
na distribuic?a?o e? injetiva.

4.4 CONCLUSO?ES

Neste cap??tulo, apresentamos um conjunto de leis ba?sicas em UML-RT e como elas
podem ser utilizadas para justificar outras leis de transformac?o?es mais elaboradas, usu-
almente utilizadas na pra?tica.

A partir da sema?ntica OhCircus, foi poss??vel tambe?m demonstrar a corretude destas
leis. Esta corretude permite a inclusa?o das leis em um processo de desenvolvimento ri-
goroso, onde o desenvolvedor pode realizar suas tarefas de modelagem com uma maior
garantia sobre seus resultados. Adicionalmente, a aplicac?a?o de leis com estas carac-
ter??sticas pode diminuir o esforc?o desprendido durante o desenvolvimento em testes de
verificac?a?o do modelo.



CAPI?TULO 5

NORMALIZAC?A?O E APLICAC?A?O DAS LEIS

Com o objetivo de analisar o poder de expressa?o do conjunto de leis proposto, neste
cap??tulo mostraremos a abrange?ncia dessas leis atrave?s de sua aplicac?a?o nos principais
passos de uma estrate?gia de normalizac?a?o de um modelo UML-RT em um modelo UML
estendido com um u?nico objeto ativo, responsa?vel por todas as interac?o?es com o ambiente
e por conservar o comportamento dina?mico do sistema modelado.

Este modelo UML estendido pode ser visto como uma forma normal, e, portanto,
nossa estrate?gia pode ser vista como uma contribuic?a?o para uma estrate?gia de completude
capturada por uma reduc?a?o a esta forma normal, semelhante a? estrate?gia apresentada
em [9] para uma linguagem de programac?a?o orientada a objetos; a completude de conjun-
tos de leis para uma linguagem imperativa simples e para a linguagem concorrente Occam
e? apresentada em [46, 80], respectivamente. Nosso foco e? em um conjunto de leis para
diagramas de classe e estrutura do modelos; uma estrate?gia completa de normalizac?a?o
necessita de um grande nu?mero de leis para capturar transformac?o?es nos diagramas de
estados, que esta? fora do escopo deste trabalho.

No processo de normalizac?a?o as leis sa?o aplicadas, usualmente, em um sentido inverso
ao que sa?o aplicadas durante um processo de desenvolvimento. Durante o processo de
desenvolvimento, elas sa?o aplicadas para quebrar abstrac?o?es, promover reuso e modula-
rizac?a?o, enquanto que em uma estrate?gia de reduc?a?o a uma forma normal, as leis sa?o
aplicadas para gerar um sistema monol??tico, cujo u?nico objetivo e? atestar o poder de
expressa?o das leis.

Nas sec?o?es a seguir mostramos a aplicac?a?o das leis em seus dois sentidos (ver Fi-
gura 5.1). Na Sec?a?o 5.1, a medida que os passos de nossa estrate?gia de normalizac?a?o
sa?o apresentados, mostramos a aplicac?a?o de algumas leis de transformac?a?o utilizadas na
reduc?a?o do modelo de sistema simplificado de automac?a?o industrial, apresentado anteri-
ormente na Sec?a?o 2.3, em uma u?nica ca?psula. Enquanto na Sec?a?o 5.2, apresentamos a
aplicac?a?o das leis durante o desenvolvimento do estudo de caso, partindo-se de um mo-
delo abstrato de ana?lise, extraido dos casos de uso do sistema, ate? um modelo concreto e
mais elaborado de projeto em UML-RT , pro?ximo a? fase de implementac?a?o. Como tanto
a estrate?gia de reduc?a?o quanto o desenvolvimento do estudo de caso utilizam o mesmo
modelo como ponto de partida, a combinac?a?o de ambos e? capaz de ilustrar o conjunto de
passos necessa?rios para desenvolver um modelo monol??tico representado por u?nica ca?psula
em um modelo mais concreto e modularizado de projeto.

5.1 ESTRATE?GIA DE NORMALIZAC?A?O

Atrave?s do uso conjunto das leis propostas mostramos que todo o modelo pode ser
representado por uma u?nica ca?psula MAIN, cujas portas pu?blicas sa?o utilizadas pelo

63



5.1 estrate?gia de normalizac?a?o 64

Figura 5.1. Os dois sentidos de aplicac?a?o das leis

sistema na comunicac?a?o com o ambiente externo. Inicialmente, assumimos que todas
as demais ca?psulas do modelo estar contidas no diagrama de estrutura de MAIN. Desta
maneira, StrM e? expresso pelo diagrama hiera?rquico de estrutura de MAIN, e toda ca?psula
que reagir a um estimulo externo, interage direta ou indiretamente com alguma porta
de MAIN. Apo?s isto toda a hierarquia de StrM e? destru??da e redunda?ncias no modelo
sa?o removidas, assegurando que todo o comportamento do modelo esta contido em suas
ca?psulas. Em seguida o objetivo e? compor as ca?psulas duas-a-duas, em uma u?nica ca?psula,
ate? que reste uma u?nica ca?psula no modelo (MAIN).

Esta estrate?gia e? efetuada atrave?s da sequ?e?ncia de passos abaixo. As leis referenciadas
em cada passo sa?o exaustivamente aplicadas no modelo. Esta sequ?encia de passos e?
executada ciclicamente, ate? que as leis na?o possam ser mais aplicadas.

i) Combinar portas de ca?psulas. As ca?psulas devem ter uma u?nica conexa?o bina?ria
entre si, utilizando, cada uma delas, uma u?nica porta (aplicac?a?o da Lei 4.13, da
esquerda para a direita);

Este passo e? utilizado principalmente para adequar a comunicac?a?o entre as ca?psulas
ao padra?o de aplicac?a?o das leis dos pro?ximos passos. Ale?m disto, e? u?til tambe?m
para diminuir portas redundantes no modelo. Em nosso estudo de caso (Figura 2.2),
todas as insta?ncias de ca?psulas comunicam-se entre si atrave?s de uma u?nica conexa?o
bina?ria, e por isto a aplicac?a?o desta lei e? desnecessa?ria.

ii) Eliminar hierarquia no diagrama de estrutura das ca?psulas. Componentes de ca?psulas
(insta?ncias) situadas na estrutura de outra ca?psula devem ser movidas para o n??vel
de estrutura superior, que conte?m esta outra ca?psula (aplicac?a?o das leis C.6, C.5
e 4.12, da direita para a esquerda).

Em nosso estudo de caso, explicitamos a ca?psula Main no modelo. Isto pode ser feito
atrave?s da sua criac?a?o (aplicac?a?o da Lei 4.1 da esquerda para a direita) e inserc?a?o
de uma insta?ncia man do tipo Main em StrM; a ca?psula ProdSys pode ser movida
para dentro do diagrama de estrutura de Main a partir da aplicac?a?o da Lei C.6 (da
direita para a esquerda).

Enta?o, devemos eliminar as insta?ncias de ca?psulas sin e son da hierarquia de ProdSys,
resultando em arquitetura plana, sem a existe?ncia de subca?psulas, como e? mostrado
na Figura 5.2. Nesta figura, a Lei C.5 foi aplicada duas vezes para que a ca?psula
sin e son fossem retiradas da estrutura de sys.

iii) Mover comportamento para ca?psulas. Todo o comportamento do modelo deve estar



5.1 estrate?gia de normalizac?a?o 65

Figura 5.2. Passo ii da normalizac?a?o do Estudo de Caso

situado dentro de suas ca?psulas; protocolos na?o devem conter qualquer comporta-
mento associado (aplicac?a?o da Lei 4.14, da esquerda para a direita);

No sistema de automac?a?o industrial, o u?nico protocolo que possui um comporta-
mento associado e? STO. Este esta? associado a?s portas so e pi nas ca?psulas Storage e
ProdSys. Para que possamos aplicar a lei que move o comportamento do protocolo
para uma ca?psula, precisamos proteger as portas so e pi e criar relay ports que
interliguem elas ao ambiente externo, atrave?s da Lei 4.10.

Em seguida, podemos mover o comportamento do protocolo STO para uma ca?psula
STOC no modelo, atrave?s da Lei 4.14. Toda as ca?psulas que possu??rem uma asso-
ciac?a?o com STO, passaram a possuir uma nova subca?psula de tipo STOC em seu
diagrama de estrutura que controla o fluxo de informac?o?es da conexa?o a?s portas
do tipo STO, tal qual a porta o fazia. Observamos que o diagrama de estrutura
e? bastante complexo e que pode ser reduzido a uma forma mais amiga?vel atrave?s
da aplicac?a?o da Lei C.5 para desencapsular as insta?ncias do tipo STOC de dentro
da estrutura de Storage e ProdSys, e removermos uma das insta?ncias redundantes
que intermediam a comunicac?a?o entre sin e sys, atrave?s da aplicac?a?o da Lei 4.11,
resultando no modelo da Figura 5.3.

Apesar do resultado obtido possibilitar a aplicac?a?o do pro?ximo passo de norma-
lizac?a?o, notamos que as insta?ncias da ca?psula STOC? na?o restringem nenhuma co-
municac?a?o na conexa?o; na realidade, as ca?psulas Storage e ProdSys ja? obedecem a
esta restric?a?o, sempre enviando ou recebendo um sinal req antes de sincronizarem
com o sinal output. Por isso, podemos remover as insta?ncias das subca?psula c e c?

que intermediam as conexo?es entre as insta?ncias sin, sys e son em StrM, atrave?s da
aplicac?a?o da Lei 4.11. O resultado e? um modelo ide?ntico ao da Figura 5.2, exceto



5.1 estrate?gia de normalizac?a?o 66

Figura 5.3. Passo iii da normalizac?a?o do Estudo de Caso

que STO na?o possui uma ma?quina de estados associada.

iv) Compor ca?psulas. Cada duas ca?psulas que se comuniquem, devem ser encapsuladas
no diagrama de estrutura de uma nova ca?psula e compostas dentro deste diagrama.
Para tanto, uma nova ca?psula e? criada a partir da aplicac?a?o da Lei 4.1, e uma
insta?ncia de seu tipo e? inserida no mesmo diagrama de estrutura das outras duas
ca?psulas que sera?o compostas (Lei 4.2). A duas ca?psulas devem ser encapsulas
dentro do diagrama de estrutura desta nova ca?psula (leis C.6 e 4.12), e finalmente
compostas dentro da nova ca?psula (aplicac?a?o da Lei 4.20, da direita para a es-
querda), reduzindo-se assim a quantidade de ca?psulas do sistemas;

Em nosso estudo de caso, para que possamos compor as ca?psulas sys e son devemos
encapsula?-las em uma nova ca?psula Controller (criada a partir da Lei 4.1), que
mediara? qualquer comunicac?a?o externa a sys ou a son. Para tanto, devemos aplicar a
Lei C.6 para encapsular son dentro de con e depois aplicar a Lei 4.12 para encapsular
sys em con, obtendo como resultado final o modelo exibido na Figura 5.4.

Apo?s encapsularmos as duas ca?psulas sys e son podemos compo?-las em uma u?nica
ca?psula atrave?s da aplicac?a?o da Lei 4.20. Cada regia?o das ma?quinas destas ca?psulas
sera? associada a uma nova regia?o na ma?quina de estados de Controller, descrevendo
o comportamento ativo destas ca?psulas atrave?s do paralelismo destas regio?es. A
Conexa?o entre as portas po e si continuara a ser descrita atrave?s de uma conexa?o
interna ao diagrama de estrutura de Controller em StrM, como pode ser visto na
Figura 5.5.

Apo?s a primeira aplicac?a?o da Lei 4.20, notamos que o modelo (visto na Figura 5.5)
se encontra em um formato que possibilita uma segunda composic?a?o de ca?psulas,



5.1 estrate?gia de normalizac?a?o 67

Figura 5.4. Primeiro modelo intermedia?rio do passo iv da normalizac?a?o do Estudo de Caso

desta vez sin e con. Notamos desta maneira que, nas ca?psulas compostas, seus con-
troladores sa?o vistos como ca?psulas normais do modelos, e que podem ser compostas
novamente. Nesta u?ltima composic?a?o, a ca?psula que conte?m sin e con e? a propria
ca?psula Main que representa todo o sistema, resultando no fim de nosso processo
de aplicac?a?o. O resultado desta segunda composic?a?o pode ser visto na Figura 5.6.

v) Remover declarac?o?es na?o utilizadas no modelo. Todas os elementos (ca?psulas, pro-
tocolos, portas, me?todos e atributos) na?o referenciados por outros elementos do
modelo devem ser removidos (aplicac?a?o das Leis 4.1, C.1, 4.2, 4.5, 4.6, 4.3, C.2, 4.8
da direita para a esquerda);

Em nosso estudo de caso, durante a aplicac?a?o das leis, diversas ca?psulas deixaram
de ter utilidade, como Storage, ProdSys, Controller e STOC. Apesar de na?o serem
mostradas mais no modelo, nenhuma lei foi utilizada para remover explicitamente
suas declarac?o?es. A remoc?a?o da declarac?a?o destes elementos do modelo pode ser
feita atrave?s da aplicac?a?o da Lei 4.1 (da direita para a esquerda).

Esta estrate?gia visa unificar as ca?psulas do modelo em uma u?nica ca?psula com todo o
comportamento do modelo, como pode ser observado na reduc?a?o de nosso estudo de caso
na Figura 5.6. Desta forma o modelo resultante e? formado por uma u?nica ca?psula que
conte?m o comportamento e os dados de todo o modelo, mantendo as mesmas portas de
comunicac?a?o, existentes anteriormente, com o ambiente externo. As classes do modelo
na?o sa?o afetadas.

A simplificac?a?o da ma?quina de estados da ca?psula resultante, reduzindo a quantidade
de regio?es de S0, na?o e? foco deste trabalho. Isto ser feito atrave?s de leis que envolvem



5.2 estudo de caso 68

Figura 5.5. Segundo modelo intermedia?rio do passo iv da normalizac?a?o do Estudo de Caso

condic?o?es de prova na equivale?ncia de diagrama de estados [34].
Este modelo poderia ser reduzido a uma u?nica ca?psula, sem a existe?ncia de classes

no modelo. Neste caso, passos adicionais devem ser aplicados, como em [9], para reduzir
todas as classes do modelo, e incluir as classes na capsula que possui uma associac?a?o
para elas (aplicac?a?o da Lei 4.19, da direita para a esquerda). Note que, caso a ca?psula
resultante tenha um comportamento puramente passivo, ela pode ser transformada em
uma classe, atrave?s da Lei 4.21. A classe final desempenharia, enta?o, papel semelhante
ao resultado da estrate?gia de reduc?a?o em [9], que reduz um sistema orientado a objeto
arbitra?rio na linguagem ROOL a uma u?nica classe que representa todo o modelo.

Algumas leis na?o foram explicitamente referenciadas no processo de normalizac?a?o.
Por exemplo, as leis 4.15 e 4.17. Entretanto, estas leis sa?o necessa?rias para, por exemplo,
particionar uma ca?psula e permitem a aplicac?a?o da Lei 4.20. Similarmente, outras leis
sa?o usadas na justificativa de leis derivadas, utilizadas no processo de normalizac?a?o ou
para preparar o modelo em um formato que possibilite a aplicac?a?o de outras leis, como
as leis 4.10 e 4.15.

5.2 ESTUDO DE CASO

Com a finalidade de ilustrar a aplicac?a?o das leis propostas no Cap??tulo 4, apresentare-
mos, nesta sec?a?o, a modelagem sistematizada de um sistema simplificado de automac?a?o
industrial (ver Sec?a?o 2.3). O sistema utilizado como estudo de caso ja? foi explorado
em [53], onde a sua modelagem em UML-RT e? apresentada, pore?m sem que nenhuma lei
de transformac?a?o tenha sido proposta. Aqui, refinamos um modelo abstrato de ana?lise,
extra??do dos casos de uso do sistema, em um modelo concreto e mais elaborado de projeto,
pro?ximo a uma implementac?a?o. Esta estrate?gia mostra que o conjunto de leis proposto



5.2 estudo de caso 69

Figura 5.6. Modelo final da composic?a?o de ca?psulas no passo iv da normalizac?a?o do Estudo
de Caso

pode justificar pra?ticas informais de projeto. Em particular, desenvolvemos este estudo
de caso seguindo algumas das pra?ticas encontradas no Processo Unificado (RUP) [52],
que sa?o explicadas no decorrer do texto.

No sistema de automac?a?o industrial [53], toda a aplicac?a?o e? responsa?vel por processar
um nu?mero de pec?as. O sistema consiste dos seguintes dispositivos: um reposito?rio de
entrada com pec?as na?o processadas, um reposito?rio de sa??da com pec?as ja? processadas,
algumas ma?quinas que processam as pec?as e alguns agentes de transporte. Cada pec?a
na?o processada deve ser retirada do reposito?rio de entrada, passar por todas as ma?quinas
em um trajeto pre?-definido e ser armazenada no reposito?rio de sa??da. As ma?quinas e
reposito?rios encontram-se distantes fisicamente, e necessitam requerer pec?as de trabalho
a um elemento de transporte, chamado holon (um agente auto?nomo de transporte).

Por simplicidade, na Sec?a?o 2.3 na?o lidamos com todas as restric?o?es da especificac?a?o,
representando apenas o comportamento global do sistema, que servira? como ponto de
partida para o desenvolvimento do estudo de caso. O objetivo, aqui, e? detalhar esta
modelagem, mostrando os passos necessa?rios ate? que ele possua duas ma?quinas e um
agente de transporte. Passos adicionais para se obter o projeto apresentado em [53] sa?o
discutidos no final da sec?a?o.

No RUP, modelos de ana?lise e projeto sa?o constru??dos a partir da visa?o de casos de
uso do sistema. Para o propo?sito deste trabalho, as funcionalidades do sistema foram
reduzidas a tre?s casos de uso: inserir pec?as, recuperar pec?as e processar pec?as (veja
Figura 2.1, na Sec?a?o 2.3). Inicialmente, o sistema se encontra inativo e sem nenhuma
pec?a; a? medida que o operador do sistema as insere, o sistema processa as pec?as e as
disponibiliza para que o operador possa recupera?-las.

Em relac?a?o ao mapeamento de casos de uso no modelo de ana?lise, baseamos nos no
trabalho reportado em [101] para extrair um objeto ativo de cada caso de uso do sistema.
Nesta abordagem, apo?s a descric?a?o dos casos de uso, o comportamento dos casos de uso



5.2 estudo de caso 70

sa?o mapeados em objetos ativos (ca?psulas) que podem utilizar outros objetos passivos
(classes), sintetizados a partir da descric?a?o dos casos de uso. A especificac?a?o conjunta
destas duas categorias de objetos forma o modelo de ana?lise. O modelo que representa
a visa?o de ana?lise de nosso estudo de caso pode ser visto na Figura 5.2, onde a ca?psula
Main representa todo o sistema, a insta?ncia sin da ca?psula Storage representa o caso de
uso inserir pec?a, a insta?ncia son da ca?psula Storage representa o caso de uso recuperar
pec?a e a insta?ncia sys da ca?psula ProdSys representa o caso de uso processar pec?a. A
classe Piece e? sintetizado a partir da descric?a?o da troca de mensagens entre estas ca?psulas.
Na estrutura de Main, e? descrita a interac?a?o entre estas ca?psulas e, consequ?entemente,
entre os casos de uso do sistema: uma u?nica insta?ncia sys recupera pec?as de trabalho
diretamente da insta?ncia sin, as processa, e as envia a? ca?psula son.

Diferente desta abordagem, no RUP, o modelo de ana?lise e? derivado a partir de casos
de uso, ignorando o uso de objetos ativos. Cada caso de uso da? origem a uma classe de
controle com todas as regras de nego?cio do caso de uso, classes de fronteira para cada
interac?a?o do sistema com um ator (pessoa ou sistema) do mundo externo e classes de
entidade com os dados utilizados pelas classes restantes associadas ao caso de uso. Atrave?s
desta te?cnica, e? poss??vel separar dados das operac?o?es associadas a?s regras de nego?cio dos
casos de uso, bem como das regras de comunicac?a?o do sistema com o ambiente externo.

Apesar das diferenc?as, a abordagem utilizada por no?s pode alcanc?ar, atrave?s do uso de
nossas leis, resultados semelhantes a? te?cnica utilizada no RUP. A ca?psula que representa
todo o caso de uso pode ser decomposta em va?rias outras ca?psulas que representem os
papeis das elementos de controle e fronteira sugeridos no RUP, enquanto entidades, por
serem naturalmente passivas, continuariam a ser representados atrave?s de classes. Por
fim, caso cada uma desta ca?psulas (de controle e de fronteira) possuam um comporta-
mento passivo, elas podem ser transformadas em classes, resultando em um modelo de
ana?lise semelhante ao proposto pelo RUP.

Em nosso estudo de caso, as ca?psulas Storage e Prodsys possuem um comportamento
ativo e representam o papel de controladores de seus respectivos casos de uso, enquanto
Main serve de fronteira com o mundo externo, neste caso nenhuma regra de comunicac?a?o
e? atribu??da a Main, que na?o possui por este motivo uma ma?quina de estados associada.

Apo?s a criac?a?o de um modelo de ana?lise, o pro?ximo passo e? encontrar uma arquitetura
candidata[52]. Nesta atividade do RUP, identificamos os elementos que sa?o abstrac?o?es
chaves para interac?a?o entre os casos de uso e verificamos a possibilidade de reuso. Ado-
tamos uma arquitetura de camadas simples onde a manipulac?a?o de dados e? isolada das
regras de nego?cio. Por esta raza?o inserimos uma colec?a?o de dados para representar a
colec?a?o de Pieces em Storage. Esta colec?a?o e? extra??da da ca?psula Storage, atrave?s da
Lei 4.19, em uma nova classe PieceCollection, como e? mostrado na Figura 5.7.

A arquitetura candidata e? incrementalmente aperfeic?oada atrave?s da identificac?a?o de
novos elementos de projeto. Como desejamos que nosso modelo possua uma segunda
ma?quina de processamento, decompomos a ca?psula ProdSys em duas outras ca?psulas.
Para isto, inicialmente necessitamos criar uma nova partic?a?o em ProdSys como parte da
responsabilidade do processamento de pec?as de trabalho. Dois novos me?todos processA()
e processB() sa?o criados em ProdSys (Lei 4.3), de forma que execuc?a?o sequ?encial des-
tes me?todos seja equivalente a process(). Enta?o, a ac?a?o p = process(x) e? reescrita na



5.2 estudo de caso 71

Figura 5.7. Arquitetura candidata do Estudo de Caso

ac?a?o equivalente var y = processA(x); p = processB(y) (Lei 4.16), e a execuc?a?o da ac?a?o
processB(y); po!input.p e? isolada em uma nova partic?a?o (Lei 4.18). Finalmente, apo?s pos-
suirmos duas partic?o?es na ca?psula ProdSys, esta pode ser decomposta em duas novas
ca?psulas (ProcessorA e ProcessorB) atrave?s da Lei 4.20, como e? mostrado na Figura 5.8;
por questa?o de clareza, algumas relac?o?es entre ca?psulas e protocolos sa?o omitidas no
modelo.

Outro elemento crucial da especificac?a?o que falta ser identificado e? o agente de trans-
porte. Este elemento itermedia a comunicac?a?o entre insta?ncias das ca?psulas Storage,
ProcessorA e ProcessorB, que representam dispositivos fisicamente separados. Para dar
origem a este elemento de transporte, criamos uma nova insta?ncia de ca?psula em StrM in-
termediando a comunicac?a?o entre as insta?ncias das ca?psulas citadas, atrave?s da Lei 4.11.
Em seguida, combinamos as insta?ncias duas a duas ate? formar uma especificac?a?o inicial
da ca?psula que representara? o agente de transporte, chamada de Holon. Utilizaremos para
combinar estas ca?psulas a Lei C.7, uma versa?o simplificada da Lei 4.20 que na?o requer
que as partic?o?es se comuniquem. O modelo resultante da aplicac?a?o destas leis pode ser
visto na Figura 5.9

Outras mudanc?as podem ser realizadas no modelo como, por exemplo, a unia?o das
portas pi e pd, e pb e po nas ca?psulas ProcessorA e ProcessorB, respectivamente, atrave?s
da Lei 4.13. Na?o realizamos estas transformac?o?es, pois na?o diminuiria o potencial de
reuso do sistema e na?o propiciaria melhoria significativa do modelo.

Outros passos de modelagem que podem ser realizado e? a criac?a?o de um novo agente de
transporte (insta?ncia de Holon) em sincronia com hts, atrave?s da aplicac?a?o incremental da
Lei 4.8 a todas as portas de hts, e o refinamentos das ma?quinas de estados de ProcessorA,
ProcessorB e Holon para que apenas um agente efetue o transporte de pec?as a cada



5.3 concluso?es 72

Figura 5.8. Identificac?a?o de ProcessorA e ProcessorB no Estudo de Caso

requisic?a?o de uma ma?quina (ProcessorA e ProcessorB), tal qual o modelo existente em [53].
Desta maneira, as ma?quinas de processamento negociariam o agente de transporte que
possu??ssem menor custo (de tempo e dista?ncia) para transporte das pec?as entre outras
ma?quinas do sistema ou reposito?rios.

Ale?m disto, podemos alterar a ma?quina de estados de Holon para que ela possua
uma partic?a?o encarregada do percurso (entre as ma?quinas e reposito?rios) que as pec?as
devem seguir no sistema e outra partic?a?o encarregada pelo transporte propriamente dito.
Atrave?s da Lei 4.20, a partic?a?o com o roteiro daria origem a uma nova ca?psula Driver
que pertenceria a? camada de nego?cio da arquitetura do sistema, enquanto a partic?a?o
responsa?vel pelo transporte daria origem a uma ca?psula Transporter pertencente a? camada
de comunicac?a?o da arquitetura do sistema. Na?o nos atemos a estes passos da modelagem
por eles estarem essencialmente relacionados a mudanc?as nos diagramas de estados do
modelos, cujas leis na?o sa?o o enfoque deste trabalho.

5.3 CONCLUSO?ES

Neste cap??tulo, ilustramos a aplicabilidade das leis propostas em um estudo de caso
real e discutimos, brevemente, como elas podem ser inseridas em um processo de desen-
volvimento. Notamos que, devido a nem todos os processos de desenvolvimento inclu??rem
a noc?a?o de objetos ativos, algumas atividades do processo devem ser adaptadas, sem que
isto altere o fluxo do processo.



5.3 concluso?es 73

Figura 5.9. Identificac?a?o de Holon no Estudo de Caso

Outro ponto observado e? que, devido ao nosso enfoque em leis estruturais do modelo,
certos passos de modelagem na?o sa?o completamente cobertos, principalmente quando
estes requerem leis que alterem o diagrama de estados de modelo. Apesar disto, a com-
pletude de nossas leis quando a? visa?o estrutural do modelo na?o e? comprometida, como
foi mostrado no estudo de caso.

Ale?m disso, demonstramos a abrange?ncia deste conjunto de leis atrave?s dos principais
passos de uma estrate?gia de normalizac?a?o. Esta estrate?gia foi ilustrada pela norma-
lizac?a?o do modelo de ana?lise do sistema de automac?a?o industrial ate? uma forma normal,
representada por um modelo UML estendido com uma u?nica ca?psula.

Como tanto a estrate?gia de reduc?a?o quanto o desenvolvimento do estudo de caso utili-
zam o mesmo modelo como ponto de partida, a combinac?a?o de ambos e? capaz de ilustrar
o conjunto de passos necessa?rios para desenvolver um modelo monol??tico representado
por u?nica ca?psula em um modelo mais concreto e modularizado de projeto.



CAPI?TULO 6

CONCLUSO?ES

Neste trabalho, mostramos a possibilidade de um desenvolvimento rigoroso em UML-
RT atrave?s do uso de leis de transformac?a?o de modelos. Estas leis sa?o apresentadas de
uma maneira incremental, onde um conjunto de leis ba?sicas e? utilizado para justificar
leis mais elaboradas e usualmente utilizadas na pra?ticas. Em contraste com a definic?a?o
usual de regras de transformac?a?o, estas leis sa?o definidas segundo uma sema?ntica formal
e garantem a preservac?a?o do comportamento do sistema modelado.

Para provarmos a corretude destas leis, necessitamos atribuir uma sema?ntica formal
a UML-RT, atrave?s de seu mapeamento para a linguagem formal OhCircus, enfocando
os elementos que UML-RT adiciona a UML (ca?psulas, protocolos, portas e conexo?es) e
considerando uma visa?o integrada do modelo envolvendo digramas de classes, estado e
estrutura. Baseado neste mapeamento sema?ntico, e na sema?ntica das leis de OhCircus,
no?s mostramos que e? poss??vel (e relativamente simples) provar tais leis de transformac?a?o
de modelos, a? medida que contribu??mos de uma forma original a? formalizara?o de trans-
formac?o?es em modelos UML-RT.

Apesar de o destino de nossa traduc?a?o ser uma linguagem de especificac?a?o (ao inve?s
de um modelo matema?tico mais padronizado), a notac?a?o de OhCircus inclui as notac?o?es
de CSP e Z, ambas formalismos bem conhecidos e maduros. Ale?m disto, a combinac?a?o
destas notac?o?es em OhCircus e? formalmente caracterizada com base na Unifying Theories
of Programming.

Nossas leis sa?o apresentadas de uma forma incremental; iniciamos com leis ba?sicas que
capturam isoladamente propriedades fundamentais dos elementos de UML-RT. A partir
destas, no?s propomos leis mais elaboradas, que formalizam transformac?o?es utilizadas na
pra?tica. As leis lidam com diversos diagramas do modelo (classe, estado e estrutura)
e sua apresentac?a?o deixa expl??cito os efeitos de sua aplicac?a?o sobre estes diagramas,
diferentemente de outras leis que consideram estes diagramas isoladamente.

Considerando os elementos que UML-RT adiciona a UML, o conjunto de leis proposto
e? abrangente, e pode ser observado como parte de uma sema?ntica axioma?tica destes ele-
mentos. A noc?a?o de abrange?ncia destas leis e? baseada na demonstrac?a?o de que um mo-
delo arbitra?rio UML-RT pode ser reduzido a um modelo UML estendido com uma u?nica
ca?psula responsa?vel por todas as interac?o?es com o ambiente. Este modelo UML esten-
dido pode ser visto como uma forma normal, e, portanto, nossa estrate?gia pode ser vista
como uma contribuic?a?o para uma estrate?gia de completude capturada por uma reduc?a?o
a esta forma normal, semelhante a? estrate?gia apresentada em [9] para uma linguagem
de programac?a?o orientada a objetos. Apesar de na?o termos apresentado uma estrate?gia
de reduc?a?o em todos os detalhes, mostramos que as leis propostas sa?o abrangentes o
suficiente para cobrir transformac?o?es que incluem ca?psulas e protocolos em diagramas de
classe e de estrutura.

74



6.1 trabalhos relacionados 75

Outro ponto importante e? a relac?a?o entre classes e ca?psulas, como capturado pela
Lei 4.21 que transforma, sob determinadas condic?o?es, um elemento no outro. Mostra-
mos, tambe?m, a aplicac?a?o das leis durante a execuc?a?o de atividades de modelagem de
ana?lise e projeto do RUP atrave?s de um estudo de caso. Como explicado no Cap??tulo 4,
transformac?o?es consistentes entre classes no diagrama sa?o livremente permitidas, desde
que estas na?o interfiram com a interface esperada por ca?psulas que invoquem me?todos
destas classes. Isto acontece porque a comunicac?a?o entre ca?psulas e classes e? atrave?s da
chamada de me?todos e porque ca?psulas na?o compartilham classes entre si. Assim do
ponto de vista destas classes, ca?psulas sa?o simplesmente elementos externos que invocam
seus servic?os.

Apesar de lidarmos, neste trabalho, com um subconjunto da linguagem UML-RT e o
fato desta linguagem na?o ter sido criada por organizac?o?es de padronizac?a?o (como a OMG),
sendo mantida pelas empresas que suportam suas ferramentas [19], va?rios conceitos desta
linguagem esta?o diretamente presentes em outras linguagens para a descric?a?o de arqui-
teturas ou de componentes, como ADLs ou UML 2.0 (versa?o ainda na?o finalizada pela
OMG). Assim, todas as contribuic?o?es que possam ser incorporadas ao desenvolvimento
usando UML-RT podem, em princ??pio, ser adaptadas para estas linguagens.

6.1 TRABALHOS RELACIONADOS

Relacionado a? formalizac?a?o de modelos visuais orientados a objetos, duas abordagens
principais podem ser identificadas [30]: suplementar e integrac?a?o de me?todos. A primeira
substitui linguagens naturais de documentac?a?o por expresso?es mais formais. A pro?pria
OCL [70] e? um exemplo desta abordagem, ela e? utilizada em conjunto com UML com o
propo?sito de anotar o modelo. Na u?ltima abordagem, te?cnicas de modelagem orientadas
a objetos sa?o tornadas mais precisas e receptivas a ana?lises rigorosas atrave?s de sua
integrac?a?o com notac?o?es de especificac?a?o formal, mapeando o modelo informal em um
dom??nio formal e bem definido. Utilizamos a u?ltima abordagem por ela ter, em princ??pio,
um maior apelo pra?tico, ja? que o desenvolvedor pode realizar suas tarefas de modelagem
na notac?a?o que possuir maior familiaridade sem explicitamente lidar com formalismos,
pore?m baseados em uma notac?a?o u?nica que possibilita a prova de va?rios aspectos do
modelo. Um exemplo bem sucedido da integrac?a?o de me?todos formais com linguagens
visuais e? a linguagem Alloy [50] que descreve a declarac?a?o de classes, seus relacionamentos
e propriedades em um diagrama similar ao diagrama de classes em UML. Contudo, apesar
de Alloy possuir uma sema?ntica bem definida, apenas um subconjunto das viso?es do
modelo e? expresso nesta linguagem.

Na literatura, diversos esforc?os te?m se referido aos problemas de integrac?a?o de modelos
UML com linguagens formais; existem diversas abordagens de especificac?a?o [12, 28, 29,
78, 69], como a combinac?a?o de UML com Z [95] ou com CSP[79]; tipicamente, cada uma
destas contribuic?o?es tende a se concentrar em uma u?nica visa?o do modelo (como diagrama
de estados [69] ou diagrama de classes [12, 28, 78]). Embora alguns trabalhos como, por
exemplo, [58, 66] utilizem uma notac?a?o uniforme para descrever um mapeamento que
considere a estrutura e o comportamento do modelo, a apresentac?a?o e? informal e baseada
em exemplos.



6.1 trabalhos relacionados 76

A formalizac?a?o de diagramas de classes utilizando a notac?a?o Z e? apresentada em
[12, 28, 29]; nestas abordagens, classes, associac?o?es e o pro?prio modelo sa?o mapeados em
esquemas em Z. O esquema que representa o modelo possui a visa?o extensional de suas
classes, com o conjunto de todos os objetos do modelo, e as associac?o?es do diagrama de
classes. Desta maneira, quaisquer propriedades sobre as classes ou associac?o?es podem
ser incorporadas como predicados deste esquema. Comparac?o?es detalhadas desta abor-
dagem e de outras que envolvem extenso?es de Z com orientac?a?o a objetos (Object-Z) [93]
sa?o discutidas em [4]. Estas abordagens para Object-Z usam, em geral, conceitos seme-
lhantes a? abordagem utilizada em Z, pore?m atrave?s de uma representac?a?o mais sucinta
do diagrama de classes, por representarem diretamente algumas das caracter??sticas de
orientac?a?o a objetos de UML.

O mapeamento de classes assumido para OhCircus (uma simplificac?a?o do encontrado
em [10]) e? semelhante ao encontrado em [78] para Object-Z, onde classes sa?o mapeadas
diretamente em construtores da linguagens, associac?o?es sa?o representadas pela instan-
ciac?a?o de atributos adicionais nas classes envolvidas na relac?a?o (localizados de acordo
com a navegac?a?o da associac?a?o) e todas as restric?o?es do modelo devem ser expressos
como invariantes destas classes. O trabalho reportado em [78] tambe?m mostra o poder
de expressividade de Z em relac?a?o a propriedades do modelo descritas OCL, corroborando
com outros trabalhos que comparam Z e OCL [49].

Com respeito a? sema?ntica formal de diagramas de estados, o mapeamento destes dia-
gramas em processos em CSP e? apresentado em [69, 75]. Em [69], ma?quinas de estados sa?o
mapeadas em processos CSP. Apesar de expressar a hierarquia de ma?quinas de estados,
este trabalho na?o lida com paralelismo ou estados com histo?ria. Ale?m disto, por utilizar
somente CSP, esta abordagem ignora ac?o?es que envolvam operac?o?es sobre os componentes
de estados ou me?todos de um elemento declarado no modelo.

Em [75], ma?quinas de estados sa?o mapeadas em processos CSP e esquemas em Z, uti-
lizando a notac?a?o unificada CSP-OZ. Cada estado possui uma representac?a?o sema?ntica
atrave?s de um esquema em Z, enquanto os eventos de comunicac?a?o e a composic?a?o des-
tes estados sa?o realizados atrave?s de processos em CSP. Desta maneira, os principais
conceitos de ma?quina de estados, como hierarquia, concorre?ncia e estados com historia
sa?o mapeados em uma notac?a?o u?nica que permite uma integrac?a?o com mapeamentos de
diagrama de classes. Apesar de lidar com hierarquia de estados, transic?o?es complexas
(por exemplo, transic?o?es entre diferentes n??veis da hierarquia que atravessam a borda de
estados compostos) na?o sa?o cobertos neste trabalho; as u?nicas transic?o?es expressas em
estados compostos sa?o transic?o?es de grupo. Apesar destes tipos de transic?o?es comple-
xas permitirem a violac?a?o do encapsulamento de estados compostos, elas sa?o necessa?rias
para indicar diferentes estados de aceitac?a?o ou falha da subma?quina de estados de um
estado composto [92]; sendo, esta propriedade crucial em nossas leis para simplificar a
representac?a?o de subma?quina de estados em um u?nico estado.

Por esta raza?o, optamos por estender o trabalho [69] utilizando a notac?a?o de OhCir-
cus. Adaptac?o?es foram necessa?rias para permitir ac?o?es sobre atributos e me?todos das
ca?psulas, e a inserc?a?o de paralelismo atrave?s de And-States. Neste sentido, o mapea-
mento de estados compostos foi completamente alterado para permitir os diversos tipos
de transic?o?es sobre And-States, utilizando uma abordagem similar a? encontrada em [75]



6.1 trabalhos relacionados 77

na utilizac?a?o de eventos de comunicac?a?o para notificar a sa??da destes estados compos-
tos para os seus sub-estados (ver Sec?a?o 3.2.2); estados historia na?o foram abordados
neste trabalho por na?o serem necessa?rios em nossas leis, ja? que na?o focamos em leis para
diagramas de estados.

Relacionado a? formalizac?a?o de UML-RT, limitac?o?es similares a?s encontradas na in-
tegrac?a?o de me?todos formais e UML podem ser encontrada em trabalhos [32, 27, 24]
que formalizam UML-RT utilizando CSP. Eles focam na traduc?a?o da visa?o estrutural de
UML-RT em CSP [32], e consideram a representac?a?o comportamental das ca?psulas [27, 24]
somente parcialmente. Por lidarem isoladamente com as viso?es de um modelo UML-RT,
estes trabalhos apresentam deficie?ncias quando analisamos as diversas viso?es do modelo
em conjunto, como discutido adiante.

Em [32] a visa?o estrutural (contido no diagrama de estrutura) das portas, ca?psulas e
conectores sa?o representados por classes e processos em CSP-OZ, e a renomeac?a?o de ca-
nais de comunicac?a?o para o mesmo nome destas portas e? utilizado para a composic?a?o de
ca?psulas, sendo esta a estrate?gia utilizada por no?s na composic?a?o (conexa?o) de ca?psula
em um diagrama de estrutura. Nenhuma refere?ncia a outros elementos declarados no
diagrama de estado ou classes e? feita neste trabalho. Apesar de em [66] os trabalhos
reportados em [32] e em [75] serem referenciados conjuntamente em uma estrate?gia para
a traduc?a?o dos diagramas de estrutura, estados e classes de UML-RT para CSP-OZ, o
mapeamento e? feito de maneira informal e atrave?s de exemplos, sem nenhuma refere?ncia
para: como o comportamento dos protocolos associados a?s portas de uma conexa?o e? incor-
porado na comunicac?a?o entre as ca?psulas; como regio?es de AND-State em um diagrama
de estados de uma ca?psula devem ser sincronizadas entre si ou com outras ma?quinas de
estados do modelo; ou quais condic?o?es sa?o necessa?rias para a composic?a?o de uma ca?psula
a outra.

O trabalho reportado em [27, 24] apresenta brevemente algumas noc?o?es que podem ser
utilizadas como base para o mapeamento de UML-RT em CSP, pore?m baseado somente
nestas noc?o?es parece ser dif??cil o mapeamento de sistemas complexos em todos os seus
aspectos. Estes trabalhos citam brevemente ma?quinas de estados simples de ca?psulas [27]
e protocolos [24] e contribuem com o mapeamento do diagrama de estruturas atrave?s do
mapeamento de conectores como processos CSP [27], apresentando ainda assim os mesmos
problemas atribu??dos aos trabalhos [66, 32, 75], ale?m disto, na?o lidam com a hierarquia
de diagramas de estrutura e estado.

Relacionado a leis para UML, existem diversos trabalhos [41, 28, 29, 38, 55, 96] que
consideram transformac?o?es para classes e diagramas de estados que consideramos com-
plementares ao nosso trabalho. Diferentemente das leis apresentadas no Cap??tulo 4, as
leis apresentadas nestes trabalhos lidam com um modelo mais abstrato, na?o considerando
associac?o?es como atributos de classes no diagrama de classes ou ac?o?es no diagrama de
estados. Ale?m disto, as leis propostas nestes trabalhos consideram restric?o?es globais ao
modelo, como aquelas que envolvem o nu?mero de insta?ncias de classes em todo o sistema;
em nosso trabalho, propriedades sa?o restritas aos invariantes das classes e ca?psulas.

Em [28, 29, 37] leis sobre diagramas de classe sa?o consideradas incluindo uma sema?ntica
formal para UML, utilizando Alloy [37] e Z [28, 29], bem como a prova da validade destas
leis; no trabalho reportado em [41], regras de transformac?a?o sa?o apresentadas baseadas



6.1 trabalhos relacionados 78

na linguagem semi-formal OCL. Destacamos o trabalho reportado em [37] por apresentar
um conjunto abrangente de leis ba?sicas para Alloy, e que podem ser facilmente aplicadas a
diagramas de classe. Semelhante ao nosso trabalho, em [37] leis mais elaboradas e usual-
mente aplicadas na pra?tica sa?o derivadas da composic?a?o de leis mais ba?sicas. Como dito
anteriormente, estes trabalhos interpretam o modelo em um n??vel mais abstrato, onde as-
sociac?o?es na?o sa?o necessariamente direcionais nem tampouco geram atributos nas classes
que relacionam. Por esta raza?o, estas leis sa?o mais gerais que as nossas e permitem des-
crever uma quantidade maior de propriedades sobre as classes do modelo. Contudo, leis
para classes na?o sa?o o foco de nosso trabalho e somente sa?o utilizadas para complementar
as leis que propomos para os elementos que UML-RT adiciona a UML.

As transformac?o?es de modelos UML apresentadas em [55, 96] contemplam diagra-
mas de estado, em adic?a?o a? diagramas classe, pore?m os efeitos em cada diagrama sa?o
considerados isoladamente, e portanto qualquer interfere?ncia entre aspectos esta?ticos e
dina?micos sa?o ignorados, diferentemente da nossa abordagem que considera estes efei-
tos simultaneamente. Em particular, [55] apresenta uma sema?ntica formal para UML,
OCL e statecharts em termos de Real-time Action Logic (RAL), e apresenta e prova
algumas transformac?o?es. Em [96], uma relac?a?o entre os conceitos de refactoring para
co?digo e transformac?o?es de modelos sa?o apresentadas de maneira informal, mostrando a
preservac?a?o de comportamento em algumas transformac?o?es para diagramas de estado e
de classe.

Relativo a leis de transformac?a?o para UML-RT, poucos trabalhos [85, 25, 63] foram
encontrados; em sua maioria, apenas a utilidade destas leis sa?o mencionadas em um pro-
cesso de desenvolvimento passo-a-passo [85] ou na verificac?a?o de consiste?ncia do modelo
durante sua evoluc?a?o [25], utilizando UML-RT.

Em [85], e? proposto um processo de desenvolvimento incorporando noc?o?es de refina-
mento, baseadas em princ??pios particulares de refinamento comportamental de interfaces
do componentes (ca?psulas) da aplicac?a?o e incorporac?a?o de tempo. O primeiro tipo de
transformac?a?o permite que as interfaces de uma ca?psula sejam alteradas levando-se em
considerac?a?o sua ma?quina de estados, enquanto o segundo tipo sugere que sincronismo
e aspectos temporais sejam ignorados nos esta?gios iniciais do desenvolvimento, e que
o modelo, inicialmente ass??ncrono, seja refinando para adiciona-los durante o desenvol-
vimento. Na?o consideramos em nosso trabalho aspectos temporais, assincronismo, ou
mesmo refinamentos. Apesar disto, o refinamento comportamental de interfaces propo?e
que o comportamento observado do componente na?o deve ser alterado, sendo semelhante
a algumas de nossas leis que lidam com a visa?o estrutural do modelo, sem alterar seu
comportamento, como leis para a conexa?o (Lei 4.8), substituic?a?o (Lei 4.9) e decomposic?a?o
(Lei 4.20) de ca?psulas (ver Cap??tulo 4).

Em [25], o principio da localidade e? explorado, formalizando a evoluc?a?o de modelos
atrave?s de leis ba?sicas de transformac?a?o; este trabalho tambe?m analisa o efeito destas
transformac?o?es na consiste?ncia de algumas propriedades do modelo, como deadlock e
compatibilidade de interface. Nenhum destes trabalhos, todavia, apresenta a aplicac?a?o
das leis de uma maneira sistema?tica, com fizemos aqui. Apesar de algumas leis serem
introduzidas (como, por exemplo, a introduc?a?o de uma ca?psula, porta ou conexa?o), ne-
nhum padra?o para os termos a? esquerda e a? direita da lei, nem tampouco as condic?o?es



6.2 trabalhos futuros 79

expl??citas para suas aplicac?o?es, sa?o apresentados. Em [63], uma u?nica lei para a delegac?a?o
de responsabilidades de uma ca?psula a subca?psulas e? apresentada, tal qual a Lei 4.20. A
diferenc?a existente entre as duas e? que a lei proposta em [63] considera a possibilidade
de uma das partic?o?es da ca?psula na?o ser movida para uma nova subca?psula, sendo este
apenas um dos passos da derivac?a?o da Lei 4.20 (ver Sec?a?o 4.2).

Sob um determinado ponto de vista, propomos leis alge?bricas que descrevem propri-
edades ba?sicas sobre os elementos que UML-RT adiciona a UML, de forma semelhante
a outras leis alge?bricas para alguns paradigmas da programac?a?o, como, por exemplo, o
orientado a objetos [9], o imperativa [46] e o concorrente [80], ou a linguagens de modela-
gem como Alloy [37]. Apesar de UML-RT possuir algumas caracter??sticas encontradas em
alguns deste paradigmas, nossa noc?a?o de equivale?ncia na?o pode ser baseada diretamente
em nenhum deles, e por esta raza?o utilizamos em nossas leis uma noc?a?o de equivale?ncia
baseada na sema?ntica de OhCircus, que por sua vez e? baseada na UTP. Nossa estrate?gia
de reduc?a?o a uma forma normal tambe?m e? similar a alguns destes trabalhos [9].

No contexto do desenvolvimento utilizando Model Driven Architecture (MDA) [65],
nossas leis sa?o classificadas como leis horizontais, por na?o alterarem o n??vel de abstrac?a?o
do modelo quanto a sua plataforma. Ale?m disto, os modelos utilizados por no?s encontram-
se em um n??vel intermedia?rio de abstrac?a?o da plataforma, por incorporarem uma visa?o
pro?xima da implementac?a?o; nossos modelos utilizam uma linguagem para a descric?a?o de
ac?o?es no diagrama de estados e lidam com associac?o?es como atributos. Apesar disto, o
modelo possui ainda assim um grande n??vel de abstrac?a?o e pode ser mapeado para diversas
plataformas espec??ficas, que descrevam, por exemplo, a tecnologia de comunicac?a?o das
ca?psulas e a representac?a?o destas na linguagem destino. Ale?m disso, nosso mapeamento
para OhCircus pode ser visto como uma transformac?a?o para um modelo transversal
com o intuito de verificar e validar propriedades do modelo. Nossas leis ainda podem
ser aplicadas em um processo de desenvolvimento tradicional, como o RUP, que utilize
UML-RT [5, 42, 1].

6.2 TRABALHOS FUTUROS

Apesar de termos proposto um conjunto abrangente de leis ba?sicas, e discutido sua
abrange?ncia atrave?s de uma estrate?gia de reduc?a?o a uma forma normal, a completude
deste conjunto na?o foi provada formalmente. As leis cobrem os principais passos da
estrate?gia, mas leis adicionais (principalmente referente a transformac?o?es de diagrama de
estados) sa?o necessa?rias.

Ale?m disto, derivac?o?es de novas leis de maior granularidade podem ser necessa?rias
para facilitar as tarefas realizadas pelo desenvolvedor durante a modelagem de sistemas.
Tais leis devem ser encontradas a partir da ana?lise de um conjunto amplo de estudos de
caso e padro?es de projeto para UML-RT. Ale?m disto, estudos sobre a incorporac?a?o de
modelos e transformac?o?es de modelos em processos de desenvolvimento [60, 51, 2] ainda
se encontram em um estado bastante incipiente. Maiores estudos nesta a?rea podera?o
revelar novas aplicac?o?es de transformac?a?o de modelos, e , consequ?entemente, a definic?a?o
de novas leis derivadas a partir das leis ba?sicas de transformac?a?o.

Outro trabalho futuro e? expandir o escopo de nossas leis para lidar com caracter??sticas



6.2 trabalhos futuros 80

encontradas comumente em linguagens orientadas a objetos, como a heranc?a de classes
e ca?psulas, e introduzir sema?ntica de refere?ncia para classes. Para isto, ale?m de neces-
sitarmos atribuir uma sema?ntica para heranc?a comportamental de ca?psulas, ainda na?o
bem definida, precisar??amos formalizar tais caracter??sticas de orientac?a?o a objetos na
sema?ntica para OhCircus, que ainda esta? em processo de definic?a?o. Outro campo de
estudo que merece especial interesse e? o desenvolvimento orientado a? agentes, onde se
verifica uma grande semelhanc?a entre o conceito de ca?psulas e agentes. Um exemplo de
uma metodologia que utiliza UML-RT para modelar agentes e? encontrado em [14].

Observamos, tambe?m, a necessidade de verificar a relac?a?o entre nossas leis de mo-
delagem e leis de programac?a?o, especialmente em linguagens de programac?a?o que lidam
com objetos ativos, como JCSP [97]. Isto possibilita o desenvolvimento rigoroso em
UML-RT lidar com tre?s n??veis distintos de abstrac?a?o do sistema, utilizando modelos em
UML-RT, especificac?o?es em OhCircus e implementac?o?es em JCSP, baseado em trabalhos
que mostram o mapeamento entre estas linguagens [72, 74]. Este desenvolvimento seria
semelhante a? abordagem em [66], que mapeia UML-RT em Java e CSP-OZ, pore?m intro-
duzindo leis de transformac?a?o como parte essencial de seu processo. Adicionalmente, a
mecanizac?a?o destas leis de transformac?a?o facilitariam sua utilizac?a?o pra?tica e automac?a?o
de tarefas de modelagem.

Por fim, acreditamos que as contribuic?o?es deste trabalho podem ser incorporadas no
desenvolvimento baseado em componentes ativos em UML 2.0, que traz va?rios dos con-
ceitos de UML-RT em sua definic?a?o, contribuindo, assim, para a integrac?a?o de me?todos
formais com uma linguagem de modelagem padronizada e amplamente utilizada pela
comunidade.

Desta maneira, uma prova?vel lista de trabalhos futuros inclui:

• Prova formal de todo o conjunto de leis ba?sicas;

• Formalizac?a?o da estrate?gia de reduc?a?o do conjunto de leis ba?sicas;

• Emprego de novos estudos de casos, e a derivac?a?o de padro?es de projeto para UML-
RT;

• Estudo do relacionamento de leis de transformac?a?o de modelos em UML-RT e leis
para linguagens de programac?a?o;

• Estudo da integrac?a?o de leis de transformac?a?o em processos de desenvolvimento
rigorosos, que incorporem linguagens formais, de modelagem e de implementac?a?o;

• Mecanizac?a?o das leis de transformac?a?o de modelos;

• Incorporac?a?o das contribuic?o?es deste trabalho a com outras linguagens de modela-
gem, como UML 2.0 e Linguagens de Descric?a?o de Arquitetura.



APE?NDICE A

SINTAXE COMPLETA DE OHCIRCUS

Program ::= OhCircusParagraph?

OhCircusParagraph ::= Paragraph
| ChannelDefinition | ChanSetDefinition
| OhProcessDefinition | ClassDefinition

ChannelDefinition ::= channel CDeclaration
CDeclaration ::= SimpleCDeclaration | SimpleCDeclaration; CDeclaration
SimpleCDeclaration ::= N+ | N+ : Expression | Schema?Exp
ChanSetDefinition ::= chanset N == CSExpression
CSExpression ::= {||} | {| N+ |} | N

| CSExpression ? CSExpression | CSExpression ? CSExpression
| CSExpression \ CSExpression

OhProcessDefinition ::= process N =? [extends N] Process
Process ::= begin PParagraph?

[stateSchema?Exp]
PParagraph?

[• Action]
end

| CompProcess
CompProcess ::= N | Proc; Process | Process \ CSExpression

| Process 2 Process | Process u Process | Process ||| Process
| Process |[ CSExpression ]| Process | Process[N+ := N+]
| Declaration ? Process | ; Declaration ? Process
| 2 Declaration ? Process |u Declaration ? Process
| ||| Declaration ? Process | Declaration ? ProcessbExp+c
| ? Declaration |[ CSExpression ]|?Process
| Declaration • Process | ; Declaration • Process
| 2 Declaration • Process |u Declaration • Process
| ||| Declaration • Process | Declaration • Process(Exp+)
| ? Declaration |[ CSExpression]| • Process

PParagraph ::= Paragraph | N =? ParAction | nameset N == NSExp
NSExp ::= {} | N+ | N | NSExp ? NSExp | NSExp ? NSExp

| NSExp \ NSExp
ParAction ::= Declaration • Action | Action
Action ::= Schema?Exp | CSPActionExp | Command | N

81



sintaxe completa de ohcircus 82

CSPActionExp ::= Skip | Stop | Chaos
| Communication ? Action | Predicate &amp;amp; Action
| Action; Action | Action 2 Action | Action u Action
| Action |[ NSExp | CSExpression | NSExp ]| Action
| Action ||[NSExp | NSExp]|| Action | ; Declaration • Action |
| Action \ CSExpression | µ N • Action | ParAction(Exp+)
| 2 Declaration • Action |u Declaration • Action
| ? Declaration |[ NSExp | CSExpression | NSExp]| • Action
| ||| Declaration ||[NSExp | NSExp]||• Action

Communication ::= NCParameter?

CParameter ::= ?N |?N : Predicate |!Expression | .Expression
ClassDefinition ::= class N =? [extends N]begin CParagraph?

[state StateSchema] CParagraph?

[initial Schema?Exp] CParagraph?
end

CParagraph ::= Paragraph | Qualifier N =? ParametrisedCommand
Qualifier ::= public | protected | private | logical
ParametrisedCommand ::= Schema?Exp | Command

| ParameterDeclaration • Command
ParameterDeclaration ::= ParameterQualifier Declaration

| ParameterQualifier Declaration; ParameterDeclaration
ParameterQualifier ::= val | res
Command ::= N+ : [Pred, Pred] | N+ := Expression+ | µ N • Command

| var Declaration • Command | super.N(OhExpression?)
| OhExpression.N(OhExpression?)
| Command; Command | if GuardedCommands fi

GuardedCommands ::= Predicate ? Command
| Predicate ? Command 2 GuardedCommands

OhExpression ::= Expression
| this | null | new N[(OhExpression+)]
| OhExpression.N | OhExpression : N(OhExpression?)
| super.N | super.N(OhExpression?)
| OhExpression instanceof N | (N)OhExpression



APE?NDICE B

LEIS DE CSP

Devido a Circusutilizar a mesma sema?ntica de va?rios operadores de CSP [79], leis ba?sicas
de CSP sobre estes operadores sa?o tambe?m leis de Circus.

Uma destas leis e? a distribuic?a?o de renaming atrave?s da composic?a?o paralela (Lei B.1).
Referenciada tambe?m como f [.]?|[X ]|?dist.

Lei B.1 (Distribuic?a?o paralela de renaming)

f [P |[ X ]| Q] = (f [P ] |[ f [X ]|]f [Q])

Somente se: f e? uma func?a?o injetiva. 2

A lei a seguir mostra a distribuic?a?o de hiding atrave?s da composic?a?o paralela (Lei B.2).
Referenciada tambe?m como hide |[ X ]|?dist.

Lei B.2 (Distribuic?a?o paralela de hiding)

(P |[ X ]| Q) \ Z = (P \ Z ) |[ (X ]| (Q \ Z )

Somente se: X ? Z = {} 2

A pro?xima lei mostra a simetria de renaming sobre o operador de hiding (Lei B.3).
Referenciada tambe?m como f [.]?hide?sym.

Lei B.3 (Simetria de renaming sobre hiding)

f [P \ X ] = f [P ] \ f [Z ]

Somente se: X ? Z = {} , e f e? uma func?a?o injetiva. 2

Outras duas leis expressa?o a associatividade (Lei B.4) e simetria (Lei B.5) da com-
posic?a?o paralela. Referenciada tambe?m como |[X ]|?assoc e |[X ]|?sym.

Lei B.4 (Associatividade do paralelismo)

P |[ X ]| (Q |[ X ]| R) = (P |[ X ]| Q) |[ X ]| R

Lei B.5 (Simetria do paralelismo)

P |[ X ]| Q = Q |[ X ]| P

Utilizaremos os fato que o operador de paralelismo somente e? idepotente sob deter-
minadas condic?o?es. Referenciada este fato como a Lei |[X ]|?idem.

83



leis de csp 84

Lei B.6 (Indepote?ncia do operador de paralelismo)

P = P |[ ?P ]| P

Somente se: P e? um processo determin??stico. 2

Tambe?m utilizaremos o fato que canais na?o utilizados no sincronismo de um operador
de paralelismo sa?o redundantes. |[cs ]|?null .

Lei B.7 (Restric?a?o de canais)

P |[ ?P ? ?Q ? cs ]| Q = P |[ ?P ? ?Q ]| Q



APE?NDICE C

LEIS DE TRANSFORMAC?A?O PARA UML-RT
ADICIONAIS

Semelhante a? Lei 4.1, a pro?xima lei estabelece quando e? poss??vel introduzir um novo
protocolo ao modelo.

Lei C.1 Declarar Protocolo

Condic?o?es:

(?) ClsM na?o possui a declarac?a?o de nenhum elemento, no mesmo pacote, chamado X.
(?) Nenhuma elemento em ClsM tem uma relac?a?o com o protocolo X.

Similarmente a? Lei 4.1, para se remover um protocolo X e? necessa?rio que nenhum outro
elemento o utilize, seja em associac?o?es, que criam como consequ?e?ncia portas de tipo X,
ou em generalizac?o?es. Assim, uma porta com tipo X na?o pode ser usada em um diagrama
de estado ou estrutura e, portanto, a apresentac?a?o destes diagramas e? irrelevante (pela
mesma raza?o que a Lei 4.1).

Assumimos que incomes e outgoings representam, respectivamente, os conjuntos de
sinais de entrada e de sa??da do protocolo.

Semelhante a outros trabalhos que lidam com leis para classes em UML [38], A
pro?xima lei estabelece quando e? poss??vel introduzir uma nova classe ao modelo.

Lei C.2 Declarar Classe

Condic?o?es:

(?) ClsM na?o possui a declarac?a?o de nenhum elemento, no mesmo pacote, chamado A.
(?) Nenhuma elemento em ClsM tem uma relac?a?o com a classe A.

85



leis de transformac?a?o para uml-rt adicionais 86

Similarmente a? Lei 4.1, para se remover uma classe A e? necessa?rio que nenhum outro
elemento a utilize, atrave?s de associac?o?es ou em generalizac?o?es em ClsM. A adic?a?o de uma
classe implica ClsM que esta podera? ser utilizada por outras classes ou ca?psulas do modelo,
que devem estar obrigatoriamente declaradas em ClsM, como a lei impo?e condic?o?es que a
classe A na?o e? utilizada por outros elementos do modelo, a apresentac?a?o de outras viso?es
M sa?o irrelevante.

A pro?xima lei estabelece quando e? permitido renomear uma ca?psula.

Lei C.3 Renomear Ca?psula

Condic?o?es:
(?) ClsM na?o possui a declarac?a?o de nenhum elemento, no mesmo pacote, chamado B.
(?) ClsM na?o possui a declarac?a?o de nenhum elemento, no mesmo pacote, chamado A.

Como consequ?e?ncia da renomeac?a?o de uma ca?psula A para B, na Lei C.3, todas as
insta?ncias de A em StrM passariam a ter o tipo B; analogamente, na aplicac?a?o da direita
para a esquerda, todas as insta?ncias de B passariam a ter o tipo A. Apesar de sua
simplicidade, esta lei e? importante quando desejamos substituir uma ca?psula no sistema
por outra de mesmo nome; ate? que a ca?psula original seja removida do modelo, as duas
ca?psulas sa?o declaradas no modelo com nomes distintos. Apo?s a substituic?a?o e remoc?a?o
da ca?psula original, a nova ca?psula e? renomeada.

A pro?xima lei estabelece quando e? permitido adicionar ou remover sinais de entrada
em um protocolo.

Lei C.4 Introduzir Sinal de Entrada

Condic?o?es:
(?) Na?o existe nenhum sinal chamado s no protocolo X.
(?) Nenhum diagrama de estados em StaM usa o sinal s.

A Lei C.4 e? ana?loga a? Lei 4.6, diferenciando-se apenas em relac?a?o a? direc?a?o do sinal
inserido. Semelhante a? Lei 4.6, a Lei C.4 possui uma restric?a?o quanto ao uso do nome do
novo elemento (sinal) em seu contexto local (protocolo) e quanto ao uso deste elemento
nos diagramas de estado do modelo.

A pro?xima lei expressa como a associac?a?o entre duas ca?psulas pode ser movida para
outra ca?psula que na?o possui subca?psulas.



leis de transformac?a?o para uml-rt adicionais 87

Lei C.5 Encapsular Ca?psula 2

Condic?o?es:

(?) Nenhum nome de porta em cps? coincide com um nome em csp; Em todo contexto em StrM
onde existir uma insta?ncia de C, a porta t? estara? conectada a? porta t de uma insta?ncia
de B.

(?) O protocolo T e todos protocolos associados a?s portas em bps e aps? possuem uma ma?quina
de estados determin??stica.

Esta lei e? ana?loga a? Lei 4.12, diferenciando-se apenas a? estrutura encontrada na
ca?psula C. No lado direito da Lei 4.12, como consequ?e?ncia da mudanc?a da associac?a?o b
de A para C, a insta?ncia b e? transferida para o diagrama de estrutura de C. Assim, a
insta?ncia b passa a fazer parte da estrutura interna de C e a necessitar de um conjunto
de portas cps? em c para ter acesso ao mundo externo; todas as conexo?es que existiam
em bps passam a se conectar a? cps?.

A pro?xima lei expressa como a associac?a?o entre duas ca?psulas pode ser movida para
outra ca?psula que na?o possui portas.



leis de transformac?a?o para uml-rt adicionais 88

Lei C.6 Encapsular Ca?psula 3

Condic?o?es:

(?) Todos protocolos associados as portas em bps e aps? possuem uma ma?quina de estados
determin??stica.

Esta lei e? ana?loga a? Lei C.5, diferenciando-se apenas por C na?o possuir nenhuma porta
associada. No lado direito da Lei 4.12, como consequ?e?ncia da mudanc?a da associac?a?o b
de A para C, a insta?ncia b e? transferida para o diagrama de estrutura de C. Assim, a
insta?ncia b passa a fazer parte da estrutura interna de C e a necessitar de um conjunto
de portas cps? em c para ter acesso ao mundo externo; todas as conexo?es que existiam
em bps passam a se conectar a? cps?.

A lei a seguir decompo?e uma ca?psula A no paralelismo de insta?ncias de ca?psulas (B e
C) que na?o se comunicam entre si.



leis de transformac?a?o para uml-rt adicionais 89

Lei C.7 Decomposic?a?o Paralela Simples de uma Ca?psula

Condic?o?es:

(?) ?batts, binv, bmeths, bps, Sb? e ?catts, cinv, cmeths, cps, Sc? particionam A; os protocolo as-
sociados a?s portas em bps e cps possuem uma ma?quina de estados determin??stica.

Analogamente a? 4.20, a Lei C.7 requer que a ca?psula A seja particionada, onde cada
partic?a?o deve ser auto-contida e fazer uso somente acesso aos atributos e aos me?todos da
partic?a?o. Ale?m disto, as u?nicas portas utilizadas em uma partic?a?o sa?o aquelas que ela
conte?m.

Semelhante a? Lei 4.20, esta lei possui o propo?sito de diminuir sua complexidade da
ca?psula A (lado esquerdo da lei), pore?m na?o possui como condic?a?o que as partes decom-
postas (que da?o origem a?s ca?psulas B e C, no lado direito da lei) comuniquem-se entre
si.

O efeito da decomposic?a?o e? criar duas novas ca?psulas componentes, b e c, uma para
cada partic?a?o, e redimensionar a ca?psula original A para agir como um mediador. Em
geral, o novo comportamento de A ira? depender da forma particular da decomposic?a?o. A
Lei C.7 captura uma decomposic?a?o paralela. No lado direito da lei, A na?o tem nenhuma
ma?quina de estados. Ele delega completamente seu comportamento original para B e C
atrave?s de conexo?es com componentes destes tipos no diagrama de estrutura.

A justificativa da Lei 4.20 a partir das leis ba?sicas pode ser feita a partir de uma
simplificac?a?o da demonstrac?a?o da Lei 4.20, mudando-se apenas a aplicac?a?o das leis ne-
cessa?rias para desencapsular as insta?ncias de ca?psulas b e c do diagrama de estrutura de
A (no lado esquerdo da lei, utilizando-se para este fato apenas a Lei C.6 que indica que
as insta?ncias desencapsuladas na?o se comunicam com nenhuma outra subca?psula de A.



REFERE?NCIAS BIBLIOGRA?FICAS

[1] Designing for Concurrency. Technical Report 084-0698, ObjecTime Limited. Ob-
jecTime, 1998.

[2] M. Alanen, J. Lilius, I. Porres, and D. Truscan. Realizing a model driven engineering
process. Technical Report 565, TUCS, Nov 2003.

[3] R. Allen. A Formal Approach to Software Architecture. PhD thesis, School of
Computer Science, Carnegie Mellon University, Pittsburgh, USA, May 1997. Issued
as CMU Technical Report CMU-CS-97-144.

[4] N. Amalio and F. Polack. Comparison of formalisation approaches of UML class
constructs in Z and Object-Z. In Third International Conference of B and Z, volume
2651 of LNCS, pages 339–358, June 2003.

[5] M. Antonsson and P. Hansson. Modeling of Real-Time Systems in UML with
Rational Rose and Rose Real-Time based on RUP. Master’s thesis, Chalmers
University of Technology, Gothenburg, Sweden, April 2001. Honorary mention in
the 2001 SNART Best Master’s Thesis Award.

[6] L. Bass, P. Clements, and R. Kazman. Software Architecture in Practice. Addison-
Wesley Longman, Reading, MA, 1998.

[7] K. Berkenko?tter. Using UML 2.0 in Real-Time Development. A Critical Review.
In International Workshop on Specification and Validation of UML models for Real
Time and Embedded Systems (SVERTS), 2003. Workshop hold in conjunction with
UML 2003.

[8] V. D. Bianco, L. Lavazza, M. Mauri, and G. Occorso. Towards uml-based formal
specifications of component-based real-time software. In M. Pezze?, editor, 6th Inter-
national Conference on Fundamental Approaches to Software Engineering, Lecture
Notes in Computer Science, pages 118–134, Warsaw, Poland, April 2003. Springer.

[9] P. Borba, A. Sampaio, A. Cavalcanti, and M. Corne?lio. Algebraic reasoning for
object-oriented programming. Science of Computer Programming, 52:53–100, 2004.

[10] R. Borges, A. Mota, and A. Sampaio. Integrando uml e me?todos formais. Technical
report, Universidade Federal de Pernambuco, Recife, Brasil, 2004.

[11] F. P. Brooks, Jr. The Mythical Man-Month. Addison Wesley, anniversary edition,
1995.

90



REFERE?NCIAS BIBLIOGRA?FICAS 91

[12] J.-M. Bruel, R. France, and M. Larrondo-Petrie. An integrated object-oriented and
formal modeling environment. Journal of Object-Oriented Programming, 10(7):25–
34, 1997.

[13] J. Buxton and B. Randell, editors. Software Engineering Techniques: Report on a
Conference sponsored by the NATO Science Committee, Rome, Italy, October 1969.
Brussels: NATO Scientific Affairs Division, April 1970.

[14] J. M. C. Silva, J. Castro. Detailing architectural design in the tropos methodology.
In Second International SofTware Requirements to Architectures Workshop, pages
85–93, 2003.

[15] A. Cavalcanti, A. Sampaio, and J. Woodcock. Refinement of Actions in Circus. In
Proceedings of REFINE’2002, Electronic Notes in Theoretical Computer Science,
2002. Invited Paper.

[16] A. Cavalcanti, A. Sampaio, and J. Woodcock. A unified language of classes and
processes. In St Eve: State-Oriented vs. Event-Oriented Thinking in Requirements
Analysis, Formal Specification and Software Engineering, Satellite Workshop at
FM’03, 2003.

[17] A. Cavalcanti, A. Sampaio, and J. Woodcock. A refinement strategy for circus.
Formal Asp. Comput., 15(2-3):146–181, 2003.

[18] S. Cheng and D. Garlan. Mapping Architectural Concepts to UML-RT. In Pro-
ceedings of the International Conference on Parallel and Distributed Processing
Techniques and Application (PDPTA’2001), Las Vegas, Nevada, USA, 2001.

[19] I. Corporation. Rational rose technical developer, 2004. Available at: http://www-
306.ibm.com/software/awdtools/developer/technical. Includes IBM Rational Rose
RealTime.

[20] I. Crnkovic. Component-based software engineering - new challenges in software
development. Software Focus, 2(4):127–133, 2001.

[21] E. W. Dijkstra and C. S. Scholten. Predicate calculus and program semantics.
Springer-Verlag New York, Inc., 1990.

[22] D. Dori. Why significant uml change is unlikely. Communications of the ACM,
45(11):82–85, 2002.

[23] D. D’Souza and A. Wills. Objects, components, and frameworks with UML: the
catalysis approach. Addison-Wesley Longman Publishing Co., Inc., 1999.

[24] G. Engels, R. Heckel, and J. Ku?ster. Rule-based specification of behavioral con-
sistency based on the uml meta-model. In 4th International Conference on The
Unified Modeling Language, Modeling Languages, Concepts, and Tools, pages 272–
286, London, UK, 2001. Springer-Verlag.



REFERE?NCIAS BIBLIOGRA?FICAS 92

[25] G. Engels, R. Heckel, J. Ku?ster, and L. Groenewegen. Consistency-Preserving
Model Evolution through Transformations. In 5th International Conference on the
Unified Modeling Language, volume 2460 of LNCS, pages 212–226. Springer, 2002.

[26] G. Engels, R. Heckel, J. M. Ku?ster, and L. Groenewegen. Consistency-Preserving
Model Evolution through Transformations. In J.-M. Je?ze?quel, H. Hussmann, and
S. Cook, editors, UML 2002 - The Unified Modeling Language. 5th International
Conference, volume 2460 of LNCS, pages 212–226, Dresden, Germany, October
2002. Springer.

[27] G. Engels, J. M. Ku?ster, R. Heckel, and L. Groenewegen. A methodology for
specifying and analyzing consistency of object-oriented behavioral models. In 8th
European Software Engineering Conference, pages 186–195. ACM Press, 2001.

[28] A. Evans. Reasoning with UML Class Diagrams. In 2nd IEEE Workshop on
Industrial Strength Formal Specification Techniques. IEEE Computer Society, 1998.

[29] A. Evans, R. France, and E. Grant. Towards formal reasoning with uml models. In
OOPSLA’99 Workshop on Behavioral Semantics, 1999.

[30] A. Evans, R. France, K. Lano, and B. Rumpe. The UML as a Formal Modeling No-
tation. In First International Workshop on the Unified Modeling Language, LNCS.
Springer, 1999.

[31] C. Fischer. Combination and Implementation of Processes and Data: from CSP-OZ
to Java. PhD thesis, Fachbereich Informatik Universita?t Oldenburg, 2000.

[32] C. Fischer, E.-R. Olderog, and H. Wehrheim. A CSP View on UML-RT Structure
Diagrams. In Proceedings of the 4th International Conference on Fundamental
Approaches to Software Engineering, pages 91–108. Springer, 2001.

[33] M. Fowler. Refactoring-Improving the design of existing code. Addison Wesley,
1999.

[34] H. Frank and J. Eder. Equivalence transformations on statecharts. In 12th Interna-
tional Conference on Software Engineering and Knowledge Engineering, Chicago,
July 2000. Knowledge System Institute.

[35] D. Garlan, S.-W. Cheng, and A. J. Kompanek. Reconciling the needs of architectu-
ral description with object-modeling notations. Science of Computer Programming,
44(1):23–49, 2002.

[36] D. Garlan, R. Monroe, and D. Wile. ACME: Architecture Description of Composed-
Based Systems. In G. T. Leavens and M. Sitaraman, editors, Foundations of
Component-Based Systems, pages 47–68. Cambridge University Press, 2000.

[37] R. Gheyi. Basic laws of object modeling. Master’s thesis, Informatics Center,
Federal Universisty of Pernambuco, Recife, Brazil, February 2004.



REFERE?NCIAS BIBLIOGRA?FICAS 93

[38] R. Gheyi and P. Borba. Refactoring Alloy Specifications. In 6t h Brazilian Workshop
on Formal Methods, volume 95 of ENTCS, pages 227–243. Elsevier Science, May
2004.

[39] W. Gibbs. Software’s Chronic Crisis. Scientific American, 271(3):86–95, September
1994.

[40] U. Gla?sser, R. Gotzhein, and A. Prinz. The formal semantics of SDL-2000: status
and perspectives. Computer Networks: The International Journal of Computer and
Telecommunications Networking, 42(3):343–358, 2003.

[41] M. Gogolla and M. Richters. Transformation Rules for UML Class Diagrams. In
First International Workshop on the Unified Modeling Language (UML)’98, LNCS,
pages 92–106. Springer, 1999.

[42] G. Gullekson. Designing for Concurrency and Distribution with Rational Rose
RealTime. Technical Report TP-1864/00, Rational Software Corporation, 2000.
Rational Software White Paper.

[43] D. Harel. Statecharts: A Visual Formalism for Complex Systems. Science of
Computer Programming, 8:231–274, 1987.

[44] D. Harel and B. Rumpe. Modeling languages: Syntax, semantics and all that stuff,
part i: The basic stuff. Technical Report MSC00-16, 2000.

[45] C. A. R. Hoare. Programming: Sorcery or science? IEEE Software, 1(2):5–16,
1984.

[46] C. A. R. Hoare, I. J. Hayes, H. Jifeng, C. C. Morgan, A. W. Roscoe, J. W. Sanders,
I. H. Sorensen, J. M. Spivey, and B. A. Sufrin. Laws of programming. Communi-
cations of the ACM, 30(8):672–686, 1987.

[47] C. A. R. Hoare and H. Jifeng. Unifying Theories of Programming. Prentice-Hall,
1998.

[48] J. Ivers, P. Clements, D. Garlan, R. Nord, B. Schmerl, and J. Silva. Documenting
Component and Connector Views with UML 2.0. Technical Report CMU/SEI-
2004-TR-008, Carnegie Mellon, Software Engineering Institute, 2004.

[49] D. Jackson. A Comparison of Object Modelling Notations: Alloy, UML and Z.
Technical report, MIT. Lab for Computer Science, August 1999.

[50] D. Jackson. Micromodels of Software: Lightweight Modelling and Analysis with
Alloy. Technical report, Software Design Group. MIT Lab for Computer Science,
2002.

[51] S. Kent. Model Driven Engineering. In Proceedings of IFM’02, volume 2335 of
LNCS, pages 286–298. Springer-Verlag, 2002.



REFERE?NCIAS BIBLIOGRA?FICAS 94

[52] P. Kruchten. The Rational Unified Process: An Introduction. Addison-Wesley, 2
edition, 2000.

[53] I. Kru?ger, W. Prenninger, and R. Sandner. Development of an Autonomous Trans-
port System using UML-RT. Technical Report TUM-I0215, Technische Universita?t,
Mu?nchen, 2002.

[54] I. H. Kru?ger. Towards Precise Service Specification with UML and UML-RT. In
J. Ju?rjens, M. V. Cengarle, E. B. Fernandez, B. Rumpe, and R. Sandner, editors,
Critical Systems Development with UML – Proceedings of the UML’02 workshop,
pages 19–34. Technische Universita?t Mu?nchen, Institut fu?r Informatik, 2002.

[55] K. Lano and J. Bicarregui. Semantics and Transformations for UML Models. In
First International Workshop on the Unified Modeling Language, volume 1618 of
LNCS, pages 107–119. Springer, June 1999.

[56] R. G. Lavender and D. C. Schmidt. Active object: an object behavioral pattern
for concurrent programming. pages 483–499, 1996.

[57] M. M. Lehman. Laws of software evolution revisited. In C. Montangero, editor, 5th
European Workshop on Software Process Technology, volume 1149 of LNCS, pages
108–124, Nancy, France, October 1996. Springer.

[58] J. Liu, J. S. Dong, B. Mohany, and K. Shi. Linking uml with integrated formal tech-
niques. In Unified Modeling Language: Systems Analysis, Design, and Development
Issues. IDEA GROUP Publishing, 2000.

[59] D. C. Luckham and J. Vera. An event-based architecture definition language. IEEE
Transactions on Software Engineering, 21(9):717–734, 1995.

[60] J. Ludewig. Models in software engineering. Software and System Modeling, 2(1):5–
14, 2003.

[61] J. Magee and J. Kramer. Dynamic structures in software architecture. In Fourth
Symposium on the Foundations of Software Engineering, pages 3–14, New York,
NY, USA, 1996. ACM Press.

[62] M. S. Mahoney. The roots of software engineering. CWI Quarterly, 3(4):325–334,
February 1990.

[63] T. McClean, F. Bordelau, and J.-P. Corriveau. Scenario-Driven Refactoring in
UML-RT. In 2nd International Workshop on Scenarios and State Machines: Mo-
dels, Algorithms, and Tools, Portland, Oregon, USA, May 2003. Held at the Inter-
national Conference on Software Engineering 2003 - ICSE’03.

[64] N. Medvidovic and R. N. Taylor. A classification and comparison framework for
software architecture description languages. IEEE Trans. Softw. Eng., 26(1):70–93,
2000.



REFERE?NCIAS BIBLIOGRA?FICAS 95

[65] J. Miller and J. Mukerji. MDA Guide Version 1.0.1. Object Management Group,
2003. OMG document omg/03-06-01.

[66] M. Mo?ller, E.-R. Olderog, H. Rasch, and H. Wehrheim. Linking csp-oz with uml
and java: A case study. In E. A. Boiten, J. Derrick, and G. Smith, editors, 4th
International Conference on Integrated Formal Methods, volume 2999 of LNCS,
pages 267–286. Springer, 2004.

[67] C. Morgan. Programming from Specifications. Prentice Hall, second edition, 1994.

[68] C. Morgan and P. H. B. Gardiner. Data refinement by calculation. Acta Inf.,
27(6):481–503, 1989.

[69] M. Y. Ng and M. J. Butler. Towards formalizing uml state diagrams in csp. In
1st International Conference on Software Engineering and Formal Methods, pages
138–147. IEEE Computer Society, September 2003.

[70] Object Management Group. OMG Unified Modeling Language Specification, 2003.
OMG document formal/03-03-01.

[71] Object Management Group, Inc. The OMG’s Home page, 2005. Avaliable at:
http://www.omg.org/.

[72] M. Oliveira and A. Cavalcanti. From Circus to JCSP. In 6th International Con-
ference on Formal Engineering Methods, volume 3308 of LNCS, pages 320–340.
Springer, 2004.

[73] R. Prieto-Diaz and J. M. Neighbors. Module interconnection languages. Journal
of Systems and Software, 6(4):307–334, 1986.

[74] R. Ramos, A. Sampaio, and A. Mota. A semantics for uml-rt active classes via
mapping into circus. In To Apear in 7th IFIP international Conference on Formal
Methods for Open Object-Based Distributed Systems, LNCS, Athens, Greece, June
2005. University of Athens, Springer.

[75] H. Rasch. Translating a subset of uml state machines into csp. Technical report,
Universita?t Freiburg, May 2002. Mobi-J Meeting.

[76] J. E. Robbins, N. Medvidovic, D. F. Redmiles, and D. S. Rosenblum. Integrating
architecture description languages with a standard design method. In Proceedings
of the 20th international conference on Software engineering, pages 209–218. IEEE
Computer Society, 1998.

[77] D. B. Roberts. Practical Analysis for Refactoring. PhD thesis, University of Illinois
at Urbana Champaign, 1999.

[78] D. Roe, K. Broda, and A. Russo. Mapping uml models incorporating ocl constraints
into object-z. Technical Report 2003/9, Imperial College London, 2003.



REFERE?NCIAS BIBLIOGRA?FICAS 96

[79] A. W. Roscoe. The Theory and Practice of Concurrency. Prentice-Hall, 1998.

[80] A. W. Roscoe and C. A. R. Hoare. The laws of occam programming. Theor.
Comput. Sci., 60(2):177–229, 1988.

[81] J. Rumbaugh, I. Jacobson, and G. Booch. The Unified Modeling Language Reference
Manual. Addison-Wesley, Reading, Mass., 1999.

[82] B. Rumpe, M. Schoenmakers, A. Radermacher, and A. Schrr. UML + ROOM as a
Standard ADL? In F. Titsworth, editor, Proceedings of the 5th International Con-
ference on Engineering of Complex Computer Systems, page 43. IEEE Computer
Society, 1999.

[83] A. Sampaio, A. Mota, and R. Ramos. Class and Capsule Refinement in UML for
Real Time. In Proceedings of the Brazilian Workshop on Formal Methods, volume 95
of ENTCS, pages 23–51, 2004.

[84] A. Sampaio, J. Woodcock, and A. Cavalcanti. Refinement in Circus. In Internati-
onal Symposium of Formal Methods Europe, volume 2391 of LNCS, pages 451–470.
Springer, 2002.

[85] R. Sandner. Developing Distributed Systems Step by Step with UML-RT. In
Workshop Visuelle Verhaltensmodellierung verteilter und nebenla?ufiger Software-
Systeme. Universita?t Mu?nster, 2000.

[86] B. Selic. An Efficient Object-Oriented Variation of the Statecharts Formalism for
Distributed Real-Time Systems. In 11th IFIP WG10.2 International Conference on
Computer Hardware Description Languages and their Applications, volume A-32 of
IFIP Transactions, pages 335–344, 1993.

[87] B. Selic. The Pragmatics of Model-Driven Development. IEEE Software, 20(5):19–
25, 2003.

[88] B. Selic. Tutorial: An overview of uml 2.0. In 6th International Conference on Soft-
ware Engineering, pages 741–742, Edinburgh, United Kingdom, May 2004. IEEE
Computer Society.

[89] B. Selic, G. Gullekson, and P. T. Ward. Real-time object-oriented modeling. John
Wiley &amp;amp; Sons, Inc., 1994.

[90] B. Selic and J. Rumbaugh. Using UML for Modeling Complex RealTime Systems.
Rational Software Corporation, 1998. available at http://www. rational.com.

[91] M. Shaw and D. Garlan. Software Architecture - Perspectives on an Emerging
Discipline. Softwaretechnik-Trends, 20(2), 2000.

[92] A. J. H. Simons. On the compositional properties of uml statechart diagrams. In
Rigorous Object-Oriented Methods, Workshops in Computing, York, UK, January
2000. BCS.



REFERE?NCIAS BIBLIOGRA?FICAS 97

[93] G. Smith. The Object-Z specification language. Kluwer Academic Publishers,
Norwell, MA, USA, 2000.

[94] G. Smith and J. Derrick. Specification, refinement and verification of concurrent
systems - an integration of Object-Z and CSP. Formal Methods in Systems Design,
18:249–284, May 2001.

[95] M. Spivey. The Z Notation: A Reference Manual. Prentice Hall, second edition,
1992.

[96] G. Sunye?, D. Pollet, Y. L. Traon, and J.-M. Je?ze?quel. Refactoring UML Models. In
4th International Conference on the The Unified Modeling Language, volume 2185
of LNCS, pages 134–148. Springer, October 2001.

[97] P. Welch and J. Martin. A CSP Model for Java Multithreading. In P. Nixon and
I. Ritchie, editors, Software Engineering for Parallel and Distributed Systems, pages
114–122. ICSE 2000, IEEE Computer Society Press, June 2000.

[98] G. Winskel. The formal semantics of programming languages: an introduction.
MIT Press, 1993.

[99] J. Woodcock and A. Cavalcanti. Circus: a concurrent refinement language. Te-
chnical Report Oxford OX1 3QD UK, Oxford University Computing Laboratory,
Wolfson Building, Parks Road, July 2001.

[100] J. Woodcock and A. Cavalcanti. The Semantics of Circus. In ZB 2002: Formal
Specification and Development in Z and B, volume 2272 of LNCS, pages 184–203.
Springer, 2002.

[101] L. Zhang, D. Xie, and W. Zou. Viewing use cases as active objects. ACM SIGSOFT
Software Engineering Notes, 26(2):44–48, 2001.




	Acr11E.tmp
	Acr11E.tmp
	Dissertação Mestrado_Desenv Rigoroso com UML-RT.pdf
	Dissertação Mestrado_Desenv Rigoroso com UML-RT.pdf
	Dissertação Mestrado_Rodrigo.pdf
	Capítulo 1---Introdução
	Capítulo 2---Linguagens de Modelagem
	UML 1.x
	ADLs
	ROOM
	Wright
	ACME
	SDL
	ADLs e UML

	UML-RT
	UML 2.0
	Conclusões

	Capítulo 3---Formalização de UML-RT
	OhCircus
	Sintaxe
	Semântica
	Expressões de Processos

	Noções de Refinamento e Equivalência
	Leis para refinamento de Processos

	Mapeamento
	Mapeamento estrutural
	Mapeamento comportamental

	Conclusões

	Capítulo 4---Leis de Transformação para UML-RT
	Leis Básicas
	Leis Derivadas e Refatoramentos
	Formalização das Leis
	Prova da Lei ??
	Prova da Lei ??

	Conclusões

	Capítulo 5---Normalização e Aplicação das Leis
	Estratégia de Normalização
	Estudo de Caso
	Conclusões

	Capítulo 6---Conclusões
	Trabalhos relacionados
	Trabalhos Futuros

	Apêndice A---Sintaxe Completa de Ohcircus
	Apêndice B---Leis de CSP
	Apêndice C---Leis de Transformação para UML-RT Adicionais








</field>
	</doc>
</add>