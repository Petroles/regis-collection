<?xml version="1.0" encoding="utf-8"?>
<add>
	<doc>
		<field name="docid">BR-TU.20280</field>
		<field name="filename">3751_333082.pdf</field>
		<field name="filetype">PDF</field>
		<field name="text">
UNIVERSIDADE FEDERAL DE SANTA CATARINA
BIBLIOTECA UNIVERSITA?RIA

Thiago Javaroni Prati

DESENVOLVIMENTO DE UMA METODOLOGIA PARA
REALIZAC?A?O DE TESTES EM PROGRAMAS DE CLP

NA INDU?STRIA DE PETRO?LEO E GA?S

Floriano?polis(SC)

2014





Thiago Javaroni Prati

DESENVOLVIMENTO DE UMA METODOLOGIA PARA
REALIZAC?A?O DE TESTES EM PROGRAMAS DE CLP

NA INDU?STRIA DE PETRO?LEO E GA?S

Dissertac?a?o submetida ao Programa
de Po?s-Graduac?a?o em Engenharia de
Automac?a?o e Sistemas para a obtenc?a?o
do Grau de Mestre em Engenharia de
Automac?a?o e Sistemas.
Orientador: Jean-Marie Farines, Dr.Eng.
Coorientador: Max Hering de Quei-
roz, Dr.Eng.

Floriano?polis(SC)

2014





Thiago Javaroni Prati

DESENVOLVIMENTO DE UMA METODOLOGIA PARA
REALIZAC?A?O DE TESTES EM PROGRAMAS DE CLP

NA INDU?STRIA DE PETRO?LEO E GA?S

Esta Dissertac?a?o foi julgada aprovada para a obtenc?a?o do T??tulo
de “Mestre em Engenharia de Automac?a?o e Sistemas”, e aprovada em
sua forma final pelo Programa de Po?s-Graduac?a?o em Engenharia de
Automac?a?o e Sistemas.

Floriano?polis(SC), 04 de Dezembro 2014.

Joa?o Ningue?m
Coordenador

Max Hering de Queiroz, Dr.Eng.
Coorientador

Banca Examinadora:

Presidente da banca
Presidente

Jean-Marie Farines, Dr.Eng.
Orientador

Segundo membro





Terceiro membro

Quarto membro





A minha fam??lia e amigos





AGRADECIMENTOS

Agradec?o...
A minha fam??lia que sempre esteve presente garantindo apoio

emocional, por serem compreensivos e atenciosos.
Aos meus amigos com os quais eu sempre pude contar, por ga-

rantirem o?timos momentos de conversa, reflexa?o e distrac?a?o.
A?quele que, em seu olhar, nada ale?m de lealdade foi poss??vel en-

contrar, que nunca deixou de expressar seu amor inabala?vel, que sempre
esteve la?, presente, mesmo que em seus momentos mais preguic?osos, que
nunca recusou sequer um simples afago, que me acompanhou por mo-
mentos extremamente importantes durante um longo tempo na minha
vida e que, mesmo sem perceber, acabou deixando um sentimento de
saudade e boas recordac?o?es que sera?o eternas. Meu querido bebe?.

Aos meus orientadores pelas o?timas ideias dadas e discusso?es es-
senciais para o desenvolvimento desse trabalho, pela pacie?ncia e com-
preensa?o que tiveram comigo.





Proponha-se a atingir o sol e voce? podera?
na?o o alcanc?ar, mas sua seta voara? muito
mais alto do que se fosse apontada para
um objeto ao mesmo n??vel de voce?.

Joel Hawes





RESUMO

Os programas de automac?a?o na indu?stria de petro?leo e ga?s, seja o
programa voltado para sistemas de seguranc?a ou de uso geral, sa?o pro-
jetados com base em especificac?o?es de seguranc?a, definidas em projeto,
que devem ser validados antes da implantac?a?o. Este documento propo?e
um me?todo para o teste automa?tico das especificac?o?es encontradas na
Matriz Causa e Efeito e implementadas em Controladores Lo?gicos Pro-
grama?veis (CLPs). Para esses testes, as especificac?o?es sa?o represen-
tadas como um conjunto de modelos de rede de Petri que observam
o comportamento do sistema controlado. O uso de um modelo for-
mal permite composic?a?o de diferentes modelos de forma sistema?tica e
a traduc?a?o das Redes de Petri em um programa que comanda as en-
tradas de um CLP e observa quando o comportamento do CLP segue
ou falha em seguir as especificac?o?es de seguranc?a. Uma ferramenta
proto?tipo foi desenvolvida para executar automaticamente o teste da
Matriz Causa e Efeito em um dado CLP. Um projeto de um forno foi
utilizado para verificar se a metologia proposta e? fa?cil de usar e via?vel.
Palavras-chave: Controladores Lo?gicos Programa?veis, Testes Auto-
matizados, Validac?a?o, redes de Petri, Sistemas Instrumentados de Se-
guranc?a.





ABSTRACT

The automation programs in the oil and gas industry, be it in Safety
Instrumented Systems (SIS) or in general purpose Programmable Lo-
gic Controllers (PLC), are designed based on safety specifications that
must be validated prior to deployment. This paper proposes a method
for the automatic test of the Cause and Efect Matrix specifications on
PLC systems. For such testing, the specifications are represented as
a set of Petri net models that observe the controlled system behavior.
The use of a formal model allows to systematically compose and trans-
late the Petri Nets into a program that commands the PLC inputs and
observes when the PLC outputs fail the safety specifications. A pro-
totype tool has been developed to automatically perform the test of the
Cause and Efect Matrix on a given PLC. A furnace project has been
used to ascertain that the proposed method is easy to use and viable.
Keywords: Programmable Logic Controllers, Automatic Testing, Va-
lidation, Petri Nets, Safety Instrumented Systems.





SUMA?RIO

1 INTRODUC?A?O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
1.1 MOTIVAC?A?O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
1.2 OBJETIVOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
1.3 ESTRUTURA DA DISSERTAC?A?O . . . . . . . . . . . . . . . . . . . . . . 21
2 MODELAGEM E VALIDAC?A?O DE PROGRAMAS

DE CLP UTILIZANDO ME?TODOS FORMAIS . . . . . 23
2.1 MODELAGEM DE SISTEMAS ATRAVE?S DE REDES DE

PETRI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
2.1.1 Fundamentos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
2.1.2 Fusa?o de redes de Petri . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
2.1.3 Observadores baseados em Redes de Petri . . . . . . . . . 27
2.2 VERIFICAC?A?O FORMAL POR MODEL CHECKING . . . . 27
2.3 ABORDAGENS FORMAIS NO DESENVOLVIMENTO OU

VERIFICAC?A?O DE PROGRAMAS DE CLP . . . . . . . . . . . . . 29
2.3.1 Diagno?stico e tratamento de falhas em sistemas

cr??ticos utilizando me?todos formais . . . . . . . . . . . . . . . . . 29
2.3.2 Uma abordagem baseada em engenharia dirigida a

modelos para a verificac?a?o de programas de CLP . . 31
2.3.3 Um conjunto de ferramentas para verificac?a?o de

modelo de programa de CLP . . . . . . . . . . . . . . . . . . . . . . . 32
2.4 VALIDAC?A?O DE PROGRAMAS ATRAVE?S DE TESTES . . 34
2.4.1 Testes em sistemas instrumentados de seguranc?a

atrave?s de equivale?ncia de classes . . . . . . . . . . . . . . . . . . 37
2.5 COMENTA?RIOS FINAIS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
3 METODOLOGIA DE DESENVOLVIMENTO DO SOFT-

WARE DE AUTOMAC?A?O NA INDU?STRIA DE PETRO?LEO
E GA?S . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41

3.1 DESCRIC?A?O DE UM FORNO INDUSTRIAL PRESENTE
EM UMA UNIDADE DE HIDROTATAMENTO DE DIESEL 41

3.2 METODOLOGIA DE DESENVOLVIMENTO DE PROJETO
DA INDU?STRIA DE PETRO?LEO E GA?S . . . . . . . . . . . . . . . . 44

3.3 METODOLOGIA PARA DESENVOLVIMENTO DO SOFT-
WARE DE CLP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49

3.4 LIMITAC?O?ES DA METODOLOGIA ATUAL . . . . . . . . . . . . . 50
3.5 COMENTA?RIOS FINAIS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
4 PROPOSIC?A?O DE UMA NOVA METODOLOGIA

PARA GERAC?A?O E REALIZAC?A?O DE TESTES . . . 53



4.1 VISA?O GERAL DA METODOLOGIA E SUA INSERC?A?O
NO DESENVOLVIMENTO DO PROJETO . . . . . . . . . . . . . . . 53

4.2 GERAC?A?O DE OBSERVADORES . . . . . . . . . . . . . . . . . . . . . . 56
4.2.1 Observadores ba?sicos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
4.2.1.1 Entradas boleanas simples . . . . . . . . . . . . . . . . . . . . . . . . . . . 58
4.2.1.2 Grupos de entradas boleanas . . . . . . . . . . . . . . . . . . . . . . . . . 59
4.2.1.3 Votac?a?o de sinais de campo . . . . . . . . . . . . . . . . . . . . . . . . . . 60
4.2.1.4 Entradas boleanas com mu?ltiplos efeitos temporizados . . . 61
4.2.2 Composic?a?o de observadores . . . . . . . . . . . . . . . . . . . . . . . 62
4.3 GERAC?A?O DE TESTES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62
4.3.1 Execuc?a?o dos testes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
4.4 EXECUC?A?O DOS OBSERVADORES A PARTIR DOS RE-

SULTADOS DOS TESTES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
4.5 COMENTA?RIOS FINAIS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
5 DESENVOLVIMENTO DE UMA FERRAMENTA PARA

SUPORTAR A METODOLOGIA PROPOSTA . . . . . . 69
5.1 DESENVOLVIMENTO DE UMA FERRAMENTA DE TES-

TES E VALIDAC?A?O DA METODOLOGIA . . . . . . . . . . . . . . 69
5.2 ENTRADA DE DADOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70
5.3 GERAC?A?O DE OBSERVADORES . . . . . . . . . . . . . . . . . . . . . . 71
5.4 DEFINIC?A?O DOS CASOS DE TESTE E GERAC?A?O DE

COMANDOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73
5.5 INTERAC?A?O DA FERRAMENTA COM A PLANTA SI-

MULADA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
5.5.1 Limitac?o?es temporais da ferramenta desenvolvida . . 75
5.6 UTILIZAC?A?O DOS OBSERVADORES PARA VALIDAC?A?O

DOS TESTES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
5.7 COMENTA?RIOS FINAIS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78
6 AVALIAC?A?O DA METODOLOGIA PROPOSTA . . . . 79
6.1 CO?DIGO DE AUTOMAC?A?O . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
6.2 SIMULAC?A?O DA PLANTA . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
6.3 EXPERIMENTOS REALIZADOS E RESULTADOS OBTI-

DOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81
6.4 COMENTA?RIOS FINAIS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
7 CONCLUSA?O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
7.1 DIRETRIZES PARA TRABALHOS FUTUROS . . . . . . . . . . . 88
REFERE?NCIAS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
APE?NDICE A -- Co?digo Ladder Utilizado para Validac?a?o 107



19

1 INTRODUC?A?O

1.1 MOTIVAC?A?O

A complexidade dos problemas de controle industrial pode che-
gar a grandes escalas. Na Indu?stria de Petro?leo e Ga?s, controles es-
pec??ficos podem ser usados para executar tarefas de automac?a?o que
requerem um elevado grau de confiabilidade, uma vez que as falhas po-
dem levar a? danos se?rios e custosos de equipamentos, danos ambientais
e ate? mesmo a perda de vidas humanas, como visto em (SKOGDALE;
SMOGELI, 2011). O desenvolvimento destes sistemas de controle requer
uma grande atenc?a?o, uma vez que lida com requisitos rigorosos, que
podem incluir restric?o?es temporais, de seguranc?a e de confiabilidade.
Para o desenvolvimento destes projetos, as empresas costumam utilizar
normas que te?m como um objetivo a normalizac?a?o da construc?a?o de um
software de automac?a?o que atenda aos requisitos do projeto.

No caso da indu?stria de petro?leo e ga?s, a ana?lise da confiabilidade
do sistema resulta na decisa?o da utilizac?a?o ou na?o de equipamentos es-
pecializados para a automac?a?o de sistemas considerados cr??ticos. A au-
tomac?a?o pode ser, enta?o, realizada atrave?s de lo?gica de rele?s, de disposi-
tivos programa?veis como Controladores Lo?gicos Programa?veis (CLPs).
Exemplos de sistemas que podem vir a ser automatizados atrave?s de
CLPs sa?o: sistema de parada de emerge?ncia (ESD-Emergency shut-
down); Sistema de parada de seguranc?a (Safety shutdown); Sistema de
intertravamento de seguranc?a; Sistema de fogo e ga?s. Os sistemas uti-
lizados devem atender a?s especificac?o?es do projeto a fim de garantir a
seguranc?a de operac?a?o da planta.

A metodologia para o desenvolvimento de sistemas de automac?a?o
atualmente adotada pela Petrobras consiste em um seque?ncia de passos
comec?ando a partir de especificac?o?es ba?sicas da planta a ser automa-
tizada e termina com o desenvolvimento de um software utilizado em
um CLP para automac?a?o. Esta metodologia utiliza um conjunto de
normas gerais e principalmente internas, como visto em (COMISSa?O DE
NORMAS Te?CNICAS, 2002) e (COMISSa?O DE NORMAS Te?CNICAS, 2012).
De acordo com essas normas, uma se?rie de documentos que contenham
informac?o?es relevantes ao longo do projeto sa?o criados. A Matriz de
Causa e Efeito (matriz C&amp;amp;E), por exemplo, e? um documento que de-
fine a relac?a?o entre sinais de campo que indicam situac?o?es cr??ticas e
ac?o?es de seguranc?a adequadas. O documento de Teste de Aceitac?a?o de
Fa?brica (FAT) descreve como testar o programa de automac?a?o final, a



20

fim de validar o programa de CLP, como descrito nos documentos do
projeto.

O desenvolvimento da aplicac?a?o presente em um sistema de au-
tomac?a?o, seja ele implementado em um CLP ou ainda um SIS, e? cons-
titu??do por sequenciamentos, intertravamentos e outras lo?gicas que po-
dem ser facilmente representadas por Sistemas a Eventos Discretos
(SED). Estes sistemas sa?o caracterizados por um espac?o de estados
discreto de valores lo?gicos cuja dina?mica e? dirigida pela ocorre?ncia de
eventos e podem ser representados por modelos formais. Em um pro-
jeto, estes SED poderiam ser desenvolvidos atrave?s de metodologias
espec??ficas e implementados nos sistemas de automac?a?o, utilizando-
se de linguagens das normas IEC 61131-3 e IEC 61499. Embora
a utilizac?a?o destas representac?o?es formais ja? tenham sido abordadas
em outros trabalhos como (PAKONEN et al., 2013), (FARINES; QUEIROZ;
CARPES, 2011) e (Ju?NIOR, 2011) para demonstrar sua efetividade no
cumprimento dos requisitos por parte do programa, existe, ainda, uma
baixa aceitac?a?o na utilizac?a?o destas representac?o?es no momento do pro-
jeto da aplicac?a?o de um sistema de automac?a?o ou ainda no momento
da validac?a?o desta aplicac?a?o.

Apesar da complexidade envolvida e da confiabilidade exigida em
sistemas de automac?a?o, a validac?a?o de programas de CLP no a?mbito
industrial e? feita principalmente atrave?s de testes e simulac?o?es. Estas
validac?o?es sa?o realizadas a partir dos requisitos presentes nos documen-
tos ba?sicos de projeto e acabam por demandar um longo tempo para
serem executadas, visto que sa?o manuais, e mesmo com o tempo des-
prendido, na?o sa?o exaustivas. Consequentemente, alguns erros podem
ser negligenciados e, portanto, podem resultar em danos aos equipa-
mentos e, a?s vezes, ameac?a aos seres humanos.

Dada a atual abordagem na realizac?a?o dos testes em a?mbito
industrial, se mostra importante a utilizac?a?o de algum me?todo que
possibilite uma maior facilidade na realizac?a?o dos testes de programa
de CLP. A gerac?a?o de testes automatizados, por exemplo, permite a
execuc?a?o dos mesmos sem a presenc?a humana, economizando tempo de
projeto ao poder ser realizado independentemente da supervisa?o de um
engenheiro e pode ainda aumentar o leque de situac?o?es testadas devido
a? essa mesma economia de tempo.



21

1.2 OBJETIVOS

O objetivo desta pesquisa e? o elaborac?a?o de uma metodologia
que permita o desenvolvimento de sistemas mais seguros e que sigam
as conformidades estabelecidas em projetos complexos, como aqueles
encontrados na indu?stria de petro?leo e ga?s. Nesse sentido, defini-se
uma metodologia de gerac?a?o de testes que permite ao engenheiro da
indu?stria do petro?leo e ga?s certificar programas a partir da conformi-
dade destes com os documentos ba?sicos existentes no projeto. Para
apoiar a aplicac?a?o desta metodologia, desenvolve-se uma ferramenta
que permite gerar e executar de forma automa?tica as seque?ncias de
testes necessa?rias para a validac?a?o.

Para a validac?a?o da ferramenta, utiliza-se um cena?rio exemplo .
Neste cena?rio, uma planta desenvolvida em ambiente de simulac?a?o e um
sistema de controle criado baseando-se nos requisitos de projeto para
esta planta exemplo sa?o utilizados. A ligac?a?o entre a planta simulada e
este sistema de controle se da? desta maneira: a planta simulada recebe
comandos oriundos do sistema de controle e responde com valores de
sensores gerados pela simulac?a?o. Isso deve ser tal que o sistema de
controle na?o perceba a diferenc?a entre um sistema dina?mico real e a
simulac?a?o. Assim, condic?o?es de operac?a?o da planta que seriam dif??ceis
de serem implementadas em uma planta real por questo?es de seguranc?a,
por exemplo, pudem ser realizadas pelo sistema. Durante esse processo
de simulac?a?o da planta e atuac?a?o por parte do sistema de controle
criado, a ferramenta obte?m os dados pertinentes para a obtenc?a?o de
resultados.

1.3 ESTRUTURA DA DISSERTAC?A?O

Na seque?ncia deste cap??tulo introduto?rio, sa?o apresentadas no
cap??tulo 2 te?cnicas para verificac?a?o e te?cnicas de teste de software, as-
sim como alguns trabalhos da a?rea. No cap??tulo 3 e? apresentada a meto-
dologia atual de desenvolvimento de software utilizada pela Petrobras,
juntamente com um exemplo para melhor entendimento. Em seguida,
no cap??tulo 4, uma nova metodologia para a realizac?a?o de testes dentro
do desenvolvimento de um projeto, segundo o exposto no cap??tulo 3, e?
desenvolvida. No cap??tulo 5, e? apresentado um estudo de caso onde sa?o
realizados testes utilizando um projeto da Petrobras como base para
os mesmos. Finalmente, no cap??tulo 6, sa?o apresentadas as concluso?es
deste trabalho e sugesto?es para trabalhos futuros.



22



23

2 MODELAGEM E VALIDAC?A?O DE PROGRAMAS DE
CLP UTILIZANDO ME?TODOS FORMAIS

Diversas te?cnicas podem ser utilizadas para o desenvolvimento de
programas de CLP. Da mesma maneira, todo desenvolvimento de pro-
grama conta com a realizac?a?o de algum tipo de validac?a?o durante este
processo ou ao final do mesmo. As te?cnicas para desenvolvimento po-
dem se basear em boas pra?ticas de programac?a?o (JACOBSON et al., 1999)
ou ainda podem ser baseadas em me?todos formais. As boas pra?ticas
de programac?a?o podem ser estipuladas tanto pela companhia que o de-
senvolve, quanto por pesquisadores da a?rea, enquanto as te?cnicas base-
adas em me?todos formais baseiam-se em algum tipo de representac?a?o
formal do sistema como: auto?matos, redes de Petri, redes Bayesianas
ou outras e te?m, como objetivo, a gerac?a?o de um programa correto por
construc?a?o.

Ja? a validac?a?o de um programa de CLP pode se dar atrave?s de
verificac?a?o formal ou atrave?s de testes. Assim como no desenvolvimento
baseado em me?todos formais, a verificac?a?o formal consiste em se uti-
lizar uma representac?a?o formal para verificar se o programa apresenta
o comportamento esperado. Para tal, o programa e? transformado em
um modelo formal equivalente e, atrave?s de fo?rmulas, tem suas propri-
edades verificadas. Ja? os testes se baseiam na definic?a?o de conjuntos
de valores de entrada e de sa??da esperados e, atrave?s da inserc?a?o das
entradas e subsequente comparac?a?o entre valores de sa??da esperados e
os obtidos, se analisa o correto funcionamento do programa.

Este cap??tulo aborda conceitos necessa?rios para o entendimento
de futuros temas deste documento, ale?m de trabalhos relacionados. Sa?o
apresentadas redes de Petri, trabalhos relacionados que lidam tanto
com a modelagem de sistemas e gerac?a?o de co?digo, como com a veri-
ficac?a?o de programas de CLP atrave?s de me?todos formais e a realizac?a?o
de testes. Sa?o apresentados os pontos mais essenciais das te?cnicas perti-
nentes e tambe?m dos trabalhos que se utilizam dessas abordagens para
validac?a?o de programas de automac?a?o.

2.1 MODELAGEM DE SISTEMAS ATRAVE?S DE REDES DE PE-
TRI

Rede de Petri e? uma te?cnica de modelagem que permite a repre-
sentac?a?o de sistemas se utilizando de um formalismo matema?tico (MA-



24

CIEL; LINS; CUNHA, 1996), (ZURAWSKI; ZHOU, 2004), (ADAM; ATLURI;
HUANG, 1998). Essa representac?a?o permite modelar sistemas parale-
los, concorrentes, ass??ncronos e na?o-determin??sticos (HAMADI; BENA-
TALLAH, 2003), (MORALES; MELO; MIYAGI, 2007), (YOO; JEONG; CHO,
2010).

Tre?s componentes definem a representac?a?o gra?fica de uma rede
de Petri: a transic?a?o (representado por uma barra), o lugar (c??rculo)
e o arco(seta) . Os lugares sa?o varia?veis de estado e as transic?o?es
correspondem a?s ac?o?es realizadas pelo sistema (MACIEL; LINS; CUNHA,
1996) enquanto o arco ligada os dois elementos anteriores entre si e
podem ser u?nicos ou mu?ltiplos.

Lugares podem ser marcados ou na?o. Um lugar marcado e? re-
presentado por um ou mais pontos desenhados dentro do c??rculo que
representa o lugar e sa?o chamados de fichas. A quantidade de fichas que
um lugar possui e? o que define o seu estado e e? chamada de marcac?a?o
deste lugar(FRANCe?S, 2003). O conjunto dos lugares da rede de Petri
forma o conjunto das varia?veis de estado que representam o sistema
modelado. Assim, as marcac?o?es de todos os lugares em um dado mo-
mento representa o estado do sistema e e? chamado de marcac?a?o da
rede(MURATA, 1989), (ZURAWSKI; ZHOU, 2004), (XU et al., 2007).

A rede de Petri permite a modelagem de diferentes tipos de mo-
delos, dentre eles: a sincronizac?a?o de processos, de operac?o?es concor-
rentes e de conflitos, a ocorre?ncia de eventos ass??ncronos ou ainda com-
partilhamento de recursos (ADAM; ATLURI; HUANG, 1998), (NASSAR et
al., 2008), (ZURAWSKI; ZHOU, 2004). Desde sua apresentac?a?o por Carl
Adam Petri, redes de Petri foram utilizadas na modelagem e ana?lise de
diferentes tipos de sistemas e aplicac?o?es como: diagno?stico e tratamento
de falhas na?o cr??ticas (MORALES; MELO; MIYAGI, 2007) (SILVA, 2002)
, protocolos distribu??dos (KANESHIRO et al., 2007), aplicac?o?es indus-
triais (NASSAR et al., 2008), fluxo de processos (KIEPUSZEWSKI; HOFS-
TEDE; AALST, 2003), controle superviso?rio (LEE; ZHOU; HSU, 2005) e
diagno?stico e tratamento de falhas na?o cr??ticas (Ju?NIOR, 2011).

Ale?m disso, va?rias ferramentas para simulac?a?o, edic?a?o e ana?lise
foram desenvolvidas desde a de?cada de 90( (ZURAWSKI; ZHOU, 1994)
, (BERTHOMIEU, 2004)) e possibilitam a representac?a?o da dina?mica
do sistema e sua estrutura em diversos n??veis de abstrac?a?o (de acordo
com a complexidade do sistema (NASSAR et al., 2008)), a ana?lise das
modelagens e tambe?m sua simulac?a?o.



25

2.1.1 Fundamentos

A rede de Petri ordina?ria e? uma tupla N = (P, T, I, O) associada
com uma descric?a?o de estado indicada por M. P = p1, p2, ..., pn e? um
conjunto finito na?o-vazio de lugares, T = t1, t2, ..., tm e? um conjunto
finito na?o-vazio de transic?o?es. I:PxT? N e? a matriz de entrada que
relaciona transic?o?es com lugares de entrada enquanto O:PxT? N e? a
matriz de sa??da que relaciona transic?o?es com lugares de sa??da. As ma-
trizes de entrada e de sa??da conte?m, em cada elemento aij, o peso do
arco que liga o lugar pi a? transic?a?o tj se existir um arco, ou zero, caso
na?o exista nenhum arco entre pi e tj (MURATA, 1989). Os arcos presen-
tes na matriz de entrada (I) sa?o aqueles que saem do lugar e apontam
para a transic?a?o correspondente, ou seja, sa?o aqueles que entram nas
transic?o?es. Os arcos na matriz de sa??da (O) sa?o aqueles que partem da
transic?a?o e apontam para o lugar, ou seja, saem das transic?o?es. M e?
um conjunto de nu?meros naturais que representa a quantidade de fichas
nos lugares, tambe?m conhecido como marcac?a?o dos lugares. M0 indica
uma marcac?a?o inicial, isto e?, uma distribuic?a?o de fichas nos lugares
que caracteriza o estado inicial da rede ((HAN et al., 2008), (MURATA,
1989),(LI; ZHOU, 2008),(XU et al., 2007),(YOO; JEONG; CHO, 2010),(ZU-
RAWSKI; ZHOU, 1994)) enquanto Mp indica o nu?mero de fichas no lu-
gar p. Uma transic?a?o t esta? habilitada se ?p ? P, M(p) ? I(p, t) e,
uma vez habilitada, pode ser disparada. O disparo de uma transic?a?o
altera a marcac?a?o M da rede produzindo uma marcac?a?o M’, tal que
M?p = Mp ? I(p, t) + O(p, t)?p ? P .

A figura 1 apresenta um exemplo de rede de Petri exemplifi-
cando como uma comunicac?a?o simples entre 2 servidores poderia ser
modelada.

Figura 1: Exemplo de redes de Petri representando a comunicac?a?o entre
dois servidores. Fonte:(OLIVEIRA, 2006)



26

Outro tipo de rede de Petri, o qual sera? abordado neste traba-
lho, e? a rede de Petri temporizada. Uma rede de Petri temporizada e?,
estruturalmente, igual a? rede de Petri ordina?ria, exceto que adiciona
a noc?a?o de tempo associada a?s transic?o?es. Uma rede de Petri tem-
porizada e? uma tupla R = (P, T, I, O, C) onde P, T, I, O possuem as
mesma definic?o?es ja? estabelecidas para a rede de Petri ordina?ria, en-
quanto C : T ? NxN e? uma func?a?o que associa um intervalo de tempo
(min,max), tal que min? 0 e max ? min, a cada transic?a?o. Para essa
rede, o disparo de uma transic?a?o so? pode ocorrer apo?s a passagem de
min unidades de tempo apo?s sua habilitac?a?o e deve ser disparada em
ate? no ma?ximo max unidades de tempo apo?s sua habilitac?a?o. Outro
aspecto importante para esta modalidade de rede de Petri e? a memo?ria
de habilitac?a?o. Apo?s o disparo de uma transic?a?o, todas as transic?o?es
que estavam habilitadas na marcac?a?o anterior e que permanecem ha-
bilitadas na nova marcac?a?o mante?m os valores de seus temporizado-
res. Apenas quando uma transic?a?o e? desabilitada na nova marcac?a?o ou
quando esta e? disparada e? que o seu tempo e? perdido.(MACIEL; LINS;
CUNHA, 1996)

2.1.2 Fusa?o de redes de Petri

Considerando um elemento de uma rede de Petri como um lugar
ou uma transic?a?o, a fusa?o de elementos de diferentes redes de Petri
permite, de forma sistema?tica e estruturada, a construc?a?o de redes de
grandes dimenso?es a partir de mo?dulos menores. Esta te?cnica permite
a utilizac?a?o de diferentes abordagens para a construc?a?o de sistemas
representados em redes de Petri. Para a representac?a?o de um sistema
qualquer em uma rede de Petri, redes menores que representam parte
do fluxo de informac?a?o no sistema ou ainda que representam diferentes
funcionalidades do sistema podem ser modeladas inicialmente e enta?o
fusionadas. Isto significa que, a partir de pequenas redes de Petri, as
quais podem ser facilmente analisadas, pode-se construir uma rede mais
complexa que oferece as caracter??sticas de cada uma das redes iniciais
(Go?IS, 2000).

A figura 2 apresenta duas redes e a fusa?o dessas redes utilizando
a te?cnica de fusa?o de lugar. Os lugares P sa?o elementos do mesmo tipo
pertencentes a?s redes iniciais R’ e R” e esta?o envolvidos no processo de
fusa?o. Nota-se que os elementos do mesmo tipo desaparecem na fusa?o,
dando origem a um novo elemento na rede final R. A fusa?o de transic?a?o
ocorre da mesma maneira, exceto que os elementos envolvidos na fusa?o



27

Figura 2: Exemplo representando a fusa?o entre duas redes de Petri
Gene?ricas

sa?o transic?o?es e na?o lugares.

2.1.3 Observadores baseados em Redes de Petri

Observadores sa?o normalmente utilizados objetivando a veri-
ficac?a?o da alcanc?abilidade de um sistema e, quando utilizados, devem
ser na?o intrusivos, ou seja, na?o devem alterar o sistema original in-
serindo novos dados ou influindo no comportamento do sistema sendo
observado. Em sistemas modelados, os observadores sa?o, normalmente,
constru??dos com a mesma abstrac?a?o utilizada para os sistemas modela-
dos e sa?o comuns na a?rea de verificac?a?o formal de sistemas (ABID et al.,
2011), sendo sua func?a?o observar transic?o?es ou estados de um sistema.

2.2 VERIFICAC?A?O FORMAL POR MODEL CHECKING

Model checking refere-se a um conjunto de te?cnicas para a ana?lise
automa?tica de sistemas reativos. Pequenos erros no desenvolvimento
de sistemas cr??ticos que utilizam te?cnicas de simulac?a?o e testes conven-
cionais podem ser (e te?m sido) encontrados (MERZ, 2001) atrave?s da
utilizac?a?o de me?todos formais. Como e? relativamente simples de utili-
zar, a abordagem que envolve verificac?a?o vem sendo adotada como um
procedimento padra?o para a garantia da qualidade de sistemas reativos.
(MERZ, 2001)



28

Uma estrutura de Kripke e? uma variac?a?o de automato na?o-
determin??stico proposto por Saul Kripke, utilizado no model checking
para representar o comportamento de um sistema. E? um modelo ma-
tema?tico que captura a ide?ia de uma ma?quina de computac?a?o, sem
adic?a?o de complexidades desnecessa?rias. E? basicamente um grafo cu-
jos no?s representam os estados alcanc?a?veis do sistema e cujas arestas
representam as transic?o?es de estado. A func?a?o de marcac?a?o mapeia
cada no? a um conjunto de propriedades que existem em um estado cor-
respondente. Lo?gicas temporais sa?o tradicionalmente interpretados em
termos de estruturas de Kripke

As entradas para um verificador de modelos sa?o modelos (ge-
ralmente finitos), na forma de estrutura de Kripke, do sistema a ser
analisado e tambe?m as propriedades a serem verificadas, geralmente
expressas como fo?rmulas de lo?gica temporal , que va?o ser verificadas do
modelo . O verificador de modelo ou confirma que as propriedades, de
fato, existem no modelo ou afirma que essas sa?o violadas. Neste u?ltimo
caso , ele fornece um contra-exemplo, na forma de uma execuc?a?o de
sistema que viola a propriedade. O usua?rio deve enta?o decidir se o
contra-exemplo e? um condic?a?o do modelo (causada talvez por uma su-
per simplificac?a?o do modelo fornecido) e, talvez, fornecer um modelo
melhor para o verificador, ou se corresponde a um funcionamento do
sistema real e rever o projeto do sistema para excluir o erro. Na pra?tica
um terceiro resultado poss??vel de verificac?a?o do modelo e? que a ana?lise
exige recursos superiores aos dispon??veis(memo?ria, por exemplo). Nesse
caso , pode ser poss??vel analisar uma representac?a?o mais superficial do
modelo do sistema ou aplicar otimizac?o?es que fazem a ana?lise via?vel .

Execuc?o?es bem sucedidas do verificador de modelos so? podem
estabelecer que certa propriedade e? garantida no modelo abstrato e
na?o no ”mundo real”ou sistema de hardware ”concreto”ou programa.
A inserc?a?o de erros durante a construc?a?o do modelo abstrato e? bem
comum e procedimentos devem sempre ser adotados (ana?lises de co?digo
por exemplo) para garantir que a representac?a?o abstrata representa
fielmente o comportamento do sistema real na medida do necessa?rio
para a ana?lise das propriedades consideradas. O verificador pode ser
de alguma ajuda ao estabelecer que o modelo abstrato, pelo menos, na?o
exclui certas execuc?o?es.



29

2.3 ABORDAGENS FORMAIS NO DESENVOLVIMENTO OU
VERIFICAC?A?O DE PROGRAMAS DE CLP

Nesta sec?a?o sera?o abordados alguns trabalhos que se baseiam na
utilizac?a?o de representac?o?es formais para a construc?a?o de um programa
de de CLP ou sua verificac?a?o. A utilizac?a?o de representac?o?es formais
confere ao desenvolvimento ou verificac?a?o de teste de programas de CLP
uma base matema?tica para sua execuc?a?o. Os trabalhos que se utilizam
de tais representac?o?es te?m como objetivo garantir certas proprieda-
des aos programas sendo desenvolvidos ou validados. Cada trabalho
apresentado possui suas pro?prias particularidades e sera?o explicados
individualmente. Dentre as abordagens abordadas, sera?o utilizados os
conceitos apresentados nesse cap??tulo.

2.3.1 Diagno?stico e tratamento de falhas em sistemas cr??ticos
utilizando me?todos formais

Em (Ju?NIOR, 2011), uma abordagem para a gerac?a?o de algorit-
mos de controle e? proposta. O princ??pio do trabalho e? a concepc?a?o de
um conjunto de procedimentos sistematizados para desenvolvimento e
validac?a?o de algoritmos de controle, a partir da modelagem de func?o?es
para diagno?stico e tratamento de falhas atrave?s da ana?lise de docu-
mentos. A abordagem deste trabalho caracteriza-se pela construc?a?o e
ana?lise de modelos de diagno?stico e tratamento de falhas em sistemas
cr??ticos e e? dividia em quatro etapas:

• modelagem.

• ana?lise.

• gerac?a?o dos programas de controle

• testes finais de aceitac?a?o.

A etapa de modelagem e? subdividida em dois esta?gios comple-
mentares: a modelagem do diagno?stico de falhas e a modelagem do
tratamento e das falhas. A sistema?tica proposta utiliza como fonte
de dados de entrada o relato?rio de ana?lise de riscos (HAZOP) e as
informac?o?es presentes em um dos documentos de automac?a?o (matriz
causa e efeito). A partir dos dados de entrada, no esta?gio da mode-
lagem do diagno?stico de falhas, sa?o geradas redes Bayesianas para o
diagno?stico de falhas e, apo?s sua obtenc?a?o, essas sa?o traduzidas para



30

redes de Petri. Em outro esta?gio, a modelagem do tratamento e das
falhas, baseando-se nas falhas poss??veis para o sistema, sa?o geradas
func?o?es instrumentadas de seguranc?a, as quais modelam func?o?es res-
ponsa?veis por lidar com essas poss??veis falhas(tratamento das falhas).
Essas func?o?es sa?o modeladas utilizando-se redes de Petri. Neste mo-
mento, existem dois grupos de modelos de redes de Petri. O responsa?vel
pelo diagno?stico e o responsa?vel pelo tratamento. De acordo com in-
formac?o?es contidas nos documentos, as redes de Petri dos dois grupos
sa?o relacionadas e integradas.

A etapa de ana?lise investiga a interac?a?o entre os modelos de di-
agno?stico e de tratamento de falhas cr??ticas uma vez que integrados.
Para essa atividade, ferramentas de simulac?a?o de redes de Petri sa?o
utilizadas. Na etapa de gerac?a?o, tem-se a gerac?a?o dos programas de
controle baseados nos modelos de diagno?stico e de tratamento integra-
dos na etapa pre?via. Estes programas sa?o gerados de acordo com a
norma IEC 61131-3. Finalmente, na etapa de aceitac?a?o, os testes fi-
nais de validac?a?o sa?o executados a fim de validar se as func?o?es criadas
atendem a?s especificac?o?es te?cnicas de acordo com a norma IEC 61511.
Informac?o?es mais detalhadas sobre este trabalho podem ser encontra-
das em (Ju?NIOR, 2011) A figura 3 apresenta a sistema?tica proposta.

Figura 3: Sistema?tica apresentada em (Ju?NIOR, 2011)



31

2.3.2 Uma abordagem baseada em engenharia dirigida a mo-
delos para a verificac?a?o de programas de CLP

Este trabalho(FARINES; QUEIROZ; CARPES, 2011) se insere no
contexto do projeto TOPCASED (VERNADAT et al., 2006), que visa
o desenvolvimento de um ambiente para sistemas embarcados , com
base em engenharia dirigida a modelos (MDE) . A plataforma apre-
sentada, a TOPCASED, integra diferentes ferramentas de verificac?a?o
como por exemplo TINA (BERTHOMIEU, 2004) e permite a utilizac?a?o
de va?rias linguagens de modelagem de usua?rio. O FIACRE, a lin-
guagem (BERTHOMIEU et al., 2008) concebida no projeto TOPCASED
serve como um formato intermedia?rio entre as linguagens de usua?rio e
de verificac?a?o de modelos formais.

Primeiramente, um metamodelo para um diagrama Ladder e?
proposto. Regras de transformac?a?o entre elementos ba?sicos e blocos de
func?a?o Ladder para FIACRE foram definidos. O resultado foi enta?o
uma sema?ntica Fiacre para programas escritos em ladder . O mo-
delo ladder e? traduzido para FIACRE a partir dessas regras, de tal
forma que cada programa ladder concebido em conformidade com o
metamodelo ladder pode ser automaticamente traduzido para uma re-
presentac?a?o FIACRE. A partir da linguagem FIACRE, a ferramenta
de compilac?a?o existente FRAC pode gerar um modelo de Transic?a?o
Tempora?rio(TTS) usado pelo conjunto de ferramentas TINA para ve-
rificac?a?o. Em seguida, as propriedades referentes ao sistema , expressas
em LTL , podem ser verificadas no modelo TTS obtido usando o model
checking dispon??vel no TINA. MDE garante que a verificac?a?o e? rea-
lizada em um modelo que e? constru??do automaticamente a partir do
programa ladder e em conformidade com regras de transformac?a?o de-
finidas, eliminando, assim, poss??veis erros inseridos pela transformac?a?o
manual dos modelos.

Este trabalho encaixa-se no ambiente TOPCASED e utiliza uma
metodologia similar e algumas de suas ferramentas para construir um
conjunto de ferramentas de verificac?a?o para os programas de PLC es-
critos com linguagens definidas na IEC 61131-3. Devido a? diversidade
de linguagens existentes (como UML, SysML ou AADL ) e de fer-
ramentas de verificac?a?o dispon??veis com seus formalismos pro?prios (
como redes de Petri , auto?matos ou a?lgebra de processos), o ambiente
TOPCASED define o idioma FIACRE como um passo intermedia?rio
na transformac?a?o do modelo. O conjunto de ferramentas de verificac?a?o
tem, portanto, como base, dois n??veis de transformac?a?o: um n??vel de
uma linguagem para o idioma intermedia?rio FIACRE e, em seguida,



32

um outro de FIACRE a?s linguagens de verificac?a?o formal. Dentre os
benef??cios da utilizac?a?o do FIACRE apresentados pelo trabalho, tem-
se: a reduc?a?o da diferenc?a sema?ntica entre linguagens de alto n??vel e
formalismos de baixo n??vel para ferramentas de verificac?a?o e a definic?a?o
de uma sema?ntica exclusiva para diferentes conjuntos de ferramentas de
verificac?a?o, o que torna mais fa?cil fa?cil a introduc?a?o de novas linguagens
de alto n??vel e novas ferramentas de verificac?a?o. No caso do trabalho
em questa?o, o FIACRE facilita o uso do conjunto de ferramentas de
verificac?a?o TINA para a linguagem Ladder para CLP, sem necessidade
de traduc?a?o direta de representac?o?es de alto formalismo como Redes
de Petri em linguagens de baixo n??vel como Ladder.

A ferramenta desenvolvida nesse projeto e? exemplificada na fi-
gura 4 e consiste do seguinte: um editor de PLC permite a criac?a?o
de programas Ladder e os salva em um arquivo XML. Um tradutor -
constru??do usando abordagem MDE e escrito em ATL (JOUAULT; KUR-
TEV, 2006) transforma o XML resultante em FIACRE. Ao co?digo FIA-
CRE resultante, se adiciona o modelo da planta tambe?m em FIACRE
e obte?m-se assim o modelo FIACRE completo. Enfim, esse modelo
completo e? compilado para TTS utilizando o compilador FRAC (parte
do TOPCASED) e pode, atrave?s do conjunto de ferramentas TINA,
ser verificado.

2.3.3 Um conjunto de ferramentas para verificac?a?o de modelo
de programa de CLP

A abordagem apresentada em (PAKONEN et al., 2013) consiste
na especificac?a?o manual de um co?digo verificador para cada bloco de
func?a?o elementar utilizado em um determinado programa. A justifi-
cativa apresentada para a definic?a?o de cada bloco manualmente foi a
seguinte:

• Em vez de usar linguagens padra?o, conforme especificado pela
IEC 61131-3, muitos dos principais fabricantes de CLP usam blo-
cos de func?o?es espec??ficas a cada fornecedor.

• Muitas vezes, os fornecedores na?o esta?o dispostos a divulgar a
algoritmos de implementac?a?o reais para o blocos de func?o?es ele-
mentares (caixa preta) por os considerarem uma propriedade in-
telectual da companhia. Apenas a descric?a?o funcional e? fornecida
aos clientes.

• Mesmo que a lo?gica interna dos blocos fossem reveladas (caixa



33

Figura 4: Ferramenta desenvolvida em (FARINES; QUEIROZ; CARPES,
2011)

branca), e? prova?vel que a implementac?a?o desses algoritmos se
de? em linguagens como C ou Java, o que na?o costuma permitir
representac?a?o direta em algumas ferramentas de verificac?a?o.

O ponto de partida na metodologia proposta neste trabalho e? a
descric?a?o funcional dos blocos de func?a?o elementar. O co?digo para mo-
del checking de cada bloco e? enta?o escrito e a verificac?a?o do modelo de
cada bloco pode ser utilizada para assegurar que o co?digo esta? correto.
As propriedades a serem verificadas sa?o obtidas a partir da descric?a?o
funcional de cada bloco.

O verificador utilizado neste trabalho foi o NuSMV, um veri-
ficador de modelo simbo?lico baseado em BDD que permite represen-
tar ambos os sistemas de estados finitos s??ncronos e ass??ncronos, com
descric?a?o de tempo discreto e as propriedades podem ser especifica-
dos usando LTL ou CTL (BAIER; KATOEN et al., 2008). A ferramenta
permite apenas expresso?es muito ba?sicas e tipos simples de varia?veis
(boleana, inteira, enumerac?a?o, matriz), o que significa que os blocos
de func?o?es de algoritmos complexos (por exemplo, PID) na?o podem ser
modelados com precisa?o razoa?vel. Lo?gicas complexas de controle devem
ser, portanto, abstra??das, ou completamente omitidas da verificac?a?o.



34

Foi desenvolvida uma ferramenta de verificac?a?o de modelos para
Simantics (KARHELA; VILLBERG; NIEMSTO?, 2012) (uma ferramenta que
oferece um ambiente de integrac?a?o entre ferramentas de simulac?a?o e de
engenharia). Atrave?s da ferramenta desenvolvida, po?de-se construir ou
reproduzir um programa em FBD e transformar esse diagrama para um
arquivo de entrada para o NuSMV. Atrave?s de uma entrada de texto,
deve-se introduzir o co?digo do bloco de func?a?o elementar ale?m da in-
terface para o mesmo(entradas e sa??das). Atrave?s da interface gra?fica
da ferramenta, constro?i-se uma representac?a?o FBD para o programa a
ser verificado e, com esse programa FBD, gera-se um arquivo de en-
trada para NuSMV contendo todos os elementos necessa?rios do modelo
- co?digo para os blocos elementares utilizadas , bem como as ligac?o?es
entre blocos. As propriedades a serem verificadas sa?o introduzidas no
NuSMV atrave?s de texto.

2.4 VALIDAC?A?O DE PROGRAMAS ATRAVE?S DE TESTES

A atividade de testar consiste em uma ana?lise dina?mica do pro-
grama produzido e e? uma atividade relevante na identificac?a?o e eli-
minac?a?o de poss??veis erros contidos no programa. A atividade de rea-
lizar testes em programas prontos e? de grande utilizac?a?o em sistemas
onde a operac?a?o na?o e? cr??tica, uma vez que seu mau funcionamento na?o
resulta em grandes perdas ou desastres. Por ser a abordagem mais na-
tural para se checar o correto funcionamento de um programa, e? muito
utilizada na indu?stria como uma das etapas finais antes da entrega de
um programa de automac?a?o. Mesmo algumas plantas cr??ticas te?m seu
programa testado baseando-se em especificac?o?es iniciais e conhecimento
interno da equipe de engenharia responsa?vel pelo projeto.

A realizac?a?o de testes de programa envolve basicamente 4 eta-
pas (BEIZER, 1990) (MYERS, 1979) (MALDONADO, 1991) (PRESSMAN,
1997):

• planejamento de testes

• projeto de casos de teste

• execuc?a?o

• avaliac?a?o dos resultados dos testes

Cada uma dessas quatro etapas, que devem ser realizadas du-
rante o desenvolvimento do programa, podem ser divididas em tre?s



35

fases de testes: testes de unidade(teste de cada mo?dulo do programa),
testes de integrac?a?o(testa o interfaceamento de cada mo?dulo) e teste
de sistema(testa se o sistema atende aos requisitos pre?-estabelecidos)
(BEIZER, 1990).

Na realizac?a?o de testes, e? importante a definic?a?o de um conjunto
de casos de teste, quando for impratica?vel a realizac?a?o de todos os tes-
tes poss??veis. Como o teste tem por principal finalidade a identificac?a?o
de erros(MYERS, 1979), um bom conjunto de casos de teste e? o con-
junto que consegue fazer o programa em teste falhar. Para a definic?a?o
do conjunto de casos de teste, existem alguns crite?rios de teste. Os
principais sa?o:

• funcional: o requisitos do teste prove?m da especificac?a?o do pro-
grama

• estrutural: os requisitos sa?o derivados a partir de uma imple-
mentac?a?o espec??fica

• baseado em erros: os requisitos sa?o estabelecidos a partir de er-
ros t??picos realizados durante o processo de desenvolvimento do
programa

Os testes podem ainda ser divididos em tre?s tipos principais:

• Testes de caixa-preta ou teste baseado em especificac?a?o tem por
objetivo inferir se o programa atinge os requisitos funcionais e na?o
funcionais . Dentre os testes de caixa-preta, pode-se citar parti-
cionamento em classe de equivale?ncia (BEIZER, 1990), ana?lise do
valor limite, grafo de causa-efeito (BEIZER, 1990) e teste baseado
em estado (MCGREGOR, 1994) (HOFFMAN; STROOPER, 1993)

• Teste de caixa-branca ou teste baseado em programa trabalha
com a inspec?a?o do co?digo fonte e a selec?a?o de casos que executem
determinada parte do co?digo(PERRY; KAISER, 1990)

• Teste de caixa cinza implica ter conhecimento de estruturas de
dados e algoritmos internos para fins de concepc?a?o de testes, en-
quanto executa desses testes no n??vel de caixa-preta. O testa-
dor na?o e? obrigado a ter pleno acesso ao co?digo-fonte do soft-
ware(PATTON, 2001).

Ao realizar testes de programa, e? importante destacar alguns
pontos:

• A realizac?a?o de testes pode desprender muito tempo de projeto



36

• Testes nunca podem ser considerados exaustivos

• E? necessa?rio a correta interpretac?a?o de resultados para se garantir
que um erro na?o seja considerado como comportamento correto
de programa

• O conjunto de testes realizados pode ser parcial e dependente
daquele que escolhe a rotina de testes

Ao se realizar testes, deve-se levar em considerac?a?o suas limitac?o?es
para evitar a inefica?cia desses. Quanto ao tempo gasto para a execuc?a?o
de testes, existem algumas abordagens para se melhorar sua eficie?ncia.
A seguir sera?o apresentadas algumas abordagens utilizadas durante a
fase de testes que podem reduzir o tempo desta fase de projeto ou ainda
melhorar sua efica?cia na busca por falhas.

Particionamento de equivale?ncia (tambe?m chamado de classe de
equivale?ncia ou ECP (BURNSTEIN, 2003)) e? uma te?cnica de teste de pro-
grama que divide os dados de entrada de um programa em partic?o?es de
dados equivalentes a partir do qual os casos de teste podem ser deri-
vados. Em princ??pio, os casos de teste sa?o projetados para cobrir cada
partic?a?o pelo menos uma vez. Esta te?cnica tenta definir casos de teste
para descobrir classes de erros, reduzindo assim o nu?mero total de casos
de teste que devem ser desenvolvidas. Uma vantagem desta abordagem
e? a reduc?a?o no tempo necessa?rio para o ensaio de um programa, devido
ao menor nu?mero de casos de teste.

Ana?lise do valor limite e? uma te?cnica de teste de programa em
que os testes sa?o projetados para incluir representantes de valores de
limite(MALDONADO et al., 2004). Dado que um conjunto de vetores de
teste para testar o sistema, uma topologia pode ser definida nesse con-
junto. Esses elementos que pertencem a? mesma classe de equivale?ncia,
tal como definido pela teoria particionamento de equivale?ncia constro?i
a base (topologia). Dado que os conjuntos de base sa?o vizinhos, existe
uma fronteira entre eles. Os elementos de teste em ambos os lados da
fronteira sa?o chamados valores limite. Na pra?tica, isso exige que os ele-
mentos de teste possam ser ordenados, e que os para?metros individuais
seguem algum tipo de ordem (ou de ordem parcial ou total).

Testes all-pairs ou teste pairwise e? um me?todo combinato?rio
de teste de programa que, para cada par de para?metros de entrada
para um sistema, testa todas as poss??veis combinac?o?es distintas de
tais para?metros. Usando vetores de teste escolhidos dentre todos os
para?metros, isso pode ser feito muito mais rapidamente do que uma
procura exaustiva de todas as combinac?o?es de todos os para?metros, por
uma ”paralelizac?a?o”dos testes de pares de para?metros. O racioc??nio por



37

tra?s dessa metodologia de testes e? a seguinte: os erros mais simples em
um programa sa?o geralmente acionados por um u?nico para?metro de
entrada. A pro?xima categoria mais simples de erros e? constitu??do por
aqueles dependentes de interac?o?es entre os pares de para?metros, que
podem ser capturados com teste all-pairs (BLACK, 2007). Problemas
envolvendo interac?o?es entre tre?s ou mais para?metros sa?o cada vez menos
comuns(KUHN; WALLACE; GALLO, 2004),e, ao mesmo enquanto cada
vez mais caro para se encontrar atrave?s de testes exaustivos, que tem
como limite ma?ximo, o teste exaustivo de todas as entradas poss??veis
(KUHN; KACKER; LEI, 2010).

A seguir, sera? apresentado um trabalho desenvolvido para a re-
alizac?a?o de testes em programas de sistemas instrumentados de segu-
ranc?a.

2.4.1 Testes em sistemas instrumentados de seguranc?a atrave?s
de equivale?ncia de classes

A metodologia definida em (OLIVEIRA LEANDRO DIAS DA SILVA,
2012) consiste em quatro etapas ilustradas na figura 5 e pode ser ex-
plicada da seguinte maneira:

• A especificac?a?o do sistema e? lida e traduzida em um modelo de
auto?mato temporizado

• O modelo e? usado para gerar automaticamente um conjunto de
casos de teste

• Para cada caso de teste, os valores de entrada e de teste sa?o
enviados ao CLP atrave?s de OPC

• A rotina no CLP e? executada gerando um conjunto de valores de
sa??da

• A sa??da do CLP e? enta?o comparado com o resultado do modelo
obtido e um veredito e? obtido

Os casos de teste sa?o gerados tendo em conta o ciclo de varredura
do PLC. Cada caso de teste e? gerado para ser executado em um ciclo
de varredura. Um caso de teste e? uma tupla C = I, O, T :

• I e? um conjunto de valores booleanos a?s entradas correspondentes
varia?vel da especificac?a?o do sistema;



38

• O e? um conjunto de valores booleanos correspondentes a?s varia?veis
de sa??da da especificac?a?o que sa?o obtidos apo?s o processamento
de I;

• T e? o trac?o, ou seja, as seque?ncias de eventos de sincronizac?a?o
executados para obter O de I.

Figura 5: Metodologia de testes utilizando equivale?ncia de classes

Ao gerar os casos de teste , algumas das poss??veis combinac?o?es de
valores das varia?veis de entrada sa?o selecionadas para serem utilizadas.
Dois tipos de falhas foram consideradas ao selecionar os valores de
entrada: falhas que afetam uma restric?a?o de tempo e as falhas que
afetam a sa??da do sistema. A selec?a?o foi feita atrave?s de classes de
equivale?ncia,e foram removidas combinac?o?es que geram casos de teste
redundantes. Dois casos de teste sa?o redundantes se forem consideradas
semelhantes e na?o agregam valor para o conjunto de teste . Eles na?o
detectam novos erros e eles na?o fornecem uma melhor cobertura de
teste do sistema em ana?lise.A remoc?a?o de testes redundantes teve como
objetivo a diminuic?a?o do tempo de realizac?a?o de testes.

A selec?a?o de combinac?o?es de entrada depende dos elementos da
especificac?a?o do sistema . Para cada varia?vel de sa??da, duas entradas
sa?o selecionadas, uma que a ativa e outra que a desativa . Este tipo
de teste tem como objetivo detectar falhas que afetam a sa??da do sis-
tema. Se o sistema tiver elementos temporizados, todas as transic?o?es de
cada temporizador sa?o executadas pelo menos uma vez, e as entradas
adequadas devem ser selecionadas. A verificac?a?o dos temporizadores e?
feita com base na entrada de cada temporizador. Portanto, para cada
temporizador, uma combinac?a?o de valores de entrada deve levar a en-
trada do temporizador para verdadeiro e outra para falso. Este tipo de
teste objetiva a detecc?a?o de falhas que afetam restric?o?es temporais.

Este trabalho propo?e, enta?o, a utilizac?a?o de um nu?mero m??nimo
de entradas do CLP, o suficiente para ativar todas as sa??das do pro-
grama de CLP e tambe?m todos os temporizadores do programa. Os



39

casos de teste sa?o selecionados a partir dos modelos de auto?matos. Essa
abordagem pode trazer problemas uma vez que considerar uma u?nica
entrada de um grupo de entradas na?o garante o correto funcionamento
de todas as entradas. Ainda, assim como explicado no trabalho, os tes-
tes devem poder ser realizados em um ciclo de CLP e, desta maneira,
exclui qualquer teste que inclua uma poss??vel seque?ncia de entradas as-
sim como uma entrada que resulta em um sequenciamento nas sa??das.

2.5 COMENTA?RIOS FINAIS

Neste cap??tulo foi realizada uma revisa?o bibliogra?fica sobre redes
de Petri, verificac?a?o formal atrave?s de model-checking e tambe?m sobre
a realizac?a?o de testes em programa. Foram apresentados trabalhos que
utilizam abordagens formais para o desenvolvimento e validac?a?o de
programas de automac?a?o industrial. No pro?ximo cap??tulo, sera? apre-
sentada a abordagem utilizada atualmente pela Petrobras para o de-
senvolvimento e validac?a?o dos programas de automac?a?o desenvolvidos
em seus projetos.



40



41

3 METODOLOGIA DE DESENVOLVIMENTO DO
SOFTWARE DE AUTOMAC?A?O NA INDU?STRIA DE
PETRO?LEO E GA?S

A metodologia de desenvolvimento de projetos de automac?a?o
atualmente utilizada em empresas de petro?leo e ga?s, como a Petrobras
consiste em uma seque?ncia de etapas que partem de definic?o?es ba?sicas
da planta a ser automatizada e culmina com o desenvolvimento do pro-
grama utilizado para automac?a?o de CLP. Durante o projeto, uma gama
de documentos, cada qual contendo informac?o?es relevantes a uma ou
va?rias etapas do projeto, e? criada. Cada etapa dessa metodologia possui
entradas e sa??das na forma de documentos, sendo que os documentos
na entrada de uma determinada etapa sa?o aqueles que sa?o necessa?rios
para a gerac?a?o dos documentos de sa??da. Neste cap??tulo, a atual me-
todologia de desenvolvimento e os documentos sera?o explicados. Para
a exemplificac?a?o da metodologia e dos documentos utilizados na me-
todologia atualmente encontrada, uma planta exemplo fornecida pela
Petrobras sera utilizada. Trata-se de uma planta de um forno industrial
e seu funcionamento e? melhor explicado a seguir.

3.1 DESCRIC?A?O DE UM FORNO INDUSTRIAL PRESENTE EM
UMA UNIDADE DE HIDROTATAMENTO DE DIESEL

Para exemplificac?a?o da metodologia atualmente utilizada por
empresas como a Petrobras, sera? utilizada uma planta de um forno
industrial. Esta planta sera? utilizada tambe?m, em cap??tulos posterio-
res para a validac?a?o da metodologia proposta neste documento. Esta
sec?a?o na?o possui como objetivo explicar detalhadamente cada aspecto
do forno, mas sim, esclarecer o funcionamento dessa planta para que
possa ser utilizada como exemplo. Maiores detalhes podem ser encon-
trados em (SILVA, 2009).

O princ??pio de um forno e? a troca de calor e isso e? obtido pela
queima de um combust??vel, o que libera gases quentes e, esses, em
contato com uma serpentina em seu interior, fornecem calor a um flu??do.
Um forno possui tre?s partes principais:

• ca?mara de radiac?a?o: regia?o onde esta?o os queimadores (responsa?veis
pela queima do combust??vel) e uma parte da serpentina para troca
de calor

• zona de convecc?a?o: regia?o onde se encontra a outra parte da



42

serpentina

• chamine?: trecho por onde os gases da combusta?o sa?o lanc?ados a?
atmosfera

Figura 6: Forno em uma planta industrial. Fonte: (SILVA, 2009)

A figura 6 ilustra um forno industrial. Dado o funcionamento
mais ba?sico do forno, e? necessa?rio entender a composic?a?o sua ba?sica,
seus instrumentos e sua interac?a?o no processo de gerac?a?o e troca de
calor. Alguns dos instrumentos pertinentes a um forno sa?o:

• queimadores: sa?o os instrumentos responsa?veis pela liberac?a?o de
calor necessa?rio atrave?s da queima de combust??veis



43

• piloto: responsa?veis pela chama piloto de cada queimador. A
figura 7 ilustra o conjunto queimador e piloto

• vaso de knock-out e? um tanque localizados a montante dos quei-
madores responsa?veis pela retirada de umidade presente no ga?s
para a sua melhor queima

• va?lvulas de bloqueio: duas va?lvulas anteriores ao queimador e
posteriores ao vaso de knock-out que possuem o objetivo de na?o
permitir o vazamento de gases

• va?lvula de ventilac?a?o: presente entra as va?lvulas de bloqueio e
responsa?vel por eliminar qualquer pressa?o que possa existir antes
da segunda va?lvula de bloqueio causada por qualquer vazamento
na primeira va?lvula de bloqueio.

• vapor de abafamento: vapor utilizado na purga do sistema para
expulsa?o de gases indesejados que poderiam causar exploso?es

• damper: registro instalado na chamine? para controle de vaza?o de
gases ou tiragem dos gases de combusta?o

Figura 7: Esquema de um queimador e seu piloto.Fonte: (SILVA, 2009)

Os componentes ba?sicos para o entendimento foram descritos,
ale?m disso, o forno possui um sistema para reaproveitamento de ga?s
residual. Por esse sistema, ga?s de purga da unidade de gerac?a?o de
hidroge?nio sa?o reaproveitados como ga?s combust??vel no forno. Uma
unidade de gerac?a?o de hidroge?nio recebe uma mistura de ga?s que pos-
sui H2, CO2 e CH4 e separa o H2 dos demais gases e os envia para a
unidade de hidrotratamento. A figura 8 ilustra os equipamentos des-
critos anteriormente e sua interac?a?o juntamente com uma unidade de
hidrotratamento.



44

Figura 8: Esquema de um forno industrial com uma unidade de hidro-
tratamento

3.2 METODOLOGIA DE DESENVOLVIMENTO DE PROJETO DA
INDU?STRIA DE PETRO?LEO E GA?S

A metodologia implementada atualmente para o desenvolvimento
de projeto da indu?stria de petro?leo e ga?s inclui a criac?a?o de uma se?rie
de documentos numa determinada ordem e cada documento prove? in-
formac?o?es importantes para o desenvolvimento do projeto. Para melhor
explicar esta metodologia, primeiramente, sera?o enumerados os tipos de
documentos presentes em um projeto e as informac?o?es contidas em cada
um, e, em seguida, sera? apresentada a metodologia de desenvolvimento
de projeto, ressaltando os documentos diretamente relacionados com o
programa de software desenvolvido para o CLP.

De acordo com normas internas a? Petrobras (COMISSa?O DE NOR-
MAS Te?CNICAS, 2002), alguns documentos sa?o considerados essenciais
para qualquer projeto. Os documentos que todo projeto deve possuir
sa?o:

• fluxograma de processo: o fluxograma de processo deve conter a
representac?a?o simplificada das malhas de controle, identificando
a varia?vel, func?a?o, localizac?a?o e conter, ainda, as va?lvulas de con-



45

trole, seguranc?a e al??vio. A figura 9 exemplifica um fluxograma
de uma vaso de knock-out .

Figura 9: Exemplo de uma parte de um fluxograma de processo refe-
rente a um vaso de knock-out

• folhas de dados de processo: devem conter informac?o?es ba?sicas
de processo que permitam a correta selec?a?o e dimensionamento
dos instrumentos.

• matriz causa e efeito: mostra o inter-relacionamento entre os
eventos anormais poss??veis de ocorrer durante a operac?a?o nor-
mal da planta ou de um equipamento em particular e as ac?o?es
que devem ser tomadas pelo sistema de seguranc?a, como tambe?m
manobras operacionais espec??ficas. A figura 10 apresenta algumas
relac?o?es referentes a? planta ja? apresentada.

• lista de instrumentos preliminar: e? um guia de acesso aos do-
cumentos de instrumentac?a?o do projeto ba?sico. Deve conter to-
dos os instrumentos da unidade, localizando-os por fluxogramas e
dando informac?o?es ba?sicas relativas aos instrumentos como: sua
situac?a?o f??sica (campo, painel, func?a?o em sistema digital, etc.).
O documento que conte?m os dados para especifica?-lo e seu tipo
ba?sico (placa, venturi, termopar, etc.)

• fluxograma de engenharia preliminar: Quanto a? instrumentac?a?o,
o Fluxograma de Engenharia deve conter as malhas de controle



46

Figura 10: Exemplo de relac?a?o contida na matriz causa e efeito para a
planta apresentada

explicitando as func?o?es dos instrumentos, sua identificac?a?o preli-
minar usada como refere?ncia no projeto ba?sico e a localizac?a?o de
cada instrumento. Deve conter tambe?m, notas explicativas que
explicitem recomendac?o?es e exige?ncias do projeto ba?sico quanto
a? instalac?a?o, a? locac?a?o detalhada ou outros requisitos ligados a?
instrumentac?a?o.

Alguns processos, por serem processos cr??ticos necessitam de al-
guns documentos extras. Eles sa?o:

• especificac?a?o para projeto de detalhamento: deve ser emitida na
fase inicial do projeto e apresentar os fundamentos ba?sicos de



47

instrumentac?a?o que devem orientar a execuc?a?o das especificac?o?es
e dos demais documentos do projeto de detalhamento.

• memorial descritivo: deve conter informac?o?es ba?sicas que per-
mitam a completa especificac?a?o de equipamentos e instrumentos
para os diversos sistemas de instrumentac?a?o ale?m de sequencia-
mentos presentes na planta. A figura 11 apresenta um exemplo
de um sequenciamento, representado por um fluxograma, contido
no memorial descritivo da planta utilizada como exemplo.

Figura 11: Exemplo de sequenciamento encontrado em memorial des-
critivo

• diagrama lo?gico: Deve ser baseado nos memoriais descritivos para
os sistemas de protec?a?o, intertravamento e sinalizac?a?o-alarme e
deve, ainda, ser construindo utilizando a?lgebra de Boole. Este
documento tem por finalidade representar toda a lo?gica de inter-
travamento do projeto e pode ser pensado como uma pre?via do
programa final do CLP. A figura 12 apresenta um trecho um um
diagrama lo?gico.

• desenhos de instalac?a?o para itens referentes a tecnologia pro?pria
indispensa?vel ao funcionamento do processo: neste documento
devem ser somente emitidos aqueles desenhos, os quais referem-
se a instalac?a?o de instrumentos especiais, com tecnologia pro?pria,
e que necessitam de informac?o?es destes documentos para o seu
correto funcionamento.



48

• arranjo preliminar do painel de controle: Deve mostrar a dis-
tribuic?a?o dos instrumentos, alarmes, chaves, la?mpadas, espac?os
reservados e demais dispositivos instalados na parte frontal do
painel de controle com suas respectivas identificac?o?es.

Figura 12: Exemplo de diagrama lo?gico

• manual de operac?a?o.

• arquitetura de instrumentac?a?o.

• lista de varia?veis (entradas e sa??das);

• folha de dados de instrumentac?a?o para instrumentos especiais:
quando o projeto envolver instrumentos especiais como sistemas
termome?tricos especiais, sistemas de n??vel de uso pouco comum
(como sistema radioativos) ou instrumentos cuja especificac?a?o
deve ser espec??fica por exige?ncias de processo, estes instrumen-
tos devem ter seus dados definidos no Projeto Ba?sico. As folhas
de dados para este caso devem conter as informac?o?es necessa?rias
ao desenvolvimento do Projeto Executivo e a? compra de instru-
mento.

• especificac?a?o te?cnica para sistemas especiais: Quando o projeto
envolve sistemas pouco comuns ou que incorporem exige?ncias es-
critas do processo, estes devem ter sua especificac?a?o preliminar
elaborada no projeto Ba?sico. Tal especificac?a?o deve conter as
exige?ncias operacionais e construtivas fixadas pelo processo e to-
das as informac?o?es que se vincularem a? exige?ncia tecnolo?gica do
processo

• diagramas de controle avanc?ado.

• descritivos das malhas de controle avanc?ado: Deve conter ex-
plicac?o?es sobre o objetivo e forma de funcionamento das ma-
lhas de controle avanc?ado, bem como explicitar as equac?o?es e



49

para?metros a serem ajustados nas func?o?es envolvidas nestas ma-
lhas.

• lista de varia?veis calculadas.

3.3 METODOLOGIA PARA DESENVOLVIMENTO DO SOFTWARE
DE CLP

Dentre os documentos descritos anteriormente, alguns esta?o mais
ligados a? criac?a?o do programa de intertravamento desenvolvido para o
programa de CLP que outros. Dentro dos documentos dispon??veis,
pode-se citar:

• Fluxograma de processo

• Matriz Causa e Efeito

• Memorial descritivo

• Diagrama lo?gico

Ainda dentro dos documentos relacionados com o programa de
CLP, existe uma documento criado exclusivamente para testar o pro-
grama de intertravamento e garantir que esse apresenta um comporta-
mento esperado. Tal documento e? o ”Teste de aceitac?a?o de fa?brica” e
apresenta em forma textual como os testes devem ser realizados para
que o programa de intertravamento seja aprovado.

E? importante tambe?m ressaltar na?o somente quais os documen-
tos utilizados num processo de automac?a?o ou quais sa?o utilizados na
gerac?a?o de co?digo para o CLP, mas tambe?m como se da? sua interac?a?o
durante o processo de automac?a?o. Na metodologia de desenvolvimento
da Petrobras, dentre os documentos citados na sec?a?o anterior, o pri-
meiro documento a ser desenvolvido e? o fluxograma de processo e, a
partir das informac?o?es deste documento, a Matriz Causa e Efeito e o
memorial descritivo sa?o criados.

A gerac?a?o das relac?o?es pertencentes a? matriz causa e efeito e? ba-
seada em informac?o?es do fluxograma de processos (relac?a?o entre equi-
pamentos destinados a? seguranc?a e sinais de sensores que devem ativar
ou desativar tais equipamentos) em conjunto com os especialistas do
projeto. Para o memorial descritivo, sa?o utilizadas informac?o?es do flu-
xograma de processo e tambe?m conhecimento de especialistas do pro-
jeto para definic?a?o de especificac?o?es de equipamentos e sequenciamentos
para a planta.



50

A informac?a?o conjunta dos dois u?ltimos documentos (matriz
causa e efeito e memorial descritivo) permite a criac?a?o do diagrama
lo?gico e do teste de aceitac?a?o de fa?brica. O diagrama lo?gico gera o pro-
grama de CLP e o TAF e? utilizado durante a fase de testes do programa
do CLP. O diagrama lo?gico conte?m as lo?gicas do futuro programa de
CLP e, as informac?o?es que definem essas lo?gicas sa?o obtidas das des-
cric?o?es encontradas no memorial descritivo assim como nas relac?o?es
existentes na matriz causa e efeito. A figura 13 apresenta esquemati-
camente a gerac?a?o dos documentos durante o processo de automac?a?o.
Em geral, a programac?a?o propriamente dita do CLP e? feita por uma
empresa terceirizada e, apo?s a entrega dos equipamentos utilizados na
programac?a?o, a Petrobras realiza o teste de aceitac?a?o de fa?brica para
definir se o programa gravado no CLP e? va?lido ou na?o. Caso seja
encontrado algum erro, o CLP e? retornado para reprogramac?a?o.

Figura 13: Metodologia de desenvolvimento de projetos na Petrobras

3.4 LIMITAC?O?ES DA METODOLOGIA ATUAL

Na metodologia atual de desenvolvimento, o resultado final, isto
e?, o programa de CLP, e? uma traduc?a?o direta das informac?o?es contidas
no diagrama lo?gico e na matriz causa e efeito para uma lo?gica Ladder.



51

Os testes realizados em seguida sa?o criados a partir de conhecimento
pre?vio de engenheiros envolvidos no projeto ale?m de informac?o?es dos
documentos existentes.

O per??odo reservado para a aprovac?a?o do CLP ja? programado e?
relativamente curto, o que resulta na necessidade de realizac?a?o de va?rios
testes em um curto espac?o de tempo. Isso pode resultar em testes com
resultados incorretos caso alguma especificac?a?o no documentos de testes
na?o seja seguida corretamente. Ainda, os testes sa?o realizados com o
CLP ja? em ma?os da Petrobras, e, caso algum erro seja encontrado, este e?
devolvido a? terceirizada para correc?a?o. Esta abordagem pode provocar
atrasos por exigir o translado do CLP entre terceirizada e Petrobras
para cada teste, ale?m de exigir o deslocamento de, pelo menos uma
pessoa, para a realizac?a?o dos testes durante as u?ltimas etapas de um
projeto de automac?a?o.

A criac?a?o de um teste de aceitac?a?o de fa?brica deve conter, ao
menos, uma quantidade m??nima de testes para se validar um programa
de CLP. Nem todos os casos de teste que um especialista pode conceber
sa?o inseridos no documento, afinal, o tempo para a realizac?a?o dos testes
e? uma varia?vel de grande importa?ncia e, cada teste extra, exige mais
tempo para validac?a?o do programa de CLP. Esta abordagem portanto
e? um teste parcial, e os problemas de configurac?a?o do CLP va?o aparecer
durante a partida e a operac?a?o da planta, acarretando problemas de
seguranc?a ou paradas da produc?a?o, com altos custos.

3.5 COMENTA?RIOS FINAIS

Neste cap??tulo abordada-se a atual metodologia de desenvolvi-
mento de projetos utilizada pela Petrobras. Apresenta-se os documen-
tos utilizados nessa atual metodologia, sua interac?a?o para a gerac?a?o do
software de CLP e a realizac?a?o de testes sobre tal CLP. Ale?m disso,
tambe?m apresenta-se limitac?o?es da metodologia como tempo despren-
dido e nu?mero de testes realizado No pro?ximo cap??tulo, sera? apresen-
tada uma nova metodologia baseada em redes de Petri para a gerac?a?o
e realizac?a?o de testes baseada em um dos documentos do projeto.



52



53

4 PROPOSIC?A?O DE UMA NOVA METODOLOGIA
PARA GERAC?A?O E REALIZAC?A?O DE TESTES

No cap??tulo anterior, foi mostrada a metodologia atual de desen-
volvimento de programas em vigor na Petrobras. Neste cap??tulo, sera?
abordada uma nova metodologia proposta para a realizac?a?o de testes
baseada em documentos de projeto e sua aplicac?a?o. Num primeiro mo-
mento, a metodologia sera? explicada a partir de uma visa?o geral e em
seguida os passos envolvidos com essa metodologia sera?o detalhados.

4.1 VISA?O GERAL DA METODOLOGIA E SUA INSERC?A?O NO
DESENVOLVIMENTO DO PROJETO

O propo?sito da metodologia a ser apresentada neste cap??tulo e?
ser integrada a? metodologia de projeto ja? existente na Petrobras e,
para tal, algumas caracter??sticas que tornam essa integrac?a?o mais su-
til sa?o extremamente deseja?veis pois aumentam o aceite por parte dos
engenheiros. A introduc?a?o de uma nova fase em uma metodologia de
desenvolvimento de projetos ja? consolidada se apresenta como um desa-
fio por lidar com ha?bitos ja? antigos, bem estabelecidos e transmitidos
entre gerac?o?es de funciona?rios. Para uma boa integrac?a?o e uma boa
aceitac?a?o por parte dos desenvolvedores, as seguintes caracter??sticas
foram buscadas:

• A Metodologia deve trabalhar com informac?o?es ja? existentes

• A Metodologia deve evitar o aumento do tempo de projeto

• A Metodologia deve possuir uma fa?cil usabilidade

• A Metodologia deve apresentar resultados facilmente entendidos
e aproveita?veis

Levando o citado em considerac?a?o, o primeiro passo para a espe-
cificac?a?o da metodologia e? definir em que momento, durante o projeto,
ela deve ser utilizada e, em conseque?ncia, quais informac?o?es sera?o uti-
lizadas.

Como mostrado anteriormente, a metodologia atual segue a uma
ordem de desenvolvimento como demonstrado na figura 13. A proposta
e? introduzir a nova metodologia ao fim do desenvolvimento do programa
de CLP, para utilizac?a?o do CLP ja? programado como uma das entra-
das para o teste. Outra entrada sa?o as informac?o?es da matriz causa e



54

efeito e tambe?m uma simulac?a?o da planta. A sa??da apo?s a realizac?a?o de
testes e? um texto em formato de Log que apresenta os testes realizados
(seque?ncia de ac?o?es tomadas) e os resultados - sucessos ou falhas do
programa. A figura14 apresenta a introduc?a?o da metodologia dentro
do processo de desenvolvimento de um projeto. Outra caracter??stica
importante ao se propor esta metodologia e? que ela pode ser imple-
mentada em paralelo com a metodologia ja? existente. Esse paralelismo
permite uma adere?ncia melhor ao permitir comparac?a?o entre ambas
metodologias.

Figura 14: Inserc?a?o da metodologia no desenvolvimento do projeto.

Dentre os documentos descritos no cap??tulo 3, alguns possuem
uma relac?a?o direta ou quase direta com o co?digo Ladder gerado e dois
devem ter sua importa?ncia ressaltada: a matriz causa e efeito e o dia-
grama lo?gico. Ambos sa?o intimamente relacionados com o co?digo de-
senvolvido para o CLP e possuem uma relac?a?o direta com o co?digo
gerado, isto e?, a informac?a?o contida nesses documentos e? traduzida
diretamente para co?digos Ladder sem maiores mudanc?as das lo?gicas
presentes ou necessidade de grandes interpretac?o?es.

O diagrama lo?gico, assim como exposto anteriormente, e? gerado
a partir de documentos iniciais de descric?a?o do sistema (memorial des-
critivo, matriz causa e efeito e fluxograma de processo). Tal aborda-



55

gem envolve a gerac?a?o de uma lo?gica em um documento atrave?s de
interac?o?es, sem teste ou verificac?o?es realizadas sobre essa mesma lo?gica
e pode resultar em uma lo?gica com falhas. O resultado final da criac?a?o
do diagrama lo?gico, pode, dessa maneira, possuir erros de lo?gica ou
ainda estar incompleto. Na?o se pode enta?o, utilizar o diagrama lo?gico
como especificac?a?o para a gerac?a?o de testes exatamente porque essa es-
pecificac?a?o utilizada na criac?a?o do programa Ladder pode conter erros
e, mesmo uma verificac?a?o baseada em model checking, que utilize essa
lo?gica como base, na?o garante o correto funcionamento do programa
Ladder.

Enta?o, para a realizac?a?o dos testes, escolheu-se a matriz causa e
efeito como ponto de partida por 2 motivos principais: esse documento
esta? presente durante todo o projeto, acompanha todo o processo de
desenvolvimento e apresenta, ainda, requisitos funcionais do projeto.
Por esse documento exibir os dados nele contidos, a relac?a?o entre sinais
de campo e sinais para atuadores no campo, de maneira constante e
baseada em regras, ele possui certa formalidade. Ele na?o esta? sujeito
a representac?o?es puramente textuais, as quais, normalmente, tem a
problema?tica de necessitar de interpretac?a?o humana, estando sujeitas
a ambiguidade, e podem apresentar diversas variac?o?es dependendo do
engenheiro responsa?vel por sua criac?a?o.

A partir das informac?o?es contidas na matriz sa?o gerados testes
para o programa e sa?o tambe?m criados observadores baseados em redes
de Petri para representar o comportamento esperado para o software
de CLP. O processo de gerac?a?o de testes resulta em uma seque?ncia de
entradas para o CLP que e? utilizada enta?o para a realizac?a?o dos testes.
Atrave?s de um protocolo industrial, o CLP tem seu programa execu-
tado com suas entradas forc?adas, de acordo com aquilo estipulado na
seque?ncia de entradas, e uma planta simulada e? utilizada como substi-
tuta para a planta real. Os dados de sa??da do CLP, sa?o armazenados
para posterior comparac?a?o com os observadores gerados anteriormente.

Os observadores criados anteriormente sa?o enta?o utilizados como
base para a validac?a?o do teste. Eles conte?m o comportamento esperado
para o sistema e sa?o executados utilizando os valores armazenados du-
rante o teste. A partir do estado final alcanc?ado por esses observadores,
e? poss??vel concluir se houve um erro ou na?o. Os resultados finais, ou
seja, a presenc?a ou na?o de erros, o estado final alcanc?ado pelo obser-
vador e os sinais envolvidos sa?o enta?o apresentados para o usua?rio. A
figura 15 apresenta a metodologia explicada anteriormente numa visa?o
geral.



56

Figura 15: Visa?o geral da metodologia proposta

4.2 GERAC?A?O DE OBSERVADORES

Um dos passos da metodologia deste documento e? a gerac?a?o de
redes de Petri a partir das informac?o?es contidas na matriz causa e
efeito. Escolheu-se representar as informac?o?es atrave?s de redes de Pe-
tri por permitirem uma fa?cil modelagem de eventos paralelos e, por
conseguir representar um grande nu?mero de diferentes estados utili-
zando um nu?mero reduzido de lugares. A utilizac?a?o de uma abordagem
formal bem estabelecida como as redes de Petri para a representac?a?o
das informac?o?es e? importante por ser bem aceita pela comunidade de
pesquisa, por facilitar a implementac?a?o de ferramentas que utilizem
essa abordagem e ainda por permitir que os modelos criados sofram
operac?o?es de maneira a se obter novos modelos mais completos.

Dentre aquilo que se deseja observar do sistema programado,
existem o caso de uma sa??da de CLP que deveria ser ativada mas na?o
foi e o caso de uma sa??da de CLP que foi ativada sem a necessidade
de ser. Esses casos sa?o respectivamente os falsos negativos e os falsos
positivos. Os observadores aqui tratados sa?o constru??dos para tratar



57

dos casos de falsos negativos, ou seja, eles sa?o utilizados para observar
se o sistema deixou de ativar alguma sa??da quando necessa?rio.

Seguindo a visa?o geral apresentada na sec?a?o 4.1, a partir do do-
cumento inicial, seguem duas etapas que utilizam as informac?o?es desse
documento. A criac?a?o de redes de Petri que representam as informac?o?es
contidas nesse documento e a definic?a?o dos testes que sera?o gerados.

A matriz causa e efeito apresenta as informac?o?es de sensores de
campo em linha e de acionamentos em coluna. O objetivo das redes de
Petri geradas e? apresentar um sistema reativo que possa ser utilizado
mais tarde para comparac?a?o dos resultados obtidos em teste. Para a
definic?a?o dessas redes de Petri, foram analisadas os diferentes tipos de
sinais vindos do campo, sua relac?a?o com os acionamentos e suas carac-
ter??sticas que deveriam estar presente no modelo criado. As entradas
foram dividas em grupos que possuem caracter??sticas semelhantes, os
grupos sa?o:

• Entradas boleanas simples

• Grupo de entradas boleanas

• Votac?a?o de sinais de campo

• Entradas boleanas com mu?ltiplos efeitos temporizados

Para cada um dos tipos de entradas foram definidas redes que
apresentam algumas caracter??sticas ba?sicas:

• Um sinal vindo do campo, se na?o tratado, deve caracterizar mais
tarde uma falha no software

• Se todos os passos necessa?rios para o correto tratamento do sinal
forem realizados, a execuc?a?o com sucesso deve ser identificada

A seguir as redes definidas sera?o apresentadas. Redes com mai-
ores detalhes desenvolvidas a partir de uma matriz causa e efeito real
juntamente com uma planta exemplo selecionada para melhor compre-
ensa?o sera?o abordadas no cap??tulo 5.

Dado que o sistema(CLP programado) a ser testado e? um sis-
tema do tipo caixa-preta, ou seja, somente se tem acesso a?s entradas
e sa??das do sistema, escolheu-se trabalhar com observadores para o di-
agno?stico de poss??veis erros. A opc?a?o por se utilizar observadores para o
diagno?stico de erros no programa se da? pelo fato de que o sistema (CLP
programado) e? do tipo caixa-preta, e, os observadores, como explicado,
na?o devem ser intrusivos, ou seja, na?o devem alterar o comportamento



58

do sistema sendo observado. Essa caracter??stica mandato?ria do obser-
vador esta? em concorda?ncia com o necessa?rio para o diagno?stico em
um sistema caixa-preta, uma vez que o programa do CLP na?o pode ser
alterado.

Dentre as informac?o?es contidas na matriz causa e efeito, se de-
seja poder observar se a relac?a?o estipulada entre causa e efeito foi cum-
prida. Cada causa possui um ou mais efeitos correspondentes e sa?o
esses efeitos que se deseja observar. As redes de Petri aqui geradas
sa?o enta?o observadores do sistema que representam as propriedades a
serem observadas no programa de CLP e, assim como um observador,
na?o introduzem novas informac?o?es no sistema sendo utilizadas somente
para se observar a presenc?a de falha ou na?o. Elas sa?o utilizadas para
determinar se os valores obtidos pelo teste sa?o aqueles que deveriam
ser obtidos por um programa que segue as especificac?o?es encontradas
na matriz causa e efeito.

No decorrer desta sec?a?o, sera?o apresentados os observadores de-
senvolvidos para o caso de estudo.

4.2.1 Observadores ba?sicos

4.2.1.1 Entradas boleanas simples

O caso mais simples existente no projeto e? a relac?a?o direta en-
tre uma entrada e uma sa??da na matriz causa e efeito. O modelo que
representa esse caso e? apresentado na figura 16 onde a entrada e? ”Des-
ligamento Manual” e a sa??da e? ”Vapor de abafamento”. Os lugares
”Desligamento manual”e ”Abertura do vapor de abafamento”indicam
o recebimento de um sinal de campo para desligamento manual e o
envio de um sinal para a abertura de uma va?lvula de abafamento res-
pectivamente.

Para esse modelo, o comportamento esperado pode ser analisado
da seguinte maneira: quando o comando para desligamento manual e?
enviado ao CLP, o tempo da transic?a?o t0 passa a decorrer e, se ate?
o tempo limite t1 o lugar ”Vapor de abafamento”na?o houver recebido
uma ficha, indicando que a va?lvula de abafamento na?o foi aberta, a
transic?a?o time out dispara sinalizando que o sistema atingiu um estado
indeseja?vel. Nesse caso, isso significa que o sistema na?o executou a
ac?a?o de abrir o vapor de abafamento dentro de um tempo limite t1.
Caso a ficha seja adicionada dentro do tempo limite, a rede alcanc?a
um estado que representa enta?o o funcionamento desejado para essa



59

relac?a?o espec??fica.

Figura 16: Observador em redes de Petri para uma entrada boleana
simples

4.2.1.2 Grupos de entradas boleanas

Um tipo de entrada presente no documento e? a existe?ncia de um
nu?mero m??nimo de sinais dentro de um determinado conjunto. Como
exemplo temos ”tre?s ou mais queimadores sem chama”, ou seja, para
todos os queimadores da planta, se no m??nimo tre?s deles ficarem sem
chama, o co?digo referente a essa linha deve ser executado no programa
de CLP. Para representar essa relac?a?o, a rede de Petri representada na
figura 17 foi desenvolvida. Os sinais utilizados sera?o, a t??tulo de exem-
plificac?a?o somente, ”Tre?s ou mais queimadores sem chama”e ”Vapor de
Abafamento”como no exemplo anterior.

Ela apresenta um comportamento parecido com o ja? descrito
para a entrada boleana simples. A diferenc?a se da? que aqui, o arco
para o disparo da transic?a?o tem peso 3, indicando a necessidade da
existe?ncia de tre?s fichas (tre?s queimadores sem chama) para a execuc?a?o



60

da rede.

Figura 17: Modelo para um grupo de entradas boleanas

4.2.1.3 Votac?a?o de sinais de campo

Outro caso presente na matriz causa e efeito e? a votac?a?o um de
dois(1oo2) e a votac?a?o dois de tre?s(2oo3). Essas votac?o?es sa?o utilizadas
quando um sinal lo?gico possui mais de um sinal f??sico no campo, isto
e?, quando dois transdutores diferentes oferecem ao sistema de controle
um valor redundante e os dois sinais, um de cada transdutor, que che-
gam ao CLP devem ser considerados na escolha da ac?a?o a ser tomada.
Na votac?a?o 1oo2, dois sinais chegam do campo e, se um deles estiver
ativo, enta?o o resultado da votac?a?o deve ser considerado ativo enquanto
na votac?a?o 2oo3, e? necessa?rio que no m??nimo 2 de 3 sinais estejam em
concorda?ncia(e ativos) para que o resultado da votac?a?o seja conside-
rado. As figuras 18 e 19 mostram os casos para votac?a?o 1oo2 e 2oo3
respectivamente.

Nesses modelos os lugares ”sinal n”com n sendo 1, 2 ou 3 sa?o
os lugares que representam os sinais vindo de campo, o lugar ”realizar
votac?a?o”assegura que somente uma ficha seja repassada para o lugar
”resultado votac?a?o”.



61

Figura 18: Modelo para um caso de votac?a?o 1oo2

4.2.1.4 Entradas boleanas com mu?ltiplos efeitos temporizados

Outro caso comum e? a existe?ncia de sequenciamentos dentro do
sistema. Para exemplificar um sequenciamento, uma nota presente na
matriz causa e efeito e? apresentada na figura 20. Neste caso, a nota
apresenta tre?s passos que devem ser realizados, em ordem: e? necessa?rio
fechar a primeira va?lvula de bloqueio, em seguida, fechar a va?lvula de
ventilac?a?o e, apo?s 5 segundos, fechar a segunda va?lvula de bloqueio. A
rede na figura 20 possui 4 lugares que representam os sinais de entrada
e sa??da sendo que os sinais ”fechar primeira va?lvula”, ”abrir va?lvula
de ventilac?a?o”e ”fechar segunda va?lvula”sa?o sinais de sa??da do CLP e
”Pressa?o muito alta no piloto”e? um sinal de entrada do CLP. Nesse
modelo o caminho composto pelas transic?o?es t1, t4, t6 e t10 represen-
tam o caminho esperado para o funcionamento correto. As transic?o?es
t0, t2, t5, t7, t9 e t12 apresentam poss??veis problemas na execuc?a?o do
modelo.

t1, t4, t6 e t10 sa?o respectivamente as transic?o?es que representam
o fechamento da primeira va?lvula, a abertura da va?lvula de ventilac?a?o,
a espera de 5 segundos antes do fechamento da segunda va?lvula e o fe-
chamento da segunda va?lvula. Ja? t0, t2, t5, t7, t9 e t12 sa?o, em ordem,
um time-out para o na?o fechamento da primeira va?lvula, a abertura
da va?lvula de ventilac?a?o antes do fechamento da primeira va?lvula de
bloqueio, o time out da abertura da va?lvula de bloqueio, o fechamento
da segunda va?lvula antes da abertura da va?lvula de ventilac?a?o, o fecha-



62

Figura 19: Modelo para um caso de votac?a?o 2oo3

mento da segunda va?lvula de bloqueio antes de passados 5 segundos e
o time out para o fechamento da segunda va?lvula de bloqueio.

4.2.2 Composic?a?o de observadores

Um mesmo sinal de sensor de campo pode necessitar de diferen-
tes tratamentos de acordo com sua relac?a?o com acionamentos. Assim,
uma entrada boleana simples pode ainda ser tambe?m uma votac?a?o 1oo2
ou 2oo3. Caso o sinal seja deste tipo, e? necessa?rio uma fusa?o entre as
redes correspondentes. Como visto na sec?a?o 2.1.2, a fusa?o de duas redes
de Petri ou, nesse caso, observadores e? feita pela unia?o ou dos estados
ou das transic?o?es equivalentes entre esses modelos. Este me?todo per-
mite a manutenc?a?o das caracter??sticas de modelos individuais enquanto
permite a criac?a?o de um modelo maior e mais completo. Para exem-
plificar a fusa?o de observadores, a figura 21 apresenta a fusa?o entre a
votac?a?o 1oo2 e o caso para uma entrada boleana simples apresentado
anteriormente.

4.3 GERAC?A?O DE TESTES

Assim como apresentado na figura 15, paralelamente a? gerac?a?o
dos observadores, existe a gerac?a?o dos testes a serem realizados. Os
testes devem ser decididos a partir das informac?o?es de sinais de campo
e acionamentos presentes na matriz causa e efeito.



63

Figura 20: Modelo em redes de Petri para um caso onde uma nota
determina uma ordem de execuc?a?o

A quantidade total poss??vel de testes a serem realizados cresce
de acordo com o nu?mero de entradas existentes no sistema a ser tes-
tado. Como as entradas tratadas sa?o bina?rias podendo assumir 2
valores diferentes, o nu?mero total de combinac?o?es de entradas exis-
tentes em um sistema com n entradas e? de 2n. A fim de se evitar
esse crescimento exponencial, trabalha-se com particionamento de equi-
vale?ncia(BEIZER, 1990) para reduzir o nu?mero de testes realizados e na?o
limitar a aplicac?a?o da metodologia a? pequenos projetos. Entre todas
as combinac?o?es poss??veis que afetam um observador, opta-se por utili-
zar as entradas que afetam somente o observador em questa?o. Desta
maneira, algumas regras que norteiam a escolha das entradas para os
testes foram definidas. Para tal, as entradas foram divididas numa ma-
neira ana?loga aos diferentes tipos de observadores. Os diferentes testes
sa?o apresentados em seguida.

O primeiro tipo ba?sico de teste a ser realizado e? o seguinte:

• Para cada Linha da matriz, forc?ar o sinal de campo correspon-
dente a?quela linha

• Comparar o desenvolvimento das sa??das do CLP de acordo com
as redes de Petri criadas



64

Figura 21: Modelo para um caso de votac?a?o 1oo2, contorno pontilhado,
fundido com uma entrada boleana simples, contorno cont??nuo.

Esse primeiro teste simples permite afirmar, ao menos, que o
programa executa os trechos correspondentes a?s linhas da matriz causa
e efeito corretamente.

Um segundo tipo de teste gerado e? aquele correspondente a?
votac?a?o, isto e?, quando o sinal possui uma votac?a?o 1oo2 ou 2oo3. Para
estes casos, sa?o gerados diferentes casos de teste. Para a votac?a?o 1oo2,
existem 3 diferentes testes sendo eles a ativac?a?o de somente um dos
sinais de campo, a ativac?a?o do outro sinal de campo e a ativac?a?o si-
multa?nea de ambos os sinais de campo. Ja? para a votac?a?o 2oo3, existem
um total ma?ximo de quatro testes poss??veis que consistem na com-
binac?a?o dos tre?s sinais de campo existentes. Dados os sinais de campo
A, B e C para o caso de votac?a?o 2oo3, os testes poss??veis consistem na
ativac?a?o das entradas: AB, AC, BC e ABC

O terceiro tipo de teste gerado e? referente caso descrito na sec?a?o
4.2.1.2, quando nu?mero m??nimo de um grupo de sinais de campo deve
estar ativo para que se execute uma ac?a?o correspondente. Para este
caso, assim como para a votac?a?o 2oo3, existe uma combinac?a?o de entra-
das poss??veis para se realizar o teste. Dado m como o nu?mero m??nimo
de entradas necessa?rias para ativar a execuc?a?o e t como o nu?mero total
de sinais provenientes do campo, o nu?mero de testes pode ser dado pela



65

combinac?a?o de t m a m, ou ainda Ctm = t!/(m!(t?m)!).

4.3.1 Execuc?a?o dos testes

Os testes gerados sa?o armazenados na forma de uma lista que
indica, para cada caso de teste, qual entrada deve ser ativada. Durante
a execuc?a?o dos testes, o seguinte e? realizado:

• Acionamento/desativac?a?o de determinada entrada especificada
na lista de testes

• Inicio do armazenamento das varia?veis e do tempo, relativo ao
in??cio do teste, em que elas foram recebidas

• Aguardo do final do caso de teste

• In??cio do pro?ximo caso de teste na lista

4.4 EXECUC?A?O DOS OBSERVADORES A PARTIR DOS RESUL-
TADOS DOS TESTES

Ao final da realizac?a?o dos testes, existem diversos dados arma-
zenados(correspondentes a?s entradas e sa??das do CLP). Para cada caso
de teste realizado, os observadores equivalentes sa?o selecionadas e, uti-
lizando um jogador de redes de Petri e as informac?o?es armazenadas do
teste(inclusive tempo), compara-se os dados armazenados com os mo-
delos em redes de Petri. Um jogador de redes de Petri e? responsa?vel
pela execuc?a?o da rede de Petri e sua evoluc?a?o dada a marcac?a?o inicial.
No caso do jogador para esta metodologia, ale?m da marcac?a?o inicial,
ainda e? considerado a inserc?a?o de fichas de acordo com a presenc?a dos
sinais de entrada e sa??da. O jogador funciona executando o seguinte
ciclo enquanto restarem dados armazenados para cada caso de teste:

• Atualizac?a?o do tempo dos arcos

• Disparo dos arcos que podem ser disparados

• Atualizac?a?o dos valores das entradas e sa??das dos CLP (Inserc?a?o
de fichas nos lugares correspondentes)

Ao final, com os dados armazenados, o observador e? analisado
para verificar se um estado deseja?vel ou indeseja?vel foi alcanc?ado. Para



66

exemplificar a abordagem, considere a figura 22. Ela apresenta duas
execuc?o?es de testes diferentes, sendo que uma reconhece a existe?ncia
de um erro enquanto outra e? um teste executado com sucesso. Es-
tes dados sa?o referentes a? uma linha cujo modelo em redes de Petri
correspondente ao ja? apresentado na figura 16.

Figura 22: Dados armazenados apo?s duas execuc?o?es de testes diferentes

Ao seguir o ciclo estipulado anteriormente, tem-se que, para
a primeira execuc?a?o (tabela da esquerda), o lugar ”Ok”acaba com
uma ficha enquanto, para o segundo caso (tabela da direita), o lugar
”NOk”acaba com uma ficha. A partir dessa ana?lise, pode-se afirmar
que o teste referente a? tabela esquerda finalizou com sucesso enquanto,
em contrapartida, o teste relacionado com a tabela direita, indicou fa-
lha do programa de CLP.

4.5 COMENTA?RIOS FINAIS

Neste cap??tulo foram foram abordados os aspectos da metodo-
logia proposta para realizac?a?o de testes em projetos utilizando os do-
cumentos ja? existentes na metodologia de desenvolvimento de projeto
da Petrobras. Foram detalhadas as caracter??sticas componentes dessa
abordagem bem como sua aplicac?a?o para a gerac?a?o de testes. Os obser-
vadores abordados aqui sa?o modelados com o objetivo de verificar a pre-
senc?a de falsos negativos. A identificac?a?o dos falsos positivos tambe?m
e? importante uma vez que um CLP que ativa todas as suas sa??das para
qualquer sinal de entrada passaria no teste de falsos negativos. Para se
adicionar a detecc?a?o de falsos positivos, novos observadores deveriam
ser modelados com essa finalidade. Eles seriam comportados pela meto-



67

dologia proposta, sendo necessa?rio somente sua modelagem e adic?a?o no
processo de testes. Para tal modelagem, seguindo os mesmos princ??pios
dos observadores apresentados, seria necessa?rio definir a sa??da na?o dese-
jada e relaciona?-la com um lugar na?o desejado, um ”NOk”, numa lo?gica
contra?ria a?quela utilizada na definic?a?o dos observadores apresentados.



68



69

5 DESENVOLVIMENTO DE UMA FERRAMENTA
PARA SUPORTAR A METODOLOGIA PROPOSTA

Neste cap??tulo, sera? apresentada uma ferramenta desenvolvida
para a realizac?a?o de testes em um estudo de caso baseado no forno
ja? abordado no cap??tulo 3. Sera?o abordados os mo?dulos funcionais da
ferramenta, sua funcionalidade e tambe?m as limitac?o?es desta imple-
mentac?a?o em questa?o.

5.1 DESENVOLVIMENTO DE UMA FERRAMENTA DE TESTES
E VALIDAC?A?O DA METODOLOGIA

Para a criac?a?o da ferramenta, foi utilizada uma abordagem top-
down. A ferramenta foi definida partindo de viso?es gerais e enta?o,
foi especializada e especificada. Numa primeira interac?a?o o interfacea-
mento mais alto n??vel da ferramenta foi definido, ou seja, a entrada dos
dados contidos na matriz causa e efeito e a sa??da em formato de um
Log para posterior consulta. Como pro?ximo passo, foram decididos os
aspectos ba?sicos da ferramenta e, assim, o fluxo de informac?o?es dentro
da ferramenta foi especificado. Como entrada, tem-se as informac?o?es
da matriz causa e efeito e, a partir dessas informac?o?es, dois principais
”itens”devem ser gerados:

• Seque?ncias de inputs utilizados para execuc?a?o de seque?ncias no
CLP

• Modelos a serem utilizados para comparac?a?o da execuc?a?o real do
programa de CLP com a execuc?a?o esperada

A seque?ncia gerada e? enta?o utilizada na troca de informac?a?o
entre o CLP e a planta simulada. Essa troca produz uma se?rie de
valores(varia?veis da planta simulada e valores de sa??da do CLP), os
quais sa?o armazenados para uso posterior.

Apo?s a execuc?a?o das seque?ncias criadas, os valores armazenados
sa?o utilizados como base para comparac?a?o contra o comportamento
esperado. Esse comportamento esperado e? obtido a partir dos modelos
gerados no passo anterior. Da comparac?a?o, um log e? gerado e finalmente
apresentado ao usua?rio. Esta e? a abordagem ja? detalhada no cap??tulo
4.

A estrutura que compo?e a ferramenta foi subdividida em dife-
rentes mo?dulos responsa?veis, cada um, por parte das tarefas realizadas



70

durante a gerac?a?o e realizac?a?o de testes. Os mo?dulos sa?o os seguintes:

• Interface: responsa?vel por permitir a entrada de dados da ma-
triz causa e efeito e tambe?m processamento desses dados para
utilizac?a?o pelos mo?dulos seguintes

• Gerador de observadores: realiza a transformac?a?o dos dados em
observadores baseados em redes de Petri para serem utilizados
por outros mo?dulos

• Gerador de comandos: gera uma lista de testes a serem realizados
baseado nas informac?o?es contidas na interface

• Gravador de resultados do CLP: grava os dados do CLP e da
planta simulada durante o teste para futura comparac?a?o

• Comparador dos resultados com os observadores e gerador de
Log: utiliza dados gravados durante os testes para comparar os
comportamentos dos observadores e do sistema a fim de definir
se o comportamento foi o correto

• Comunicac?a?o OPC: realiza a comunicac?a?o OPC entre planta si-
mulada e ferramenta de testes

Os mo?dulos especificados interagem entre si trocando os dados
necessa?rios. Isso gera um fluxo dos dados e de transformac?a?o dos dados
dentro da ferramenta desde a informac?a?o crua da matriz causa e efeito
ate? o Log final gerado. A figura 23 apresenta os mo?dulos e tambe?m sua
interac?a?o.

5.2 ENTRADA DE DADOS

O objetivo da interface e? permitir que o usua?rio insira as in-
formac?o?es contidas matriz causa e efeito. Como visto no cap??tulo 3, a
matriz possui algumas informac?o?es textuais ale?m da relac?a?o direta en-
tre sinal de campo e sinal de entrada. O usua?rio tambe?m deve ser capaz
de inserir essas informac?o?es de maneira que elas possam ser utilizadas
posteriormente para a criac?a?o de modelos.

Para a representac?a?o dos dados, foi escolhido a transformac?a?o
de toda a informac?a?o visual contida na matriz causa e efeito para uma
informac?a?o textual que possa ser facilmente analisada, transformada e
utilizada. Este arquivo de texto conte?m a informac?a?o da matriz causa e
efeito de uma maneira ordenada e e? dividido em duas partes principais:



71

Figura 23: Mo?dulos da ferramenta e fluxo de informac?a?o entre mo?dulos

uma se?rie de sinais que correspondem a?s colunas e, ao fim destes, uma
se?ries de sinais que correspondem a?s linhas.

5.3 GERAC?A?O DE OBSERVADORES

Um dos aspectos chave da ferramenta criada e? a gerac?a?o de ob-
servadores baseados em redes de Petri a partir das informac?o?es con-
tidas na matriz causa e efeito. A ferramenta deve ser capaz de criar
va?rias insta?ncias de observadores, cada um adaptado para um sinal de
campo(causa) e atuador(efeito) diferentes. Para atingir tal objetivo,
foram definidas estruturas gene?ricas para as redes de Petri utilizadas
para os observadores. Essas estruturas sa?o mais tarde especificadas
para adequar o observador a? um conjunto de sinais espec??ficos. A fi-
gura 24 sumariza os passos para a obtenc?a?o de observadores.

O exemplo de observador dado para a figura 25 e? parte do banco
de observadores presente na ferramenta. Os locais dessa rede possuem
os nomes gene?ricos ”fromfieldsignal1”e ”tofieldsignal1”propositalmente.
Eles representam os sinais de entrada do campo e de sa??da para o
campo. Ao instanciar um observador, a ferramenta o torna u?nico subs-
tituindo esses nomes pelos sinais existentes na matriz causa e efeito.
Assim, a instanciac?a?o de um observador na ferramenta funciona da se-



72

Figura 24: Passos para se obter os observadores a partir do banco de
observadores

guinte maneira: e? escolhida uma definic?a?o ja? existente, os nomes dos
lugares sa?o substitu??dos de maneira a representar corretamente uma
relac?a?o na matriz causa e efeito e, em seguida, pode ser armazenada
para posterior uso. Para o caso descrito, ”fromfieldsignal1”deve ser
substitu??do pelo nome da varia?vel contida na linha da matriz causa
e efeito enquanto ”tofieldsignal1”deve ser substitu??do pelo nome da
varia?vel na coluna da matriz causa e efeito. Levando-se em considerac?a?o
a primeira linha da matriz causa e efeito da planta exemplo e a se?tima
coluna da mesma, temos como causa o sinal ”PSHH-014A/B/C”e como
efeito, o equipamento ”XY-037”. Para a obtenc?a?o da primeira rede ne-
cessa?ria para o observador correspondente, o nome ”fromfieldsignal1”e?
substituido por ”PSHH-014A/B/C”enquanto o nome ”tofieldsignal1”e?
substituido por ”XY-037”. O resultado e? o visto na figura 26.

Um outro caso importante na criac?a?o dos observadores e? quando
se faz necessa?rio a fusa?o de duas redes diferentes para se obter o ob-
servador desejado. Para tal fim, assim como descrito anteriormente, os
observadores ja? existentes nos bancos de observadores sa?o especificados
de acordo com os sinais correspondentes na matriz causa e efeito e,
enta?o, suas informac?o?es sa?o fusionadas a fim de se obter o observador
completo. Para o mesmo conjunto de sinais ”PSHH-014A/B/C”e ”XY-
037”observa-se que e? necessa?rio ainda a especificac?a?o de uma votac?a?o
2oo3, assim como esta? definido na matriz causa e efeito na coluna ”no-
tas”. A votac?a?o 2oo3 tambe?m possui um observador ja? definido com
nomes gene?ricos e a substituic?a?o destes nomes pelos conjuntos de sinais



73

Figura 25: Exemplo de observador que compo?e o banco de observadores

”PSHH-014A/B/C”e ”XY-037”resulta na rede vista na figura 27.
O u?ltimo passo para a obtenc?a?o do observador completo que

relaciona os sinais ”PSHH-014A/B/C”e ”XY-037”e? enta?o a fusa?o das
duas redes apresentadas nas figuras 26 e 27. Como resultado desta
fusa?o obte?m-se a rede de Petri apresentada na figura 28. Esta rede e? o
observador completo para os sinais ”PSHH-014A/B/C”e ”XY-037”.

5.4 DEFINIC?A?O DOS CASOS DE TESTE E GERAC?A?O DE CO-
MANDOS

A partir das entradas ja? lidas, a ferramenta pode, agora, defi-
nir quais sera?o as seque?ncias impostas a?s varia?veis de acordo com a
metodologia explicada no cap??tulo 4. Para tal, sa?o observados tanto
os sinais de campo(sensores) quanto poss??veis detalhes existentes que
afetem aquele sinal. No caso da primeira linha da matriz, as entradas
”PSHH-014A”, ”PSHH-014B”e ”PSHH-014C”possuem uma relac?a?o de
votac?a?o 1oo3. Isso significa, assim como visto no cap??tulo 4 que sera?o
testadas todas as combinac?o?es entre essas tre?s entradas. Esse mo?dulo
da ferramenta cria uma lista com o nome das varia?veis de campo e os
valores que elas devem assumir de maneira a executar uma das linhas
da matriz causa e efeito.



74

Figura 26: Primeiro passo no desenvolvimento do observador

Um exemplo do teste gerado para as varia?veis ”PSHH-014A”,
”PSHH-014B”e ”PSHH-014C”(varia?veis da primeira linha da matriz
causa e efeito) e? o seguinte: ”PSHH-014A”? 0, ”PSHH-014C”? 0.
Isso significa que em um dos testes gerados, as entradas ”PSHH-014A”e
”PSHH-014C”seriam forc?adas para 0(0 aqui e? considerado o valor que
ativa a entrada). Da mesma maneira, para esta linha, ainda seriam
gerados mais tre?s testes, cada um considerando uma combinac?a?o dife-
rente para as entradas ”PSHH-014A”, ”PSHH-014B”e ”PSHH-014C”,
sempre forc?ando seu valor para 0 em cada teste.

5.5 INTERAC?A?O DA FERRAMENTA COM A PLANTA SIMULADA

Para que os testes possam ser realizados e? necessa?rio uma si-
mulac?a?o da planta a ser automatizada e tambe?m de comunicac?a?o com
o CLP ja? programado. De maneira a utilizar um protocolo ja? conhe-
cido para os engenheiros, foi escolhido o OPC(OLE for Process Con-
trol) como ponte entre o CLP e planta simulada. OPC e? um padra?o
de comunicac?a?o industrial entre equipamentos de diferentes fabricantes
criado em 1996 e oferece diferentes verso?es com objetivos espec??ficos.



75

Figura 27: Votac?a?o para o sinal ”PSHH-014A/B/C”

Neste trabalho foi utilizado o OPC DA(data access), que oferece uma
interface simplificada para acesso de varia?veis de processo atrave?s de
identificadores chamados de tags. E? um protocolo bem estabelecido no
ambiente industrial, muito utilizado em sistemas superviso?rios e, ale?m
da ampla aceitac?a?o por parte da indu?stria, e? amplamente suportado
pela comunidade de desenvolvimento de software atrave?s de diferentes
bibliotecas de acesso.

Apo?s os comandos definidos, a ferramenta pode iniciar a execuc?a?o
do teste, forc?ando cada varia?vel assim como explicado anteriormente.
Nesse momento, existe comunicac?a?o entre a planta e a ferramenta e se
faz necessa?rio especificar como a ferramenta e? capaz de alterar o valor
de uma varia?vel simulada na planta.

Foi definido um princ??pio para a criac?a?o de uma planta simulada
tal que permite a? ferramenta forc?ar corretamente os valores de campo
quando necessa?rio. Deve ser adicionada a? simulac?a?o, assim como expli-
citado na figura 29, uma lo?gica que de? prioridade ao valor enviado pela
ferramenta(neste caso, valor 0). Aqui pode-se ver que a planta executa
a simulac?a?o normalmente, mas o valor final da varia?vel de campo e? de-
cidido pelo comando enviado da ferramenta quando essa deseja forc?ar
o valor a 0.

5.5.1 Limitac?o?es temporais da ferramenta desenvolvida

Um ciclo de CLP demora na ordem de milissegundos dependendo
do equipamento em questa?o enquanto um servidor OPC tem tempo de



76

Figura 28: Observador criado para a relac?a?o ”PSHH-014A/B/C”e
”XY-037”

atualizac?a?o entre 0,2 segundos e alguns segundos dependendo do ser-
vidor e configurac?o?es utilizados. Essa diferenc?a deve ser considerada
ao se estipular o tempo limite para ser considerado um time out na
execuc?a?o de um teste. Um tempo para time out na?o deve ser me-
nor que o tempo m??nimo para aquisic?a?o dos dados, caso contra?rio,
pode-se encontrar uma falha onde ela, na realidade, na?o existe. Assim,
no pior cena?rio, o tempo m??nimo para time out a partir do tempos
de aquisic?a?o de dados e processamento do CLP pode ser calculado
da seguinte maneira: timeout &gt;= tempoparaescritanoservidorOCP
+tempodeprocessamentodoCLP +tempoparaleituradoservidorOPC.
Este tempo deve ser considerado na realizac?a?o dos testes para na?o gerar
um falso negativo como resultado.



77

Figura 29: Paradigma utilizado para forc?ar os valores das varia?veis de
campo na planta simulada

5.6 UTILIZAC?A?O DOS OBSERVADORES PARA VALIDAC?A?O DOS
TESTES

Enquanto os testes sa?o realizados, uma tabela de valores lidos e?
montada para cada teste. Esta tabela deve conter as varia?veis utilizadas
no teste em questa?o assim como a informac?a?o do tempo decorrido entre
as leituras. Para isso, antes do in??cio do teste, sa?o verificadas quais
varia?veis sa?o pertinentes aos teste em questa?o, ou seja, a causa e o
efeito de determinado teste. Essas varia?veis sa?o armazenadas e, a cada
ciclo, tem seus valores lidos e armazenados. Ale?m disso, em cada ciclo,
e? obtido, a partir do sistema operacional, o tempo decorrido desde a
u?ltima leitura.

Apo?s a realizac?a?o de todos os testes, resta a etapa da com-
parac?a?o. Nesta etapa, os observadores gerados anteriormente e os
valores gravados durante a execuc?a?o dos testes sera?o utilizados para
determinar se o programa de CLP se comportou como esperado. Neste
momento, existem diversos observadores gerados (um para cada relac?a?o
da matriz causa e efeito) e diversas tabelas com valores gravados du-
rante a execuc?a?o do teste. Para que a comparac?a?o seja executada, os



78

seguintes passos sa?o seguidos:

• Para cada observador, relacionar a tabela de valores que trata as
mesmas varia?veis

• Executar o observador levando em considerac?a?o os valores conti-
dos na tabela relacionada

• Analisar o estado alcanc?ado, identificando uma execuc?a?o com su-
cesso ou com falha

O segundo passo, a execuc?a?o do observador, e? o verdadeiro res-
ponsa?vel pela validac?a?o do teste. Essa execuc?a?o pode ser subdividido
da seguinte maneira:

• Ler valores de uma linha das varia?veis da tabela

• Alterar valores dos lugares correspondentes dos observadores (lu-
gares referentes aos valores de campo e equipamentos)

• Atualizar tempo das transic?o?es habilitadas

• Disparar transic?o?es que possam ser disparadas

• Passar para a pro?xima linha da tabela e repetir

Com essa execuc?a?o, pode-se observar enta?o se os testes resul-
taram na descoberta de algum erro ou se o programa executou como
esperado.

5.7 COMENTA?RIOS FINAIS

Neste cap??tulo, o desenvolvimento de uma ferramenta utilizada
na validac?a?o da metodologia proposta no cap??tulo 4 foi apresentada.
Aqui foi explicado em detalhes como a informac?a?o e? tratada dentro
da ferramenta e como essa informac?a?o e? utilizada dentro dos diversos
mo?dulos nela contidos ale?m da execuc?a?o da tarefa espec??fica a? cada
mo?dulo.



79

6 AVALIAC?A?O DA METODOLOGIA PROPOSTA

Para a aplicac?a?o da metodologia proposta foi utilizada uma planta
da Petrobras na realizac?a?o de testes. A planta e? a mesma de um forno
ja? descrito no cap??tulo 3. Neste cap??tulo, sera?o apresentados os to?picos
pertinentes a? validac?a?o da metodologia, sua aplicac?a?o, erros introduzi-
dos ao co?digo, testes realizados e resultados encontrados. Sera?o apre-
sentados os modelos desenvolvidos para este estudo de caso proposto e
os resultados obtidos ao se aplicar a metodologia nesta planta exemplo.

6.1 CO?DIGO DE AUTOMAC?A?O

Para a validac?a?o da ferramenta, foi criado um co?digo Ladder
com o objetivo de automatizar a planta em questa?o. O co?digo foi
criado com respeito a? matriz causa e efeito encontrada no anexo B e
com a finalidade de seguir os requisitos impostos pela matriz. Para
exemplificac?a?o, a figura 30 apresenta uma pequena parte do programa
Ladder, sua lo?gica completa pode ser vista no anexo A

Figura 30: Exemplo de programa Ladder do caso de estudo



80

Para a criac?a?o do programa, se utilizou uma abordagem subdivi-
dindo a matriz causa e efeito em linhas. Cada linha da matriz gerou um
trecho de co?digo, chamado de ”net” no ambiente de programac?a?o es-
pec??fico. Essa subdivisa?o em trechos distintos foi escolhida por facilitar
uma poss??vel correc?a?o de co?digo caso fosse encontrado algum erro.

6.2 SIMULAC?A?O DA PLANTA

Para a simulac?a?o da planta, foi utilizado o ambiente simulink do
software matlab. Essa escolha foi feita por facilitar o desenvolvimento
da simulac?a?o da planta e possibilitar o desenvolvimento da planta no
n??vel de abstrac?a?o necessa?rio, no entanto, outro software de simulac?a?o
poderia ser utilizado dado que gravasse as informac?o?es de varia?veis da
planta simulada em servidor OPC.

Visto que o programa de CLP executa uma das linhas da matriz
causa e efeito uma vez que um sinal correspondente e? ativado e que,
para a realizac?a?o dos testes, e? necessa?rio a verificac?a?o dos sinais de
sensores que chegam do campo e dos sinais enviados a? atuadores, a
planta simulada possui apenas algumas dina?micas cont??nuas, as quais
sa?o importantes para a correta execuc?a?o do programa. A figura 31
apresenta uma parte do ambiente simulink com a simulac?a?o da planta.

Figura 31: Exemplo de planta simulada no ambiente simulink



81

6.3 EXPERIMENTOS REALIZADOS E RESULTADOS OBTIDOS

Para uma melhor visualizac?a?o dos testes sendo realizados, foi
desenvolvida uma representac?a?o gra?fica atrave?s da ferramenta WinCC.
O objetivo deste sino?ptico desenvolvido e? apenas a visualizac?a?o, logo,
na?o foram criadas entradas de dados ou comandos, apenas elementos de
visualizac?a?o foram utilizados. A figura 32 apresenta o sino?ptico criado.

Figura 32: Superviso?rio criado para visualizac?a?o dos testes

Para a validac?a?o da ferramenta, erros foram introduzidos no pro-
grama Ladder, e, em seguida, se observou se a ferramenta era capaz ou
na?o de apontar a existe?ncia do erro. Erros foram introduzidos sistema-
ticamente em cada sec?a?o do co?digo a fim de se testar a capacidade de
reconhecimento de diferentes erros. Para a demonstrac?a?o do funciona-
mento da ferramenta, sera?o apresentados os erros inseridos no programa
e em seguida o resultado gerado pela ferramenta e gravado no log.

• Primeiro caso de teste: neste primeiro caso, o algoritmo res-
ponsa?vel por definir o correto funcionamento da votac?a?o 2oo3 no
bloco de func?a?o visto na figura 30 foi alterado de acordo com o que
pode ser visto na figura 33. O resultado do teste, deve apresentar



82

Figura 33: Primeiro exemplo de mudanc?a realizada ao co?digo para
realizac?a?o de testes. A figura A representa o co?digo antes da mudanc?a
enquanto a figura B representa a figura apo?s a mudanc?a.

erro em todos os testes que envolverem a votac?a?o 2oo3. Como
resultado no log, po?de-se observar erros nos testes que utilizavam
as varia?veis PSHH014-A, PSHH014-B e PSHH014-C, assim como
pode ser visto na figura 34. Neste Log, cada ensaio e? utilizado
para execuc?a?o de um observador e e? apresentado como uma si-
mulac?a?o no Log. Cada simulac?a?o lida com um sinal de entrada
e os respectivos sinais de sa??da como definido pela matriz C&amp;amp;E
e apresenta as varia?veis usadas nos testes, as entradas e sa??das,
bem como uma breve sentenc?a relacionando o erro que ocorreu.
”PSHH”e? um sinal de entrada e que indica alta pressa?o, enquanto
”XY”sa?o va?lvulas que devem ser fechadas ou abertas com a che-
gada de um sinal ”PSHH”. Os sinais PSHH- 014A, PSHH-014B
e PSHH-014C sa?o, respectivamente, a As entradas de sinal A, B
e C para o bloco de votac?a?o 2oo3. A partir do resultado apresen-
tado no log, dos equipamentos envolvidos, dos sinais de campo
envolvidos, pode-se restringir poss??veis locais onde o co?digo falha
em sua execuc?a?o.

• Segundo caso de teste: para esse caso, utilizou-se o programa sem
a introduc?a?o de erros para se verificar se a ferramenta na?o gerava
erros na?o existentes. O resultado do teste na?o deveria apresentar



83

Figura 34: Parte do log que apresenta a existe?ncia de erros na execuc?a?o
do teste

nenhum erro gerado, apresentando somente testes realizados com
sucesso. A figura 35 apresenta parte do log para o teste sem
introduc?a?o de erro.

• Terceiro caso de teste: neste terceiro caso de teste, uma limitac?a?o
existente na metodologia sera? demonstrada. Devido ao fato de
a ferramenta trabalhar com leituras c??clicas do servidor OPC,
e, esse realizar atualizac?o?es tambe?m c??clicas, e? poss??vel que dois
sinais que surgem em ciclos diferentes no CLP sejam interpretados
como tendo surgindo no mesmo ciclo dentro da ferramenta devido
a? alta velocidade de execuc?a?o do CLP e baixa taxa de atualizac?a?o
do servidor OPC. Para melhor clarificac?a?o, leva-se em relac?a?o
uma caso ja? apresentado, que encontra-se na figura 36

Caso, o programa apresente um erro onde os sinais abrir ”ven-
tilac?a?o”e ”fechar segunda va?lvula”ocorram dentro de um tempo
menor que o tempo de atualizac?a?o do servidor OPC, dois cami-
nhos de execuc?a?o da rede de petri se abrem, permitindo que dois
estados diferentes sejam alcanc?ados. Levando-se em considerac?a?o
somente os lugares P = p5, p11, abrir ventilac?a?o, fechar segunda
va?lvula, Va?lv. 2 fechou antes da valv vent., va?lv. 2 fechou an-
tes de 5 s, como marcac?a?o inicial M0=1,0,0,0,0,0 e ainda, que na
pro?xima leitura, a ferramenta adicione fichas de maneira a dei-
xar o sistema com a seguinte marcac?a?o M1= 1,0,1, 1,0,0 as duas
execuc?o?es poss??veis sa?o:



84

Figura 35: Parte do log que apresenta somente testes realizados com
sucesso

– execuc?a?o da transic?a?o t12 e marcac?a?o final Mf=0 0,1,0,1,0

– execuc?a?o da transic?a?o t4 levando a? marcac?a?o M2 = 0,1,0,1,0,0
e depois da transic?a?o t9 levando o sistema a? marcac?a?o final
Mf = 0,0,0,0,0,1

Ambas as marcac?o?es finais implicam erros no sistema, contudo,
devido ao recebimento simulta?neo dos dois sinais pelo servidor, a
ferramenta na?o pode apontar com exatida?o o erro ocorrido. Para
esse caso, a ferramenta apresenta as duas possibilidades de erros
ao usua?rio no log. Para testar essa situac?a?o, o seguinte erro foi
introduzido no programa de CLP, assim como demonstrado na
figura 37. O resultado do log apresentado para o usua?rio pode
ser visto na figura 38.

• Para que seja mantida a concisa?o do documento, na?o sera?o apre-
sentados mais testes. Os testes escolhidos para apresentac?a?o neste
documento sa?o aqueles que continham caracter??sticas pertinentes
para a validac?a?o da ferramenta. Embora outros testes tenham
sido realizados, eles na?o apresentam novidades relevantes de tal
forma que sua abordagem aqui tornaria esta sec?a?o demasiada
longa.



85

Figura 36: Rede de petri correspondente a? nota 5

6.4 COMENTA?RIOS FINAIS

Neste cap??tulo, foi apresentada a aplicac?a?o de uma ferramenta
constru??da com base na metodologia proposta nesta dissertac?a?o. Foi
tambe?m apresentado um estudo de caso utilizado para aplicar a meto-
dologia e validar a ferramenta desenvolvida, assim como os resultados
obtidos ao se aplicar a metodologia em questa?o ao estudo de caso. Tudo
aquilo desenvolvido para aplicac?a?o da metodologia desenvolvida, desde
o ambiente de simulac?a?o ate? a ferramenta esta?o dispon??veis em: http:
//1drv.ms/1zfbUHv ou https://onedrive.live.com/redir?resid=
8B54AFE170F06603!215405&amp;amp;authkey=!AEOWYCqHbyKHato&amp;amp;ithint=folder%

2c.



86

Figura 37: Exemplo utilizado para o terceiro teste. A figura A re-
presenta o co?digo antes da mudanc?a enquanto a figura B representa a
figura apo?s a mudanc?a.

Figura 38: Parte do log para o terceiro teste.



87

7 CONCLUSA?O

Neste trabalho foi abordado o estudo e a realizac?a?o automa?tica
de testes em um forno utilizada na indu?stria de petro?leo e ga?s. Foi
desenvolvida uma nova metodologia para a realizac?a?o de testes base-
ada na utilizac?a?o de modelos formais constru??dos com redes de Petri.
Esta abordagem se difere daquela atualmente utilizada ao definir auto-
maticamente os testes realizados utilizando como base os conteu?dos da
matriz causa e efeito, documento criado durante o desenvolvimento do
projeto, e executar os testes para posteriormente comparar os resulta-
dos a?queles previstos pela matriz causa e efeito. Nesta metodologia, os
requisitos de projeto contidos na matriz causa e efeito sa?o transforma-
das em redes de Petri que tem como func?a?o a representac?a?o, atrave?s de
uma ferramenta formal, os mesmos requisitos. De posse dessas redes,
testes sa?o gerados e realizados de maneira a executar uma confere?ncia
do programa de CLP ja? existente. Os dados dos testes realizados sa?o
utilizados para, atrave?s da execuc?a?o da rede de Petri, validar a execuc?a?o
de cada teste. O resultado e? obtido atrave?s do estado alcanc?ado pela
rede o que determina a correta ou na?o correta execuc?a?o por parte do
CLP.

Foi desenvolvida uma ferramenta a fim de validar a metodologia e
realizar testes sobre uma planta de uma forno utilizada pela Petrobras.
Com essa ferramenta foram realizados testes sobre um CLP progra-
mado cujo objetivo era seguir os requisitos impostos pela matriz causa
e efeito. Esse programa de CLP podia ou na?o conter erros inseridos de
maneira a desrespeitar o correto funcionamento esperado. Nos testes
realizados, ao se inserir um erro que desrespeitava diretamente alguma
relac?a?o presente na matriz causa e efeito, esse erro era encontrado pela
ferramenta.

As principais contribuic?o?es deste trabalho sera?o relacionadas a
seguir:

• Definic?a?o de uma nova metodologia para realizac?a?o automa?tica
de testes

• Relacionamento entre requisitos da matriz de causa e efeito com
modelos em redes de petri

• Desenvolvimento de uma ferramenta para validar a nova metodo-
logia



88

Com relac?a?o a utilizac?a?o de redes de Petri para se realizar tes-
tes caixa preta de programas de CLP, vale lembrar que na?o existem
registros deste tipo de abordagem na literatura. A realizac?a?o de testes
mostrou-se eficaz para encontrar erros do programa de CLP em relac?a?o
aos requisitos impostos pela matriz causa e efeito e essa metodologia
mostra-se como uma boa aliada durante o desenvolvimento de um pro-
jeto de automac?a?o industrial podendo diminuir o tempo gasto na rea-
lizac?a?o de testes e tambe?m evitando que um programa com erros chegue
a ser levado a campo para posterior descoberta dos erros. A utilizac?a?o
de modelos baseados em redes de Petri adicionam um formalismo no
processo de automac?a?o na?o encontrado anteriormente. Esse forma-
lismo permitiu na?o somente o desenvolvimento da nova metodologia
como permite tambe?m sua expansa?o para a aplicac?a?o de novas te?cnicas
que se baseiam em modelos formais. Essa nova metodologia se insere
na atual metodologia de desenvolvimento de projeto utilizada pela Pe-
trobras de maneira sutil, sem a alterac?a?o brusca da maneira com a qual
o projeto e? desenvolvido. Isso foi procurado para que a metodologia
possu??sse uma maior aceitac?a?o por parte dos engenheiros responsa?veis.
Este trabalho foi submetido para IFAC Workshop on Automatic Con-
trol in Offshore Oil and Gas Production sob o t??tulo:Automatic Test of
Safety Specifications for PLC Programs in The Oil and Gas Industry

7.1 DIRETRIZES PARA TRABALHOS FUTUROS

A metodologia apresentada neste trabalho incluiu a utilizac?a?o
de um dos documentos utilizados durante um projeto de automac?a?o.
Outros documentos de grande importa?ncia ainda podem ser utilizados
na criac?a?o e realizac?a?o de testes dos softwares de CLP. Ale?m disso,
a expansa?o do trabalho ja? realizado permite a criac?a?o de uma ferra-
menta mais abrangente e que pode se fazer u?til em projetos de outra
natureza. Levando isso em considerac?a?o, alguns temas a serem investi-
gados futuramente, com o objetivo de se criar novos me?todos de teste
ou aperfeic?oar os testes realizados, sa?o propostos:

• Expansa?o dos observadores dispon??veis a fim de se abranger mais
projetos.

• Formalizac?a?o de outros documentos existente no projeto de au-
tomac?a?o da Petrobras como o memorial descritivo para utilizac?a?o
conjunta na realizac?a?o de testes.

• Realizac?a?o dos testes utilizando como base, na?o o CLP progra-



89

mado, mas o Diagrama lo?gico para que seja realizada uma va-
lidac?a?o pre?via a programac?a?o do CLP, utilizando ate? model chec-
king e economizando assim, tempo de projeto.

• Introduc?a?o da ferramenta em um ambiente integrado, com especi-
alizac?o?es para a inserc?a?o de informac?o?es de projeto, de dados para
a simulac?a?o e para verificac?a?o de programas de CLP na indu?stria
de petro?leo e ga?s.



90



91

REFERE?NCIAS

ABID, N. et al. Verification of Real-Time Specification Patterns on
Time Transition Systems. [S.l.], 2011.

ADAM, N. R.; ATLURI, V.; HUANG, W.-K. Modeling and analysis
of workflows using petri nets. Journal of Intelligent Information
Systems, Springer, v. 10, n. 2, p. 131–158, 1998.

BAIER, C.; KATOEN, J.-P. et al. Principles of model checking. [S.l.]:
MIT press Cambridge, 2008.

BEIZER, B. Software Testing Techniques. New York: Van Nostrand
Reinhold Company, 1990.

BERTHOMIEU, B. et al. Fiacre: an intermediate language for model
verification in the topcased environment. In: ERTS 2008. [S.l.: s.n.],
2008.

BERTHOMIEU, P.-O. R. e. F. V. B. The tool tina - construction
of abstract state spaces for petri nets and time petri nets. European
Congress on Embedded Real Time Software, 2004.

BLACK, R. Pragmatic Software Testing: Becoming an Effective and
Efficient Test Professional. New York: [s.n.], 2007.

BURNSTEIN, I. Practical Software Testing. [S.l.]: Springer-Verlag,
2003.

COMISSa?O DE NORMAS Te?CNICAS. Norma te?cnica N-1883. [S.l.]:
Petrobras, 2002.

COMISSa?O DE NORMAS Te?CNICAS. Norma te?cnica N-2595. [S.l.]:
Petrobras, 2012.

FARINES, J.; QUEIROZ, M. H.; CARPES, A. M. M. A model-driven
engineering approach to formal verification of plc programs. Emerging
Technologies and Factory Automation, p. 1–8, 2011.

FRANCe?S, C. Introduc?a?o a? redes de Petri. [S.l.], 2003.

Go?IS, G. M. Um Sistema Tutor Multi-Agentes no Dom??nio de Redes
de Petri. Dissertac?a?o (Mestrado) — UFPA, Campina Grande, 2000.



92

HAMADI, R.; BENATALLAH, B. A. A petri net-based model for web
service composition. Australian Computer Society, v. 14, 2003.

HAN, R. et al. A petri net theory-based method for modeling web
service-based systems. p. 1–7, 2008.

HOFFMAN, D.; STROOPER, P. A case study in class testing.
CASCON, p. 472–782, 1993.

JACOBSON, I. et al. The unified software development process. [S.l.]:
Addison-Wesley Reading, 1999.

Ju?NIOR, R. S. Diagno?stico e tratamento de falhas cr??ticas em sistemas
instrumentados de seguranc?a. Dissertac?a?o (Mestrado) — USP, Sa?o
Paulo, 2011.

JOUAULT, F.; KURTEV, I. Transforming models with atl. In:
SPRINGER. Satellite Events at the MoDELS 2005 Conference. [S.l.],
2006. p. 128–138.

KANESHIRO, P. J. I. et al. Modeling of collision resolution algorithm
in lonworks networks. p. 743–749, 2007.

KARHELA, T.; VILLBERG, A.; NIEMSTO?, H. Open ontology-based
integration platform for modeling and simulation in engineering.
International Journal of Modeling, Simulation, and Scientific
Computing, World Scientific, v. 3, n. 02, 2012.

KIEPUSZEWSKI, B.; HOFSTEDE, A. H. ter; AALST, W. M.
van der. Fundamentals of control flow in workflows. Acta Informatica,
Springer, v. 39, n. 3, p. 143–209, 2003.

KUHN, D. R.; KACKER, R. N.; LEI, Y. Practical combinatorial
testing. [S.l.], 2010. v. 800, 142 p.

KUHN, D. R.; WALLACE, D. R.; GALLO, J. A. Software
fault interactions and implications for software testing. Software
Engineering, IEEE Transactions on, IEEE, v. 30, n. 6, p. 418–421,
2004.

LEE, J.-S.; ZHOU, M.-C.; HSU, P.-L. An application of petri nets
to supervisory control for human-computer interactive systems.
Industrial Electronics, IEEE Transactions on, IEEE, v. 52, n. 5, p.
1220–1226, 2005.



93

LI, Z.; ZHOU, M. Control of elementary and dependent siphons in
petri nets and their application. Systems, Man and Cybernetics, Part
A: Systems and Humans, IEEE Transactions on, IEEE, v. 38, n. 1, p.
133–148, 2008.

MACIEL, P. R.; LINS, R. D.; CUNHA, P. R. Introduc?a?o a?s redes de
Petri e aplicac?o?es. [S.l.]: UNICAMP-Instituto de Computacao, 1996.

MALDONADO, J. C. Crite?rios potenciais usos: Uma contribuic?a?o ao
teste estrutural de software. Tese (Doutorado), 1991.

MALDONADO, J. C. et al. Introduc?ao ao teste de software. Sa?o
Carlos, 2004.

MCGREGOR, J. D. Functional testing of classes. San Francisco, 1994.

MERZ, S. Model checking: A tutorial overview. In: Modeling and
verification of parallel processes. [S.l.]: Springer, 2001. p. 3–38.

MORALES, R. A. G.; MELO, J. G.; MIYAGI, P. E. Diagnosis and
treatment of faults in productive systems based on bayesian networks
and petri net. In: IEEE. Automation Science and Engineering,
2007. CASE 2007. IEEE International Conference on. [S.l.], 2007. p.
357–362.

MURATA, T. Petri nets: Properties, analysis and applications.
Proceedings of the IEEE, IEEE, v. 77, n. 4, p. 541–580, 1989.

MYERS, G. J. The art of software testing. New York: Wiley, 1979.

NASSAR, M. G. V. et al. Modeling and analysing of the material
entry flow system in a pickling line process using petri net. In: ABCM
Symposium Series in Mechatronics. [S.l.: s.n.], 2008. v. 3, p. 444–453.

OLIVEIRA, C. Simulac?a?o de redes de petri em ambiente java. 2006.

OLIVEIRA LEANDRO DIAS DA SILVA, A. P. K. C. G. Kezia de
V. Uma abordagem para gerac?a?o e execuc?a?o de casos de teste em
programas de sistemas instrumentados de seguranc?a. CBA, 2012.

PAKONEN, A. et al. A toolset for model checking of plc software.
p. 1–6, 2013.

PATTON, R. Software testing. [S.l.]: Sams Indianapolis, 2001.



94

PERRY, D. E.; KAISER, G. E. Adequate testing and object-oriented
programming. Journal of Object-Oriented Programming, SIGS
Publications, v. 2, n. 5, p. 13–19, 1990.

PRESSMAN, R. S. Software Engineering - A Practitioner?s Approach.
[S.l.]: McGraw-Hill, 1997.

SILVA, M. K. Metodologia para detecc?a?o e tratamento de falhas em
sistemas de manufatura atrave?s de rede de Petri. Tese (Doutorado) —
USP, Sa?o Paulo, 2002.

SILVA, M. K. Pre?-Detalhamento da Instrumentac?a?o e Automac?a?o
de um Forno Industrial de um Complexo Petroqu??mico. Dissertac?a?o
(Mestrado) — DAS/UFSC, Floriano?polis, 2009.

SKOGDALE, J. E.; SMOGELI, O. Looking Forward-Reliability of
Safety Critical Control Systems on Offshore Drilling Vessels. [S.l.],
2011.

VERNADAT, F. et al. The topcased project-a toolkit in open-source
for critical applications and system development. Data Systems In
Aerospace (DASIA), Berlin, Germany, v. 22, n. 05, p. 2006–25, 2006.

XU, X. et al. A novel modeling design method for automated storage
and retrieval system based on petri nets. p. 2046–2051, 2007.

YOO, T.; JEONG, B.; CHO, H. A petri nets based functional
validation for services composition. Expert Systems with Applications,
Elsevier, v. 37, n. 5, p. 3768–3776, 2010.

ZURAWSKI, R.; ZHOU, M. Petri nets and industrial applications: A
tutorial. Industrial Electronics, IEEE Transactions on, IEEE, v. 41,
n. 6, p. 567–583, 1994.

ZURAWSKI, R.; ZHOU, M. Software fault interactions and
implications for software testing. IEEE Trans. on Software
Engineering, v. 30, 2004.



APE?NDICE A -- Co?digo Ladder Utilizado para Validac?a?o





97



98



99



100



101



102



103



104



105



106



APE?NDICE B -- Matriz Causa &amp;amp; Efeito Utilizado no Estudo
de Caso





109


</field>
	</doc>
</add>