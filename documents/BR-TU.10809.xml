<?xml version="1.0" encoding="utf-8"?>
<add>
	<doc>
		<field name="docid">BR-TU.10809</field>
		<field name="filename">1597_Freitas_LucasBatista_D.pdf</field>
		<field name="filetype">PDF</field>
		<field name="text">


ii



iii



Instituto de Computac?a?o

Universidade Estadual de Campinas

Modelagem geolo?gica por simplo?ides de Be?zier

Lucas B. Freitas1

Dezembro de 2010

Banca Examinadora:

• Jorge Stolfi (Orientador)

• Dr. Eduardo Filpo Ferreira da Silva

Petrobras

• Prof. Dr. Jesse? Carvalho Costa

CPGf – UFPa

• Profa. Dra. Maria Cristina Cunha

IMECC – Unicamp

• Prof. Dr. Philippe Devloo

FEC – Unicamp

• Prof. Dr. Luiz Carlos Pacheco Velho

IMPA (Suplente)

• Profa. Dra. Anamaria Gomide

IC – Unicamp (Suplente)

• Prof. Dr. He?lio Pedrini

IC – Unicamp (Suplente)

1Suporte financeiro de: Bolsa da FAPESP (processo 2006/50344-4) 2006–2008.

v



Resumo

A explorac?a?o e monitoramento de um reservato?rio de petro?leo ou ga?s natural exige co-

nhecimento bastante detalhado das estruturas geolo?gicas da regia?o de interesse. A repre-

sentac?a?o matema?tica e computacional desse conhecimento e? um modelo geof??sico.

Nesta tese descrevemos um sistema geral para modelagem geof??sica baseado em ele-

mentos finitos polinomiais de graus arbitra?rios. Adotamos uma abordagem comum na

indu?stria, em que a geometria e as propriedades das formac?o?es geolo?gicas sa?o represen-

tadas por func?o?es definidas por partes, ou splines, que consistem da justaposic?a?o de tais

elementos. Neste contexto, apresentamos contribuic?o?es teo?ricas e computacionais.

A principal contribuic?a?o teo?rica e? uma teoria unificada dos elementos simploidais de

Be?zier, que incluem os tipos de elementos finitos mais comuns na modelagem por malhas—

tais como arcos de Be?zier, retalhos de Be?zier triangulares e retangulares, blocos de Be?zier

tetrae?dricos, prisma?ticos e hexae?dricos, e suas generalizac?o?es para dimenso?es arbitra?rias,

com graus independentes em cada eixo e cada componente. Como parte testa teoria,

desenvolvemos fo?rmulas gene?ricas expl??citas para conversa?o entre estes va?rios tipos de

blocos, bem como diferenciac?a?o, reparametrizac?a?o afim e elevac?a?o de grau.

As contribuic?o?es computacionais desta tese incluem a implementac?a?o dessa teoria na

forma de uma biblioteca (BezEl) que permite a representac?a?o e manipulac?a?o eficiente

de malhas de elementos de Be?zier simplodais com dimenso?es e graus arbitra?rios. Outra

contribuic?a?o original desta tese e? uma metodologia para realizar o trac?ado eficiente de

raios em malhas de elementos simploidais.

vii



Abstract

The exploration and monitoring of a hydrocarbon reservoir demand a very detailed kno-

wledge about the geological structures of the target area. The mathematical and compu-

tation representation of this knowledge is a geophysical model.

In this thesis, we describe a general system for geophysical modeling based on poly-

nomial finite elements of arbitrary degree. We adopted an approach that is popular in

industry, whereby both the geometry and the physical properties of the geological for-

mations are represented by piecewise-defined functions, or splines, that are obtained by

the assembly of many such elements. In this context, we present both theoretical and

computational contributions.

The main theoretical contribution is a unified theory of simploidal Be?zier elements,

which include the element types most common in mesh based modeling – such as Be?zier

arcs, triangular and rectangular Be?zier patches, tetrahedral, prismatic and hexahedral

Be?zier blocks, and their generalizations to arbitrary dimensions with independent degrees

on each axis and each component. As part of this theory, we developed general explicit

formulas for the conversion between these various block types, as well as differentiation,

affine reparametrization and degree raising.

The computational contributions of this thesis include the implementation of this

theory as a library (BezEl) that allows efficient representation and manipulation of meshes

of simploidal Be?zier elements with arbitrary dimension and degree. Another original

contribution of this thesis is a methodology for performing efficient ray tracing in meshes

of such simploidal elements.

ix



Agradecimentos

Antes de tudo, agradec?o a Deus por ter me concedido esta grac?a. Agradec?o tambe?m

meus orientadores, o prof. Jorge Stolfi e o prof. Martin Tygel, por terem me guiado nesta

dif??cil trajeto?ria e a FAPESP, ao Instituto de Computac?a?o e ao Laborato?rio de Geof??sica

Computacional pelo suporte financeiro e pela infra-estrutura que me foi disponibilizada.

xi



Suma?rio

Resumo vii

Abstract ix

Agradecimentos xi

1 Introduc?a?o 1

1.1 Modelagem Geof??sica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1

2 Modelos geolo?gicos 3

2.1 Principais abordagens . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3

2.1.1 Modelos baseados em grade uniforme . . . . . . . . . . . . . . . . . 3

2.1.2 Modelos baseados em interfaces . . . . . . . . . . . . . . . . . . . . 4

2.1.3 Modelos de malhas tridimensionais . . . . . . . . . . . . . . . . . . 5

2.2 Nossa abordagem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7

2.2.1 Blocos simploidais . . . . . . . . . . . . . . . . . . . . . . . . . . . 7

2.2.2 Informac?o?es topolo?gicas . . . . . . . . . . . . . . . . . . . . . . . . 8

2.2.3 Restric?o?es intra- e inter-blocos . . . . . . . . . . . . . . . . . . . . . 8

3 Polino?mios de Bernstein 11

3.1 A base de Bernstein univariada . . . . . . . . . . . . . . . . . . . . . . . . 11

3.2 Representac?a?o de Be?zier para polino?mios . . . . . . . . . . . . . . . . . . . 12

3.3 Elevac?a?o de grau . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13

3.4 Diferenciac?a?o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13

3.5 Arco de Be?zier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

4 Multi-, hiper- e ultra-??ndices 17

4.1 Multi-??ndices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17

4.2 Matrizes irregulares e hiper-??ndices . . . . . . . . . . . . . . . . . . . . . . 19

4.3 Ultra-??ndices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

xiii



5 Elementos de Be?zier tensoriais 23

5.1 Polino?mios tensoriais . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23

5.1.1 A base de Bernstein tensorial . . . . . . . . . . . . . . . . . . . . . 23

5.1.2 A representac?a?o de Be?zier de polino?mios tensoriais . . . . . . . . . 25

5.1.3 Elevac?a?o de grau . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25

5.1.4 Diferenciac?a?o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25

5.1.5 Derivada direcional . . . . . . . . . . . . . . . . . . . . . . . . . . . 26

5.2 Elementos tensoriais de Be?zier . . . . . . . . . . . . . . . . . . . . . . . . . 27

6 Elementos de Be?zier simpliciais 31

6.1 Espac?os afins cano?nicos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31

6.1.1 Simplexos cano?nicos . . . . . . . . . . . . . . . . . . . . . . . . . . 32

6.1.2 Facetas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

6.2 Polino?mios simpliciais . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

6.2.1 A base de Bernstein simplicial . . . . . . . . . . . . . . . . . . . . . 33

6.2.2 A representac?a?o de Be?zier de polino?mios simpliciais . . . . . . . . . 35

6.2.3 Elevac?a?o de grau . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35

6.2.4 Derivada direcional . . . . . . . . . . . . . . . . . . . . . . . . . . . 35

6.3 Elementos simpliciais de Be?zier . . . . . . . . . . . . . . . . . . . . . . . . 36

7 Conversa?o tensorial/simplicial 41

7.1 Mapeamento cano?nico tensorial/simplicial . . . . . . . . . . . . . . . . . . 41

7.2 Conversa?o de tensorial para simplicial . . . . . . . . . . . . . . . . . . . . . 44

7.3 Conversa?o de simplicial para tensorial . . . . . . . . . . . . . . . . . . . . . 45

8 Simplo?ides de Be?zier 47

8.1 Espac?o multi-afim cano?nico . . . . . . . . . . . . . . . . . . . . . . . . . . 47

8.1.1 Simplo?ides cano?nicos . . . . . . . . . . . . . . . . . . . . . . . . . . 48

8.1.2 Facetas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48

8.2 Polino?mios simploidais . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49

8.2.1 A base de Bernstein simploidal . . . . . . . . . . . . . . . . . . . . 49

8.2.2 Representac?a?o de Be?zier de polino?mios simploidais . . . . . . . . . 50

8.2.3 Elevac?a?o de grau . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50

8.2.4 Diferenciac?a?o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52

8.3 Elementos de Be?zier Simploidais . . . . . . . . . . . . . . . . . . . . . . . . 53

9 Mapeamentos afins 55

9.1 Mapeamento afim de A? para A? . . . . . . . . . . . . . . . . . . . . . . . 55

9.1.1 Mapeamento afim cano?nico de Ad para A1?d . . . . . . . . . . . . . 56

xiv



9.2 Derivadas de um mapeamento afim . . . . . . . . . . . . . . . . . . . . . . 56

9.3 Exemplos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56

9.3.1 Mapeamento afim de A(1) para A(2) . . . . . . . . . . . . . . . . . . 56

9.3.2 Mapeamento afim de A(2) para A(2) . . . . . . . . . . . . . . . . . . 57

9.3.3 Mapeamento afim de A(2) para A(2,1) . . . . . . . . . . . . . . . . . 57

9.3.4 Mapeamento afim de A(1,1) para A(2) . . . . . . . . . . . . . . . . . 58

9.3.5 Mapeamento afim de A(1,1) para A(1,1) . . . . . . . . . . . . . . . . 59

10 Reparametrizac?a?o de elementos de Be?zier 61

10.1 Reparametrizac?a?o afim . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 62

10.2 Mapeamento de simploidal para simplicial . . . . . . . . . . . . . . . . . . 64

10.3 Reparametrizac?a?o afim gene?rica . . . . . . . . . . . . . . . . . . . . . . . . 65

10.4 Derivada direcional da reparametrizac?a?o . . . . . . . . . . . . . . . . . . . 67

11 Aspectos gerais da implementac?a?o 69

11.1 Elementos de Be?zier . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69

11.2 Blocos de Be?zier generalizados . . . . . . . . . . . . . . . . . . . . . . . . . 72

11.3 Compartilhamento de para?metros . . . . . . . . . . . . . . . . . . . . . . . 76

11.4 Para?metros internos e externos . . . . . . . . . . . . . . . . . . . . . . . . 78

11.5 Extrac?a?o de componentes . . . . . . . . . . . . . . . . . . . . . . . . . . . 82

11.6 Extrac?a?o de facetas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83

11.7 Elevac?a?o de grau . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88

11.8 Reparametrizac?a?o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91

11.9 Derivada direcional . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91

12 Restric?o?es entre blocos 93

12.1 Colagem na?o-conforme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93

12.2 Restric?o?es entre para?metros internos . . . . . . . . . . . . . . . . . . . . . 94

12.3 Colagem na?o-conforme geral . . . . . . . . . . . . . . . . . . . . . . . . . . 102

12.4 Colagem com imposic?a?o de suavidade . . . . . . . . . . . . . . . . . . . . . 105

13 A biblioteca bezEl 107

13.1 Estruturas de indexac?a?o . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107

13.1.1 Multi-??ndices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107

13.1.2 Hiper-??ndices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108

13.1.3 Ultra-??ndices . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109

13.2 Espac?os multi-afins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109

13.2.1 Matrizes irregulares . . . . . . . . . . . . . . . . . . . . . . . . . . . 109

13.2.2 Matrizes regulares . . . . . . . . . . . . . . . . . . . . . . . . . . . 110

xv



13.2.3 Pontos e vetores de espac?os multi-afins . . . . . . . . . . . . . . . . 110

13.2.4 Mapeamento afim . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110

13.3 Polino?mios Simploidais . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 111

13.4 Elementos de Be?zier simploidais . . . . . . . . . . . . . . . . . . . . . . . . 112

13.4.1 Tipos de bloco . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112

13.4.2 Blocos de Be?zier . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114

13.5 Modelos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115

13.5.1 Colec?a?o de blocos . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115

13.5.2 Reposito?rio de para?metros externos . . . . . . . . . . . . . . . . . . 115

13.5.3 Equac?o?es entre varia?veis . . . . . . . . . . . . . . . . . . . . . . . . 115

13.5.4 Reposito?rios de equac?o?es . . . . . . . . . . . . . . . . . . . . . . . . 116

13.5.5 Estrutura topolo?gica . . . . . . . . . . . . . . . . . . . . . . . . . . 116

13.6 Classes adicionais . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117

13.6.1 Visualizac?a?o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117

13.6.2 Coletor de lixo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117

14 Editor de modelos 2D 119

14.1 Editor de topologia e propriedades f??sicas . . . . . . . . . . . . . . . . . . . 119

14.2 Editor de geometria . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124

15 Simulac?a?o s??smica 127

15.1 Trac?ado de raios . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127

15.1.1 Ondas s??smicas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128

15.1.2 Equac?o?es do raio . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128

15.1.3 Custo da integrac?a?o em coordenadas cartesianas . . . . . . . . . . . 129

15.1.4 Interac?a?o do raio com interfaces . . . . . . . . . . . . . . . . . . . . 130

15.2 Trac?ado de raios nas coordenadas locais do bloco . . . . . . . . . . . . . . 130

15.2.1 Normalizac?a?o de U(t) . . . . . . . . . . . . . . . . . . . . . . . . . . 132

15.2.2 Custo da integrac?a?o em coordenadas locais do bloco . . . . . . . . . 132

15.3 Exemplo nume?rico . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132

16 Concluso?es 135

Bibliografia 137

xvi



Lista de Tabelas

11.1 Tabela com valores de ? para diferentes ?. . . . . . . . . . . . . . . . . . . 82

13.1 Enumerac?a?o de multi-??ndices . . . . . . . . . . . . . . . . . . . . . . . . . . 108

xvii



Lista de Figuras

2.1 (a) Ilustrac?a?o esquema?tica da geologia de uma regia?o e (b) modelagem da

mesma por uma grade uniforme. . . . . . . . . . . . . . . . . . . . . . . . . 4

2.2 Modelo baseado em interfaces criado no sistema de modelagem do software

Norsar. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5

2.3 Exemplos de modelos constru??dos por softwares comerciais: (a) Modelo

criado usando earthVision, da empresa Dynamic Grahics que usa apenas

por blocos hexae?dricos tricu?bicos. (b) Modelo criado usando goCAD, da

empresa Paradigm, formado por por elementos prisma?ticos de bases variadas. 6

2.4 Modelo geolo?gico representado utilizando nossa abordagem. . . . . . . . . . 7

2.5 Ilustrac?a?o da abordagem acoplada para modelagem de geometria e propri-

edades f??sicas. (a) Modelo inicial e (b) modelo depois de alterar a geometria. 9

2.6 Modelo geolo?gico constru??do com nossa biblioteca BezEl, usando blocos

hexae?dricos e tetrae?dricos. . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

3.1 Elementos da base de Bernstein univariada de grau 4 . . . . . . . . . . . . 12

3.2 Um arco de Be?zier F de grau 4 no R2 (esquerda em vermelho) mostrando

seus pontos de controle de Be?zier (em azul) e a poligonal de Be?zier (trace-

jada); e os gra?ficos de suas componentes F0(z) = 2z
4 +3z e F1(z) = z

4 +z2

(direita) mostrando os respectivos coeficientes de Be?zier (pontos azuis). . . 15

5.1 Alguns dos 12 polino?mios B?? da base de Bernstein tensorial de P
(3,2)
2 . Os

eixos vermelho, verde e azul representam x0, x1 e B
(3,2)
? (x0,x1). . . . . . . . 24

5.2 (a) Um elemento tensorial de Be?zier F de dimensa?o 2 (retalho) e multi-grau

(2, 3) no R3; e suas componentes (b) F0, (c) F1 e (d) F2. . . . . . . . . . . 28

5.3 A grade de controle (em vermelho) de um retalho tensorial de Be?zier de

dimensa?o 2 e multi-grau (3, 2)(amarelo). . . . . . . . . . . . . . . . . . . . 29

6.1 Espac?os afins A1 e A2. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31

6.2 Simplexos cano?nicos. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

6.3 Polino?mios da base de Benstein simplicial de P32 . . . . . . . . . . . . . . . . 34

xix



6.4 (a) Um elemento simplicial de Be?zier F de dimensa?o 2 (retalho triangular)

e grau 3 no R3; e suas componentes (b) F0, (c) F1 e (d) F2. . . . . . . . . . 38

6.5 Um elemento simplicial de Be?zier de dimensa?o 2 e grau 3, e sua grade de

controle (em vermelho). . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39

7.1 Colando um retalho 3D tensorial a um retalho tetrae?drico. . . . . . . . . . 41

7.2 O mapeamento cano?nico ?2. . . . . . . . . . . . . . . . . . . . . . . . . . . 42

7.3 O mapeamento cano?nico ?3. . . . . . . . . . . . . . . . . . . . . . . . . . . 42

7.4 O mapeamento cano?nico ?2 e a relac?a?o entre um polino?mio tensorial f
?,

definido no R2, e sua forma simplicial cano?nica f ??. . . . . . . . . . . . . . 43

8.1 O prisma cano?nico (esquerda) e um exemplo de um bloco de Be?zier sim-

ploidal (direita). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47

8.2 Alguns simplo?ides cano?nicos. . . . . . . . . . . . . . . . . . . . . . . . . . . 48

8.3 Um elemento de Be?zier simploidal de multi-dimensa?o (1, 2) (um prisma de

Be?zier) e multi-grau (2, 3) mostrando seus pontos de controle e sua grade

de Be?zier (em vermelho). . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54

9.1 Exemplo de um mapeamento afim de A(1) para A(2) (ou de A1 para A2). . 57

9.2 Exemplo de mapeamento afim de A(2) para A(2) (ou de A2 para A2). . . . . 57

9.3 Exemplo de um mapeamento afim de A(2) (ou A2) para A(2,1). . . . . . . . 58

9.4 Exemplo de um mapeamento afim de A(1,1) para A(2) (ou A2). Note que

os segmentos AB e CD, que sa?o imagens das facetas K1,1|1,0 e K
1,1|1,1, sa?o

paralelas entre si. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59

9.5 Exemplo de um mapeamento afim de A(1,1) para A(1,1). . . . . . . . . . . . 60

10.1 Bloco de Be?zier de dom??nio prisma?tico . . . . . . . . . . . . . . . . . . . . 61

10.2 Uma func?a?o F , de A(2) para R, restrita ao K(2) (em amarelo) e sua repa-

rametrizac?a?o pelo mapeamento afim ? de A(1,1) para A(2), da sec?a?o 9.3.4,

resultando na func?a?o F ??, de A(1,1) para R, restrita ao K(1,1) (em vermelho). 63

11.1 Exemplo de modelo geolo?gico. . . . . . . . . . . . . . . . . . . . . . . . . . 70

11.2 Representac?a?o de Be?zier de um bloco do modelo da figura 11.1, mostrando

a grade de controle de Be?zier (em vermelho) e, para alguns pontos, os

respectivos ??ndices. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71

11.3 Outro exemplo de um bloco de Be?zier de multi-dimensa?o (1, 1, 1) e multi-

graus (3, 3, 1). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72

xx



11.4 Representac?a?o mais econo?mica dos blocos da figura 11.1. Os pontos verme-

lhos, verdes e azuis representam os coeficientes de Be?zier das componentes

X,Y e Z respectivamente. Observe que apenas uma coordenada de cada

ponto e? livre. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74

11.5 Implementac?a?o de um bloco de Be?zier. . . . . . . . . . . . . . . . . . . . . 75

11.6 Implementac?a?o do compartilhamento de para?metros entre blocos de Be?zier 76

11.7 Colagem conforme de dois blocos do tipo brickKind. . . . . . . . . . . . . 77

11.8 Diagrama da colagem conforme de dois blocos que compo?em a malha da

figura 11.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78

11.9 Uma malha pseudo-cil??ndrica composta por 3 pares de ane?is conce?ntricos,

cada um formado por 4 blocos. . . . . . . . . . . . . . . . . . . . . . . . . 79

11.10Um bloco simploidal para a malha da figura 11.9. Os pontos amarelos sa?o

pontos de controle de Be?zier das coordenadas X e Y enquanto os pontos

azuis sa?o os pontos de controle de Be?zier da coordenada Z. . . . . . . . . . 79

11.11Ilustrac?a?o dos para?metros que derivam os coeficientes de Be?zier de blocos

que compo?em a malha da figura 11.9. . . . . . . . . . . . . . . . . . . . . . 80

11.12Esquema da relac?a?o o reposito?rio de para?metros, um bloco e seu tipo com

matrizes de conversa?o entre para?metros externos e internos. . . . . . . . . . 82

11.13Um bloco prisma?tico de multi-grau (2, 2) e suas facetas (1, 0) e (0, 2). . . . 85

11.14Extrac?a?o de facetas de um prisma da figura 11.13 . . . . . . . . . . . . . . 86

11.15Facetas do bloco da malha cil??ndrica: (a) Faceta (0, 0), (b) . . . . . . . . . 86

11.16Extrac?a?o de facetas do prisma da figura 11.13 . . . . . . . . . . . . . . . . 87

11.17Elevac?a?o de grau de um bloco prisma?tico de multi-grau (2, 2) para (3, 3). . 88

11.18Diagrama ilustrativo da elevac?a?o de grau de um bloco prisma?tico. . . . . . 89

11.19Elevac?a?o de grau de um bloco da malha pseudo-cil??ndrica de grau (0, 3, 3)

em X,Y e (1, 0, 0) em Z, para (3, 3, 3) em X, Y e Z. . . . . . . . . . . . . 90

11.20Diagrama ilustrativo da elevac?a?o de grau de um bloco da malha pseudo-

cil??ndrica. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90

12.1 Uso de restric?o?es entre para?metros externos de dois blocos pseudo-cil??ndricos:

o cyl A (em verde) e o cyl B (em amarelo). . . . . . . . . . . . . . . . . . 94

12.2 Representac?a?o das restric?o?es 12.1 a 12.4 na BezEl. . . . . . . . . . . . . . . 95

12.3 Adic?a?o de um poc?o ao modelo da figura 11.1. . . . . . . . . . . . . . . . . 96

12.4 Regia?o em torno do poc?o. . . . . . . . . . . . . . . . . . . . . . . . . . . . 97

12.5 Diagrama da colagem conforme de um bloco que compo?e o poc?o com um

bloco de transic?a?o. Denotamos por X , E e I as operac?o?es de extrac?a?o

de uma faceta, elevac?a?o de grau e identificac?a?o de coeficientes de Be?zier,

respectivamente. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101

xxi



12.6 Colagem na?o-conforme de um bloco prism de dom??nio K(2,1) e grau (2, 2)

com um bloco tetra de dom??nio K(3) e grau (2). . . . . . . . . . . . . . . . 102

12.7 Colagem na?o-conforme. Ilustrac?a?o dos blocos para colagem, seus dom??nios

e o mapeamento de colagem. Denotamos por X , E, R e I as operac?o?es de

extrac?a?o de uma faceta, elevac?a?o de grau, reparametrizac?a?o e identificac?a?o

de coeficientes de Be?zier, respectivamente. . . . . . . . . . . . . . . . . . . 104

12.8 Colagem com suavidade. Na figura, o ponto P ? R3 e? A.F(U) = B.F(?(U)),

e o vetor ? ? R3 e? (D?A.F)(U) = (D?B.F)(?(U)). . . . . . . . . . . . . . . 106

14.1 Primeira etapa: definic?a?o das linhas nodais sobre a regia?o de interesse. . . 120

14.2 Segunda etapa: definic?a?o das interfaces (incluindo os limites superior e

inferior do modelo) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121

14.3 Terceira etapa: identificac?a?o das fa?cies (indicadas por cores arbitra?rias). . . 122

14.4 Quarta etapa: decomposic?a?o das fa?cies em blocos triangulares. . . . . . . . 122

14.5 Quinta etapa: especificac?a?o das velocidades em cada fa?cie. . . . . . . . . . 123

14.6 Interface do editor de geometria. As coordenadas Z dos pontos vermelhos

sa?o os coeficientes do modelo. . . . . . . . . . . . . . . . . . . . . . . . . . 126

15.1 Ilustrac?a?o da propagac?a?o de uma onda s??smica resultante de um impulso

inicial no instante t = 0 e no ponto R(0), mostrando a frente de onda em

dois instantes subsequ?entes t = t1 e t = t2, e um raio (em vermelho) com

direc?a?o inicial p(0). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129

15.2 Ilustrac?a?o do trac?ado de raios nas coordenadas locais de um bloco simploi-

dal bidimensional. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131

15.3 Modelo geof??sico criado pelo editor TopEdit. As velocidades variam de

1500m/s (ciano) a 5000m/s (vermelho). . . . . . . . . . . . . . . . . . . . . 133

15.4 Simulac?a?o s??smica por trac?amento de raios. Raios refletidos (a) na base da

primeira camada e (b) na base da segunda camada. . . . . . . . . . . . . . 134

xxii



Cap??tulo 1

Introduc?a?o

A explorac?a?o e monitoramento de um reservato?rio de petro?leo ou ga?s natural exige conhe-

cimento bastante detalhado das estruturas geolo?gicas da regia?o, num volume que pode

cobrir centenas de quilo?metros quadrados de a?rea e va?rios quilo?metros de profundidade.

Essas informac?o?es sa?o fundamentais tanto para a localizac?a?o de novas jazidas petrol??feras,

quanto para o melhor aproveitamento das jazidas existentes.

1.1 Modelagem Geof??sica

Esses para?metros incluem a densidade, velocidade de propagac?a?o de ondas s??smicas, po-

rosidade, conteu?do de o?leo, a?gua e ga?s, etc. Um sistema de modelagem geof??sica e? uma

colec?a?o de software para criac?a?o, manipulac?a?o e uso de tais modelos.

Nesta tese descrevemos um sistema geral para modelagem geof??sica. Como e? usual

na maioria de tais sistemas, a geometria e as propriedades das formac?o?es geolo?gicas sa?o

representadas por splines, as quais consistem da justaposic?a?o de diversos blocos de ge-

ometria simples deformados por func?o?es polinomiais. Estes incluem blocos simpliciais

(tetraedros ou tria?ngulos), os blocos tensoriais (hexaedros ou reta?ngulos) e os blocos sim-

ploidais que sa?o uma generalizac?a?o dos dois anteriores incluindo, por exemplo, prismas

de base triangular.

O sistema desenvolvido nesta tese permite a utilizac?a?o de blocos de todos estes tipos

em um mesmo modelo. Neste trabalho, desenvolvemos uma teoria matema?tica geral para

blocos simploidais, que trata blocos diferentes dom??nios, graus e dimenso?es de maneira

uniforme. Esta ana?lise teo?rica inclui fo?rmulas gerais expl??citas para elevac?a?o de grau,

diferenciac?a?o e conversa?o entre os diversos tipos de splines simploidais.

Para validac?a?o da teoria, implementamos uma biblioteca na linguagem C++, que

denominamos BezEl, que permite construir e manipular modelos geolo?gicos formados por

blocos simploidais gerais.

1



2 Cap??tulo 1. Introduc?a?o

Uma novidade desta biblioteca e? um mecanismo gene?rico para implementar restric?o?es

entre os para?metros dos blocos, por exemplo para restringir a geometria de um bloco ou

para impor continuidade entre blocos adjacentes. Este mecanismo e? geral o bastante para

permitir colagens na?o-conformes, onde uma u?nica face de um bloco corresponde a? unia?o

de duas ou mais faces de blocos adjacentes

Ale?m de geral, a implementac?a?o de cada bloco permite a representac?a?o econo?mica de

blocos com geometria restrita, por exemplo, quando va?rios blocos similares sa?o usados

para formar uma malha uniforme.

Embora a modelagem geof??sica tenha sido a motivac?a?o original e orientadora deste

trabalho, as ferramentas sa?o potencialmente u?teis em outras a?reas como engenharia civil,

meca?nica, hidra?ulica, aerona?utica, metereologia, oceanografia, astrof??sica, animac?a?o, etc.

No pro?ximo cap??tulo, descrevemos as principais abordagens para representac?a?o de

modelos geolo?gicos. O restante da tese consiste de duas partes: a formulac?a?o matema?tica

e a validac?a?o computacional. Na primeira parte, descrevemos os polino?mios de Bernstein

(cap??tulo 3), os elementos de Be?zier tensoriais (cap??tulo 5), simpliciais (cap??tulo 6) e a

conversa?o entre eles (cap??tulo 7). Em seguida, formalizamos os elementos simploidais

(cap??tulo 8) e sua reparametrizac?a?o afim (cap??tulo 10).

Na segunda parte, descrevemos os aspectos gerais da biblioteca BezEl (cap??tulo 11),

detalhamos o uso de restric?o?es nesta biblioteca (cap??tulo 12), e descrevemos um exemplo

de utilizac?a?o da mesma, consistindo de um editor gra?fico de modelos geolo?gicos bidimensi-

onais (cap??tulo 14). Finalmente, descrevemos uma metodologia para trac?amento de raios

eficiente em malhas de elementos simploidais (cap??tulo 15) que implementamos como um

proto?tipo em Java Applet.



Cap??tulo 2

Modelos geolo?gicos

Para muitos fins, a geologia de uma regia?o pode ser modelada adequadamente por uma

colec?a?o de fa?cies — regio?es tridimensionais, dentro das quais as propriedades do meio

variam suavemente — separadas por interfaces — superf??cies onde as propriedades do

meio apresentam alguma descontinuidade.

Um modelo geof??sico deve capturar os aspectos relevantes tanto da geometria das inter-

faces quanto da litologia (composic?a?o e propriedades f??sicas) das fa?cies. Para simulac?a?o

s??smica por trac?ado de raios, por exemplo, o sistema de modelagem deve ser capaz de

representar interfaces como superf??cies suaves (C1 ou C2) e deve tambe?m ser capaz de

modelar variac?a?o suave de propriedades f??sicas dentro de cada fa?cie.

2.1 Principais abordagens

Ha? tre?s grandes categorias de sistemas de modelagem geof??sica em uso corrente: (a)

sistemas baseados em grade uniforme, (b) sistemas baseados em interfaces e (c) sistemas

baseados em malhas tridimensionais.

2.1.1 Modelos baseados em grade uniforme

Uma te?cnica cla?ssica para modelagem geof??sica e? cobrir a regia?o de interesse com uma

grade densa e uniforme, armazenando as propriedades f??sicas de interesse em cada no? da

grade. Veja a figura 2.1. Estes modelos sa?o simples e extremamente flex??veis, mas na?o

conseguem modelar precisamente descontinuidades abruptas e intruso?es estreitas. Por

esta raza?o, sa?o mais utilizados em aplicac?o?es de imageamento baseado na equac?a?o da

onda (wave equation methods), que na?o requerem elevada precisa?o na representac?a?o das

propriedades f??sicas.

3



4 Cap??tulo 2. Modelos geolo?gicos

(a) (b)

Figura 2.1: (a) Ilustrac?a?o esquema?tica da geologia de uma regia?o e (b) modelagem da mesma
por uma grade uniforme.

2.1.2 Modelos baseados em interfaces

Em sistemas baseados em interfaces geolo?gicas, as fronteiras entre fa?cies sa?o modeladas

explicitamente por malhas bidimensionais. A geometria das fa?cies e? definida indireta-

mente, como sendo a partic?a?o da regia?o de interesse definida pelas interfaces. Sua grande

vantagem sobre os modelos baseados em grade uniforme e? a capacidade de representar

descontinuidades abruptas de forma precisa.

Dentre os sistemas baseados em interfaces, os mais simples permitem apenas mode-

los do tipo “bolo de camadas” (layer cake), onde a profundidade z de cada interface e?

considerada uma func?a?o da posic?a?o horizontal (x,y). Esta abordagem permite modelar

sucesso?es de camadas de formas e espessuras varia?veis, mas na?o permite modelar geolo-

gias mais complexas, como camadas dobradas sobre si mesmas (cavalgamentos), falhas,

intruso?es, etc.

Outros sistemas suportam interfaces e fa?cies com geometrias mais complexas. Um

exemplo e? o sistema descrito por Vinje [26]. Nesse sistema, cada interface e? implementada

por uma malha triangular onde as posic?o?es dos no?s sa?o dados do modelo. Veja a figura 2.2.

Informac?o?es adicionais sobre as interfaces (como normal e curvatura) sa?o estimadas pelo

sistema e armazenadas nos no?s da malha [20]. As propriedades f??sicas dentro de cada fa?cie

sa?o modeladas por func?o?es das coordenadas x,y,z do ponto, representadas por splines

tricu?bicas.



2.1. Principais abordagens 5

Figura 2.2: Modelo baseado em interfaces criado no sistema de modelagem do software Norsar.

2.1.3 Modelos de malhas tridimensionais

Nos sistemas baseados em malhas tridimensionais, a regia?o de interesse e? particionada

ce?lulas ou blocos, cuja geometria relativamente simples e? descrita por um pequeno nu?mero

de para?metros (ver, por exemplo Konig [16] ou Wang [28]). Combinando um nu?mero

suficiente de blocos pode-se representar geologias arbitrariamente complexas.

Para serem vantajosos, estes sistemas precisam suportar blocos com facetas na?o pla-

nas, que permitam modelar interfaces suaves. Uma escolha comum sa?o blocos polinomiais,

onde cada bloco e? a imagem de algum so?lido geome?trico simples por uma func?a?o polino-

mial.

Um exemplo desta categoria e? o sistema descrito por Meng e Bleinstein [21]. Esse

sistema usa blocos tetrae?dricos de grau 3 que preenchem a regia?o de interesse. Cada fa?cie

e? modelada por um subconjunto dos tetraedros, e cada interface e? a colec?a?o dos retalhos

triangulares que separam duas fa?cies.

Outro exemplo e? o sistema PZ de Devloo [7] cujos blocos sa?o generalizac?o?es dos blocos

de Coons [4], definidos por interpolac?a?o de pontos, curvas e superf??cies parame?tricas.

Dependendo dos tipos de blocos permitidos, sistemas baseados em malhas tridimen-

sionais permitem modelar estruturas geolo?gicas de forma arbitra?ria com continuidade e

suavidade. Normalmente eles permitem construir modelos com milho?es de blocos, mas

geralmente restringem os tipos de blocos a um u?nico tipo de elemento, simplicial ou ten-

sorial. A figura 2.3 mostra dois exemplos de modelos geolo?gicos criados usando softwares

comerciais.



6 Cap??tulo 2. Modelos geolo?gicos

(a)

(b)

Figura 2.3: Exemplos de modelos constru??dos por softwares comerciais: (a) Modelo criado usando
earthVision, da empresa Dynamic Grahics que usa apenas por blocos hexae?dricos tricu?bicos. (b)
Modelo criado usando goCAD, da empresa Paradigm, formado por por elementos prisma?ticos
de bases variadas.



2.2. Nossa abordagem 7

2.2 Nossa abordagem

2.2.1 Blocos simploidais

Nosso sistema de modelagem e? baseado em malhas tridimensionais. Cada elemento da

malha e? um bloco simploidal, que consiste em um conjunto de func?o?es polinomiais que

descrevem na?o apenas a geometria do bloco como tambe?m uma colec?a?o arbitra?ria de

propriedades f??sicas (densidade, elasticidade, etc) no seu interior. A figura 2.4 mostra um

exemplo de modelo geolo?gico representado utilizando nossa abordagem que consiste de

mais de 645 mil blocos hexae?dricos de grau 1.

Figura 2.4: Modelo geolo?gico representado utilizando nossa abordagem.

Tanto a geometria quanto a f??sica sa?o definidas em func?a?o do mesmo sistema de coordena-

das locais, que sa?o coordenadas barice?ntricas relativas ao dom??nio do bloco (por exemplo

um tetraedro regular ou um cubo unita?rio). A geometria e? definida por tre?s func?o?es X,Y

e Z, que fornecem as coordenadas reais na regia?o de interesse de cada ponto do bloco,

dadas suas coordenadas locais U. As propriedades f??sicas desse mesmo ponto sa?o dadas

por func?o?es adicionais das coordenadas locais U. Neste ponto, nossa abordagem difere de

va?rios sistemas, como o de Vinje [26], onde as propriedades f??sicas sa?o modeladas como

func?o?es das coordenadas reais X,Y e Z.

Nossa abordagem tem a vantagem de que alterac?o?es na geometria das fa?cies acarretam



8 Cap??tulo 2. Modelos geolo?gicos

automaticamente as alterac?o?es adequadas nas propriedades. Veja figura 2.5. Por outro

lado, esta abordagem e? inconveniente quando e? necessa?rio determinar as propriedades

f??sicas a partir das coordenadas X,Y e Z; como ocorre, por exemplo, na simulac?a?o s??smica.

No cap??tulo 15, apresentaremos um me?todo para contornar esta limitac?a?o.

Os blocos simploidais permitidos na nossa abordagem incluem tetraedros, hexaedros e

prismas triangulares com paredes curvas de grau arbitra?rio. Eles na?o incluem blocos mais

complexos, como octaedros, pira?mides de base quadrada, prismas hexagonais, etc. (Esta

limitac?a?o pode ser contornada utilizando dois ou mais blocos simploidais para modelar

estas outras formas.) A figura 2.6 mostra um exemplo de modelo geolo?gico que combina

blocos hexae?dricos de grau 3 e blocos tetrae?dricos de grau 1.

2.2.2 Informac?o?es topolo?gicas

No nosso sistema, um modelo conte?m, ale?m da colec?a?o e blocos, uma relac?a?o de adjace?ncia

que descreve a topologia da malha e, para cada par de blocos adjacentes, um mapeamento

de colagem que relaciona as coordenadas locais dos dois blocos na faceta comum.

2.2.3 Restric?o?es intra- e inter-blocos

Cada modelo tambe?m inclui, opcionalmente, um conjunto de restric?o?es sobre os para?me-

tros dos blocos que o compo?em. Estas restric?o?es podem incluir, por exemplo, condic?o?es

de continuidade (restric?o?es inter-blocos), que garantem que na?o haja frestas ou sobre-

posic?a?o entre blocos vizinhos, que as interfaces possuam derivadas cont??nuas, ou que as

propriedades f??sicas variam suavemente de um bloco para outro da mesma fa?cie. Outros

tipos de restric?o?es (restric?o?es intra-blocos) podem ser utilizadas para eliminar para?metros

desnecessa?rios na descric?a?o de cada bloco. Estas restric?o?es podem ser utilizadas para

garantir que as condic?o?es acima sejam satisfeitas durante a construc?a?o e edic?a?o interativa

do modelo.



2.2. Nossa abordagem 9

(a)

(b)

Figura 2.5: Ilustrac?a?o da abordagem acoplada para modelagem de geometria e propriedades
f??sicas. (a) Modelo inicial e (b) modelo depois de alterar a geometria.



10 Cap??tulo 2. Modelos geolo?gicos

Figura 2.6: Modelo geolo?gico constru??do com nossa biblioteca BezEl, usando blocos hexae?dricos
e tetrae?dricos.



Cap??tulo 3

Polino?mios de Bernstein

Neste cap??tulo, revisamos conceitos relacionados aos polino?mios de Bernstein-Be?zier uni-

variados, e definimos o conceito de arcos de Be?zier.

3.1 A base de Bernstein univariada

Para qualquer g ? N, a base de Bernstein univariada de grau g consiste dos polino?mios

B
g
i , para i = 0, · · · ,g, definidos por:

B
g
i (z) =

(

g

i

)

zi (1 ? z)g?i (3.1)

para todo z ? R [1]. Na teoria de Be?zier e? conveniente introduzir a notac?a?o z? = 1 ? z.

Nesta notac?a?o, a fo?rmula 3.1 fica

B
g
i (z) =

(

g

i

)

zi z? g?i (3.2)

Veja a figura 3.1.

Note que a fo?rmula (3.2) e? o termo geral da fo?rmula de Newton para pote?ncia g do

bino?mio (z + z?)g. Os polino?mios de Bernstein sa?o importantes tambe?m na teoria da

probabilidade: se z e? a probabilidade de um evento E, enta?o B
g
i (z) e? a probabilidade de

E ocorrer exatamente i vezes em g tentativas.

Dentre as propriedades dos polino?mios de Bernstein, destacamos:

P1: Os polino?mios sa?o na?o-negativos no intervalo [0, 1]

P2: Cada polino?mio tem apenas um ma?ximo no intervalo [0, 1], em z = i/g

11



12 Cap??tulo 3. Polino?mios de Bernstein

 0

 1

 0  0.25  0.5  0.75  1

t

B
4 i
(t
)

i=0
i=1
i=2
i=3
i=4

Figura 3.1: Elementos da base de Bernstein univariada de grau 4

P3: Os polino?mios de grau g formam uma partic?a?o da unidade:

g
?

i=0

B
g
i (z) = 1 para todo z ? R.

P4: Todos os polino?mios sa?o nulos em z = 0, exceto B
g
0 .

P5: Todos os polino?mios sa?o nulos em z = 1, exceto Bgg .

3.2 Representac?a?o de Be?zier para polino?mios

A representac?a?o de Be?zier de uma func?a?o polinomial f de grau g de R para R e? sua

expansa?o em termos da base de Bernstein univariada, ou seja

f(z) =

g
?

i=0

biB
g
i (z) (3.3)

onde b0, · · · ,bg sa?o nu?meros reais, chamados ordenadas de Be?zier ou coeficientes de Be?zier

da func?a?o f. Em consequ?e?ncia da propriedade P3, o valor de f(z), para qualquer z ? [0, 1],

esta? no intervalo [bmin,bmax], onde bmin e? o menor dos coeficientes bi, e bmax o maior deles.

E? comum associar cada coeficiente de Be?zier bi de B
g
i a? sua posic?a?o nominal i/g, o

valor de z onde B
g
i (z) atinge seu ma?ximo no intervalo [0, 1].



3.3. Elevac?a?o de grau 13

3.3 Elevac?a?o de grau

A fo?rmula de elevac?a?o de grau (3.4) proposta por Trump [24] nos permite expressar um

polino?mio de Bernstein B
g
i (z) de grau g como uma combinac?a?o linear de polino?mios B

h
j (z)

de qualquer grau prescrito h ? g.

B
g
i (z) =

i+h?g
?

k=i

(

k

i

)(

h ? k

g ? i

)

(

h

g

) Bhk (z) (3.4)

Portanto, para converter um polino?mio f de sua representac?a?o em termos de Bg para

sua representac?a?o em termos de Bh basta multiplicar seu vetor de coeficientes de Be?zier

(b0, · · · ,bg) pela matriz M de (g + 1) linhas e (h + 1) colunas, onde

Mik =

?

?

?

?

?

(

h

g

)?1(
k

i

)(

h ? k

g ? i

)

se i ? k e i ? k ? (h ? g)

0 caso contra?rio

3.4 Diferenciac?a?o

A derivada de ordem r do polino?mio de Bernstein univariado B
g
i e? dada por

?rB
g
i (z) = ?

r

((

g

i

)

zi(1 ? z)g?i
)

Utilizando a fo?rmula de Leibnitz para a derivada do produto [15], temos que

?rB
g
i (z) =

(

g

i

) r
?

j=0

(

r

j

)

(

?jzi
)(

?r?j(1 ? z)g?i
)

Note que o termo dentro do somato?rio se anula sempre que j &gt; i ou r ? j &gt; g ? i, pois a

j-e?sima derivada de um polino?mio de grau i e? zero. Enta?o,

?rB
g
i (z) =

g!

i!(g ? i)!

r
?

j=0
j?r?g+i

j?i

(

r

j

)

i!

(i ? j)!
zi?j

(g ? i)!

(g ? i ? r + j)!
(1 ? z)g?i?r+j(?1)r?j

=
g!

(g ? r)!

r
?

j=0
j?r?g+i

j?i

(

r

j

)

(?1)r?j
(

g ? r

i ? j

)

zi?j(1 ? z)g?i?r+j

=

r
?

j=0
j?r?g+i

j?i

g!

(g ? r)!

(

r

j

)

(?1)r?jB
g?r
i?j (z) (3.5)



14 Cap??tulo 3. Polino?mios de Bernstein

Como consequ?e?ncia desta fo?rmula, temos

?B
g
i (0) =

?

?

?

?1 se i = 0

1 se i = 1

0 c.c.

e ?B
g
i (1) =

?

?

?

?1 se i = g

1 se i = g ? 1

0 c.c.

Mais geralmente,

?rB
g
i (0) =

?

?

?

?

?

?

?

?

?

r
?

j=0
j?r?g+i

j?i

g!

(g ? r)!

(

r

j

)

(?1)r?j se i ? r

0 c.c.

e

?rB
g
i (1) =

?

?

?

?

?

?

?

?

?

r
?

j=0
j?r?g+i

j?i

g!

(g ? r)!

(

r

j

)

(?1)r?j se i ? r

0 c.c.

3.5 Arco de Be?zier

A representac?a?o de Be?zier para polino?mios e? muito usada em computac?a?o gra?fica para

descrever curvas suaves de forma arbitra?ria. Este uso foi introduzido por P.Be?zier na

de?cada de 60 para controle nume?rico e projeto de carrocerias de automo?vel [1]. Formal-

mente, definimos uma curva de Be?zier de grau g em Rm como uma func?a?o F : R ? Rm

cujas m componentes F0,F1, · · ·Fm?1 sa?o polino?mios de grau g, definidos em termos da

representac?a?o de Be?zier. A restric?a?o da curva ao intervalo [0, 1] e? chamada de arco de

Be?zier.

Os g + 1 coeficientes de Be?zier das m componentes do arco podem ser interpretados

como as coordenadas de g + 1 pontos do Rm, chamados de pontos de controle ou pontos

de Be?zier do arco. Mais especificamente, para qualquer i = {0, · · · ,g}, o ponto de

controle Pi ? R
m e? tal que sua j-e?sima coordenada e? o coeficiente de Be?zier de ??ndice i

da componente Fj. A poligonal que liga os pontos de Be?zier Pi, na ordem crescente de

??ndice i, e? chamada de poligonal de Be?zier do arco. Veja a figura 3.2.

Note que os pontos F(z) de arco de Be?zier F esta?o totalmente contidos no fecho convexo

dos pontos de controle de F . Esta propriedade dos arcos de Be?zier e? consequ?e?ncia direta da

propriedade P3 dos polino?mios de Bernstein univariados. Outra propriedade importante e?

que os pontos P0 e Pg sa?o os extremos do arco, isto e? F(0) = P0 e F(1) = Pg. Ale?m disso,

o vetor velocidade da curva no in??cio ?F(0) e? mu?ltiplo do vetor P1 ? P0, e no fim ?F(1)

e? um mu?ltiplo de Pg ? Pg?1. Mais geralmente, a r-e?sima derivada inicial ?
rF(0) depende



3.5. Arco de Be?zier 15

F0(z)

F
1
(z
)

F
0
(z
)

0 1
4

1
2

3
4

1

z

F
1
(z
)

0 1
4

1
2

3
4

1

Figura 3.2: Um arco de Be?zier F de grau 4 no R2 (esquerda em vermelho) mostrando seus
pontos de controle de Be?zier (em azul) e a poligonal de Be?zier (tracejada); e os gra?ficos de suas
componentes F0(z) = 2z

4 + 3z e F1(z) = z
4 + z2 (direita) mostrando os respectivos coeficientes

de Be?zier (pontos azuis).

apenas dos pontos P0,P1, · · · ,Pr, e a final ?
rF(1) apenas dos pontos Pg,Pg?1, · · · ,Pg?r.

Estas propriedades decorrem das propriedades P4 e P5 da base de Bernstein, e simplificam

bastante a concatenac?a?o de dois ou mais arcos de Be?zier para formar um spline de Be?zier

de continuidade arbitra?ria.



Cap??tulo 4

Multi-, hiper- e ultra-??ndices

Neste cap??tulo, introduzimos uma notac?a?o especial para indexac?a?o de objetos multi-

dimensionais, necessa?ria para os cap??tulos seguintes.

4.1 Multi-??ndices

Como DeRose [6], definimos um multi-??ndice como uma tupla ? = (?0, · · · ,?d) de nu?meros

naturais. Denotamos por I o conjunto de todos os multi-??ndices, e por Id o conjunto de

todos os multi-??ndices com d + 1 componentes, ou seja Nd+1. Para quaisquer d,n ? N,

tais que n ? d, quaisquer multi-??ndices ?,? ? Id, qualquer vetor x ? R
d+1, e qualquer

func?a?o F de Rd+1 para R, definimos as seguintes operac?o?es:

17



18 Cap??tulo 4. Multi-, hiper- e ultra-??ndices

soma e subtrac?a?o: ? ± ? = (?0 ± ?0,?1 ± ?1, · · · ,?d ± ?d)

divisa?o: ?/? = (?0/?0, · · · ,?d/?d) ? R
d

divisa?o por um nu?mero real: ?/g = (?0/g, · · · ,?d/g) ? R
d

comparac?a?o: ? ? ? ? (?0 ? ?0) ? (?1 ? ?1) ? · · · ? (?d ? ?d)

total: |?| = ?0 + ?1 + · · · + ?d

fatorial: ?! = ?0!?1! · · ·?d!

coeficiente multinomial:

(

g

?

)

=
g!

?!
=

g!

?0! · · ·?d!

multi-combinac?a?o:

(

?

?

)

=
?!

(? ? ?)!?!
=

(

?0
?0

)

· · ·

(

?d
?d

)

pote?ncia: x? = x?00 x
?1
1 · · ·x

?d
d

derivada parcial: ??F = ??00 · · ·?
?d
d F

Quando um multi-??ndice ? e? usado como um expoente, como na fo?rmula de potenciac?a?o

acima, tambe?m usamos o termo multi-grau.

Para quaisquer g ? Z e d ? N denotamos por I
g
d o conjunto dos multi-??ndices ? ? Id

tais que |?| = g. (Observe que I
g
d
= ? se g &amp;lt;0.) Denotamos tambe?m por g ? d a tupla

(g,g, · · · ,g) ? Id?1, com d elementos, todos iguais a g.

O uso de multi-??ndices simplifica diversas fo?rmulas de a?lgebra multivariada, ca?lculo,

equac?o?es diferenciais parciais, probabilidade, etc. Por exemplo, para quaisquer d,g ? N e

qualquer x = (x0,x1, · · · ,xd) ? R
d+1, a fo?rmula multinomial

(x0 + x1 + · · · + xd)
g =

?

i0,·,id
i0+···+id=g

g!

(

d
?

j=0

x
ij
j

ij!

)

pode ser escrita de forma mais sucinta como

(x0 + x1 + · · · + xd)
g =

?

??I
g
d

g!

?!
x? =

?

??I
g
d

(

g

?

)

x? (4.1)

Outro exemplo e? a fo?rmula de Leibnitz para a r-e?sima derivada do produto de va?rias

func?o?es. Sejam F0(t), · · · ,Fd(t), d + 1 func?o?es de R para R. Na notac?a?o usual, a fo?rmula

e?

?r

(

d
?

i=0

Fi

)

=

r
?

?0=0

· · ·
r
?

?d=0
?0+···+?d=r

d
?

i=0

??iFi



4.2. Matrizes irregulares e hiper-??ndices 19

Usando multi-??ndices, a fo?rmula reduz-se a

?r

(

d
?

i=0

Fi

)

=
?

??Ir
d

(

r

?

) d
?

i=0

??iFi (4.2)

4.2 Matrizes irregulares e hiper-??ndices

Para indexar coeficientes de polino?mios simploidais (cap??tulo 8), necessitamos estender a

notac?a?o de multi-??ndice. Para este fim, definimos uma matriz irregular como uma tupla

M = (M0,M1, · · · ,Mm) de tuplas reais (suas linhas). Note que, diferentemente de uma

matriz ordina?ria, uma matriz irregular pode conter linhas de tamanhos diferentes; por

exemplo ((1, 0), (2, 5, 3)) ou

(

1 0

2 5 3

)

(4.3)

Dado um multi-??ndice ? ? Im, denotamos por M? o conjunto de todas as matrizes irregu-

lares tais que sua i-e?sima linha tem ?i + 1 componentes. Por exemplo, a matriz (4.3) e?

um elemento de M(1,2).

Um hiper-??ndice e? uma matriz irregular de nu?meros naturais; ou seja, uma tupla

? = (?0, ?1, · · · , ?m) de multi-??ndices, a exemplo de (4.3) acima. Note que um multi-

??ndice pode ser visto como um hiper-??ndice de uma u?nica linha. (O termo hiper-??ndice ja?

foi usado por DeRose [6], mas apenas para matrizes regulares).

Dado um multi-??ndice ? ? Im, denotamos por H? o conjunto de todos os hiper-??ndices

? tais que cada linha ?i pertence a I?i. Ou seja, H? e? o subconjunto de M? cujos elementos

sa?o naturais. No caso espec??fico de ? = n ? (m + 1), ou seja, quando todas as linhas ?i
tem o mesmo nu?mero de componentes ?i + 1 = n + 1, abreviamos H? por Hm,n. Neste

caso, um elemento de Hm,n e? uma matriz ordina?ria (retangular) de nu?meros naturais com

m + 1 linhas e n + 1 colunas.

Dados nu?meros naturais m e s, multi-??ndices ?,?,? ? Im, hiper-??ndices ?, ? ? H?, e

duas matrizes irregulares U,T ? M?, definimos as operac?o?es



20 Cap??tulo 4. Multi-, hiper- e ultra-??ndices

divisa?o por um multi-??ndice: ?/? = (?0/?0, · · · , ?m/?m) ? M?

comparac?a?o: ? ? ? ? (?0 ? ?0) ? (?1 ? ?1) ? · · · ? (?m ? ?m)

soma das colunas: |?| = (|?0|, · · · , |?m|) ? Im

total: ||?|| = |(|?|)| ? N

fatorial: ?! = ?0!?1! · · · ?m!

hiper-combinac?a?o:

(

?

?

)

=
?!

?!(? ? ?)!
=

(

?0
?0

)

· · ·

(

?d
?d

)

pote?ncia: T? =
?m

i=0

??i
j=0 T

?i,j
i,j

Ademais, se ? ? Im e? tal que ?i ? (m ? 1), e ? e? um hiper-??ndice pertencente a H? (ou

seja, cada linha tem ao menos m elementos), denotamos por diag(?) a diagonal de ?, ou

seja, o multi-??ndice (?00, ?11, · · · , ?mm) ? Im.

Dados m,n ? N, e multi-??ndices ?,? ? Im denotamos por H
?
? o conjunto de todos os

hiper-??ndices ? tais que o total |?i| de cada linha ?i e? ?i. Ale?m disso, denotamos por

H
?,?
m,n o conjunto de todos o hiper-??ndices (retangulares) ? ? H

?
m,n tais que a soma da

j-e?sima coluna e? ?j.

Da mesma forma que multi-??ndices, os hiper-??ndices nos permitem simplificar muitas

fo?rmulas da a?lgebra multi-afim. Por exemplo, a expansa?o do produto de pote?ncias de

multino?mios

(x00 + x01 + x02)
5(x10 + x11)

3(x20 + x21 + x22 + x23)
2

utilizando a notac?a?o de hiper-??ndices, pode ser escrito como

?

??H
(5,3,2)
(2,1,3)

(

(5, 3, 2)

?

)

?

?

x00 x01 x02
x10 x11
x20 x21 x22 x23

?

?

?

Outros exemplos de uso de hiper-??ndices sera?o vistos no cap??tulo 8.

4.3 Ultra-??ndices

Para as fo?rmulas de reparametrizac?a?o de polino?mios simploidais (cap??tulo 10), necessi-

tamos estender ainda mais a notac?a?o de ??ndices. Para este fim, definimos um tensor

irregular como uma tupla T = (T0,T1, · · · ,Tp) onde cada Ti, chamado de plano i de T , e?

uma matriz irregular. Denotamos por Tp o conjunto de todos os tensores irregulares de

p + 1 planos.



4.3. Ultra-??ndices 21

Um ultra-??ndice e? um tensor irregular de nu?meros naturais; ou seja, uma tupla ? =

(?0, ?1, · · · , ?p) de hiper-??ndices. Observe que um hiper-??ndice por ser visto como um

ultra-??ndice de um u?nico plano.

Para todo m,p ? N e todo ? ? Im, denotamos por Up,? o conjunto de todos os ultra-

??ndices que consistem de p + 1 hiper-??ndices, todos em H?. As operac?o?es de hiper-??ndices

podem ser estendidas para ultra-??ndices. Em particular, definimos a soma dos planos de

um ultra-??ndice ? ? Up.?, como o hiper-??ndice |?| = ?0 +?1 + · · ·?p. Definimos tambe?m

o fatorial de um ultra-??ndice ? ? Up.?, denotado por ?!, como o produto ?0!?1! · · · ?p!

Dados m,p ? N, uma multi-dimensa?o ? ? Im e um hiper-??ndice ?, denotamos por U
?
p,?

o conjunto de todos os ultra-??ndices ? tais que |?| = ?.



Cap??tulo 5

Elementos de Be?zier tensoriais

Neste cap??tulo, revisamos conceitos relacionados aos polino?mios de Bernstein-Be?zier ten-

soriais; e definimos os elementos de Be?zier tensoriais utilizados por P. Be?zier na de?cada

de 1960 [1].

5.1 Polino?mios tensoriais

Definimos o espac?o dos polino?mios tensoriais de dimensa?o d ? N e multi-grau ? ? Id?1,

denotado por P?d , como o espac?o vetorial de todas as func?o?es f de R
d para R, tais que

f(x) e? um polino?mio de grau ?i em cada coordenada xi do argumento, quando sa?o fixadas

todas as demais coordenadas xj com j 6= i. Por exemplo, a func?a?o f de R
2 para R com

fo?rmula

f(x) = 4x30 + 5x1 ? 3x0x
2
1 + 5x0x1

= (4)x30 + (?3x
2
1 + 5x1)x0 + (5x1)

= (?3x0)x
2
1 + (5x0 + 5)x1 + (4x

3
0)

e? um polino?mio tensorial de multi-grau (3, 2). Note que f(x) na?o pode ser escrito como

o produto de dois polino?mios f ?(x0) e f
??(x1), cada um dependendo apenas de uma coor-

denada.

A base cano?nica de P?d e? a lista de todos os mono?mios em d varia?veis x0, · · · ,xd?1 que

possuem grau no ma?ximo ?i em cada varia?vel xi. Por exemplo, para d = 2 e ? = (1, 2),

a base cano?nica e? 1, x0, x1, x0x1, x
2
1 e x0x

2
1. A dimensa?o de P

?
d e?

?d?1
i=0 (?i + 1).

5.1.1 A base de Bernstein tensorial

Dado d ? N e um multi-grau ? ? Id?1, a base de Bernstein tensorial de P
?
d , consiste dos

polino?mios tensoriais B?? (u), para todos os multi-??ndices ? ? Id?1 tais que ? ? ?, cada

23



24 Cap??tulo 5. Elementos de Be?zier tensoriais

(a) ? = (0, 2) (b) ? = (1, 1)

(c) ? = (2, 0)

Figura 5.1: Alguns dos 12 polino?mios B?? da base de Bernstein tensorial de P
(3,2)
2 . Os eixos

vermelho, verde e azul representam x0, x1 e B
(3,2)
? (x0, x1).

um definido por

B?? (x) =
d?1
?

i=0

B?i?i (xi) (5.1)

para todo x ? Rd. Veja figura 5.1.

Os polino?mios de Bernstein tensoriais B?? (u) compartilham varias propriedades dos

polino?mios de Bernstein univariados B
g
i (z), incluindo:

P1?: Os polino?mios B?? sa?o na?o-negativos no hipercubo [0, 1]
d

P2?: Cada polino?mio tem apenas um ma?ximo no hipercubo [0, 1]d, no ponto ?/? ? Rd.

P3?: Os polino?mios B?? de mesmo multi-grau ? formam uma partic?a?o da unidade:
?

??Id?1
???

B?? (x) = 1 para todo x ? R
d.



5.1. Polino?mios tensoriais 25

5.1.2 A representac?a?o de Be?zier de polino?mios tensoriais

Seja f uma func?a?o polinomial tensorial de multi-grau ? ? Id?1 de R
d para R. A re-

presentac?a?o de Be?zier de f e? sua expansa?o em termos da base de Bernstein tensorial, a

saber

f(x) =
?

??Id?1
???

b?B
?
? (x) (5.2)

onde cada b? e? um nu?mero real, o coeficiente de Be?zier (tensorial) de multi-??ndice ? de

f.

Para fins de visualizac?a?o, costuma-se definir a posic?a?o nominal de cada coeficiente de

Be?zier b? como o ponto ?/? = (?0/?0, · · · ,?d?1/?d?1) ? R
d, onde esse polino?mio atinge

o ma?ximo. Veja a figura 5.1.

5.1.3 Elevac?a?o de grau

Se ? e ? sa?o dois multi-graus pertencentes a Id?1 com ? ? ?, enta?o a aplicac?a?o repetida

da fo?rmula de elevac?a?o de grau (3.4) garante que cada polino?mio B?? de multi-grau ? pode

ser expresso como uma combinac?a?o linear de polino?mios B?? de multi-grau ?. A saber,

B?? (x) =
?

??Id?1
????(???)

???
???

(

?

?

)?1(
?

?

)(

? ? ?

? ? ?

)

B?? (x)

para todo x ? Rd.

5.1.4 Diferenciac?a?o

Pelas fo?rmulas (5.1) e (3.5), a i-e?sima derivada parcial de ordem r de B?? e?

?ri B
?
? (x) = ?

r
i

?

?

?
B?i?i (xi)

d?1
?

j=0
j 6=i

B?j?j (xj)

?

?

?

=

?

?

?

?

?

r
?

p=0
p?r??i+?i

p??i

?i!

(?i ? r)!

(

r

p

)

(?1)r?pB?i?r?i?p (xi)

?

?

?

?

?

d
?

j=0
j 6=i

B?j?j (xj)



26 Cap??tulo 5. Elementos de Be?zier tensoriais

Portanto, para qualquer ? ? Id, a derivada mista de ordem ?i em cada coordenada xi e?

??B?? (x) = ?
?0
0 · · ·?

?d
d B

?
? (x) =

d?1
?

i=0

?

?

?

?

?

r
?

p=0
p??i??i+?i

p??i

?i!

(?i ? ?i)!

(

?i
p

)

(?1)?i?pB?i??i?i?p (xi)

?

?

?

?

?

=
?

µ?Id
µ????+?

µ??

?!

(? ? ?)!

(

?

µ

)

(?1)|?|?|µ|B?????µ (x) (5.3)

Observe que ??B?? e? um polino?mio tensorial de multi-grau ? = ? ? ? se ? ? ?. Caso

contra?rio (se ?i &gt; ?i para algum i), a derivada e? o polino?mio nulo pois o somato?rio fica

vazio.

5.1.5 Derivada direcional

Se X e? um conjunto e E e? uma expressa?o que envolve uma varia?vel livre x, escrevemos

(x : X ? E) (5.4)

para a func?a?o de dom??nio X que mapeia cada x ? X para o valor correspondente de E.

Seja ? um vetor do Rd e f uma func?a?o de Rd para R. A derivada (direcional) de ordem

r de f na direc?a?o ? e? definida por

(Dr?f)(x) = [?
r (t : R ? f(x + t?))] (0).

A derivada direcional de ordem r do polino?mio de Bernstein tensorial B?? na direc?a?o ? e?

portanto

(Dr?B
?
? )(x) =

[

?r

(

t : R ?
d?1
?

i=0

B?i?i (xi + t?i)

)]

(0)

Aplicando a fo?rmula de Leibniz (4.2), temos

(Dr?B
?
? )(x) =

?

??Ir
d?1

r!

?!

d?1
?

i=0

[

??i
(

t : R ? B?i?i (xi + t?i)
)]

(0)

=
?

??Ir
d?1

r!

?!

d?1
?

i=0

??ii (?
?iB?i?i )(xi)

=
?

??Ir
d?1

r!

?!
??(??B?? )(x)

(5.5)



5.2. Elementos tensoriais de Be?zier 27

para todo x ? Rd. Observe que (Dr?B
?
? ) e? um polino?mio tensorial cujo multi-grau ? na?o

excede ?. No caso espec??fico em que ? e? paralelo ao eixo de coordenadas i do dom??nio,

?i = max {0,?i ? r} e ?j = ?j para todo j 6= i.

5.2 Elementos tensoriais de Be?zier

Assim como polino?mios univariados de Be?zier sa?o usados para modelar curvas arbitra?rias,

os polino?mios tensoriais de Be?zier sa?o usados para modelar superf??cies e volumes. Para

este fim, define-se um elemento tensorial de Be?zier de dimensa?o d e multi-grau ? ? Id?1
em Rm como sendo uma func?a?o F : [0, 1]d ? Rm cujas m componentes sa?o polino?mios do

espac?o P?d definidos em termos da representac?a?o de Be?zier. Note que um arco de Be?zier e?

um caso particular de elemento tensorial de Be?zier (com d = 1). Os outros casos de maior

importa?ncia em modelagem geome?trica sa?o o retalho tensorial (d = 2) e o bloco tensorial

(d = 3) de Be?zier. Veja a figura 5.2.

De forma ana?loga aos arcos de Be?zier, os m coeficientes de Be?zier de um mesmo

elemento F com mesmo multi-??ndice ? em cada componente podem ser vistos como as

coordenadas de um ponto P? do R
m, o ponto de controle de Be?zier de ??ndice ?. A grade

de controle de um elemento de Be?zier e? formada pelos seus pontos de controle e pelos

segmentos de reta que ligam cada ponto P? aos pontos P? tais que apenas um dos ??ndices

?i difere do correspondente ??ndice ?i, e em apenas uma unidade. Veja a figura 5.3.

Em decorre?ncia da propriedade P3?, os pontos F(x) de um elemento tensorial F esta?o

totalmente contidos no fecho convexo dos pontos de controle de F [9].



28 Cap??tulo 5. Elementos de Be?zier tensoriais

(a)

(b) (c) (d)

Figura 5.2: (a) Um elemento tensorial de Be?zier F de dimensa?o 2 (retalho) e multi-grau (2, 3)
no R3; e suas componentes (b) F0, (c) F1 e (d) F2.



5.2. Elementos tensoriais de Be?zier 29

Figura 5.3: A grade de controle (em vermelho) de um retalho tensorial de Be?zier de dimensa?o 2
e multi-grau (3, 2)(amarelo).



Cap??tulo 6

Elementos de Be?zier simpliciais

Neste cap??tulo, revisamos conceitos relacionados aos polino?mios de Bernstein-Be?zier sim-

pliciais e definimos os elementos de Be?zier simpliciais.

6.1 Espac?os afins cano?nicos

Definimos o espac?o afim cano?nico de dimensa?o d ? N, denotado por Ad, como o conjunto

A
d = {u ? Rd+1

?

?

d
?

i=0

ui = 1}. (6.1)

Note que os pontos de Ad constituem um hiperplano d-dimensional do Rd+1 que corta

cada eixo na coordenada 1. Veja a figura 6.1. Note tambe?m que A0 possui um u?nico

ponto, a 1-tupla (1); e que Ad+e na?o e? o mesmo que Ad × Ae.

A
1

A
2

x0x0
x1

x1 x2

Figura 6.1: Espac?os afins A1 e A2.

Definimos tambe?m o espac?o tangente afim cano?nico de dimensa?o d ? N, denotado por

V
d, como o espac?o tangente de Ad, isto e? o conjunto de todos os vetores de Rd+1 que sa?o

31



32 Cap??tulo 6. Elementos de Be?zier simpliciais

diferenc?as de dois pontos de Ad. Mais especificamente,

V
d = {? ? Rd+1

?

?

d
?

i=0

?i = 0}. (6.2)

Note que Vd+e na?o e? o mesmo que Vd × Ve.

6.1.1 Simplexos cano?nicos

Definimos o simplexo cano?nico de dimensa?o d ? 0 como o conjunto Kd dos pontos de Ad

que tem todas as coordenadas na?o-negativas; ou seja

K
d = {(u0, · · · ,ud) ? R

d+1
?

?

d
?

i=0

ui = 1 ?
d
?

i=0

ui ? 0} (6.3)

Os simplexos cano?nicos de dimensa?o 1, 2 e 3 sa?o um segmento em R2, um tria?ngulo

equ?ila?tero em R3 e um tetraedro regular em R4, ilustrados na figura 6.2.

K
1

K
2

K
3

x0
x0x0 x1x1

x1
x2

x2

x3

Figura 6.2: Simplexos cano?nicos.

6.1.2 Facetas

Definimos a faceta j do simplexo cano?nico Kd, denotada por Kd|j, como sendo o conjunto

de pontos u ? Kd tais que uj = 0. Note que K
d|j e? congruente ao simplexo K

d?1.

6.2 Polino?mios simpliciais

Definimos o espac?o dos polino?mios simpliciais de dimensa?o d ? N e grau g ? N, denotados

por P
g
d, como o conjunto das func?o?es f de A

d para R tais que f pode ser expresso como

um polino?mio de grau g nas d + 1 coordenadas do argumento u. Por exemplo,

f(u) = 3u0u
2
1 + 2u

3
1 (6.4)



6.2. Polino?mios simpliciais 33

e? um elemento de P22 . Verifica-se que a dimensa?o de P
g
d
e?

(

d + g

g

)

[5].

Uma vez que as coordenadas do argumento somam 1, qualquer mono?mio pode ser

multiplicado por qualquer pote?ncia de (u0 + · · · + ud) sem afetar o valor de f. Portanto,

o mesmo polino?mio pode ser escrito de va?rias formas. O polino?mio f da fo?rmula (6.4),

por exemplo, pode ser escrito tambe?m como

f(u) = 3u20u
2
1 + 2u0u

3
1 + 3u0u

3
1 + 2u

4
1

Se f e? um polino?mio de grau g, podemos obter uma fo?rmula u?nica (para cada g) exigindo

que o polino?mio seja homoge?neo, isto e? que todos os mono?mios tenham o mesmo grau

total. Para colocar uma colec?a?o arbitra?ria de mono?mios nesta forma, basta multiplicar

todo mono?mio com grau total k &amp;lt;g por (u0 + · · · + ud)
g?k.

6.2.1 A base de Bernstein simplicial

Dados d ? N e g ? N, a base de Bernstein simplicial de P
g
d
consiste dos polino?mios

simpliciais Bg? de A
d para R, para todo ? ? I

g
d, onde

Bg?(u) =

(

g

?

)

u? para todo u ? Ad (6.5)

Veja figura 6.3.

Note que, no caso espec??fico onde d = 1, a fo?rmula (6.5) para Bg?(u) e? equivalente a?

fo?rmula (3.2) do polino?mio de Bernstein univariado B
g
i (z), com u0 = z, u1 = z? = 1 ? z,

?0 = i e ?1 = g ? i.

Observe tambe?m que a fo?rmula (6.5) esta? relacionada com a fo?rmula de Newton para

a pote?ncia g do multino?mio (u0 + u1 + · · · + ud). Em teoria estat??stica, esta fo?rmula

define a distribuic?a?o de probabilidade multinomial. Suponha que um experimento pode

ter d + 1 resultados mutuamente exclusivos E0, · · · ,Ed sendo que cada Ei ocorre com

probabilidade ui. Enta?o, B
g
?(u) e? a probabilidade de, em g tentativas, o evento E0 ocorrer

?0 vezes, E1, ?1 vezes, ..., e Ed ?d vezes.

As propriedades de polino?mios univariados te?m ana?logos para simpliciais:

P1??: Os polino?mios sa?o na?o-negativos no simplexo Kd

P2??: Cada polino?mio tem apenas um ma?ximo no simplexo de Kd, no ponto ?/g ? Ad.

P3??: Os polino?mios Bg? de mesmo grau g formam uma partic?a?o da unidade:

?

??I
g
d

Bg?(u) = 1 para qualquer u ? K
d (6.6)



34 Cap??tulo 6. Elementos de Be?zier simpliciais

(a) B3
(3,0,0)

(u) (b) B3
(0,3,0)

(u)

(c) B3
(0,0,3)

(u) (d) B3
(2,1,0)

(u)

(e) B
(3)
(1,1,1)

(u)

Figura 6.3: Polino?mios da base de Benstein simplicial de P32.



6.2. Polino?mios simpliciais 35

6.2.2 A representac?a?o de Be?zier de polino?mios simpliciais

A representac?a?o de Be?zier de uma func?a?o polinomial simplicial f de grau g de Ad para R

e? sua expansa?o em termos da base de Bernstein simplicial de grau g; a saber,

f(u) =
?

??I
g
d

b?B
g
?(u) (6.7)

onde cada b? e? um nu?mero real, o coeficiente (simplicial) de Be?zier de f. Como no caso

tensorial, a posic?a?o nominal do coeficiente b? e? ?/g = (?0/g, · · · ,?d/g) ? A
d.

6.2.3 Elevac?a?o de grau

A fo?rmula de elevac?a?o de grau de polino?mios de Bernstein univariados (3.4) pode ser

generalizada para polino?mios simpliciais. Especificamente, para quaisquer graus g,h ? N

tais que g ? h, qualquer dimensa?o d ? N e qualquer multi-??ndice ? ? I
g
d
, temos

Bg?(u) =
g!

?!
u? =

(

h

g

)?1
?

µ?Ih
d

??µ

(

µ

?

)

Bhµ (u) (6.8)

Uma demonstrac?a?o desta fo?rmula foi publicada por Trump [24].

6.2.4 Derivada direcional

A derivac?a?o de func?o?es definidas em Ad e? mais complicada do que em Rd. Como as

coordenadas do dom??nio devem somar 1, na?o e? poss??vel alterar o valor de uma coordenada

mantendo as demais fixas; e portanto o conceito de derivada parcial na?o faz muito sentido.

Por esta raza?o, para func?o?es definidas no Ad e? mais conveniente trabalhar com derivadas

direcionais.

Seja F uma func?a?o de Ad para R e ? um vetor de Vd. Definimos a r-e?sima derivada

(direcional) de F na direc?a?o ? como sendo a func?a?o Dr?F , de A
d para R, definida por

(Dr?F)(u) = [?
r(s : R ? F(u + s?))] (0) para todo u ? Ad. (6.9)

Aplicando esta definic?a?o ao polino?mio de Bernstein (6.5), temos

(Dr?B
g
?)(u) =

[

?r
(

t : R ?
g!

?!
(u + t?)?

)]

(0) (6.10)

Usando a fo?rmula de Leibnitz (4.2),

(Dr?B
g
?)(u) =

g!

?!

?

??Ir
d

r!

?!

d
?

i=0

[

??i (t : R ? (ui + t?i)
?i)
]

(0) (6.11)



36 Cap??tulo 6. Elementos de Be?zier simpliciais

Note que o p produto?rio se anula quando ?i &gt; ?i para algum i, uma vez que a derivada de

ordem ?i +1 de um polino?mio de grau ?i e? zero. Portanto podemos restringir o somato?rio

aos multi-??ndices ? tais que ? ? ?.

(Dr?B
g
?)(u) =

g!

?!

?

??Ir
d

???

r!

?!

d
?

i=0

?i!

(?i ? ?i)!
u?i??ii ?

?i
i

=
g!

?!

?

??Ir
d

???

r!

?!

?!

(? ? ?)!
u?????

=
g!

(g ? r)!

?

??Ir
d

???

r!

?!
??

(g ? r)!

(? ? ?)!
u???

=
g!

(g ? r)!

?

??Ir
d

???

r!

?!
??B

g?r
???(u)

Estendendo a definic?a?o do polino?mio de Bernstein (6.5) para vetores de Vd, podemos

escrever o fator
r!

?!
??

como

Br?(?).

Portanto temos que

(Dr?B
g
?)(u) =

g!

(g ? r)!

?

??Ir
d

???

Br?(?) B
g?r
???(u) (6.12)

Observe que a derivada se anula (porque o somato?rio e? vazio) se r &gt; g. A equac?a?o (6.12)

generaliza a apresentada por Farin para o caso bidimensional [8]. Se introduzimos µ =

? ? ?, obtemos a fo?rmula alternativa

(Dr?B
g
?)(u) =

g!

(g ? r)!

?

µ?I
g?r
d

Br??µ(?) B
g?r
µ (u) (6.13)

6.3 Elementos simpliciais de Be?zier

Um elemento simplicial de Be?zier de dimensa?o d e grau g em Rm e? uma func?a?o F :

K
d ? Rm cujas m componentes F0,F1, · · · ,Fm?1 sa?o polino?mios do espac?o P

g
d definidos

em termos da representac?a?o de Be?zier. Note que o arco de Be?zier e? um caso particular de



6.3. Elementos simpliciais de Be?zier 37

elemento simplicial de Be?zier (com d = 1). Os outros casos de maior importa?ncia para

modelagem geome?trica sa?o o retalho simplicial (ou tria?ngulo) de Be?zier (d = 2) e o bloco

simplicial (ou tetraedro) de Be?zier (d = 3). Veja a figura 6.4.

Os m coeficientes de Be?zier de mesmo multi-??ndice ? em cada componente Fi podem

ser vistos como as coordenadas de um ponto P? do R
m, o ponto de controle de Be?zier

de multi-??ndice ? do elemento. E? conveniente associar o ponto P? ao ponto u = ?/g do

dom??nio Kd. Similarmente ao caso da curva e do elemento tensorial, segue da propriedade

P3?? que a imagem de um elemento simplicial F esta? totalmente contida no fecho convexo

dos pontos de controle de F [9]. A grade de controle do elemento e? formada pelos pontos

de controle P? e pelos segmentos que ligam todos os pares de pontos P? e P? tais que ?

e ? diferem em exatamente dois ??ndices i e j, com ?i ? ?i = +1 e ?j ? ?j = ?1. Veja a

figura ??.



38 Cap??tulo 6. Elementos de Be?zier simpliciais

(a)

(b) (c) (d)

Figura 6.4: (a) Um elemento simplicial de Be?zier F de dimensa?o 2 (retalho triangular) e grau 3
no R3; e suas componentes (b) F0, (c) F1 e (d) F2.



6.3. Elementos simpliciais de Be?zier 39

Figura 6.5: Um elemento simplicial de Be?zier de dimensa?o 2 e grau 3, e sua grade de controle
(em vermelho).



Cap??tulo 7

Conversa?o tensorial/simplicial

Em modelagem geome?trica, frequ?entemente surge a necessidade de converter elementos

tensoriais para simpliciais e vice versa, por exemplo para obter sub-retalhos triangulares

de retalhos retangulares, ou vice-versa. Estas converso?es tambe?m sa?o necessa?rias para

impor restric?o?es de continuidade entre um spline definido em uma malha retangular e um

spline definido em uma malha triangular. Veja a figura 7.1.

Figura 7.1: Colando um retalho 3D tensorial a um retalho tetrae?drico.

Neste cap??tulo, apresentamos fo?rmulas para conversa?o entre estas duas representac?o?es de

polino?mios multivariados. Estes resultados generalizam, para dimensa?o arbitra?ria, a con-

versa?o de retalhos retangulares para triangulares de Goldmann [11], Hu [14] e Lasser [18],

e a conversa?o de retalhos triangulares para retangulares de Brueckner [3], Hu [13] [14]e

Lasser [17].

7.1 Mapeamento cano?nico tensorial/simplicial

Definimos o mapeamento cano?nico de Ad para Rd como a func?a?o ?d tal que se x = ?d(u),

enta?o xi = ui para i ? {0, · · · ,d ? 1}. Veja as figuras 7.2 e 7.3.

Dizemos que um polino?mio f ??, definido no espac?o Ad, e? a forma simplicial cano?nica de

um polino?mio tensorial f ?, definido no espac?o Rd, se para todo u ? Ad, f ??(u) = f ?(?d(u)).

Nesse caso, dizemos que f ? e? a forma tensorial cano?nica de f ??. Veja a figura 7.4.

41



42 Cap??tulo 7. Conversa?o tensorial/simplicial

A2 R2

u0

u1

u2
x0

x1

?2

(1, 0, 0) (0, 0, 1)

(0, 1, 0)

(0, 0) (1, 0)

(0, 1) (1, 1)

(1

Figura 7.2: O mapeamento cano?nico ?2.

u0
u1

u2

u3

(0, 0, 1, 0)

(0, 1, 0, 0)

(0, 0, 0, 1)

(1, 0, 0, 0)

(0, 0, 0)
(1, 0, 0)

(1, 1, 0)

(0, 0, 1)

(0, 1, 1) (1, 1, 1)

?3

Figura 7.3: O mapeamento cano?nico ?3.

Nosso objetivo, neste cap??tulo, e? desenvolver fo?rmulas expl??citas para conversa?o de um

polino?mio tensorial f ? para sua forma simplicial cano?nica f ??, e vice versa, na representac?a?o

de Be?zier. Mais especificamente, dados os coeficientes de Be?zier b?? de um polino?mio

tensorial f ? de multigrau ? ? Id,

f ?(x) =
?

??Id
???

b??B
?
? (x)

desejamos encontrar os coeficientes b??? de sua simplicial cano?nica f
??,

f ??(u) =
?

??I
g
d

b???B
g
?(u)

onde g = |?|. A relac?a?o entre os coeficientes b?? e b
??
? pode ser resumida por uma matriz

de mudanc?a de base M??:

b??? =
?

??I
g
d

M??b
?
?



7.1. Mapeamento cano?nico tensorial/simplicial 43

u0

u1

u2
x0

x1

(1, 0, 0) (0, 0, 1)

(0, 1, 0)

(0, 0) (1, 0)

(0, 1) (1, 1)

?2

A
2

R
2

f ?f ?? = f ? ? ?2

Figura 7.4: O mapeamento cano?nico ?2 e a relac?a?o entre um polino?mio tensorial f
?, definido no

R
2, e sua forma simplicial cano?nica f ??.



44 Cap??tulo 7. Conversa?o tensorial/simplicial

7.2 Conversa?o de tensorial para simplicial

Pela definic?a?o (5.1), dados ? ? Id?1 e µ ? Id?1 tal que µ ? ?, a forma simplicial cano?nica

do polino?mio de Bernstein tensorial B?? pode ser escrita como

B?? (?d(u)) =

d?1
?

j=0

B?j?j (uj) para todo u ? A
d (7.1)

Ale?m disso, cada polino?mio de Bernstein univariado B
g
i (uj) no lado direito da fo?rmula (7.1)

pode ser descrito como uma combinac?a?o linear de polino?mios de Bernstein simpliciais de-

finidos em Ad. Mais especificamente

B
g
i (uj) =

g!

i!(g ? i)!
uij(1 ? uj)

k

=
g!

i!(g ? i)!
uij

?

?

?
1 ?

?

?

?

d
?

:p=0
:j 6=j

up

?

?

?
+

?

?

?

d
?

:p=0
:j 6=j

up

?

?

?
? uj

?

?

?

k

=
g!

i!k!
uij(u0 + · · · + uj?1 + uj+1 + · · · + ud)

k

=
g!

i!k!
uij
?

??Ik
d

?j =0

k!

?!
u?00 · · ·u

?j?1
j?1 u

?j+1
j+1 · · ·u

?d
d

=
?

??Ik
d

?j =0

g!

?!i!
u?00 · · ·u

?j?1
j?1 u

i
j u

?j+1
j+1 · · ·u

?d
d

=
?

??I
g
d

?j =i

g!

?!
u?00 · · ·u

?d
d

=
?

??I
g
d

?j =i

B
g
?
(u) (7.2)

Combinando esta equac?a?o com a fo?rmula (7.1), temos

B?? (?d(u)) =
d?1
?

j=0

?

??I
?j
d

?j =?j

B?j? (u)

Para expandir o produto?rio acima em termos de somato?rios, utilizamos a notac?a?o de

hiper-??ndices

B?? (?d(u)) =
?

??H?
d?1,d

diag(?)=?

B?0?0 (u) · · ·B
?d?1
?d?1

(u)



7.3. Conversa?o de simplicial para tensorial 45

Agora usamos o fato de que o produto de m + 1 polino?mios de Bernstein simpliciais de

graus ?0,?1, · · · ,?m pode ser reduzido a um u?nico polino?mio de Bernstein simplicial de

grau g = ?0 + ?1 + · · · + ?m. Segundo DeRose [6],

B?0?0 (u) · · ·B
?d?1
?d?1

(u) =
?!(?0 + · · · + ?d?1)!

?0! · · · ?d?1!|?|!
B

|?|
?0+···+?d?1

(u). (7.3)

Enta?o,

B?? (?d(u)) =
?

??H?
d?1,d

diag(?)=?

?!(?0 + · · · + ?d?1)!

?!|?|!
B

|?|
?0+···+?d?1

(u)

=
?

??I
|?|
d

?

??H
?,?
d?1,d

diag(?)=?

?!?!

?!|?|!
B |?|? (u)

Portanto,

M?? =
?

??H
?,?
d?1,d

diag(?)=?

?!?!

?!|?|!

7.3 Conversa?o de simplicial para tensorial

Seja g,d naturais e ? um multi-??ndice de I
g
d
. As fo?rmulas a seguir expressam a forma

tensorial cano?nica de um polino?mio de Bernstein simplicial Bg?, como uma combinac?a?o

linear de polino?mios de Bernstein tensoriais B?? (x), onde ? = g
?d = (g, · · · ,g) ? Id?1.

Para estas fo?rmulas, denotamos por i o u?ltimo elemento ?d de ?, e por ?
? ? I

g?i
d?1 o

multi-??ndice que e? igual a ? nos seus primeiros d ? 1 elementos (ou seja, ?? = ?|d?1).

Observe que ?! = ??! i! e u? = uid
?d?1

j=0 u
??
j

j . Equac?a?o (6.5) enta?o se torna

Bg?(?
?1
d
(x)) =

g!

?!
x
??0
0 x

??1
1 · · ·u

??
d?1

d?1 (1 ? x0 ? · · ·xd?1)
i

=
g!

?!
x
??0
0 x

??1
1 · · ·x

??
d?1

d?1

?

µ?Ii
d

i!

µ!
(1 ? d)µd

d?1
?

k=0

(1 ? xk)
µk

=
?

µ?Ii
d

(1 ? d)µd
g!

(µ + ?)!

(µd + i)!

µd!

d?1
?

k=0

B
??
k
+µk

??
k

(xk)

(7.4)

Introduzindo a varia?vel j = i ? µd e substituindo µd por i ? j, equac?a?o (7.4) se torna



46 Cap??tulo 7. Conversa?o tensorial/simplicial

Bg?(?
?1
d (x)) =

i
?

j=0

?

??I
j
d?1

(1 ? d)i?j
g!

(? + ??)!(i ? j)!

d?1
?

k=0

B
??
k
+?k

??
k

(xk)

(7.5)

Substituindo agora ? por ? + ?? e q por i ? j, equac?a?o (7.5) se torna

Bg?(?
?1
d
(x)) =

i
?

q=0

?

??I
g?q
d?1

????

(1 ? d)q
g!

?!q!

d?1
?

k=0

B
?k
??
k
(xk) (7.6)

Para reduzir a fo?rmula (7.6) a uma combinac?a?o linear de polino?mios de Bernstein de

mesmo multi-grau ?, e? necessa?rio aplicar a fo?rmula (3.4) de elevac?a?o de grau de polino?mios

de Bernstein univariados a cada termo da somato?ria. Obtemos enta?o

Bg?(?
?1
d
(x)) =

?

??Id?1
????

???

?

?

?

?

?

?

?

?

??Id?1
????

|?|?g
???+????

(1 ? d)g?|?|
g!(? ? ?)!

?!(g ? |?|)!

(

?

??

)(

? ? ?

? ? ??

)

?

?

?

?

?

?

?

B?? (x)

(7.7)

Portanto temos

M?? =

?

?

?

?

?

?

?

?

?

?

?

?

?

?

??Id?1
????

|?|?g
???+????

(1 ? d)g?|?|
g!(???)!
?!(g?|?|)!

(

?

??

)(

? ? ?

? ? ??

)

se ?? ? ?

0 caso contra?rio



Cap??tulo 8

Simplo?ides de Be?zier

Neste cap??tulo, definiremos a abordagem unificada dos polino?mios simploidais[6], que ge-

neralizam polino?mios tensoriais e simpliciais para dom??nios que sa?o produtos cartesianos

de simplexos cano?nicos denominados simplo?ides. Em particular, descrevemos os elemen-

tos de Be?zier simploidais ou simplo?ides de Be?zier, que, analogamente, generalizam a

representac?a?o de Be?zier-DeCasteljau destes polino?mios, como o elemento prisma?tico da

figura 8.1.

Figura 8.1: O prisma cano?nico (esquerda) e um exemplo de um bloco de Be?zier simploidal
(direita).

Neste cap??tulo, tambe?m daremos fo?rmulas gerais expl??citas para elevac?a?o para graus ar-

bitra?rios, bem como para o ca?lculo de derivadas direcionais de ordem arbitra?ria.

8.1 Espac?o multi-afim cano?nico

Definimos A?, o espac?o multi-afim cano?nico de multi-dimensa?o ? ? Im, como o conjunto

A
? = {U ? M? : |Ui| = 1, i = 0, · · · ,m}. (8.1)

Note que A? = A?0 × · · · × A?m e que, diferentemente do espac?o cartesiano, (Am)×n na?o e?

isomo?rfico a Am·n em geral. Quando um multi-??ndice ? e? utilizado para denotar a dimensa?o

de um espac?o multi-afim, como na definic?a?o acima, o chamamos de multi-dimensa?o.

47



48 Cap??tulo 8. Simplo?ides de Be?zier

Definimos tambe?m o espac?o vetorial cano?nico de multi-dimensa?o ?, denotado por V?,

como o conjunto de diferenc?as entre pares de pontos do A?; isto e?, o subespac?o de M?
consistindo das matrizes ? tais que |?i| = 0 para todo i = 0, · · · ,m.

8.1.1 Simplo?ides cano?nicos

Dados m ? N e ? ? Im, definimos o simplo?ide cano?nico de multi-dimensa?o ? como o

produto cartesiano

K
? = K?0 × · · · × K?m

Note que K? ? A?. Os simplo?ides cano?nicos de dimensa?o (1, 1), (2, 1) e (1, 1, 1) esta?o ilus-

trados na figura 8.2. Em particular, os simplexos cano?nicos Kd e os hipercubos cano?nicos

||||||

×××
×

K
(1,1)

K
(2,1)

K
(1,1,1)

Figura 8.2: Alguns simplo?ides cano?nicos.

[0, 1]d de Rd podem ser vistos como casos particulares de simplo?ides cano?nicos.

8.1.2 Facetas

Definimos a faceta de ??ndices i,j de um simplo?ide cano?nico K?, para 0 ? i ? m e

0 ? j ? ?i, denotada por K
?|i,j, como

K
?|i,j = {U ? K

? : Uij = 0}. (8.2)

Observe que K?|i,j e? congruente ao simplo?ide K
? onde ? ? Id e? tal que ?i = ?i ?1 e ?k = ?k

para todo k 6= i. Observe tambe?m que o conceito de faceta de um simplexo cano?nica Kd

(sec?a?o 6.1.2) e? um caso particular desta definic?a?o.



8.2. Polino?mios simploidais 49

8.2 Polino?mios simploidais

Definimos o espac?o dos polino?mios simploidais de multi-dimensa?o ? ? Im e multi-grau

? ? Im, denotado por P
?
? , como o espac?o de todas as func?o?es f de A

? para os reais, tais

que para cada i ? {0, · · · ,d}, f(U) e? uma func?a?o polinomial simplicial da componente Ui
com grau ?i quando as outras componentes sa?o consideradas fixas. Por exemplo, considere

a func?a?o f de A(2,1) para R definida por

f(U) = f

(

U00 U01 U02
U10 U11

)

= U200U
2
10U11 + U

2
01U

3
11 + U

2
01U

3
10 +

+U01U02U10U
2
11 + U01U02U

2
10U11 + U

2
02U

3
11

= (U210U11)U
2
00 + (U

3
11 + U

3
10)U

2
01 +

+(U10U
2
11 + U

2
10U11)U01U02 + (U

3
11)U

2
02 (8.3)

= (U201)U
3
10 + (U

2
00 + U

2
01)U

2
10U11 +

+(U201)U10U
2
11 + (U

2
01 + U

2
02)U

3
11 (8.4)

Observe que, pela fo?rmula (8.3), a func?a?o f e? um polino?mio simplicial de grau 2 da

componente U0 = (U00,U01,U02); e pela fo?rmula (8.4), e? um polino?mio simplicial de grau

3 da componente U1 = (U10,U11).

Note que qualquer func?a?o f ? P?? tambe?m pertence ao espac?o P
?
?
se ? ? ?. Note ainda

que todo polino?mio simplicial pode ser visto trivialmente como um polino?mio simploidal.

Ademais, todo polino?mio tensorial f em Rd de multi-grau ? ? Id?1 pode ser visto como

um polino?mio simploidal definido no espac?o multi-afim A1?d = A1 × · · · × A1, utilizando

o mapeamento ?d de R
d em A1?d tal que ?d(x0, · · · ,xd?1) = ((x0, 1 ? x0), · · · , (xd?1, 1 ?

xd?1)). Por esta mesma corresponde?ncia, todo polino?mio simploidal de dom??nio A
1?d e

multi-grau ? ? Id?1 e? essencialmente um polino?mio tensorial de dom??nio R
d e mesmo

multi-grau ?.

8.2.1 A base de Bernstein simploidal

Para todo m ? N, toda multi-dimensa?o ? ? Im e todo multi-grau ? ? Im, definimos a base

de Bernstein simploidal de P?? , como consistindo dos polino?mios simploidais B
?
?, para

todo ? ? H?? , cada um definido como um produto de polino?mios de Bernstein simpliciais:

B??(U) =

m
?

i=0

B
?i
?i
(Ui) para todo U ? A

?. (8.5)



50 Cap??tulo 8. Simplo?ides de Be?zier

Note que estes polino?mios generalizam os polino?mios de Bernstein simpliciais (? ? I0) e

polino?mios de Bernstein tensoriais (? = 1 ? m = (1, 1, · · · , 1)).

8.2.2 Representac?a?o de Be?zier de polino?mios simploidais

A representac?a?o de Be?zier de uma func?a?o polinomial simploidal f de multi-dimensa?o

? ? Id e multi-grau ? ? Id e? sua expansa?o em termos da base de Bernstein simploidal B
?
? ,

a saber

f(U) =
?

??H?
?

b?B
?
?(U)

onde cada b? e? um nu?mero real, um coeficiente (simploidal) de Be?zier de f. De forma

ana?loga aos polino?mios simpliciais, a posic?a?o nominal de cada coeficiente b? e? definida

como sendo o ponto ?/? ? A?

Por exemplo, a func?a?o f definida pela fo?rmula 8.4 tem os seguintes coeficientes de

Be?zier:

c200
30

= 0 c200
21

= 1 c200
12

= 0 c200
03

= 0

c110
30

= 0 c110
21

= 0 c110
12

= 0 c110
03

= 0

c020
30

= 1 c020
21

= 1/3 c020
12

= 1/3 c020
03

= 1

c011
30

= 0 c011
21

= 0 c011
12

= 0 c011
03

= 0

c002
30

= 0 c002
21

= 0 c002
12

= 0 c002
03

= 1

c101
30

= 0 c101
21

= 0 c101
12

= 0 c101
03

= 0

8.2.3 Elevac?a?o de grau

A fo?rmula de elevac?a?o de grau (6.8) para polino?mios simpliciais pode ser estendida para

polino?mios simploidais gerais. Mais especificamente, dados um natural m, uma multi-

dimensa?o ? ? Im, um multi-grau de origem ? ? Im, um hiper-??ndice ? ? H
?
? e um



8.2. Polino?mios simploidais 51

multi-grau de destino ? ? Im tal que ? ? ?,temos

B??(U) =

m
?

i=0

B
?i
?i
(U)

=

(

?

?0?I
?0
?0

?0??0

(

?0
?0

)

B?0?0 (U)

)

(

?0
?0

) · · ·

(

?

?m?I
?m
?m

?m??m

(

?m
?m

)

B?m?m(U)

)

(

?m
?m

)

=

?

?0?I
?0
?0

?0??0

· · ·
?

?m?I
?m
?m

?m??m

(

?0
?0

)

· · ·

(

?m
?m

)

B?0?0 (U) · · · B
?m
?m

(U)

(

?

?

)

Introduzindo o hiper-??ndice ? cujas linhas sa?o ?0,?1, · · · ,?m temos

B??(U) =

(

?

?

)?1
?

??H
?
m,?

???

(

?0
?0

)

· · ·

(

?m
?m

)

B
?
?(U)

=

(

?

?

)?1
?

??H
?
m,?

???

(

?

?

)

B
?
?(U) (8.6)

Portanto, dada a representac?a?o de Be?zier de um polino?mio F de multi-grau ?

F(U) =
?

??H?
?

b??B
?
?(U)

podemos obter os coeficientes do mesmo polino?mio em termos da base de multi-grau ?

F(U) =
?

??H
?
?

b???B
?
?(U)

pela fo?rmula

b??? =
?

??H?
?

K??b
?
? (8.7)

onde

K?? =

(

?

?

)?1(
?

?

)



52 Cap??tulo 8. Simplo?ides de Be?zier

8.2.4 Diferenciac?a?o

Dados um natural m, uma multi-dimensa?o ? ? Im e um vetor ? ? V
?, a derivada de

ordem r do polino?mio de Bernstein simploidal B?? na direc?a?o ? e?

(Dr?B
?
?)(U) =

[

?r

(

t : R ?
m
?

i=0

B
?i
?i
(Ui + t?i)

)]

(0) (8.8)

para qualquer U ? A?. Usando a fo?rmula de Leibnitz (4.2), obtemos

(Dr?B
?
?)(U) =

?

??Irm

r!

?!

m
?

i=0

[

??i
(

t : R ? B?i?i (Ui + t?i)
)]

(0)

Mais uma vez, se ?i &gt; ?i para algum i, o termo de dentro do somato?rio e? igual a zero.

Utilizando a fo?rmula (6.12) obtemos

(Dr?B
?
?)(U) =

?

??Irm
???

r!

?!

m
?

i=0

?i!

(?i ? ?i)!

?

??I
?i
?i

???i

B?i
?
(?i) B

?i??i
?i??

(Ui)

=
?

??Irm
???

r!

?!

?!

(? ? ?)!

?

??H?
?

???

m
?

i=0

B?i?i(?i) B
?i??i
?i??i

(Ui)

Como na sec?a?o 6.2.4, se considerarmos a definic?a?o de B??

B??(U) =
m
?

i=0

?i!

?i!
U?ii

como va?lida em todo espac?o Mm,?, ao inve?s de apenas no espac?o A
?, podemos escrever

(Dr?B
?
?)(U) =

?

??Irm
???

r!

?!

?!

(? ? ?)!

?

??H?
?

???

B??(?) B
???
???(U)

(8.9)

Como pode-se notar, esta equac?a?o e? a versa?o simploidal da equac?a?o 6.12. Entretanto, uma

forma mais adequada para nossos propo?sitos e? obtida realizando a elevac?a?o de multi-grau

de ? ? ? para ?:

(Dr?B
?
?)(U) =

?

??Irm
???

r!

?!

?!

(? ? ?)!

?

??H?
?

???

B??(?)
?

??H?
?

?????

(

?

? ? ?

)(

?

? ? ?

)

B??(U)



8.3. Elementos de Be?zier Simploidais 53

que pode ser reorganizada em

(Dr?B
?
?)(U) =

?

??H?
?

?

??Irm
???

?

??H?
?

???
?????

r!

(

?

? ? ?

)

B??(?) B
?
?(U) (8.10)

Portanto, dados os coeficientes de Be?zier b?? de um polino?mio F , podemos obter os coefi-

cientes de Be?zier b??? da derivada direcional D
r
?F pela fo?rmula

b??? =
?

??H?
?

K??b
?
? (8.11)

onde

K?? =
?

??Irm
???

?

??H?
?

???
?????

r!

(

?

? ? ?

)

8.3 Elementos de Be?zier Simploidais

Um elemento simploidal de Be?zier de multi-dimensa?o ? e multi-grau ? ? Id?1 em R
d e?

a uma func?a?o F : K? ? Rm cujas m componentes sa?o polino?mios simploidais do espac?o

P?? definidos em termos da representac?a?o de Be?zier. Assim como o polino?mio simploidal

generaliza os polino?mios simpliciais e tensoriais, o elemento simploidal de Be?zier generaliza

os elementos simpliciais e tensoriais. Veja a figura ??.

Os pontos de controle de um elemento F sa?o definidos de maneira ana?loga aos dos ele-

mentos simpliciais e tensoriais: o coeficiente de Be?zier de hiper-??ndice ? da componente

Fi e? a coordenada i do ponto de controle P? de F .

A grade de controle de Be?zier de F consiste dos seus pontos de controle P? e dos

segmentos de reta que ligam todos os pares de pontos P? e P? tais que ? e ? diferem em

apenas dois elementos i,j da mesma linha k com ?ki ? ?ki = +1 e ?kj ? ?kj = ?1.



54 Cap??tulo 8. Simplo?ides de Be?zier

Figura 8.3: Um elemento de Be?zier simploidal de multi-dimensa?o (1, 2) (um prisma de Be?zier)
e multi-grau (2, 3) mostrando seus pontos de controle e sua grade de Be?zier (em vermelho).



Cap??tulo 9

Mapeamentos afins

Um mapeamento afim e? uma func?a?o de um espac?o X ? Rm para outro espac?o Y ? Rn tal

que cada coordenada do resultado e? uma func?a?o afim (polinomial de primeiro grau) das

coordenadas do argumento. Note que transformac?o?es lineares de Rm para Rn sa?o casos

particulares de mapeamentos afins [12].

Nesta tese, mapeamentos afins sa?o importantes para a reparametrizac?a?o de elementos

de Be?zier, em particular para descrever a colagem de blocos adjacentes de uma malha.

9.1 Mapeamento afim de A? para A?

No caso espec??fico onde X e Y sa?o espac?os multi-afins de multi-dimenso?es ? ? Im e

? ? In respectivamente, um mapeamento afim e? definido por constantes reais M
rs
ij onde

r ? {0, · · · ,n}, s ? {0, · · · ,?r}, i ? {0, · · · ,m} e j ? {0, · · · ,?i} tais que

(?(U))rs =
m
?

i=0

?i
?

j=0

UijM
rs
ij para todo U ? A

?. (9.1)

Note que, para que ?(U) pertenc?a a A?, e? necessa?rio que, para todo r ? {0, · · · ,n}:
?r
?

s=0

(?(U))rs = 1

Verifica-se que esta condic?a?o e? equivalente a dizer que para todo r ? {0, · · · ,n}, existe

um wr ? Am tal que
?r
?

s=0

Mrsij = w
r
i (9.2)

para todo i = {0, · · · ,m} e todo j ? {0, · · · ,?i}. Observe que a constante w
r
i define o peso

da linha i de U na formac?a?o da linha r de ?(U). Observe tambe?m que a condic?a?o (9.2)

implica que o lado esquerdo na?o depende de j.

55



56 Cap??tulo 9. Mapeamentos afins

Em particular, quando o dom??nio e/ou contra-dom??nio sa?o espac?os afins (isto e?, ? = (d)

e/ou ? = (e)) podemos suprimir o ??ndice i e/ou o ??ndice r dos coeficientes Mrsij , pois estes

??ndices sa?o sempre 0.

9.1.1 Mapeamento afim cano?nico de Ad para A1?d

Um caso particular muito comum de mapeamento afim e? o mapeamento cano?nico ?d de

A
d para Rd (definido na sec?a?o 7.1), que pode ser visto como um mapa de X = A(d) para

Y = A1?d . Neste caso, as constantes Mrsj sa?o

Mrs0 =

{

1, se r = s,

0, se r 6= s
e Mrs1 = 1 ? M

rs
0 =

{

0, se r = s,

1, se r 6= s

9.2 Derivadas de um mapeamento afim

Seja ? um mapeamento afim de A? para A?, definido pelas constantes Mrsij onde r ?

{0, · · · ,n}, s ? {0, · · · ,?r}, i ? {0, · · · ,m} e j ? {0, · · · ,?i}; e seja ? uma direc?a?o de A
?.

A derivada (direcional) de ? na direc?a?o ? e? uma constante (independente de U) dada por

((D??)(U))rs =
m
?

i=0

?i
?

j=0

?ijM
rs
ij (9.3)

Observe que, por esta raza?o, ?(K?|ij) e? uma co?pia transladada de ?(K
?|ik) para todo

i ? {0, · · · ,m} e para todo j,k ? {0, · · · ,?i}.

9.3 Exemplos

Neste sec?a?o, apresentamos alguns exemplos de mapas afins entre espac?os multi-afins de

dimenso?es variadas, e os respectivos coeficientes Mrsij .

9.3.1 Mapeamento afim de A(1) para A(2)



9.3. Exemplos 57

M00 = 0.4 M
0
1 = 0.8

M10 = 0.5 M
1
1 = ?0.3

M20 = 0.1 M
2
1 = ?0.5

(100)

(010)

(001)
A

B
(10)

(01)

Figura 9.1: Exemplo de um mapeamento afim de A(1) para A(2) (ou de A1 para A2).

9.3.2 Mapeamento afim de A(2) para A(2)

M00 = 0.7 M
0
1 = 0.2 M

0
2 = 0.2

M00 = 0.6 M
0
1 = 0.8 M

0
2 = 0.2

M00 = ?0.3 M
0
1 = 0.0 M

0
2 = 0.6

(100)

(010)

(001)

A

B

C

(100)

(010)

(001)

Figura 9.2: Exemplo de mapeamento afim de A(2) para A(2) (ou de A2 para A2).

9.3.3 Mapeamento afim de A(2) para A(2,1)



58 Cap??tulo 9. Mapeamentos afins

A

B

C

M
0,0
0 = 0.5 M

0,0
1 = 0.1 M

0,0
2 = 0.7

M
1,0
0 = 0.5 M

1,0
1 = 0.4 M

1,0
2 = ?0.4

M
2,0
0 = 0.0 M

2,0
1 = 0.5 M

2,0
2 = 0.7

M
0,1
0 = 0.5 M

0,1
1 = 0.4 M

0,1
2 = 0.6

M
1,1
0 = 0.5 M

1,1
1 = 0.6 M

1,1
2 = 0.4

(100)

(010)

(001)

Figura 9.3: Exemplo de um mapeamento afim de A(2) (ou A2) para A(2,1).

9.3.4 Mapeamento afim de A(1,1) para A(2)



9.3. Exemplos 59

M00,0 = 0.0 M
0
0,1 = 0.5 M

0
1,0 = 0.0 M

0
1,1 = 0.0

M10,0 = 0.0 M
1
0,1 = 0.0 M

1
1,0 = 0.5 M

1
1,1 = 0.0

M20,0 = 0.5 M
2
0,1 = 0.0 M

2
1,0 = 0.0 M

1
1,1 = 0.5

( 1 01 0 )(
1 0
0 1 )

( 0 10 1 ) (
0 1
1 0 )

(100)

(010)

(001)

A

B

C

D

Figura 9.4: Exemplo de um mapeamento afim de A(1,1) para A(2) (ou A2). Note que os segmentos
AB e CD, que sa?o imagens das facetas K1,1|1,0 e K

1,1|1,1, sa?o paralelas entre si.

9.3.5 Mapeamento afim de A(1,1) para A(1,1)



60 Cap??tulo 9. Mapeamentos afins

M
0,0
0,0 = 0.5 M

0,0
0,1 = 0.0 M

0,0
1,0 = 0.5 M

0,0
1,1 = 0.0

M
0,1
0,0 = 0.0 M

0,1
0,1 = 0.5 M

0,1
1,0 = 0.0 M

0,1
1,1 = 0.5

M
1,0
0,0 = 0.0 M

1,0
0,1 = 0.5 M

1,0
1,0 = 0.5 M

1,0
1,1 = 0.0

M
1,1
0,0 = 0.5 M

1,1
0,1 = 0.0 M

1,1
1,0 = 0.0 M

1,1
1,1 = 0.5

( 1 01 0 )
( 1 01 0 ) (

1 0
0 1 )(

1 0
0 1 )

( 0 10 1 )(
0 1
0 1 ) (

0 1
1 0 )(

0 1
1 0 )

A

B

C

D

Figura 9.5: Exemplo de um mapeamento afim de A(1,1) para A(1,1).



Cap??tulo 10

Reparametrizac?a?o de elementos de

Be?zier

Neste cap??tulo, consideraremos o problema da reparametrizac?a?o afim de elementos sim-

ploidais de Be?zier.

Este problema inclui va?rios casos particulares importantes, como a extrac?a?o de facetas

e a subdivisa?o de um bloco de Be?zier (algoritmo de DeCasteljau generalizado). Por

exemplo, considere um elemento de Be?zier de multi-grau (5, 7) cujo dom??nio e? o prisma

cano?nico, K(1,2). Veja a figura 10.1.

A

B

Figura 10.1: Bloco de Be?zier de dom??nio prisma?tico

A extrac?a?o da face A deste retalho produzira? um retalho de Be?zier de dom??nio K(1,1) e

multi-grau (5, 7). A extrac?a?o da face B, por outro lado, produzira? um retalho de Be?zier

de dom??nio K(2) e multi-grau (7). Esta operac?a?o e? uma ferramenta importante para a

colagem na?o conforme de retalhos simploidais, como veremos no cap??tulo 12.

61



62 Cap??tulo 10. Reparametrizac?a?o de elementos de Be?zier

10.1 Reparametrizac?a?o afim

Seja F uma func?a?o de A? para R, e ? um mapeamento afim de outro espac?o multi-afim

A
? para A?. Definimos a reparametrizac?a?o de F por ? como a composic?a?o F ? ?, que e?

uma func?a?o de A2 para R. Veja a figura 10.2.

Se F e? um polino?mio simploidal de multigrau ?, verifica-se que G = F ? ? tambe?m e? um

polino?mio simploidal, cujo multi-grau ? depende de ?, ? e ?.

Neste cap??tulo, consideramos o problema de calcular a representac?a?o de Be?zier de

G a partir da representac?a?o de Be?zier de F e do mapa ?. Especificamente, dados os

coeficientes de Be?zier b?? de um polino?mio simploidal F ? P
?
? ,

F(U) =
?

??H?
?

b??B
?
?(U) para todo U ? A

?

e um mapeamento afim ? de outro espac?o multi-afim A? para A?, deseja-se encontrar o

multi-grau ? e os coeficientes b??? tais que

G(V ) = F(?(V )) =
?

??H
?
?

b???B
?
?(V ) para todo V ? A

?

Como veremos, os coeficientes b??? sa?o func?o?es lineares dos coeficientes b
?
?. Portanto a

relac?a?o entre os coeficientes b?? e b
??
? pode ser resumida por uma matriz de mudanc?a de

base K???:

b??? =
?

??H?
?

K???b
?
?

onde K??? e? o coeficiente de B
?
? na representac?a?o de Be?zier de B

?
? ? ?.



10.1. Reparametrizac?a?o afim 63

( 1 01 0 )(
1 0
0 1 )

( 0 10 1 ) (
0 1
1 0 )

(100)

(010)

(001)

?

F ? ? F

K(2)K(1,1)

Figura 10.2: Uma func?a?o F, de A(2) para R, restrita ao K(2) (em amarelo) e sua reparametrizac?a?o
pelo mapeamento afim ? de A(1,1) para A(2), da sec?a?o 9.3.4, resultando na func?a?o F ??, de A(1,1)

para R, restrita ao K(1,1) (em vermelho).



64 Cap??tulo 10. Reparametrizac?a?o de elementos de Be?zier

10.2 Mapeamento de simploidal para simplicial

Consideramos, inicialmente, o caso particular onde ? e? um mapeamento de um espac?o

multi-afim para um espac?o afim. Seja ? um mapeamento de A? para Ae com ? ? Im e

m,e ? N. Pelas fo?rmulas (8.5) e (9.1), para todo grau g ? N e todo multi-??ndice ? ? I
g
d
,

a composic?a?o Bg? ? ? e? dada por

Bg?(?(U)) =
g!

?!

e
?

s=0

(

m
?

i=0

?i
?

j=0

UijM
s
ij

)?s

Podemos expandir este produto?rio em um somato?rio sobre um multi-??ndice µ, um hiper-

??ndice ? e um ultra-??ndice ?. Na fo?rmula abaixo, Ms e? a matriz irregular tal que (Ms)ij =

Mrij para todo i ? {0, · · · ,m} e todo j ? {0, · · · ,?i}:

Bg?(?(U)) =
g!

?!

?

µ?I
g
m

?

??H
µ
?

?

??U?
e,?

e
?

s=0

?s!

?s!

m
?

i=0

?i
?

j=0

(UijM
s
ij)

?s,i,j

=
?

µ?I
g
m

?

??H
µ
?

?

??U?
e,?

g!

?!

(

e
?

s=0

m
?

i=0

?i
?

j=0

(Msij)
?s,i,j

)

m
?

i=0

?i
?

j=0

e
?

s=0

(Uij)
?s,i,j

=
?

µ?I
g
m

?

??H
µ
?

?

??U?
e,?

g!

?!

(

e
?

s=0

(Ms)?s

)

m
?

i=0

?i
?

j=0

U
?i,j
ij

=
?

µ?I
g
m

?

??H
µ
?

?

??U?
e,?

g!?!

?!µ!

(

e
?

s=0

(Ms)?s

)

m
?

i=0

µi
?i
U

?i
i

=
?

µ?I
g
m

?

??H
µ
?

?

?

?

??U?
e,?

g!?!

?!µ!

e
?

s=0

(Ms)?s

?

?B
µ
?(U) (10.1)

Para a simplificar a notac?a?o, podemos escrever a equac?a?o (10.1) como

Bg?(?(U)) =
?

µ?I
g
m

?

??H
µ
?

g!

µ!
G(e,?,?, ?,M)B

µ
?(U) (10.2)

onde M e? a colec?a?o das matrizes irregulares Ms para todo s ? {0, · · · ,e} e

G(e,?,?, ?,M) =
?

??U?
e,?

?!

?!

e
?

s=0

(Ms)?s (10.3)

Note que equac?a?o (10.2) generaliza a formula (7.4), que realiza a conversa?o de polino?mios

de Bernstein tensoriais para simpliciais.



10.3. Reparametrizac?a?o afim gene?rica 65

10.3 Reparametrizac?a?o afim gene?rica

Vamos considerar agora o caso geral onde ? e? um mapeamento afim de um espac?o multi-

afim A? para outro espac?o multi-afim A?, com ? ? Im, ? ? In e m,n ? N. Pela definic?a?o de

polino?mio de Bernstein simploidal (8.5), para todo multi-grau ? ? In e todo hiper-??ndice

? ? H?? , a composic?a?o B
?
? ? ? e? dada por

B??(?(U)) =
n
?

r=0

B?r?r ((?(U))r).

Utilizando a equac?a?o (10.2) obtemos

B??(?(U)) =

n
?

r=0

?

µ?I
?r
m

?r!

µ!

?

??H
µ
?

G(?r, ?r,?, ?,M
r)B

µ
?(U)

=
?

??I
|?|
m

?

??H
?,?
n,m

?

??H?
?

?

??U?
n,?

n
?

r=0

?r!

?r!
G(?r, ?r,?, ?r,M

r)B?r
?r

(U)

=
?

??I
|?|
m

?

??H
?,?
n,m

?

??H?
?

?

??U?
n,?

?!

?!

(

n
?

r=0

G(?r, ?r,?, ?r,M
r)

)

n
?

r=0

m
?

i=0

B
?r,i
?r,i

(Ui)

=
?

??I
|?|
m

?

??H
?,?
n,m

?

??H?
?

?

??U?
n,?

?!

?!

(

n
?

r=0

G(?r, ?r,?, ?r,M
r)

)

m
?

i=0

n
?

r=0

B
?r,i
?r,i

(Ui)

(10.4)



66 Cap??tulo 10. Reparametrizac?a?o de elementos de Be?zier

Utilizando equac?a?o (7.3) de produto de polino?mios de Bernstein simpliciais, obtemos

B??(?(U)) =
?

??I
|?|
m

?

??H
?,?
n,m

?

??H?
?

?

??U?
n,?

?!

?!

(

n
?

r=0

G(?r, ?r,?, ?r,M
r)

)

m
?

i=0

B?i?i(Ui)
?i!

?i!

n
?

r=0

?r,i!

?r,i!

=
?

??I
|?|
m

?

??H
?,?
n,m

?

??H?
?

?

??U?
n,?

?!?!

?!?!

(

n
?

r=0

G(?r, ?r,?, ?r,M
r)

)

B??(U)

m
?

i=0

n
?

r=0

?r,i!

?r,i!

=
?

??I
|?|
m

?

??H?
?

?

?

?

??U?
n,?

?!?!

?!?!

n
?

r=0

G(?r, ?r,?, ?r,M
r)

?

?B??(U)

que pode ser reescrito como

B??(?(U)) =
?

??I
|?|
m

?

??H?
?

?!?!

?!
H(?,?,?, ?, ?,M)B??(U) (10.5)

onde

H(?,?,?, ?, ?,M) =
?

??U?
n,?

1

?!

n
?

r=0

G(?r, ?r,?, ?r,M
r)

Na fo?rmula (10.5), o lado direito envolve polino?mios de Bernstein de multi-graus diferen-

tes. Utilizamos enta?o a equac?a?o (8.6) para elevar cada multi-grau ? para o multi-grau

? = |?| ? d. Obtemos assim

B??(?(U)) =
?

??I
|?|
m

?

??H?
?

?!?!

?!
H(?,?,?, ?, ?,M)B??(U)

=
?

??I
|?|
m

?

??H?
?

?!?!

?!
H(?,?,?, ?, ?,M)

?

??H
?
m,?

???

(

?

?

)

(

?

?

)B
?
?(U)

=
?

??H
?
m,?

?

??I
|?|
m

?

??H?
?

???

?!?!

?!

(

?

?

)

H(?,?,?, ?, ?,M)
(

?

?

) B
?
?(U) (10.6)



10.4. Derivada direcional da reparametrizac?a?o 67

Portanto, temos

K??(?) =
?

??I
|?|
m

?

??H?
?

???

?!?!

?!

(

?

?

)

H(?,?,?, ?, ?,M)
(

?

?

) (10.7)

10.4 Derivada direcional da reparametrizac?a?o

Seja F um polino?mio simploidal de multi-dimensa?o ? e ? um mapeamento afim ? : A? ?

A
?. A derivada de G = F ? ? na direc?a?o ? ? V?, avaliada no ponto V ? A?, e? dada por

D?G(V ) = (D?(F ? ?))(V )

= [?(s : R ? (F ? ?)(V + s?))] (0)

aplicando a regra da cadeia e a fo?rmula (9.3) da derivada direcional de ?, obtemos

D?G(V ) =
m
?

r=0

?r
?

s=0

(?rsF)(?(V )) ([?(t : R ? (? (V + t?))rs)] (0))

=

m
?

r=0

?r
?

s=0

(?rsF)(?(V ))

m
?

i=0

?i
?

j=0

Mrsij ?ij

Seja enta?o ? o vetor de V? definido por

?rs =
m
?

i=0

?i
?

j=0

Mrsij ?ij

a equac?a?o acima pode ser reescrita como

D?G(V ) = (D?F)(?(V )) (10.8)

Verifica-se que as derivadas direcionais de ordem maior tambe?m satisfazem a relac?a?o (10.8).

Mais especificamente, para qualquer ordem r,

Dr?G(V ) = D
r
?F(?(V )) (10.9)



Cap??tulo 11

Aspectos gerais da implementac?a?o

As malhas usadas em modelagem geolo?gica podem ter centenas de milhares ou milho?es de

elementos simploidais de Be?zier. Em teoria, a forma (e outras propriedades) de cada bloco

podem ser especificada pelos seus pontos de controle de Be?zier. Entretanto, as restric?o?es

de continuidade, suavidade e geometria, tipicamente presentes nessas malhas, tornam

esta representac?a?o redundante e muito perdula?ria em termos de espac?o. Neste cap??tulo,

descrevemos as te?cnicas utilizadas na biblioteca BezEl para representar tais modelos de

maneira mais econo?mica.

11.1 Elementos de Be?zier

Um modelo geolo?gico geralmente utiliza um reperto?rio bem pequeno de tipos distintos de

blocos de Be?zier. Por exemplo, a figura 11.1 mostra duas camadas geolo?gicas compostas

por um u?nico tipo de bloco de Be?zier (hexaedros), com superf??cies superior e inferior

onduladas mas com paredes verticais planas, arranjadas de forma que suas projec?o?es no

plano horizontal formam uma grade retangular.

Em princ??pio, podemos modelar este tipo de bloco por um elemento tensorial de Be?zier

de dimensa?o 3 e multi-grau (3, 3, 1) no R3. Ou seja, o dom??nio e? o cubo K(1,1,1) e cada

componente X,Y ,Z da imagem e? um polino?mio nas varia?veis u,v e w do dom??nio com

grau 3 em u e em v e grau 1 em w. Nesta representac?a?o, sa?o necessa?rios 96 para?metros

para expressar a forma do bloco: 32 coeficientes de Be?zier para cada componente X,Y e

Z, ou seja, 32 pontos de controle de Be?zier, veja a figura 11.2

69



70 Cap??tulo 11. Aspectos gerais da implementac?a?o

Figura 11.1: Exemplo de modelo geolo?gico.



11.1. Elementos de Be?zier 71

(

0 1
0 1
0 1

)

(

1 0
0 1
0 1

)

(

0 1
1 0
0 1

)

(

0 1
0 1
1 0

)

U0

U1

U2

K
(1,1,1)

b( 0 1
0 3
0 3

)

b( 0 1
0 3
1 2

)

b( 0 1
0 3
2 1

)

b( 0 1
0 3
3 0

)

b( 0 1
1 2
3 0

)

b( 0 1
2 1
3 0

)

b( 0 1
3 0
3 0

)

b( 1 0
3 0
3 0

)

b( 1 0
3 0
2 1

)

b( 1 0
3 0
1 2

)

b( 1 0
3 0
0 3

)

b( 1 0
2 1
0 3

)

b( 1 0
1 2
0 3

)

b( 1 0
0 3
0 3

)

Figura 11.2: Representac?a?o de Be?zier de um bloco do modelo da figura 11.1, mostrando a grade
de controle de Be?zier (em vermelho) e, para alguns pontos, os respectivos ??ndices.



72 Cap??tulo 11. Aspectos gerais da implementac?a?o

11.2 Blocos de Be?zier generalizados

Observe que este tipo de bloco e? muito mais geral do que o necessa?rio para construir a

malha da figura 11.1, pois inclui blocos com paredes curvas e inclinadas, como ilustrado

na figura 11.3.

Figura 11.3: Outro exemplo de um bloco de Be?zier de multi-dimensa?o (1, 1, 1) e multi-graus
(3, 3, 1).

Uma vez que, nessa malha, a projec?a?o de cada bloco no plano horizontal e? sempre um

reta?ngulo alinhado com os eixos, a componente X pode ser modelada por uma func?a?o

linear da coordenada u do dom??nio apenas. Da mesma forma, a componente Y pode ser

uma func?a?o linear da coordenada v apenas. Somente a componente Z precisa ser uma

func?a?o linear de w e cu?bica em u e v. Portanto, podemos modelar cada bloco da malha

por tre?s func?o?es simploidais X, Y e Z com o mesmo dom??nio K(1,1,1) mas multi-graus

diferentes — (1, 0, 0),(0, 1, 0) e (3, 3, 1), respectivamente. Veja a figura 11.4.

Para especificar estas func?o?es basta fornecer dois para?metros para X (as coordenadas

xmin e xmax, que sa?o os coeficientes de Be?zier b
X
((0,1),(0,0),(0,0))

e bX
((1,0),(0,0),(0,0))

desta func?a?o),

dois para?metros para Y (ymin e ymax, ou b
Y
((0,0),(0,1),(0,0))

e bY
((0,0),(1,0),(0,0))

) e 32 para?metros

para Z (os coeficientes bZ? onde ? ? H
(3,3,1)
(1,1,1)

). Veja figura 11.4. Note que estes u?ltimos sa?o

os 16 coeficientes da face superior e os 16 coeficientes de Be?zier da face inferior. No total,

sa?o apenas 2 + 2 + 32 = 36 para?metros, uma economia de memo?ria de aproximadamente

63%.

Por convenie?ncia, neste cap??tulo usaremos a notac?a?o B.X, B.Y e B.Z para indicar as

componentes do bloco de Be?zier generalizado B que representam a geometria; e analo-

gamente para outras componentes que representam as propriedades f??sicas. Ale?m disso,



11.2. Blocos de Be?zier generalizados 73

denotaremos por B.P(U) o ponto de coordenadas (B.X(U),B.Y(U),B.Z(U)). Na bibli-

oteca, estas componentes sa?o identificadas por ??ndices 0,1,2,etc; e acessadas atrave?s do

me?todo B.eval(k,U) que calcula a componente k para o ponto U do dom??nio A?

Considerando este exemplo, na biblioteca BezEl, optamos por representar cada ce?lula

de uma malha por um bloco de Be?zier generalizado, que e? uma lista de func?o?es polinomiais

simploidais de mesmo dom??nio mas de multi-graus arbitra?rios e independentes.

Cada bloco e? uma insta?ncia da classe Block e e? de um determinado tipo. Este tipo

e? descrito por um objeto separado (uma insta?ncia da classe BlockKind), que armazena

informac?o?es como a dimensa?o do contra-dom??nio, a multi-dimensa?o e os multi-graus. A

figura 11.5 ilustra esta representac?a?o. Nesta figura, os blocos B0 e B1 sa?o do mesmo

tipo C0. O bloco B2, por outro lado, e? do tipo C1. Note que o nu?mero e significado

dos para?metros params de cada bloco sa?o determinados pelo seu tipo. Por convenie?ncia,

usaremos a notac?a?o B.? para indicar o para?metro ? do bloco B.

Esta separac?a?o permite uma representac?a?o eficiente de malhas que possuem muitos

blocos de um mesmo tipo, como a da figura 11.1. O tipo destes blocos e? descrito por uma

insta?ncia brickKind da classe BlockKind, com dimensa?o do contra-dom??nio, o para?metro

brickKind.rD, 3, a multi-dimensa?o do dom??nio, brickKind.dD, com valor (1, 1, 1) e mul-

tigraus, para?metro brickKind.deg, ((1, 0, 0), (0, 1, 0), (3, 3, 1)).



74 Cap??tulo 11. Aspectos gerais da implementac?a?o

Figura 11.4: Representac?a?o mais econo?mica dos blocos da figura 11.1. Os pontos vermelhos,
verdes e azuis representam os coeficientes de Be?zier das componentes X,Y e Z respectivamente.
Observe que apenas uma coordenada de cada ponto e? livre.



11.2. Blocos de Be?zier generalizados 75

Block: B1

params:

kind:

Block: B2

params:

kind:

Block: B0

params:

kind:

BlockKind: C0

dD

rD

deg

(2,1)

3

(3,2) (2,2) (1,1)

BlockKind: C1

dD

rD

deg

(3)

3

(3) (2)(3)

Figura 11.5: Implementac?a?o de um bloco de Be?zier.



76 Cap??tulo 11. Aspectos gerais da implementac?a?o

11.3 Compartilhamento de para?metros

As restric?o?es de continuidade e suavidade impl??citas no modelo da figura 11.1 implicam

na identidade de diversos de seus coeficientes de Be?zier. Por exemplo, todos os blocos de

uma fileira devem ter os mesmos coeficientes xmin e xmax ou ymin e ymax, dependendo da

orientac?a?o da fileira. Ale?m disso, os coeficientes de Be?zier da face superior da camada

de baixo dever ser iguais aos da face inferior da camada de cima. Adicionalmente, se

desejarmos que as superf??cies de cada camada sejam cont??nuas, os coeficientes de Be?zier

que determinam uma aresta superior ou inferior de um bloco devem coincidir com os

coeficientes correspondentes nos blocos vizinhos.

Estas situac?o?es sa?o muito comuns, e por essa raza?o a biblioteca BezEl foi projetada

para facilitar o compartilhamento de para?metros. Especificamente, o vetor B.params de

cada bloco B conte?m apenas refere?ncias (??ndices) para seus para?metros, e na?o os valores

dos mesmos. Os valores dos para?metros de todos os blocos de um mesmo modelo G sa?o

armazenados em um u?nico vetor G.vars associado ao modelo. Desta forma, diversos blo-

cos do mesmo modelo podem compartilhar o mesmo para?metro, e a modificac?a?o do valor

de um para?metro e? automaticamente refletida em todos os blocos que o compartilham. A

figura 11.6 ilustra esta estrate?gia no caso da figura 11.5.

Block: B1

params:

kind:

Block: B2

params:

kind:

Block: B0

params:

kind:

BlockKind: C0

dD

rD

deg

(2,1)

3

(3,2) (2,2) (1,1)

BlockKind: C1

dD

rD

deg

(3)

3

(3) (2)(3)

ParamDepot: pD

vars:

Figura 11.6: Implementac?a?o do compartilhamento de para?metros entre blocos de Be?zier

Como exemplo de compartilhamento de para?metros, vamos descrever aqui o procedi-

mento t??pico para efetuar a colagem de dois blocos A e B da malha da figura 11.1 (tipo

brickKind). Esta operac?a?o e? uma colagem conforme, onde uma faceta inteira de um

bloco e? identificada com uma faceta de outro bloco. Veja a figura 11.7. O objetivo da



11.3. Compartilhamento de para?metros 77

colagem conforme e? garantir que na?o haja frestas nem sobreposic?o?es entre os blocos. Esta

operac?a?o deve ser repetida va?rias vezes para construir a malha da figura 11.1

A B

Figura 11.7: Colagem conforme de dois blocos do tipo brickKind.

Inicialmente, identificamos os para?metros de A que sera?o compartilhados pelo bloco

B. Estes sa?o os para?metros da faceta U1 = 1 de A. Veja a figura 11.8. Como pode ser

visto na figura 11.4, estes sa?o os coeficientes de Be?zier bX? , b
Y
? e b

Z
? das componentes X,Y

e Z de A cujo hiper-??ndice ? e? tal que ?1,1 = 0. Em seguida, para cada para?metro de A

a ser compartilhado, determinamos o hiper-??ndice do coeficiente correspondente no bloco

B. Este sera? um dos coeficientes bX? , b
Y
?,b

Y
? com ?1,0 = 0. Finalmente, criamos o bloco B

compartilhando os para?metros de A.



78 Cap??tulo 11. Aspectos gerais da implementac?a?o

(

0 1
0 1
0 1

)

(

1 0
0 1
0 1

)

(

0 1
1 0
0 1

)

(

0 1
0 1
1 0

)

U0

U1

U2

A B

K
(1,1,1)

Figura 11.8: Diagrama da colagem conforme de dois blocos que compo?em a malha da figura 11.1

11.4 Para?metros internos e externos

Os 36 coeficientes de Be?zier da figura 11.4 constituem uma representac?a?o individual

m??nima para o bloco da malha da figura 11.1 no sentido que para descrever a forma

de um desses blocos isoladamente sa?o necessa?rios de fato 36 para?metros. Entretanto, em

outras situac?o?es, pode ocorrer que os coeficientes de Be?zier de um u?nico bloco isolado

esta?o sujeitos a restric?o?es. Neste caso, o bloco pode ser completamente descrito por um

nu?mero menor de para?metros.

Por exemplo, considere os blocos utilizados para construir malhas pseudo-cil??ndricas

como a da figura 11.9, onde cada anel e? formado por N blocos simploidais. Cada um destes

blocos e? limitado por 4 faces planas e duas faces polinomiais cu?bicas que aproximam a

superf??cie de um cilindro. Veja figura 11.10. Observe que as componentes X e Y sa?o de

multi-grau (3, 1, 0), ou seja, sa?o polino?mios de grau 3 em u, 1 em v e independentes de



11.4. Para?metros internos e externos 79

w. Cada func?a?o tem portanto 8 coeficientes de Be?zier, bX? e b
Y
? onde ?, ? ? H

(3,1,0)
(1,1,1)

. Estes

16 coeficientes podem ser vistos como 8 pontos de controle projetados no plano XY . A

componente Z, por outro lado, e? de multi-grau (0, 0, 1), ou seja, e? independente de u e

de v mas e? uma func?a?o linear de w, e e? especificada por 2 coeficientes de Be?zier, bZ? onde

? ? H
(0,0,1)
(1,1,1)

= {((0, 0), (0, 0)(0, 1)), ((0, 0), (0, 0), (1, 0))}; estes coeficientes especificam as

alturas z0 e z1 das facetas inferior e superior do bloco.

Figura 11.9: Uma malha pseudo-cil??ndrica composta por 3 pares de ane?is conce?ntricos, cada um
formado por 4 blocos.

Figura 11.10: Um bloco simploidal para a malha da figura 11.9. Os pontos amarelos sa?o pontos
de controle de Be?zier das coordenadas X e Y enquanto os pontos azuis sa?o os pontos de controle
de Be?zier da coordenada Z.

Portanto, este bloco de Be?zier generalizado tem 8 + 8 + 2 = 18 coeficientes de Be?zier.

Entretanto, se considerarmos o a?ngulo ? = 2?/N fixo, todos os 18 coeficientes de Be?zier



80 Cap??tulo 11. Aspectos gerais da implementac?a?o

podem ser escritos como func?o?es lineares de 8 para?metros: as alturas z0 e z1, as coorde-

nadas (xc,yc) do eixo do cilindro, e as coordenadas (x0,y0) e (x1,y1) de dois cantos do

bloco, projetados no plano Z = 0. Veja a figura 11.11.

(x0,y0) (x1,y1)

z0

z1

(xc,yc)

Figura 11.11: Ilustrac?a?o dos para?metros que derivam os coeficientes de Be?zier de blocos que
compo?em a malha da figura 11.9.

A relac?a?o entre estes 8 para?metros e os coeficientes de Be?zier bX? , b
Y
? e b

Z
? depende do

a?ngulo ? e do me?todo de aproximac?a?o escolhido. Em 2006, Riskus publicou um conjunto



11.4. Para?metros internos e externos 81

de fo?rmulas para este fim [23]:

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

bX((0,3),(0,1),(0,0))

bX
((1,2),(0,1),(0,0))

bX((2,1),(0,1),(0,0))

bX
((3,0),(0,1),(0,0))

bX((0,3),(1,0),(0,0))

bX
((1,2),(1,0),(0,0))

bX((2,1),(1,0),(0,0))

bX
((3,0),(1,0),(0,0))

bY((0,3),(0,1),(0,0))

bY
((1,2),(0,1),(0,0))

bY((2,1),(0,1),(0,0))

bY
((3,0),(0,1),(0,0))

bY
((0,3),(1,0),(0,0))

bY
((1,2),(1,0),(0,0))

bY
((2,1),(1,0),(0,0))

bY((3,0),(1,0),(0,0))

bZ
((0,0),(0,0),(0,1))

bZ((0,0),(0,0),(1,0))

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

=

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

1 1 0 0 0 0 0 0

1 1 0 0 ? 0 0 0

1 ? 0 0 1 0 0 0

1 0 0 0 1 0 0 0

1 0 1 0 0 0 0 0

1 0 1 0 0 ? 0 0

1 0 ? 0 0 1 0 0

1 0 0 0 0 1 0 0

0 0 0 1 1 0 0 0

0 ?? 0 1 1 0 0 0

0 ?1 0 1 ? 0 0 0

0 ?1 0 1 0 0 0 0

0 0 0 1 0 1 0 0

0 0 ?? 1 0 1 0 0

0 0 ?1 1 0 ? 0 0

0 0 ?1 1 0 0 0 0

0 0 0 0 0 0 1 0

0 0 0 0 0 0 0 1

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

xc
x0
x1
yc
y0
y1
z0
z1

?

?

?

?

?

?

?

?

?

?

?

?

?

?

onde o valor de ? depende do a?ngulo ?. A tabela 11.1 mostra os valores de ? para alguns

a?ngulos.

A biblioteca BezEl tambe?m permite este tipo de otimizac?a?o. Em geral, os para?metros

B.params de um bloco B na?o sa?o os coeficientes de Be?zier de suas componentes, mas sim

uma colec?a?o arbitra?ria de para?metros externos. Os coeficientes de Be?zier (para?metros

internos do bloco) sa?o func?o?es afins deles.

A relac?a?o entre os para?metros internos e externos e? mais um atributo do tipo do bloco,



82 Cap??tulo 11. Aspectos gerais da implementac?a?o

? ?
30? 0.175534
45? 0.265216
60? 0.357259
90? 0.552284

Tabela 11.1: Tabela com valores de ? para diferentes ?.

Block: B1

params:

kind:

Block: B2

params:

kind:

ParamDepot: pD

vars:

Block: B0

params:

kind:

BlockKind: C0

dD

rD

deg

(2,1)

3

(3,2) (2,2) (1,1)

M

BlockKind: C1

dD

rD

deg

(3)

3

(3) (2)(3)

M

Figura 11.12: Esquema da relac?a?o o reposito?rio de para?metros, um bloco e seu tipo com matrizes
de conversa?o entre para?metros externos e internos.

representado por uma matriz M armazenada no objeto BlockKind correspondente. Veja

figura 11.12

11.5 Extrac?a?o de componentes

A representac?a?o descrita na sec?a?o 11.4 economiza espac?o mas na?o e? eficiente quando

desejamos utilizar os coeficientes de Be?zier de um mesmo bloco B diversas vezes, por

exemplo na avaliac?a?o de B.F em muitos pontos do dom??nio. Para estes casos, utilizamos

isoladamente as diversas componentes do bloco, obtidas atrave?s do me?todo B.explicit().

Este me?todo, que na?o precisa de argumentos, retorna um vetor de B.kind.rD polino?mios

simploidais, cada um representando uma componente B.Fi.



11.6. Extrac?a?o de facetas 83

Na biblioteca BezEl, polino?mios simploidais sa?o representados por objetos da da classe

BezierSimploidPoly. Cada insta?ncia P desta classe conte?m apenas tre?s atributos: a

multi-dimensa?o P.domainType, o multi-grau P.multiDegree e um vetor P.coef com seus

coeficientes de Be?zier. O me?todo P.evaluate avalia o polino?mio em um ponto U do

dom??nio, fornecido como argumento.

Ao contra?rio da representac?a?o de blocos, o vetor P.coef armazena os valores nume?ricos

dos coeficientes de Be?zier. Estes valores sa?o calculados pelo me?todo B.explicit a partir

dos valores correntes de para?metros externos e da matriz B.kind.M.

11.6 Extrac?a?o de facetas

Uma operac?a?o importante na biblioteca BezEl e? a extrac?a?o de facetas de blocos. Esta

operac?a?o resulta em um bloco que compartilha para?metros (externos e internos) com

o bloco original. Esta e? uma etapa importante em colagens arbitra?rias (na?o conforme)

blocos, como veremos no cap??tulo 12

Considere por exemplo um bloco de Be?zier generalizado B cujo dom??nio e? o prisma

cano?nico, K(2,1) de multi-grau (2, 3) para X,Y e Z, como o da figura 11.13a. A fi-

gura 11.13b mostra a faceta superior deste bloco correspondente a? faceta K(2,1)|(1,0) do

dom??nio. A extrac?a?o desta faceta do bloco B produz um bloco de Be?zier de dom??nio K(2)

e grau (2) para X,Y e Z.

Vamos agora descrever a extrac?a?o desta faceta utilizando a biblioteca BezEl. Veja a

figura 11.14. Esta operac?a?o consiste de duas etapas: criac?a?o um novo tipo de bloco para

a faceta e a criac?a?o do bloco que e? a faceta propriamente dita. Suponha que o bloco

original e? descrito pelo objeto B e seu tipo e? o objeto prismKind. Para extrair a faceta

da figura 11.13b procedemos da seguinte forma:

1. Criamos um tipo de bloco apropriado, triangKind, invocando o me?todo

prismKind-&gt;get FacetKind cujos argumentos sa?o os ??ndices da faceta desejada, no

caso, (1,0).

2. Criamos o bloco B top da faceta, invocando o me?todo B-&gt;get Facet. Os argu-

mentos deste me?todo sa?o o tipo do bloco triangKind e os ??ndices (1,0) da faceta

desejada. Veja figura 11.14

A figura 11.13 mostra uma das faceta laterais, correspondente a? faceta K(2,1)|(0,1) do

dom??nio. A extrac?a?o desta faceta produz um bloco de Be?zier de dom??nio K(1,1) e grau

(2, 3) para X,Y e Z. De forma ana?loga, a extrac?a?o desta faceta e? realizada invocando o

me?todo prismKind-&gt;get FacetKind com argumentos (0,1) para obter o tipo de bloco

adequado, digamos retangKind; e em seguida, invocando o me?todo B-&gt;get Facet com

argumentos retangKind e (0,1) para obter a faceta B side.



84 Cap??tulo 11. Aspectos gerais da implementac?a?o

Note que os para?metros externos (e internos) dos novos blocos B top e B side sa?o

subconjuntos dos para?metros externos (e internos) do bloco original B. Ale?m disso, os

tipos de bloco triangKind e retangKind podem ser compartilhados por quaisquer outras

facetas semelhantes, ou quaisquer outros retalhos de mesmas multi-dimenso?es e multi-

graus.

A figura 11.15 mostra outro exemplo, a extrac?a?o da faceta lateral interna do bloco da

figura 11.10. O procedimento e? similar. Seja B o bloco original, de tipo cylSliceKind.

O me?todo B-&gt;get FacetKind, invocado com argumentos (2,0) fornece um novo tipo de

bloco, cylPlateKind, adequado para a faceta desejada. Este tipo de bloco e? um retalho

bidimensional de dom??nio K(1,1), com X e Y de multi-grau (3, 0) e Z de multi-grau (0, 1). O

objeto B side, que descreve a faceta, e? obtido invocando B-&gt;get Facet, com argumentos

cylPlateKind e (2,0). Veja figura 11.16.

Assim como cylSliceKind tem uma relac?a?o na?o trivial entre para?metros externos e

internos, o mesmo ocorre com cylPlateKind. Temos 4 coeficientes de Be?zier para X, 4

para Y e 2 para Z, num total de 10 para?metros. Pore?m, todos estes podem ser descritos

como func?o?es lineares de 4 para?metros externos: o intervalo de Z, zmin e zmax, e as

coordenadas x,y de uma das arestas verticais.

Uma vez que sliceKind armazena em sliceKind-&gt;M as relac?o?es entre os para?metros

internos e externos de blocos deste tipo, a criac?a?o do tipo plateKind requer a especificac?a?o

destas relac?o?es para blocos do tipo da faceta. A matriz plateKind-&gt;M, que descreve as

relac?o?es entre os para?metros externos e internos da faceta de ??ndice (2, 0), e? uma sub-

matriz de sliceKind-&gt;M obtida selecionando as linhas relacionadas aos hiper-??ndices

{? ? H
(3,0,1)
(1,1,1)

?

? ?2,0 6= 0}

e eliminando as colunas compostas unicamente por zeros.



11.6. Extrac?a?o de facetas 85

( 0 0 10 1 )

( 0 0 11 0 )

( 1 0 00 1 )
K

(2,1)

prism.X

prism.X(K
(2,1)
(10)

)

prism.X(K
(2,1)
(02)

)

K
(2,1)|02 = K

(1,1)

K
(2,1)|10 = K

(2)

Figura 11.13: Um bloco prisma?tico de multi-grau (2, 2) e suas facetas (1, 0) e (0, 2).



86 Cap??tulo 11. Aspectos gerais da implementac?a?o

Block: fside

params:

kind:

ParamDepot: pD

vars:

Block: ftop

params:

kind:

BlockKind: prismKind

dD

rD

deg

(2,1)

3

(2,2) (2,2) (2,2)

M

BlockKind: triangKind

dD

rD

deg

(2)

3

(2) (2)

M

(2)

BlockKind: rectangKind

dD

rD

deg

(1,1)

3

(2,2) (2,2) (2,2)

M

Block: prism

params:

kind:

Figura 11.14: Extrac?a?o de facetas de um prisma da figura 11.13

(a) (b)

Figura 11.15: Facetas do bloco da malha cil??ndrica: (a) Faceta (0, 0), (b)



11.6. Extrac?a?o de facetas 87

Block: plate1

params:

kind:

ParamDepot: pD

vars:

BlockKind: sliceKind

dD

rD

deg

(1,1,1)

3

M

BlockKind: plateKind

dD

d3

deg

(1,1)

3

(3,0) (3,0) (0,1)

M

Block: slice1

params:

kind:

(3,0,1) (3,0,1) (0,1,0)

6 external params

      18

internal params

        4

external params

      10

internal params

rD

Figura 11.16: Extrac?a?o de facetas do prisma da figura 11.13



88 Cap??tulo 11. Aspectos gerais da implementac?a?o

11.7 Elevac?a?o de grau

Outra operac?a?o muito frequ?ente em modelagem geome?trica e? a elevac?a?o de grau. No

exemplo da figura 11.17, a partir de um elemento prisma?tico de Be?zier B, de multi-grau

(2, 2) nas componentes X,Y e Z (figura 11.17a), obtemos um bloco RB (figura 11.17b) de

mesmo dom??nio mas de multi-grau (3, 3) em todas as componentes que coincide com B

em todos os pontos do dom??nio.

(a) (b)

Figura 11.17: Elevac?a?o de grau de um bloco prisma?tico de multi-grau (2, 2) para (3, 3).

A figura 11.18 ilustra a elevac?a?o de grau utilizando a biblioteca BezEl. Assim como a

extrac?a?o de facetas, esta operac?a?o consiste de duas etapas: criac?a?o um tipo de bloco

adequado e a criac?a?o do bloco de grau maior propriamente dito. Suponha que o bloco da

figura 11.17a e? descrito pelo objeto prism22 e seu tipo e? o objeto prism22Kind. Suponha

que na?o ha? qualquer restric?a?o sobre a forma do bloco, de modo que seus 54 para?metros

externos sa?o os pro?prios coeficientes de Be?zier das func?o?es X,Y e Z (18 pontos de controle).

Para elevar o grau de todas as componentes para (3, 3) procedemos da seguinte forma:

1. Criamos um tipo de bloco apropriado, digamos prism22 33 Kind, invocando o

me?todo prism22Kind-&gt;get raisedDegreeKind cujo argumento e? um vetor con-

tendo os novos multi-graus, neste caso, [(3,3),(3,3),(3,3)].

2. Criamos o bloco da figura 11.17b prism22 33, invocando o me?todo get SubBlock

de prism22 utilizando como argumento o tipo do bloco prism22 33 Kind.

O novo bloco tem 120 para?metros internos (40 pontos de controle). Entretanto, como des-

crito na sec?a?o 8.2.3, os coeficientes de Be?zier do novo elemento sa?o func?o?es lineares dos co-

eficientes do elemento inicial. Portanto, os para?metros externos do novo bloco sa?o os mes-

mos do bloco original, ou seja os 54 coeficientes de Be?zier. A relac?a?o entre os para?metros



11.7. Elevac?a?o de grau 89

ParamDepot: pD

vars:

BlockKind: prism22Kind

dD

rD

deg

(2,1)

3

(2,2) (2,2) (2,2)

M

Block: prism22

params:

kind:

Block: prism22_33

params:

kind:

BlockKind: prism22_33_Kind

dD

rD

deg

(2,1)

3

(3,3) (3,3) (3,3)

M

54 external vars

      120

internal vars

Figura 11.18: Diagrama ilustrativo da elevac?a?o de grau de um bloco prisma?tico.

internos e externos do novo elemento sa?o armazenadas na matriz prism22 33 Kind.M

que tem 120 linhas e 54 colunas e cujos elementos sa?o os coeficientes K?? definidos na

sec?a?o 8.2.3.

A figura 11.19 mostra outro exemplo, a elevac?a?o de grau do elemento para compor ma-

lhas pseudo-cil??ndricas descrito na sec?a?o 11.4. O procedimento e? similar. Seja cylSlice1 o

bloco original, de tipo cylSliceKind. O me?todo cylSliceKind-&gt;get raisedDegreeKind,

invocado utilizando o vetor de multi-graus [(3,3,3),(3,3,3),(3,3,3)] como argu-

mento, fornece um novo tipo de bloco, cylSlice33Kind, adequado para o bloco desejado.

Este tipo de bloco tem como dom??nio o simplo?ide cano?nico K(1,1,1) e as componentes

X,Y e Z sa?o de grau (3, 3, 3). Ale?m disso, este tipo de bloco e? responsa?vel pela con-

versa?o dos 6 para?metros externos do bloco original cylSlice1 nos seus 18 para?metros

internos (a matriz cylSliceKind.M) e a conversa?o destes nos 192 para?metros internos

do bloco coincidente de grau maior (fo?rmula (8.7)). Para isto, estas duas operac?o?es li-

neares sa?o combinadas em uma u?nica matriz de 192 linhas por 6 colunas, o atributo

cylSlice33Kind-&gt;M. O objeto cylSlice33, que descreve o elemento coincidente de grau

maior, e? obtido invocando cylSlice1-&gt;get SubBlock, utilizando como argumento o novo

tipo de bloco cylSlice33Kind. Veja figura 11.20.



90 Cap??tulo 11. Aspectos gerais da implementac?a?o

(a) (b)

Figura 11.19: Elevac?a?o de grau de um bloco da malha pseudo-cil??ndrica de grau (0, 3, 3) em X,Y
e (1, 0, 0) em Z, para (3, 3, 3) em X, Y e Z.

Block: cylSlice33

params:

kind:

ParamDepot: pD

vars:

BlockKind: cylSliceKind

dD

rD

deg

(1,1,1)

3

M

BlockKind: cylSlice33Kind

dD

rD

deg

(1,1,1)

3

(3,3,3)

M

Block: cylSlice1

params:

kind:

(3,0,1) (3,0,1) (0,1,0)

6 external vars

      18

internal vars

      192

internal vars

6 external vars

(3,3,3) (3,3,3)

Figura 11.20: Diagrama ilustrativo da elevac?a?o de grau de um bloco da malha pseudo-cil??ndrica.



11.8. Reparametrizac?a?o 91

11.8 Reparametrizac?a?o

A func?a?o A.F de um bloco A pode ser reparametrizada atrave?s do me?todo A.subBlock.

Esta operac?a?o resulta em um novo bloco cujos para?metros externos sa?o um subconjunto

dos para?metros externos de A, mas, em geral, definido em um dom??nio diferente (que pode

extrapolar do dom??nio de A) e com um conjunto diferente de para?metros internos.

Como nas operac?o?es anteriores, e? necessa?rio criar um novo tipo de bloco para cada

mapa ? definido, e depois criar o bloco desejado que tera? este tipo. Este novo tipo

reparKind e? criado pelo me?todo A.kind.get BlockKind of Composition w DM utilizando

o mapa ? como argumento. A matriz reparKind.M e? a composic?a?o da matriz dos coefi-

cientes de ? (descrita no cap??tulo 10) com a matriz A.kind.M.

Um mapa afim ? e? representado na biblioteca BezEl por uma insta?ncia da classe

DomainMapping, que conte?m os coeficientes Mrsij (cap??tulo 9) armazenados na forma de

uma matriz irregular (indexada por r,s) de matrizes irregulares (indexadas por i,j).

Note que o mapa ? na?o precisa ser sobrejetor. Por exemplo, se A e? um retalho trian-

gular (dom??nio K2) e ? leva de K1 para K2, a reparametrizac?a?o de A por ? retorna uma

curva de Be?zier, que corresponde ao segmento de reta ?(K1) no espac?o A2.

11.9 Derivada direcional

Outra operac?a?o importante implementada pela BezEl e? o ca?lculo da derivada direcional

da func?a?o A.F de um bloco A, em uma direc?a?o dada ? do dom??nio do bloco. Como descrito

no cap??tulo 8, a derivada direcional de cada componente A.Fi tambe?m e? um polino?mio

simploidal e, portanto, pode ser vista como a componente dA.Fi de um outro bloco dA de

mesma multi-dimensa?o.

Para isso, um novo tipo derivKind deve ser criado para cada tipo de bloco e cada

direc?a?o ? atrave?s do me?todo A.kind.get BlockKind of DirectionalDerivative. Os

argumentos deste me?todo sa?o a ordem r da derivada e o vetor direc?a?o ?. Em seguida, o

bloco dA pode ser criado atrave?s do me?todo A.subBlock, fornecendo o tipo derivKind

como argumento.



Cap??tulo 12

Restric?o?es entre blocos

Outra ferramenta importante para modelagem geome?trica, fornecida pela biblioteca Be-

zEl, e? a especificac?a?o de restric?o?es afins (de 1o¯ grau) entre os para?metros dos blocos de

um mesmo modelo.

Para representar tais restric?o?es, cada modelo G da biblioteca BezElpossui, ale?m do

vetor G.vars de classe ParamDepot, uma insta?ncia G.eqs da classe EquationDepot, que e?

uma lista de equac?o?es afins sobre os para?metros externos armazenados em G.vars. Cada

elemento desta lista e? um objeto da classe Equation que representa uma u?nica restric?a?o.

Observe que restric?o?es que envolvem os coeficientes de Be?zier de um u?nico bloco isolado

podem ser implementadas alternativamente pela matriz do tipo do bloco, como descrito

na sec?a?o 11.4. Mais precisamente, se o bloco do tipo B tem n coeficientes de Be?zier e as

restric?o?es definem um certo subespac?o afim do Rn de dimensa?o p, e? poss??vel implementar

estas restric?o?es escolhendo p para?metros externos e preenchendo adequadamente a matriz

B.M (de tamanho n×p). Pore?m, esta soluc?a?o exige que um novo tipo de bloco seja criado

para cada conjunto diferente de restric?o?es.

12.1 Colagem na?o-conforme

Um exemplo de uso de restric?o?es e? a colagem de dois blocos pseudo-cil??ndricos de ?

radianos, cyl A e cyl B (veja sec?a?o 11.4), de modo que a faceta externa de cyl B coincide

com parte da faceta interna de cyl A, como na figura 12.1.

Para que na?o existam nem frestas nem sobreposic?a?o entre os blocos, as restric?o?es que

devem ser satisfeitas sa?o facilmente determinadas pela pro?pria definic?a?o dos para?metros

externos deste tipo de bloco (ver figura 11.11):

93



94 Cap??tulo 12. Restric?o?es entre blocos

1
4

1
4

1
2

Figura 12.1: Uso de restric?o?es entre para?metros externos de dois blocos pseudo-cil??ndricos: o
cyl A (em verde) e o cyl B (em amarelo).

cyl A.x1 ? cylB.x0 = 0 (12.1)

cyl A.y1 ? cylB.y0 = 0 (12.2)

0.75cyl A.z0 + 0.25cyl A.z1 ? cylB.z0 = 0 (12.3)

0.25cyl A.z0 + 0.75cyl A.z1 ? cylB.z1 = 0 (12.4)

Neste caso, a lista G.eqs do modelo teria 4 elementos do tipo Equation (veja figura 12.2).

Note que os para?metros externos do bloco, na verdade, residem no vetor G.vars.

12.2 Restric?o?es entre para?metros internos

No exemplo da sec?a?o 12.1, as restric?o?es foram formuladas diretamente sobre os para?metros

externos dos blocos. Em algumas situac?o?es, e? mais natural expressar uma determinada

restric?a?o em termos dos para?metros internos (coeficientes de Be?zier). Nestes casos, as ma-

trizes M dos tipos dos blocos envolvidos devem ser usadas para substituir cada para?metro

interno presente na equac?a?o pela combinac?a?o afim equivalente de para?metros externos.

A inserc?a?o de um poc?o ao modelo da figura 11.1 ilustra uma destas situac?o?es. Veja

a figura 12.3. Neste exemplo, o poc?o e? composto por 4 blocos do tipo cylSliceKind

(descrito na sec?a?o 11.4) de a?ngulo ? = ?/2. Como mostra a figura 12.4, esta operac?a?o



12.2. Restric?o?es entre para?metros internos 95

ParamDepot: pD

vars:

size: 3

coefs: 0.25 0.75 ?1.0

size: 3

Equation: eq2

params:

coefs: 0.75 0.25 ?1.0

size: 2

Equation: eq0

params:

term:

coefs: 1.0 ?1.0

0.0

Equation: eq3

size: 2

Equation: eq1

params:

term:

coefs: 1.0 ?1.0

0.0 term: 0.0 term: 0.0

params:

Block: cyl_A

params:

kind:
BlockKind: cylSliceKind

dD

rD

deg

(1,1,1)

3

(3,3,3)

M

(3,3,3) (3,3,3)

Block: cyl_B

params:

kind:

EquationDepot: eD

eqs:

Figura 12.2: Representac?a?o das restric?o?es 12.1 a 12.4 na BezEl.

implica em substituir um dos blocos da malha pelos 4 blocos do poc?o, e mais 4 blocos de

transic?a?o que preenchem o espac?o entre o poc?o e o resto da malha.

Os blocos de transic?a?o tambe?m podem ser blocos tensoriais, mas devem ser de tipo

diferente do brickKind. Para que eles possam se acomodar adequadamente a? parede

pseudo-cil??ndrica do poc?o, as componentes X e Y deste novo tipo devem ser func?o?es

cu?bicas das coordenadas U1 e U2; mas podem ser independentes de U0 pois tanto o poc?o

quanto a malha tem paredes verticais. A componente Z, por outro lado, deve ser uma

func?a?o linear de U0 e cu?bica em U1 e U2. Assim, tanto a func?a?o X quanto a Y possuem

16 coeficientes de Be?zier, bx? e b
y
? onde ?, ? ? H

(3,3,0)
(1,1,1)

, enquanto que a componente Z

possui 32 coeficientes, bz? onde ? ? H
(3,3,1)
(1,1,1)

. Vamos supor que este tipo de bloco e? descrito

pelo objeto cylJoinKind, cujos para?metros externos sa?o os pro?prios coeficientes de Be?zier

(isto e?, cylJoinKind.M e? trivial).



96 Cap??tulo 12. Restric?o?es entre blocos

Figura 12.3: Adic?a?o de um poc?o ao modelo da figura 11.1.

Suponha que desejamos colar um bloco join deste tipo a um bloco cyl do tipo

cylSliceKind segundo a figura 12.5. Para isso, procedemos da seguinte forma

1. Obtemos a faceta (1, 1) de join, que chamaremos de f join. Note que os para?metros

externos de f join sa?o um subconjunto dos para?metros externos de join.

2. Obtemos a faceta (1, 0) do bloco cyl, que chamaremos de f cyl.

3. Elevamos o multi-grau da componente Z da faceta f cyl de (0, 1) para (3, 1), ob-

tendo o novo bloco f cyl rD de mesmo multi-grau da faceta f join. Note que

f cyl rD tem um novo tipo e que seus para?metros externos sa?o um subconjunto dos

para?metros externos de cyl.

4. Para cada componente (X,Y e Z) de f join, e para cada coeficiente de Be?zier

? dessa componente (ou seja bx? para X, b
y
? para Y e b

z
? para Z), criamos uma

restric?a?o no reposito?rio eqs do modelo que iguala f join.? ao coeficiente de Be?zier

f cyl rD.? correspondente na outra faceta. Como o tipo de f cyl rD possui uma

matriz M na?o trivial, usamos esta matriz para substituir este coeficiente de Be?zier

pela combinac?a?o apropriada dos para?metros externos de f cyl rD.

5. Finalmente, descartamos os blocos auxiliares criados: f join, f cyl e f cyl rD.

O passo 1 implica em criar (ou se reutilizar) um tipo de bloco espec??fico para a faceta

f join. Este tipo de bloco tem dom??nio K(1,1) e multigraus (3, 0) para as componentes X



12.2. Restric?o?es entre para?metros internos 97

(a) (b)

Figura 12.4: Regia?o em torno do poc?o.

e Y e (3, 1) para a componente Z. Analogamente, o passo 2 implica em criar ou reutilizar

um tipo de bloco para a faceta, f cylKind, de dom??nio K(1,1) e multigraus (3, 0) para as

componentes X e Y e (1, 0) para a componente Z, cuja matriz f cylKind.M e?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

1 0 0 0

1 ? 0 0

? 1 0 0

0 1 0 0

0 1 0 0

?? 1 0 0

?1 ? 0 0

?1 0 0 0

0 0 1 0

0 0 0 1

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

onde ? = 0.552285 (veja sec?a?o 11.4).

O passo 3 requer outro tipo de bloco, f cylKind rD, para a faceta f cyl rD, cuja matriz



98 Cap??tulo 12. Restric?o?es entre blocos

e?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

1 0 0 0

1 ? 0 0

? 1 0 0

0 1 0 0

0 1 0 0

?? 1 0 0

?1 ? 0 0

?1 0 0 0

0 0 1 0

0 0 1 0

0 0 1 0

0 0 1 0

0 0 0 1

0 0 0 1

0 0 0 1

0 0 0 1

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?



12.2. Restric?o?es entre para?metros internos 99

No passo 4, as restric?o?es criadas sobre os para?metros internos sa?o

f join.bx((3,0),(0,0) = f cyl rD.c
x
((3,0),(0,0)

f join.bx((2,1),(0,0) = f cyl rD.c
x
((2,1),(0,0)

f join.bx((1,2),(0,0) = f cyl rD.c
x
((1,2),(0,0)

f join.bx((0,3),(0,0) = f cyl rD.c
x
((0,3),(0,0)

f join.b
y

((3,0),(0,0)
= f cyl rD.c

y

((3,0),(0,0)

f join.b
y

((2,1),(0,0)
= f cyl rD.c

y

((2,1),(0,0)

f join.b
y

((1,2),(0,0)
= f cyl rD.c

y

((1,2),(0,0)

f join.b
y

((0,3),(0,0)
= f cyl rD.c

y

((0,3),(0,0)

f join.b
y

((3,0),(0,1)
= f cyl rD.c

y

((3,0),(0,1)

f join.b
y

((2,1),(0,1)
= f cyl rD.c

y

((2,1),(0,1)

f join.b
y

((1,2),(0,1)
= f cyl rD.c

y

((1,2),(0,1)

f join.b
y

((0,3),(0,1)
= f cyl rD.c

y

((0,3),(0,1)

f join.bz((3,0),(1,0) = f cyl rD.c
z
((3,0),(1,0)

f join.bz((2,1),(1,0) = f cyl rD.c
z
((2,1),(1,0)

f join.bz((1,2),(1,0) = f cyl rD.c
z
((1,2),(1,0)

f join.bz((0,3),(1,0) = f cyl rD.c
z
((0,3),(1,0)



100 Cap??tulo 12. Restric?o?es entre blocos

que, expressas em termos dos para?metros externos de cyl sa?o

f join.bx((3,0),(0,0) ? cyl.y1 = 0

f join.bx((2,1),(0,0) ? (?cyl.x1 + cyl.y1) = 0

f join.bx((1,2),(0,0) ? (cyl.x1 + ?cyl.y1) = 0

f join.bx
((0,3),(0,0)

? cyl.x1 = 0

f join.b
y

((3,0),(0,0)
? (?cyl.x1) = 0

f join.b
y

((2,1),(0,0)
? (?cyl.x1 + ?cyl.y1) = 0

f join.b
y

((1,2),(0,0)
? (??cyl.x1 + cyl.y1) = 0

f join.b
y

((0,3),(0,0)
? cyl.y1 = 0

f join.b
y

((3,0),(0,1)
? cyl.z0 = 0

f join.b
y

((2,1),(0,1)
? cyl.z0 = 0

f join.b
y

((1,2),(0,1)
? cyl.z0 = 0

f join.b
y

((0,3),(0,1)
? cyl.z0 = 0

f join.bz
((3,0),(1,0)

? cyl.z1 = 0

f join.bz
((2,1),(1,0)

? cyl.z1 = 0

f join.bz
((1,2),(1,0)

? cyl.z1 = 0

f join.bz
((0,3),(1,0)

? cyl.z1 = 0

Neste caso, como cada para?metro de f join aparece em exatamente uma equac?a?o com

coeficiente 1, todas estas restric?o?es sa?o independentes e compat??veis.

Note que cada ponto do R3 na faceta compartilhada do modelo tem as mesmas co-

ordenadas locais relativas aos blocos f join e f cyl rD. Ou seja, a colagem garante que

f cyl rD.F(U) = f join.F(U) para todo U ? A(1,1).



12.2. Restric?o?es entre para?metros internos 101

(

0 1
0 1
0 1

)

(

1 0
0 1
0 1

)

(

0 1
1 0
0 1

)

(

0 1
0 1
1 0

)

( 0 10 1 )

( 1 00 1 )

( 0 11 0 )

K
(1,1,1)

K
(1,1)

U0

U1

U2

U0

U1

join

f join
cyl

f cylf cyl rD

XX I E

Figura 12.5: Diagrama da colagem conforme de um bloco que compo?e o poc?o com um bloco de
transic?a?o. Denotamos por X , E e I as operac?o?es de extrac?a?o de uma faceta, elevac?a?o de grau e
identificac?a?o de coeficientes de Be?zier, respectivamente.



102 Cap??tulo 12. Restric?o?es entre blocos

12.3 Colagem na?o-conforme geral

Em muitas aplicac?o?es, a identificac?a?o de facetas completas na?o e? suficiente. Frequ?ente-

mente, desejamos identificar uma parte de uma faceta de um bloco com parte de uma

faceta de outro bloco. Nestes casos, como no exemplo da sec?a?o 12.1, a corresponde?ncia

entre as coordenadas locais de cada ponto compartilhado relativas a cada faceta na?o e?

trivial. Na biblioteca BezEl, este tipo de colagem pode ser realizada se a corresponde?ncia

entre as coordenadas locais for uma bijec?a?o afim.

Mais especificamente, suponha que as facetas em questa?o sa?o representadas por dois

elementos simploidais de Be?zier A e B, de dom??nios K? e K?, respectivamente, e queremos

identificar A.F(U) com B.F(V ), onde U pertence a um subconjunto X de A? e V pertence

a um subconjunto Y de A?. Para simplificar, vamos supor que X,Y,A? e A? te?m a mesma

dimensa?o topolo?gica, e que queremos identificar A.F(U) com B.F(?(U)) onde ? e? um

mapa afim de A? para A? dado. Note que nem X nem Y tem que ser o simplo?ide cano?nico

correspondente (K? ou K? respectivamente). Note tambe?m que, nestas condic?o?es, as

func?o?es A.F e (B.F) ? ? coincidem em todo o dom??nio A?, e na?o apenas no conjunto X.

Por exemplo, suponha que desejamos colar um bloco prisma?tico prism, de multi-grau

(2, 2), com um bloco tetrae?drico tetra, de grau (2), como na figura 12.6.

Figura 12.6: Colagem na?o-conforme de um bloco prism de dom??nio K(2,1) e grau (2, 2) com um
bloco tetra de dom??nio K(3) e grau (2).

.

Para isso, e? necessa?rio definir: (a) as facetas que participara?o da colagem, e (b) o mapea-

mento de colagem ?. No caso, trata-se do mapa ? : A(2) ? A(1,1) ilustrado na figura 12.7.



12.3. Colagem na?o-conforme geral 103

Para obtermos o conjunto de restric?o?es entre os para?metros de prism e tetra que

garantem esta colagem, procedemos da seguinte forma:

1. Obtemos a faceta (0, 2) de prism, que chamaremos de f prism. Esta faceta e? um

bloco de dom??nio K(1,1) e grau (2, 2).

2. Obtemos a faceta (0, 0) de tetra, de dom??nio K(2) e grau (2), que chamaremos de

f tetra.

3. Reparametrizamos a faceta f prism atrave?s da sua composic?a?o com o mapeamento

? para obter o bloco simplicial f prism a2. Note que, como demonstrado no

cap??tulo 10, este novo bloco tem dom??nio K(2) e suas componentes sa?o de grau

(4). O objetivo e? fazer f prism a2.F coincidir com f tetra.F em todo A(2).

4. Elevamos o grau da faceta f tetra de (2) para (4), obtendo o novo bloco f tetra rD.

Esta faceta e? um bloco de dom??nio K(2) e grau (4), o mesmo que f prism a2.

5. Adicionamos ao reposito?rio eqs do modelo as restric?o?es que igualam cada coeficiente

de Be?zier de f prism a2 ao coeficiente correspondente de f tetra rD. Note que,

para isso, e? necessa?rio utilizar as matrizes f prism a2.kind.M e f tetra rD.kind.M

para substituir cada coeficiente de Be?zier pela combinac?a?o dos para?metros externos

apropriada.

6. Finalmente, descartamos os blocos auxiliares criados: f prism, f prism a2, f tetra

e f tetra rD.



104 Cap??tulo 12. Restric?o?es entre blocos

( 0 0 10 1 )

( 0 0 11 0 )

( 1 0 00 1 )

( 0 0 0 1 )

( 0 0 1 0 )

( 0 1 0 0 )

( 1 0 0 0 )

K
(2,1)

K
(3)

prism

f prism
f prism a2

tetra

f tetra
f tetra rD

( 0 10 1 )
( 1 00 1 )

( 0 11 0 )

?

( 0 0 1 )

( 0 1 0 ) ( 1 0 0 )

K
(1,1) K

(2)

X
X

I

ER

Figura 12.7: Colagem na?o-conforme. Ilustrac?a?o dos blocos para colagem, seus dom??nios e o
mapeamento de colagem. Denotamos por X , E, R e I as operac?o?es de extrac?a?o de uma faceta,
elevac?a?o de grau, reparametrizac?a?o e identificac?a?o de coeficientes de Be?zier, respectivamente.



12.4. Colagem com imposic?a?o de suavidade 105

12.4 Colagem com imposic?a?o de suavidade

Na colagem de dois blocos, frequentemente e? necessa?rio impor restric?o?es de suavidade,

ale?m das restric?o?es de continuidade.

Por exemplo considere dois blocos hexae?dricos (dom??nio K1,1,1) colados por uma faceta

como na figura 12.8, com mapa de colagem ? trivial:

?(U) =

?

?

U00 ? 1 U01 + 1

U10 U11
U20 U21

?

? .

Para conseguir a simples continuidade, basta impor que o ponto A.F(U) = B.F(?(U))

para todo U da faceta K1,1,1|0,1 do dom??nio de A. A colagem tera? suavidade (parame?trica)

de primeira ordem se a derivada em qualquer direc?a?o ? ? V1,1,1 de A.F em qualquer ponto

U dessa faceta for igual a? derivada de B.F , na mesma direc?a?o ?, no ponto ?(U). Observe

que, para direc?o?es ? paralelas a? faceta comum, esta condic?a?o decorre automaticamente

da condic?a?o de continuidade. Observe tambe?m que o operador de derivada direcional de

primeira ordem D1? e? linear na direc?a?o ?. Portanto, se a continuidade ja? foi assegurada,

basta garantir esta condic?a?o para uma direc?a?o ? transversal a? faceta.



106 Cap??tulo 12. Restric?o?es entre blocos

A
(1,1,1)

?

A
B

(

0 1
0 1
0 1

)

(

0 1
0 1
1 0

)

(

1 0
0 1
0 1

)

(

0 1
1 0
1 0

)

(

2 ?1
0 1
0 1

)

(

2 ?1
1 0
0 1

)

(

2 ?1
1 0
1 0

)

(

1 0
1 0
1 0

)

U0

U1

U2

U

?

P

?

Figura 12.8: Colagem com suavidade. Na figura, o ponto P ? R3 e? A.F(U) = B.F(?(U)), e o
vetor ? ? R3 e? (D?A.F)(U) = (D?B.F)(?(U)).



Cap??tulo 13

A biblioteca bezEl

O co?digo da BezEl esta? dispon??vel para download no link https://bitbucket.org/lbfreitas/bezel

13.1 Estruturas de indexac?a?o

A biblioteca inclui classes destinadas a representar multi-,hiper-, e ultra-??ndices (vetores,

matrizes e tensores irregulares de inteiros).

13.1.1 Multi-??ndices

A representac?a?o de multi-??ndices consiste na classe MultiIndex, que possui apenas dois

atributos: sua dimensa?o dim e em um vetor elem de inteiros de tamanho dim+1. Por

exemplo, o multi-??ndice (2, 1, 3, 7) pode ser instanciado com os comandos

MultiIndex* m = new MultiIndex(3);

m-&gt;elem[0] = 2;

m-&gt;elem[1] = 1;

m-&gt;elem[2] = 3;

m-&gt;elem[3] = 7;

Apesar de uma multi-dimensa?o ou um multi-grau ser apenas um uso espec??fico de um

multi-??ndice, para maior clareza do co?digo, criamos as classes MultiDimension e MultiDegree,

derivadas da classe MultiIndex.

Ale?m das operac?o?es ba?sicas descritas na sec?a?o 4.1, esta classe implementa uma se?rie de

me?todos para enumerar multi-??ndices sujeitos a va?rios tipos de restric?o?es. Estes me?todos

devolvem um vetor de multi-??ndices (classe std::vector&lt;MultiIndex*&gt;) contendo os

multi-??ndices desejados. A tabela 13.1 relaciona alguns dos me?todos de enumerac?a?o da

classe MultiIndex. Nesta tabela, lambda e mu representam os multi-??ndices ? e µ respec-

tivamente, e enum e enumAux sa?o os vetores de multi-??ndices resultantes.

107



108 Cap??tulo 13. A biblioteca bezEl

Tabela 13.1: Enumerac?a?o de multi-??ndices

Conjunto de multi-??ndices Implementac?a?o

{? ? Id : ? &amp;lt;?} enum = lambda-&gt;getLessThan()

{? ? Id : µ &amp;lt;? &amp;lt;?} enumAux = lambda-&gt;getLessThan();
enum = mu-&gt;selectGreaterFrom(enumAux);

{? ? I
g
d
} enum = MultiIndex::getMultiIdxSet(g,d)

{? ? Id : |?| ? g} enum = MultiIndex::getMultiIdxSetLessEq(g,d)

A ordem dos multi-??ndices definida por estes me?todos e? utilizada em todos os contextos

em que e? necessa?rio para converter um multi-??ndice em um ??ndice inteiro, por exemplo

para armazenar os coeficientes de Be?zier de um polino?mio simplicial.

13.1.2 Hiper-??ndices

A classe HiperIndex representa os hiper-??ndices. Sua implementac?a?o consiste basica-

mente em um vetor line de multi-??ndices, um para cada linha do hiper-??ndice, e em

um multi-??ndice dim que define o tamanho de cada linha. Por exemplo, o hiper-??ndice

((1, 0), (2, 5, 3)) pode ser representado por uma insta?ncia Lambda desta classe, com

Lambda.dim = (1, 2). Esta insta?ncia pode ser criada pelos comandos

MultiIndex* delta = new MultiIndex(1);

delta -&gt;elem[0] = 1;

delta -&gt;elem[1] = 2;

HyperIndex* Lambda = new HyperIndex(delta);

Lambda -&gt;allocate ();

Lambda -&gt;line[0]-&gt;elem[0] = 1;

Lambda -&gt;line[0]-&gt;elem[1] = 0;

Lambda -&gt;line[1]-&gt;elem[0] = 2;

Lambda -&gt;line[1]-&gt;elem[1] = 5;

Lambda -&gt;line[1]-&gt;elem[2] = 3;

Ale?m das operac?o?es ba?sicas descritas na sec?a?o 4.2, esta classe tambe?m implementa

me?todos para a enumerac?a?o de um conjunto de hiper-??ndices. Mais especificamente, dados

dois multi-??ndices ? e ?, representados por alpha e delta, o conjunto dos hiper-??ndices

? ? H?? pode ser obtido utilizando o me?todo esta?tico



13.2. Espac?os multi-afins 109

std::vector&lt;HyperIndex*&gt; getAllIndexes(MultiIndex* alpha,MultiIndex* delta);

O ordem definida por este me?todo e? a utilizada em todos os contextos em que e? necessa?rio

linearizar um conjunto de hiper-??ndices, por exemplo para armazenar os coeficientes de

Be?zier de um polino?mio simploidal.

13.1.3 Ultra-??ndices

Os ultra-??ndices sa?o implementados por insta?ncias da classe UltraIndex. Na biblioteca

BezEl, esta classe esta? restrita a ultra-??ndices em que todos os planos tem o mesmo

formato, isto e?, a elementos de Up,?, para algum p ? N e algum ? ? I. Os atributos desta

classe sa?o: o nu?mero de planos nPlanes, a multi-dimensa?o (compartilhada) dim dos seus

planos; e um vetor plane de hiper-??ndices, de tamanho nPlanes.

As operac?o?es de soma de planos e fatorial sa?o implementadas pelos me?todos sum e

factorial, respectivamente. Outro me?todo importante e?

vector&lt;UltraIndex*&gt; getAllIndexes(int p, MultiIndex* d, HyperIndex* s);

que enumera todos os ultra-??ndices de p+1 planos, cada um de dimensa?o d e cuja soma

dos planos e? o hiper-??ndice s.

13.2 Espac?os multi-afins

Outro conjunto de classes e? usado para representar pontos e vetores de espac?os multi-afins

(A? e V?), que sa?o matrizes irregulares de nu?meros reais. Pontos e vetores de espac?os afins

sa?o tratados como casos particulares.

Na biblioteca BezEl, todas as coordenadas sa?o insta?ncias de uma classe Number, que

pode ser concretizada pelo tipo double ou por outros tipos (como racionais exatos).

13.2.1 Matrizes irregulares

Uma matriz irregular e? implementada por uma insta?ncia da classe IrregularMatrix.

Seus atributos sa?o a multi-dimensa?o mD da matriz e uma matriz bidimensional irregular

data de ponteiros para os elementos da matriz, da classe Number. Mais especificamente,

cada posic?a?o data[i] aponta para um vetor de refere?ncias de nu?meros reais de tamanho

mD.elem[i]. Por exemplo, a matriz irregular M = ((1.3, 0.7), (2.1, 5.7, 3.0)) pode ser criada

pelos comandos

MultiDimension* delta = new MultiDimension(1);

delta -&gt;elem[0] = 1; delta -&gt;elem[1] = 2;

IrregularMatrix* M = new IrregularMatrix(delta);



110 Cap??tulo 13. A biblioteca bezEl

M-&gt;allocate ();

M-&gt;data[0][0] = new Number (1.3);

M-&gt;data[0][1] = new Number (0.7);

M-&gt;data[1][0] = new Number (2.1);

M-&gt;data[1][1] = new Number (5.7);

M-&gt;data[1][2] = new Number (3.0);

13.2.2 Matrizes regulares

Matrizes regulares bidimensionais sa?o representadas por insta?ncias da classe Matrix, de-

rivada da classe IrregularMatrix. Ale?m dos atributos herdados, a classe Matrix possui

os atributos n rows e n cols que indicam o nu?mero de linhas e colunas da matriz. Esta

classe dispo?e de me?todos para realizar algumas operac?o?es da a?lgebra matricial como o

produto a? esquerda (leftMultiply), produto a? direita (rightMultiply), tranposic?a?o

(transpose), etc.

13.2.3 Pontos e vetores de espac?os multi-afins

Um ponto de um espac?o multi-afim A? e? implementado por uma insta?ncia da classe

DomainPoint. Esta classe, derivada da classe IrregularMatrix, tem apenas os atributos

herdados desta u?ltima. O mesmo vale para vetores de um espac?o tangente multi-afim V?,

representados por insta?ncias da classe DomainVector.

13.2.4 Mapeamento afim

A classe DomainMapping implementa mapeamentos afins entre espac?os multi-afins, des-

critos no cap??tulo 9. O dom??nio e o contra-dom??nio sa?o espac?os multi-afins determinados

por suas multi-dimenso?es, armazenadas nos atributos dD and rD, respectivamente. Os

coeficientes do mapeamento, descritos na equac?a?o (9.1), sa?o armazenados na forma de

uma matriz bidimensional irregular coef de insta?ncias da classe IrregularMatrix. Mais

especificamente, coef[r][s] e? a matriz irregular de multi-dimensa?o dD que conte?m os co-

eficientes Mrsij para todo i = 0, · · · ,dD.dim e todo j = 0, · · · ,dD.elem[i]. Uma insta?ncia

M desta classe tem um me?todo M-&gt;map(DomainPoint* U) que retorna a imagem do ponto

U pelo mapeamento M.



13.3. Polino?mios Simploidais 111

13.3 Polino?mios Simploidais

A classe BezierSimploidPoly implementa um polino?mio simploidal na representac?a?o de

Be?zier. Seus atributos sa?o a multi-dimensa?o dD do seu dom??nio (uma insta?ncia da classe

MultiDimension), seu multi-grau deg (uma insta?ncia da classe MultiDegree), um vetor

coef contendo seus coeficientes de Be?zier (ponteiros para a classe Number e o tamanho

n coef deste vetor. A ordem dos coeficientes neste vetor e? definida pelo me?todo esta?tico

getAllIndexes da classe HyperIndex (sec?a?o 13.1.2). Observe que estes coeficientes na?o

sa?o armazenados no reposito?rio de para?metros (descrito no cap??tulo 11). Uma insta?ncia

p desta classe tem os seguintes me?todos principais

• p-&gt;evaluate(DomainPoint* U)

Este me?todo retorna o valor do polino?mio p calculado no ponto U, que deve ser um

ponto do espac?o-multi-afim de multi-dimensa?o dD. O resultado e? do tipo Number*.

• p-&gt;get Poly of Facet(int k, int i)

Este me?todo retorna um novo polino?mio q que corresponde a? restric?a?o do polino?mio

p a? faceta de ??ndices k,i do simplo?ide que e? seu dom??nio.

• p-&gt;get Matrix of Facet(int k, int i)

Este me?todo retorna uma matriz K que relaciona os coeficientes de Be?zier do po-

lino?mio p com os do polino?mio q que corresponde a? restric?a?o do polino?mio p a? faceta

de ??ndices k,i do simplo?ide que e? seu dom??nio.

• p-&gt;get Matrix of RaisedDegree(MultiDegree* new deg)

Este me?todo retorna uma matriz K que relaciona os coeficientes de Be?zier do po-

lino?mio p com os do polino?mio q, ide?ntico a p, pore?m representado como um po-

lino?mio de grau new deg, que deve ser maior ou igual a p-&gt;deg.

• p-&gt;get Matrix of DirectionalDerivative(int r, DomainVector* Xi)

Este me?todo retorna uma matriz K que relaciona os coeficientes de Be?zier do po-

lino?mio p com os do polino?mio q, que corresponde a? r-e?sima derivada direcional do

polino?mio p na direc?a?o Xi, que deve ser um vetor tangente ao espac?o multi-afim de

dimensa?o dD.

• p-&gt;get Matrix of Composition w AffineMap(DomainMapping* dm)

Este me?todo retorna uma matriz K que relaciona os coeficientes de Be?zier do po-

lino?mio p com os do polino?mio q que corresponde a? composic?a?o do polino?mio p com o

mapeamento afim dm; ou seja q-&gt;evaluate(U) e? equivalente a p-&gt;evaluate(dm-&gt;map(U)).



112 Cap??tulo 13. A biblioteca bezEl

A matrix K, retornada nos quatro me?todos acima e? representada por uma insta?ncia

da classe Matrix. O coeficiente q-&gt;coef[i] pode ser enta?o calculado acumulando

o produto p-&gt;coef[j] * K-&gt;data[j][i] para todo j = 0, · · · ,n coef.

13.4 Elementos de Be?zier simploidais

Lembramos que um bloco de Be?zier simploidal (definido no cap??tulo 11) representa uma

func?a?o de um simplo?ide K? para um espac?o cartesiano Rm, onde cada uma das compo-

nentes da imagem e? um polino?mio simploidal possivelmente de grau distinto.

13.4.1 Tipos de bloco

Como discutido no cap??tulo 11, a classe BlockKind, descreve as caracter??sticas de um

conjunto de blocos com um mesmo dom??nio e contra-dom??nio, mesmo grau e mesma

relac?a?o entre para?metros internos e externos. Os atributos da classe BlockKind sa?o a

multi-dimensa?o dD = ? do dom??nio, a dimensa?o rD = m do contra-dom??nio , os multi-

graus deg de cada componente, o nu?mero de para?metros internos n int e externos n ext,

e a matriz M que converte para?metros externos em internos. A dimensa?o do dom??nio dD e?

uma insta?ncia de MultiDimension enquanto que a dimensa?o do contra-dom??nio rD e? um

inteiro. Os multi-graus deg sa?o representados por um vetor de tamanho rD de insta?ncias

da classe MultiDegree. A matriz M e? uma insta?ncia da classe Matrix.

Por exemplo, um tipo de bloco brickKind que descreve blocos do que compo?em a

malha da figura 11.1 pode ser criado pelos comandos

MultiDimension* mD = new MultiDimension(2);

mD-&gt;elem[0] = 1; mD-&gt;elem[1] = 1; mD-&gt;elem[2] = 1;

MultiDegree* deg[3];

deg[0] = new MultiDegree(2);

deg[0]-&gt;elem[0] = 1;

deg[0]-&gt;elem[1] = 0;

deg[0]-&gt;elem[2] = 0;

deg[1] = new MultiDegree(2);

deg[1]-&gt;elem[0] = 0;

deg[1]-&gt;elem[1] = 1;

deg[1]-&gt;elem[2] = 0;

deg[2] = new MultiDegree(2);

deg[2]-&gt;elem[0] = 3;

deg[2]-&gt;elem[1] = 3;

deg[2]-&gt;elem[2] = 1;



13.4. Elementos de Be?zier simploidais 113

BlockKind* brickKind = new BlockKind(mD,3,deg);

// by default: brickKind -&gt;M = NULL

Os principais me?todos de uma insta?ncia bK sa?o

• bK-&gt;getInternalVars(int *varId)

Este me?todo aplica a matriz bK-&gt;M de conversa?o de para?metros externos para in-

ternos. O resultado e? um vetor de coeficientes (de tipo Number*) representados por

uma insta?ncia da classe Matrix com uma u?nica coluna.

• bK-&gt;get Kind of RaisedDegree(MultiDegree** new deg)

Este me?todo cria um novo tipo de bloco bK raised para descrever blocos com

mesmo dom??nio e contra-dom??nio do tipo bK pore?m com graus descritos pelo vetor

new deg com bK-&gt;rD insta?ncias da classe MultiDegree. Cada bloco deste tipo tera?

o mesmo nu?mero de para?metros externos (bK-&gt;n ext) mas um nu?mero diferente de

para?metros internos. A matriz bK raised-&gt;M e? calculada de modo que os mesmos

para?metros externos produzira?o polino?mios ide?nticos, apesar de formalmente de

graus distintos.

• bK-&gt;get Kind of DirectionalDerivative(int r, DomainVector* Xi)

Este me?todo cria um novo tipo de bloco bK deriv para descrever blocos com mesmo

dom??nio e contra-dom??nio do tipo bK. Os graus do tipo bK deriv, entretanto, de-

pendem a ordem r da derivada e de sua direc?a?o Xi. Cada bloco deste tipo tera?

o mesmo nu?mero de para?metros externos (bK-&gt;n ext) mas um nu?mero diferente

de para?metros internos. A matriz bK deriv-&gt;M e? calculada de modo que os mes-

mos para?metros externos produzira? os coeficientes de Be?zier da r-e?sima derivada

direcional do bloco do tipo bK.

• bK-&gt;get Kind of Composition w DM(DomainMapping* dm)

Este me?todo cria um novo tipo de bloco bK dm para descrever blocos oriundos da

composic?a?o de blocos do tipo bK com o mapeamento afim dm. Este novo tipo bK dm

tem o mesmo dom??nio do mapeamento afim dm-&gt;dD e mesmo contra-dom??nio do tipo

bK-&gt;rD. Cada bloco do tipo bK dm tera? o mesmo nu?mero de para?metros externos

(bK-&gt;n ext) mas um nu?mero diferente de para?metros internos. A matriz bK dm-&gt;M

e? calculada de modo que os mesmos para?metros externos produzira? os coeficientes

de Be?zier da composic?a?o.

• bK-&gt;get Kind of Facet(int k, int i)



114 Cap??tulo 13. A biblioteca bezEl

• bK-&gt;get IndexMap of Facet(int k, int i)

O primeiro me?todo, bK-&gt;get Kind of Facet(int k, int i), cria um novo tipo de

bloco bK facet para descrever blocos que sa?o facetas de blocos do tipo bK. Este novo

tipo bK facet tem mesmo contra-dom??nio de bK. Entretanto, seu dom??nio e graus

dependem na?o apenas do dom??nio de bK mas tambe?m da faceta escolhida. Cada

bloco deste novo tipo tera? um nu?mero menor de para?metros externos. A matriz

bK facet-&gt;M e? calculada de modo que um subconjunto dos para?metros externos de

um bloco do tipo bK produzira? os coeficientes de Be?zier sua faceta. Este subcon-

junto e? calculado pelo segundo me?todo, bK-&gt;get IndexMap of Facet(int k, int

i). Este me?todo retorna um vetor com os bK facet-&gt;n ext ??ndices dos para?metros

externos que pertencera?o a? faceta.

13.4.2 Blocos de Be?zier

Como descrito no cap??tulo 11, cada elemento de Be?zier e? implementado por uma insta?ncia

da classe Block. Seus atributos sa?o um ponteiro model para o modelo ao qual pertence

(vide sec?a?o 13.5), o ??ndice bId do bloco na lista de blocos do modelo (sec?a?o 13.5.1), um ve-

tor varId contendo os ??ndices de seus para?metros externos no reposito?rio (sec?a?o 13.5.2),

e uma refere?ncia kind para o tipo do bloco (insta?ncia de BlockKind). Cada insta?ncia

possui tambe?m um atributo mark, utilizado temporariamente por algoritmos de percur-

sos e visualizac?a?o. Observe que os para?metros internos do bloco na?o sa?o armazenados

permanentemente.

Os me?todos mais importantes de uma insta?ncia b desta classe sa?o

• b-&gt;explicit()

Este me?todo converte o bloco em uma lista de polino?mios simploidais expl??citos,

um para cada componente, na forma de um vetor de b-&gt;rD insta?ncias da classe

BezierSimploidPoly. Os coeficientes de Be?zier dos polino?mios sa?o calculados

usando a matriz b-&gt;kind-&gt;M.

• b-&gt;getSubBlock using Imap(BlockKind* bK, int *idx map)

Este me?todo cria um novo bloco c do tipo bK cujos para?metros externos sa?o um

subconjunto dos para?metros externos do bloco b. O subconjunto (e sua ordem) e?

especificado pelo vetor de inteiros idx map, de tamanho b-&gt;kind-&gt;n ext, tal que se

idx map[j] = k, enta?o c-&gt;varId[j] = b-&gt;varId[k].

• b-&gt;getSubBlock(BlockKind* newbK)

Este me?todo e? um caso particular do me?todo b-&gt;getSubBlock using Imap(BlockKind*

bK, int *idx map), quando o vetor idx map e? a identidade; ou seja, todos os



13.5. Modelos 115

para?metros externos do bloco b sa?o tambe?m para?metros externos do bloco c =

b-&gt;getSubBlock(newbK).

13.5 Modelos

Um modelo geolo?gico e? representado por um objeto da classe Model que possui quatro

atributos: uma colec?a?o de blocos de Be?zier blks, um reposito?rio pDep com os para?metros

externos desses blocos, um reposito?rio eqDep de equac?o?es entre esses para?metros, e uma

estrutura topolo?gica topo que especifica as relac?o?es de adjace?ncia entre blocos.

13.5.1 Colec?a?o de blocos

A colec?a?o blks e? uma insta?ncia da classe std::vector cujos elementos sa?o insta?ncias da

classe Block. O ??ndice de cada bloco b neste vetor e? seu atributo b-&gt;bId.

13.5.2 Reposito?rio de para?metros externos

O reposito?rio de para?metros externos (veja cap??tulo 11) e? implementado por uma insta?ncia

pDep da classe ParamDepot. O nu?mero de para?metros do modelo e? armazenado no atributo

inteiro pDep.nP, e os valores correntes destes para?metros (insta?ncias da classe Number)

sa?o armazenados em um vetor pDep.data nas posic?o?es [0, ... ,pDep.nP-1]. Novos

para?metros sa?o acrescentados ao modelo pelo me?todo reserveNewVars(int qty), que

estende o vetor pDep.data se necessa?rio e retorna um vetor de qty inteiros, os ??ndices dos

para?metros reservados. Os para?metros externos de um bloco b sa?o pDep.data[b.varId[k]],

para k variando de 0 a b.kind.n ext-1. A atribuic?a?o e leitura dos valores de para?metros

armazenados em um reposito?rio pDep sa?o implementado pelos me?todos

pDep-&gt;setVar(int varId, Number* value);

pDep-&gt;getVar(int varId);

13.5.3 Equac?o?es entre varia?veis

As restric?o?es entre blocos (cap??tulo 12) sa?o implementadas pela classe Equation. Cada

insta?ncia desta implementa uma restric?a?o linear entre um ou mais para?metros externos

do modelo, armazenados no reposito?rio pDep. Uma insta?ncia e desta classe possui um

atributo inteiro size que e? o nu?mero de para?metros envolvidos na equac?a?o; um vetor

varId, de tamanho size, contendo os ??ndices desses para?metros no reposito?rio; e um vetor

coefs, tambe?m de tamanho size, que armazena os coeficientes de cada para?metro na



116 Cap??tulo 13. A biblioteca bezEl

equac?a?o. O termo independente e? representado pelo atributo independent. Os me?todos

e-&gt;add(Equation* op);

e-&gt;sub(Equation* op);

e-&gt;mul(Number* s);

e-&gt;div(Number* s);

realizam as operac?o?es de soma e subtrac?a?o da equac?a?o op, e multiplicac?a?o e divisa?o pelo

escalar s e retornam uma nova equac?a?o. Ha? tambe?m um me?todo e-&gt;collapse(), que

cria um anova equac?a?o eliminando os termos cujo coeficiente e? nulo.

13.5.4 Reposito?rios de equac?o?es

A classe EquationDepot implementa um reposito?rio de equac?o?es. Seus atributos sa?o:

o nu?mero nE de equac?o?es e um vetor eqs de tamanho nE contendo apontadores para

insta?ncias da classe Equation. Equac?o?es podem ser adicionadas a um reposito?rio eDep

uma-a-uma, utilizando o me?todo eDep-&gt;addRestriction ou em grupos, utilizando o

me?todo eDep-&gt;addRestrictionSet.

13.5.5 Estrutura topolo?gica

A topologia de um modelo mod e? representada por uma insta?ncia mod-&gt;topo da classe

AdjacencyList, que implementa listas de adjace?ncias. Ale?m de um ponteiro para o

modelo ao qual pertence, esta classe conte?m um u?nico atributo, o vetor topo-&gt;list

(uma insta?ncia de std::vector) tal que mod.topo.list[i] sa?o as adjace?ncias do bloco

bi = mod.blks[i]. Esta informac?a?o e? implementada por outros bi.nfacets vetores

de triplas do tipo AdjLstElem, uma para cada faceta do dom??nio de bi. O me?todo

mod-&gt;topo-&gt;getAdjBlocks(i,k,l) retorna o vetor de triplas de adjace?ncias do bloco

bi pela sua (k, l)-faceta. Cada tripla tbklm = mod-&gt;topo-&gt;getAdjBlocks(i,k,l)[m]

descreve o m-e?simo vizinho do bloco bi adjacente a? faceta (k, l). O ??ndice tiklm.adjId

armazena a posic?a?o do bloco vizinho em mod.blks. O atributo tiklm.adjFacet armazena

os ??ndices da faceta de mod.blks[tiklm.adjId] atrave?s da qual se verifica a adjace?ncia;

e o mapeamento afim timlm.dm relaciona o dom??nio desta faceta com o dom??nio da faceta

correspondente do bloco bi. (Lembre que a biblioteca BezEl supo?e que esse mapeamento

afim e? constante.)



13.6. Classes adicionais 117

13.6 Classes adicionais

13.6.1 Visualizac?a?o

A visualizac?a?o dos blocos de Be?zier representados pela bezEl e? realizada com o aux??lio do

trac?ador de raios POVRay. A classe Model vis e? a mais importante nesta tarefa. Uma

insta?ncia vis desta classe representa facetas de blocos por malhas de tria?ngulos planos

com transpare?ncia, arestas (e grade de controle) por sequ?e?ncias de cilindros e pontos de

controle de Be?zier por esferas. O atributo vis-&gt;model e? um ponteiro para o modelo a ser

visualizado. Outros atributos sa?o o vetor de strings vis-&gt;color e o vetor de nu?meros reais

vis-&gt;transmit, ambos de tamanho vis-&gt;nPigments. Mais especificamente, se b e? um

bloco pertencente ao modelo vis-&gt;model, b sera? pintado com cor vis-&gt;color[b-&gt;mark]

e transpare?ncia vis-&gt;transmit[b-&gt;mark]. Note que a string de cor deve ter o formato

do POVRay, por exemplo rgb&lt;0.4,0.1,0.0&gt;.

Os me?todos de uma insta?ncia vis mais importantes sa?o

• vis-&gt;initDomain(int nk11, int nk2)

Este me?todo estabelece a resoluc?a?o da representac?a?o das facetas. As facetas de

dom??nio K(1,1) sa?o divididas em nk11 * nK11 reta?ngulos, e cada reta?ngulo e? dividido

em dois tria?ngulos planos. As facetas de dom??nio K(2), por outro lado, sa?o divididas

em 4nK2 tria?ngulos.

• vis-&gt;plotPOV(FILE* fp)

Este me?todo gera a representac?a?o POVRay do modelo vis-&gt;mod e escreve no ar-

quivo apontado por fp. Observe que os blocos deste modelo marcados com valores

negativos ou maiores ou iguais a vis-&gt;nPigments na?o sa?o exportados para esta

representac?a?o.

13.6.2 Coletor de lixo

A classe SmartPointer implementa um coletor de lixo simples para algumas classes da

BezEl como Number, MultiIndex, HyperIndex, etc. A inicializac?a?o do coletor e? realizada

atrave?s do me?todo initSmartPointers(). O coletor armazena internamente uma pilha

de ponteiros SmartPointer.pointers de objetos de tipos arbitra?rios. Apo?s inicializado,

cada criac?a?o de uma nova insta?ncia de uma das classes acima armazena um ponteiro nesta

pilha. Os me?todos mais importantes sa?o

• SmartPointer.get next()

Este me?todo retorna o tamanho atual da pilha.



118 Cap??tulo 13. A biblioteca bezEl

• SmartPointer.delete from(int p)

Este me?todo remove e destro?i todos os objetos da pilha depois da posic?a?o from.

Estes me?todos sa?o usados quando um procedimento cria um nu?mero grande de ob-

jetos tempora?rios que sera?o destru??dos ao final do procedimento. Neste caso, o proce-

dimento comec?a executando int p = SmartPointer.get next(), e antes de retornar

executa SmartPointer.delete from(p).



Cap??tulo 14

Editor de modelos 2D

Para demonstrar a capacidade da biblioteca, implementamos um editor de modelos geof??si-

cos bidimensionais. Este editor consiste em dois programas: (a) o editor de topologia e

propriedades f??sicas e (b) o editor de geometria.

O editor de topologia e propriedades f??sicas, implementado como um Java applet,

utiliza estruturas pro?prias e grava a descric?a?o do modelo em um arquivo texto. O editor

de geometria, implementado em Qt/C++, le? um arquivo texto e reconstro?i o modelo

utilizando as func?o?es e estruturas de dados da biblioteca BezEl. Este editor permite

ajustar as coordenadas verticais de certos pontos de controle de Be?zier, preservando as

restric?o?es de suavidade de interfaces.

14.1 Editor de topologia e propriedades f??sicas

O editor de topologia (TopEdit) e? usado para definir o nu?mero de fa?cies e interfaces, suas

relac?o?es de adjace?ncias e uma geometria inicial. A regia?o de interesse e? um reta?ngulo

com o eixo X representando a posic?a?o horizontal e o eixo Z a profundidade. O eixo Y e?

impl??cito; supo?e-se que todas as propriedades sa?o constantes nesta direc?a?o.

Uma sec?a?o de edic?a?o consiste de cinco etapas.

Na primeira etapa, a regia?o de interesse e? dividida por uma colec?a?o de linhas nodais

verticais, igualmente espac?adas. Veja a figura 14.1. O nu?mero de linhas e? escolhido pelo

usua?rio, e deve ser tanto maior quanto maior for a complexidade topolo?gica do modelo.

Na segunda etapa, o usua?rio especifica uma se?rie de interfaces geolo?gicas. Cada inter-

face e? uma curva em que a profundidade Z e? uma func?a?o da coordenada X. A curva pode

comec?ar ou terminar num dos lados verticais do modelo, ou na intersec?a?o de uma interface

anterior com uma linha nodal. O editor exige que cada interface cruze pelo menos duas

regio?es entre linhas nodais. Veja a figura 14.2.

As linhas nodais dividem cada interface em arcos de Be?zier de grau 3, conectados com

119



120 Cap??tulo 14. Editor de modelos 2D

Figura 14.1: Primeira etapa: definic?a?o das linhas nodais sobre a regia?o de interesse.

primeira derivada cont??nua. O usua?rio pode alterar a coordenada vertical dos pontos de

controle de cada arco, e o editor modifica os pontos de controle dos arcos vizinhos de

modo a manter a suavidade da interface.

Na terceira etapa, o editor identifica as fa?cies do modelo. Cada fa?cie e? uma regia?o

conexa maximal delimitada superiormente e inferiormente por duas interfaces. Portanto,

cada fa?cie pode ser delimitada a? esquerda e a? direita por um trecho de linha nodal (in-

cluindo os lados verticais da regia?o) ou pelo ponto de encontro de duas interfaces. Veja a

figura 14.3.

Na quarta etapa, o editor particiona automaticamente cada fa?cie em um conjunto de

blocos triangulares de Be?zier de grau 3. Os tre?s ve?rtices de cada bloco sa?o intersecc?o?es de

linhas nodais com interfaces. Uma das arestas e? vertical (parte de uma linha nodal) e o

ve?rtice oposto a ela esta? sobre uma das linhas nodais vizinhas. As outras arestas podem

ser arcos de interface ou arestas “diagonais” escolhidas automaticamente pelo editor. Veja

a figura 14.4.

Na u?ltima etapa, o usua?rio especifica a velocidade de propagac?a?o da onda em cada

fa?cie. O usua?rio pode definir separadamente a velocidade de propagac?a?o ao longo das

interfaces superior e inferior de cada fa?cie. Se os dois valores forem diferentes, entende-se

que ha? uma variac?a?o suave de velocidade com a profundidade. Veja a figura 14.5.



14.1. Editor de topologia e propriedades f??sicas 121

Figura 14.2: Segunda etapa: definic?a?o das interfaces (incluindo os limites superior e inferior do
modelo)

O editor salva estas informac?o?es em um arquivo texto, que especifica o nu?mero de

blocos, suas relac?o?es de adjace?ncia e a corresponde?ncia entre as coordenadas locais de

blocos adjacentes. Ale?m disso, o arquivo especifica os blocos e as respectivas facetas que

compo?em cada interface.



122 Cap??tulo 14. Editor de modelos 2D

Figura 14.3: Terceira etapa: identificac?a?o das fa?cies (indicadas por cores arbitra?rias).

Figura 14.4: Quarta etapa: decomposic?a?o das fa?cies em blocos triangulares.



14.1. Editor de topologia e propriedades f??sicas 123

Figura 14.5: Quinta etapa: especificac?a?o das velocidades em cada fa?cie.



124 Cap??tulo 14. Editor de modelos 2D

14.2 Editor de geometria

O editor de geometria (GeoEdit) le? o arquivo texto gerado pelo editor de topologia e

reconstro?i o modelo, agora utilizando as estruturas e func?o?es da biblioteca BezEl. A

reconstruc?a?o do modelo consiste de tre?s etapas.

Na primeira etapa, o editor cria o modelo (classe Model) e os blocos da malha. Cada

bloco e? uma insta?ncia da classe Block (cap??tulo 11) que pode ter dois tipos poss??veis,

lvKind e rvKind, dependendo da posic?a?o da aresta vertical — no lado esquerdo ou direito

do bloco, respectivamente. Os dois tipos te?m dom??nio K2 e tre?s componentes X, Z, e

V , de grau (3), (3) e (1) respectivamente. Cada bloco tem 14 para?metros externos, que

sa?o o ??ndice lN da linha nodal que conte?m sua aresta, os 10 coeficientes de Be?zier da

componente Z, e os tre?s coeficientes de Be?zier da componente V (que sa?o as velocidades

nos ve?rtices do bloco). Cada bloco tem 23 para?metros internos: 10 coeficientes de Be?zier

para cada componente X e Z, e tre?s para a componente V . As matrizes de conversa?o

tem a forma
?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

D10×1 010×10 010×3 A10×1

010×1 I10×10 010×3 010×1

03×1 03×10 I3×3 03×1

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

As submatrizes A e D sa?o

A =

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

0

0

0

0

±d/3

±d/3

±d/3

±2d/3

±2d/3

±d

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

. D =

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

d

d

...

d

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

.

onde d e? a dista?ncia entre as linhas nodais, e o sinal ± e? escolhido de acordo com o tipo

(positivo para lvKind.M e negativo para rvKind.M).



14.2. Editor de geometria 125

Na segunda etapa, para cada par de blocos adjacentes, o editor acrescenta ao mo-

delo um conjunto restric?o?es que descrevem as adjace?ncias entre os blocos, garantindo

a ause?ncia de frestas e superposic?o?es. (Estas restric?o?es poderiam ter sido implementa-

das pelo compartilhamento de para?metros externos, como descrito na sec?a?o 11.3; pore?m

quando o editor foi escrito, esta funcionalidade na?o havia sido implementada.) Ainda

nesta etapa, o editor tambe?m acrescenta ao modelo uma se?rie de restric?o?es que garantem

a suavidade de cada interface. Estas restric?o?es na?o sa?o atualmente utilizadas pelo editor,

mas poderiam ser utilizadas por outros programas, por exemplo em um algoritmo geral

para a determinac?a?o automa?tica de elementos finitos [19].

Na terceira etapa, o editor escolhe um subconjunto dos coeficientes de Be?zier — os co-

eficientes do modelo — que podem ter sua componente vertical alterada arbitrariamente

pelo usua?rio. Para cada um destes coeficientes, o editor determina tambe?m as alterac?o?es

que devem ser feitas nos para?metros externos dos blocos de modo a preservar as res-

tric?o?es de continuidade e suavidade. A modificac?a?o do coeficiente pelo usua?rio acarreta

a modificac?a?o automa?tica dos para?metros externos de um ou mais blocos conforme estas

informac?o?es. Veja a figura 14.6.

Observe que a alterac?a?o de um ponto de controle no interior de uma fa?cie na?o altera a

forma da mesma, mas sim a corresponde?ncia entre as coordenadas locais U e a coordenada

Z. Embora a velocidade V seja sempre a mesma func?a?o afim das coordenadas locais U,

essa alterac?a?o vai modificar a relac?a?o entre V e a coordenada Z no interior da fa?cie.



126 Cap??tulo 14. Editor de modelos 2D

Figura 14.6: Interface do editor de geometria. As coordenadas Z dos pontos vermelhos sa?o os
coeficientes do modelo.



Cap??tulo 15

Simulac?a?o s??smica

Uma das ferramentas principais para determinar a estrutura geolo?gica de uma regia?o

extensa e? a s??smica de reflexa?o, que consiste em aplicar um forte sinal meca?nico em um

ponto da regia?o de interesse e registrar seus ecos em um conjunto de receptores (geofones

em terra ou hidrofones no mar) distribu??dos na regia?o de aquisic?a?o, por exemplo na

superf??cie terrestre, abaixo da superf??cie ou no fundo do mar, no interior de poc?os, etc.

Embora o objetivo final seja inverter os dados s??smicos assim obtidos para se conhe-

cer a geologia da sub-superf??cie, ha? interesse tambe?m no problema direto, a simulac?a?o

s??smica, onde o modelo geof??sico e? fornecido a priori e a aquisic?a?o de dados s??smicos e?

obtida computacionalmente, resultando em dados s??smicos simulados, conhecidos como

sismogramas sinte?ticos.

A simulac?a?o s??smica e? uma ferramenta poderosa para modelagem, explorac?a?o, geren-

ciamento e monitoramento de reservato?rios. Ela ajuda a validar modelos geolo?gicos e

interpretar dados s??smicos reais, por exemplo possibilitando a identificac?a?o e posiciona-

mento de interfaces e a determinac?a?o de propriedades f??sicas das fa?cies principais [2].

A simulac?a?o s??smica pode ser feita por va?rias te?cnicas incluindo soluc?a?o da equac?a?o

da onda sobre uma grade regular [27], aproximac?o?es baseadas na teoria de raios [25] e

de frentes de onda [26]. Dentre estas te?cnicas de simulac?a?o, o trac?amento de raios se

destaca por sua versatilidade e eficie?ncia computacional, sendo especialmente apropriado

para modelos baseados em interfaces ou em malhas tridimensionais.

15.1 Trac?ado de raios

O trac?ado de raios se aplica tipicamente a? situac?o?es onde a excitac?a?o s??smica e? impulsiva

— uma fonte pontual (explosa?o ou tiro de canha?o de ar), localizada em um ponto da

regia?o e limitada a um intervalo de tempo muito curto.

127



128 Cap??tulo 15. Simulac?a?o s??smica

15.1.1 Ondas s??smicas

Verifica-se que, em cada instante seguinte ao impulso, a deformac?a?o ela?stica na rocha

consiste de uma colec?a?o de ondas s??smicas. Cada onda pode ser modelada por uma

superf??cie, a frente da onda, que se desloca de maneira cont??nua atrave?s de uma fa?cie.

Neste trabalho, por simplicidade, nos restringiremos ao trac?ado de raios em meios

isotro?picos, nos quais a velocidade de propagac?a?o da frente de onda depende unicamente

de sua posic?a?o, e na?o da direc?a?o de propagac?a?o. Nestes meios, dois tipos de onda se

propagam de forma independente e com velocidades diferentes. A onda compressional ou

onda P, mais ra?pida, desloca as part??culas da rocha na direc?a?o da sua propagac?a?o. A

onda cisalhante ou onda S, mais lenta, desloca as part??culas na direc?a?o perpendicular a?

sua propagac?a?o.

15.1.2 Equac?o?es do raio

Nesse contexto, um raio e? a trajeto?ria de um ponto da frente de onda que se desloca sempre

na direc?a?o perpendicular a? ela. Esta trajeto?ria pode ser modelada por uma func?a?o R dos

reais, R, para o R3, tal que R(t) sa?o as coordenadas do ponto t segundos depois do impulso

inicial. Veja a figura 15.1.

Dentro de uma camada, onde as propriedades f??sicas da rocha variam suavemente, um

raio R satisfaz as equac?o?es

R?(t) = v(R(t))2p(t)

p?(t) =
1

v(R(t))
(~?v)(R(t)). (15.1)

Nestas equac?o?es, p e? uma func?a?o auxiliar de R para R3, e R? e p? denotam as derivadas de

R e de p em relac?a?o ao tempo.

A func?a?o dada v associa a cada ponto da regia?o de interesse o mo?dulo da velocidade

de propagac?a?o da onda simulada (P ou S) naquele ponto. O valor de p(t), chamado de

vagarosidade, e? um vetor perpendicular a? frente de onda no instante t e no ponto R(t),

cujo mo?dulo e? igual a 1/v(R(t)). A figura 15.1 ilustra estes conceitos.

Observe que, dadas a posic?a?o inicial R(t0) e a vagarosidade inicial p(t0) de um raio

para algum instante t0 ? 0, as equac?o?es (15.1) determinam a posic?a?o R(t) no raio para

todo t ? t0. Esta trajeto?ria pode ser calculada numericamente, por exemplo pelo me?todo

Runge-Kutta [22].

As equac?o?es (15.1) descrevem apenas a posic?a?o e a direc?a?o do raio. A integrac?a?o

destas equac?o?es e? chamada de trac?ado cinema?tico do raio. Pore?m, cada ponto de uma

onda tem tambe?m outras propriedades f??sicas como amplitude, durac?a?o e forma do pulso,



15.1. Trac?ado de raios 129

R(0)

R(t1)

R(t2)

p(0)

p(t1)

p(t2)

Figura 15.1: Ilustrac?a?o da propagac?a?o de uma onda s??smica resultante de um impulso inicial
no instante t = 0 e no ponto R(0), mostrando a frente de onda em dois instantes subsequ?entes
t = t1 e t = t2, e um raio (em vermelho) com direc?a?o inicial p(0).

polarizac?a?o, etc. A evoluc?a?o destas propriedades ao longo do tempo e? descrita por um

outro conjunto de equac?o?es, cuja interac?a?o constitui o trac?ado de raios dina?mico.

15.1.3 Custo da integrac?a?o em coordenadas cartesianas

A integrac?a?o das equac?o?es do raio (15.1) na forma apresentada e? bastante dispendiosa no

caso de malhas com elementos curvos, como os usados na nossa biblioteca. Este custo

decorre principalmente da necessidade de verificar, a cada passo de interac?a?o, se o raio

continua no mesmo elemento ou se cruzou sua fronteira. Mais especificamente, suponha

que o ponto R(t) do raio esta? no interior do bloco B, cujo dom??nio e? um simplo?ide K?, para

algum ? ? Im e algum m ? N. Para determinar se o ponto R(t) esta? dentro do elemento

e? necessa?rio encontrar o ponto U(t) (do dom??nio A?) tal que R(t) = B.P(U(t)), onde

B.P = (B.P0,B.P1,B.P2) = (B.X,B.Y,B.Z) sa?o as tre?s componentes de B que descrevem a

geometria do bloco. Uma vez determinado o ponto U(t), podemos verificar se ele esta?

dentro do simplo?ide K?. A determinac?a?o de U(t) a partir de R(t) recai em um sistema

de 3 equac?o?es polinomiais cuja soluc?a?o exige me?todos iterativos custosos como Newton-

Raphson.

O ca?lculo de U(t) e? necessa?rio tambe?m quando as propriedades f??sicas sa?o descritas

em termos das coordenadas locais, como no nosso modelo; pois nesse caso precisamos de



130 Cap??tulo 15. Simulac?a?o s??smica

U(t) para calcular velocidade de propagac?a?o v(R(t)) = B.v(U(t)). Ale?m disso, para obter

o gradiente cartesiano (?v)(R(t)) precisamos calcular o seu gradiente (?B.v)(U(t)) nas

coordenadas locais e traduzir este u?ltimo para o gradiente em relac?a?o a?s coordenadas X,Y

e Z. A alternativa comum de modelar as propriedaes f??sicas como func?a?o das coordenadas

cartesianas economizaria esta conversa?o, mas na?o eliminaria a necessidade de calcular U(t)

para a detecc?a?o da fronteira do bloco.

15.1.4 Interac?a?o do raio com interfaces

As equac?o?es (15.1) sa?o va?lidas apenas enquanto o raio viaja em um meio onde v varia

suavemente com a posic?a?o. Quando um raio R atinge uma interface, onde ha? mudanc?a

brusca nas propriedades f??sicas, ele geralmente se extingue e da? origem a um ou mais

novos raios, refletidos e/ou transmitidos. A direc?a?o inicial de cada novo raio R? depende

da direc?a?o final do raio R, da inclinac?a?o local da interface, e do contraste de velocidades

atrave?s da interface (que por sua vez depende dos tipos de onda S ou P), de acordo com a

lei de Snell [25]. Cada novo raio R? e? governado pelas equac?o?es (15.1) ate? encontrar outra

interface, e assim por diante. Na simulac?a?o nume?rica, costuma-se especificar de antema?o

o lado da interface (isto e?, se o raio e? refletido ou transmitido) e o tipo de onda (S ou

P) que deve ser escolhido em cada interface atravessada. Esta sequ?e?ncia de escolhas e?

chamada de assinatura do raio [25].

Quando o raio atinge a fronteira, o custo de identificar o bloco vizinho e?, no ma?ximo,

proporcional ao nu?mero de vizinhos. A transic?a?o do raio, por outro lado, tem custo cons-

tante. Uma vez que, em malhas t??picas, cada bloco tem um nu?mero limitado de vizinhos,

o custo do trac?ado de raios e? proporcional ao nu?mero total de interfaces atravessadas mais

o nu?mero total de passos de integrac?a?o efetivados no interior dos blocos.

15.2 Trac?ado de raios nas coordenadas locais do bloco

Para evitar a conversa?o das coordenadas X,Y e Z para coordenadas locais U, no?s adapta-

mos as equac?o?es do raio (15.1) de modo a descrever diretamente a evoluc?a?o de U(t) [10].

Mais precisamente, substitu??mos o estado do integrador [R(t),p(t)] por [U(t),p(t)], onde

U(t) sa?o as coordenadas locais do ponto R(t) em B. Veja a figura 15.2. Note que o vetor

vagarosidade p(t) continua sendo representado pelas suas coordenadas Cartesianas f??sicas.

Reescrevemos enta?o o sistema (15.1) como

U?(t) = (W(t))?1 (B.v(U(t)))
2
p(t)

p?(t) = (W(t))?1
(

1

B.v(U(t))

)

G(t) , (15.2)



15.2. Trac?ado de raios nas coordenadas locais do bloco 131

U(t)

R(t)

R(t)

B.v(U)

B.v(U)

B.P(U)

B

X

X

Z

Z

U00

U01U02

Figura 15.2: Ilustrac?a?o do trac?ado de raios nas coordenadas locais de um bloco simploidal
bidimensional.

onde W(t) e? a matriz jacobiana das func?o?es da forma do bloco B calculada no ponto U(t),

Wik(t) =
?(B.Pi)

?Uk
(U(t)). (15.3)

e G(t) e? o vetor gradiente da func?a?o B.v em relac?a?o as coordenadas locais, tambe?m cal-

culado no ponto U(t),

Gk(t) =
?(B.v)

?Uk
(U(t)) (15.4)

Nas equac?o?es (15.3) e (15.4), supo?e-se que as coordenadas Uij de um ponto U de A
? sa?o

renumeradas U0,U1, · · · ,Us?1, onde s = |?|+m, em alguma ordem fixa. Observe que cada

derivada parcial ?(B.Pi)/?Uk e ?(B.v)/?Uk , como ja? mencionado no cap??tulo 8, e? uma

func?a?o polinomial simploidal, facilmente determinada a partir dos coeficientes de Be?zier

do bloco B.



132 Cap??tulo 15. Simulac?a?o s??smica

Observe que o sistema (15.2) na?o e? va?lido quando a matriz W e? singular. Entretanto,

a inexiste?ncia de tais singularidades e? um requisito natural para um modelo geof??sico

baseado em ce?lulas.

15.2.1 Normalizac?a?o de U(t)

Em teoria, se U(t0) esta? em A
?, isto e? a soma de cada linha de U(t) e? 1, as equac?o?es (15.2)

mante?m U(t) em A? para todo t ? t0. Pore?m, na pra?tica, erros de arredondamento podem

fazer com que U(t) saia de A?. Para corrigir tais desvios e? necessa?rio normalizar U(t)

apo?s cada passo de integrac?a?o forc?ando
??i

j=0 Uij(t) = 1.

15.2.2 Custo da integrac?a?o em coordenadas locais do bloco

A principal vantagem deste me?todo e? evitar as iterac?o?es de Newton-Raphson para deter-

minar U(t) a partir de R(t). A desvantagem e? a necessidade de calcular o jacobiano W(t)

e sua inversa, mas estas contas sa?o mais simples do que as iterac?o?es de Newton-Raphson.

15.3 Exemplo nume?rico

Para validar esta nova abordagem, implementamos um mo?dulo na linguagem Java que

realiza o trac?ado de raios nos modelos bidimensionais criados pelo editor TopEdit descrito

no cap??tulo 14. Dados a posic?a?o da fonte, a direc?a?o inicial de um raio e a sua assinatura,

o programa realiza o trac?ado do raio integrando o sistema (15.2), utilizando o me?todo

Runge-Kutta de quarta-ordem [22], ate? encontrar uma interface. Neste ponto, o programa

acompanha um dos novos raios, determinado por uma assinatura previamente fornecida.

Adicionalmente, o usua?rio pode especificar um feixe de raios, fornecendo a abertura em

graus do feixe e a separac?a?o em graus entre os raios que o compo?e.

Para ilustrar o programa, usamos a seguir um modelo geof??sico de uma regia?o plana

(propagac?a?o 2D) com 12km de extensa?o por 8km de profundidade, mostrado na fi-

gura 15.3. Neste teste, a fonte foi localizada na superf??cie, mais especificamente na posic?a?o

X = 4km e Z = 0km. A figura 15.4a ilustra os raios refletidos na base da primeira camada,

com direc?o?es iniciais variando de ?28? a 28? com incrementos de 1?. A figura 15.4b, por

sua vez, ilustra os raios refletidos na base da segunda camada, com direc?o?es iniciais vari-

ando de ?17? a 17? com mesmo incremento. Em ambas as simulac?o?es, usamos integrac?a?o

de RungeKutta com passo de 2ms.



15.3. Exemplo nume?rico 133

Figura 15.3: Modelo geof??sico criado pelo editor TopEdit. As velocidades variam de 1500m/s
(ciano) a 5000m/s (vermelho).



134 Cap??tulo 15. Simulac?a?o s??smica

(a)

(b)

Figura 15.4: Simulac?a?o s??smica por trac?amento de raios. Raios refletidos (a) na base da primeira
camada e (b) na base da segunda camada.



Cap??tulo 16

Concluso?es

Nesta tese, estudamos a representac?a?o de modelos geolo?gicos por malhas de elementos

de Be?zier simploidais. Esta classe de elementos inclui, como casos particulares, a curva

de Be?zier, os retalhos triangulares e retangulares de Be?zier, e os blocos hexae?dricos, te-

trae?dricos e prisma?ticos de Be?zier.

Na primeira parte da tese, revisamos os conceitos de elementos simpliciais e tenso-

riais e desenvolvemos fo?rmulas gene?ricas expl??citas para conversa?o entre estes dois tipos

para dimenso?es e graus arbitra?rios. Ale?m disso, formalizamos os elementos simploidais

de Be?zier e apresentamos fo?rmulas gene?ricas para elevac?a?o de grau, diferenciac?a?o e re-

parametrizac?a?o por mapeamentos afins constantes. Para este fim, usamos a notac?a?o de

multi-??ndices de DeRose [6], estendemos sua notac?a?o de hiper-??ndices para incluir ma-

trizes irregulares, e definimos o novo conceito de ultra-??ndice. Grac?as a estes conceitos,

conseguimos obter fo?rmulas sucintas va?lidas para todos os tipos de blocos e dimenso?es.

Na segunda parte, aplicamos esta teoria a? representac?a?o computacional de malhas de

elementos simploidais. Descrevemos a biblioteca BezEl, por no?s desenvolvida, que permite

a representac?a?o e manipulac?a?o eficiente de malhas de elementos de Be?zier simplodais de

dimenso?es e graus arbitra?rios. A generalidade do nu?mero de dimenso?es destes elementos

permite que a malha descreva na?o apenas a geometria do modelo mas tambe?m um conjunto

arbitra?rio de propriedades f??sicas do seu interior.

Dentre as caracter??sticas originais da BezEl, destacamos o conceito do tipo de bloco

e a distinc?a?o entre para?metros internos e externos, que permitem representar de forma

econo?mica malhas regulares e semi-regulares com blocos de graus elevados. Outras contri-

buic?o?es originais desta biblioteca sa?o rotinas gene?ricas para extrac?a?o de facetas, repara-

metrizac?a?o, elevac?a?o de grau e diferenciac?a?o. A biblioteca BezEl tambe?m proporciona

a asserc?a?o de restric?o?es lineares arbitra?rias sobre os para?metros dos blocos, que podem

ser usadas, por exemplo, para editar a geometria do modelo mantendo a suavidade de

interfaces.

135



136 Cap??tulo 16. Concluso?es

Validamos a biblioteca implementando um editor interativo da geometria de um mo-

delo geolo?gico bidimensional (apresentado no cap??tulo 14).

Outra contribuic?a?o original desta tese e? uma estrate?gia para trac?amento eficiente de

raios em modelos descritos por malhas de elementos de Be?zier simploidais (descrita no

cap??tulo 15) . Esta metodologia consiste em efetuar a integrac?a?o das equac?o?es do raio em

termos das coordenadas locais de cada bloco em vez das coordenadas X, Y e Z do espac?o

f??sico. Desta forma, evita-se a inversa?o nume?rica das func?o?es de geometria do bloco. Ale?m

disso, a detecc?a?o da intersecc?a?o do raio com a fronteira do bloco torna-se uma operac?a?o

trivial.



Refere?ncias Bibliogra?ficas

[1] P. Be?zier. Numerical control; mathematics and applications [by] P. Be?zier. Appendi-

xes by A. R. Forrest. Translated by A. R. Forrest and Anne F. Pankhurst. J. Wiley

London, New York, 1972.

[2] T.N. Bishop. Tomographic determination of velocity and depth in laterally varying

media. Geophysics, 50:903–923, 1985.

[3] I Brueckner. Construction of Be?zier points of quadrilaterals from those of triangles.

Computer Aided Design, 1980.

[4] S.A. Coons. Surface patches and b-splines curves. In in Computer Aided Geometric

Design (ed. Barnhill and Riesenfeld), pages 1–16. Academic Press, 1974.

[5] C. DeBoor. B–form basics. In in (Geometric Modeling: Algorithms and New

Trends),(ed. Farin), pages 131–148. SIAM Publications, 1987.

[6] T.D. DeRose, R.N. Goldman, H. Hagen, and S. Mann. Functional composition algo-

rithms via blossoming. ACM Trans. Graph., 12(2):113–135, 1993.

[7] R.B. Devloo. Pz: An object oriented environment for scientific programming. Com-

puter Methods in Applied Mechanics and Engineering, 150:133–153, 1997.

[8] G. Farin. Be?zier polynomials over triangles and the construction of piecewise CR

polynomials. Technical Report TR91, Brunel University, 1980.

[9] G. Farin. Curves and Surfaces for Computer Aided Geometric Design. Academic

Press, third edition, 1992.

[10] L. Freitas, J. Stolfi, and M. Tygel. Fast ray tracing in cellular models. In Expanded

Abstracts, 10th International Congress of the Geophysics Brazillian Society, 2007.

[11] R Goldman and D. Filip. Conversion from Be?zier rectangles to Be?zier triangles.

Computer Aided Design, 1987.

137



138 REFERE?NCIAS BIBLIOGRA?FICAS

[12] K. Hoffman and R. Kunze. Linear Algebra. Prentice Hall, second edition, 1971.

[13] S.-M. Hu. Conversion of a triangular Be?zier patch into three rectangular Be?zier

patches. Computer Aided Geometric Design, 13(3):219–226, 1996.

[14] S.-M. Hu. Conversion between triangular and rectangular Be?zier patches. Comput.

Aided Geom. Des., 18(7):667–671, 2001.

[15] W. Kaplan. Advanced Calculus. Addison-Wesley, 1993.

[16] M. Konig. Cell ray tracing for smooth, isotropic media: a new concept based on a

generalized analytic solution. Geophysical Journal International, 1995.

[17] D. Lasser. Tensor product Be?zier surfaces on triangle Be?zier surfaces. Computer

Aided Geometric Design, 19(8):625–643, 2002.

[18] D. Lasser. Triangular subpatches of rectangular Be?zier surfaces. Comput. Math.

Appl., 55(8):1706–1719, 2008.

[19] A.P. Malheiro and J. Stolfi. Finding minimal bases in arbitrary spline spa-

ces. In Proceedings of the 22nd Canadian Conference on Computational Geometry

(CCCG2010), pages 135–138, 2010.

[20] J. L. Mallet, C. Sword, and W. Velten. Computation of smooth second derivatives on

irregular triangulated surfaces. In Expanded Abstracts, 67th SEG Annual Meeting,

pages 1715–1718, 1997.

[21] Z. Meng and N. Bleistein. Wavefront construction (WF) ray tracing in tetrahedral

models – application to 3-D traveltime and raypath computations. Technical Report

CWP-251, Center for Wave Phenomena, Colorado School of Mines, 1997.

[22] W.H. Press, B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling. Numerical Recipes:

The Art of Scientific Computing. Cambridge University Press, 1986.

[23] A. Riskus. Approximation of a cubic Be?zier curve by circular arcs and vice versa.

Information Tecnology and Control, 35(4):371–378, 2006.

[24] W. Trump and H. Prautzsch. Arbitrarily high degree elevation of Be?zier representa-

tions. Computer Aided Geometric Design, 13(5):387 – 398, 1996.

[25] V. C?erveny?. Seismic Ray Theory. Cambridge University Press, 2001.

[26] V. Vinje, E. Iversen, H. Gjøystdal, and K. A?stebøl. 3D ray modeling by wavefront

construction in open models. Geophysics, 64:1912–1919, 1999.



REFERE?NCIAS BIBLIOGRA?FICAS 139

[27] J. Virieux. P-sv wave propagation in heterogeneous media: Velociy-stress finite-

difference method. Geophysics, 51, 1986.

[28] L. Wang. Estimation of Multi-valued Green’s function by Dynamic Ray tracing and

True Amplitude Kirchoff Inversion in 3D-Heterogeneous media. PhD thesis, Center

of Wave Phenomenon, 2000.


</field>
	</doc>
</add>