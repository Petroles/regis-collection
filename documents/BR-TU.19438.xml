<?xml version="1.0" encoding="utf-8"?>
<add>
	<doc>
		<field name="docid">BR-TU.19438</field>
		<field name="filename">2788_Pereira_RomuloAlbuquerque_M.pdf</field>
		<field name="filetype">PDF</field>
		<field name="text">
Escalonamento de Atividades de

Desenvolvimento de Poc?os de Petro?leo:

GRASP

Romulo Albuquerque Pereira

Dissertac?a?o de Mestrado

i



Instituto de Computac?a?o

Universidade Estadual de Campinas

Escalonamento de Atividades de Desenvolvimento de

Poc?os de Petro?leo: GRASP

Romulo Albuquerque Pereira

Novembro de 2005

Banca Examinadora:

• Prof. Dr. Arnaldo Vieira Moura (Orientador)

• Prof. Dr. Ricardo Dahab

Instituto de Computac?a?o – UNICAMP

• Prof. Dr. Vin??cius Amaral Armentano

Faculdade de Engenharia Ele?trica e de Computac?a?o – UNICAMP

• Prof. Dr. Joa?o Meidanis (Suplente)

Instituto de Computac?a?o – UNICAMP

ii







Escalonamento de Atividades de Desenvolvimento de

Poc?os de Petro?leo: GRASP

Este exemplar corresponde a? redac?a?o final da

Dissertac?a?o devidamente corrigida e defendida

por Romulo Albuquerque Pereira e aprovada

pela Banca Examinadora.

Campinas, 16 de novembro de 2005.

Prof. Dr. Arnaldo Vieira Moura (Orientador)

Prof. Dr. Cid Carvalho de Souza

(Co-orientador)

Dissertac?a?o apresentada ao Instituto de Com-

putac?a?o, unicamp, como requisito parcial para

a obtenc?a?o do t??tulo de Mestre em Cie?ncia da

Computac?a?o.

v



c© Romulo Albuquerque Pereira, 2005.

Todos os direitos reservados.

vi



Resumo

Este trabalho de mestrado procurou estudar e resolver um problema real de escalonamento

das atividades de desenvolvimento de poc?os de petro?leo em alto mar. Uma versa?o mais

simples deste mesmo problema foi provada ser NP-dif??cil. Nosso estudo se concentrou no

problema real enfrentado pela Petrobras, com todas suas caracter??sticas e nuances.

Antes que locais promissores de bacias petrol??feras sejam efetivamente desenvolvidos

em poc?os de petro?leo produtivos, e? necessa?rio realizar diversas atividades de perfurac?a?o,

completac?a?o e interligac?a?o nesses locais. O escalonamento dessas atividades deve satisfa-

zer va?rias restric?o?es conflitantes e buscar a maximizac?a?o da produc?a?o de petro?leo em um

dado horizonte de tempo. O problema foi atacado em duas etapas: uma sem conside-

rar o deslocamento de recursos e outra considerando-os. Para tal, adotamos a estrate?gia

Greedy Randomized Adaptive Search Procedure (GRASP) e incorporamos va?rias te?cnicas

espec??ficas para obter melhores desempenho e qualidade da soluc?a?o final. Os resultados

sa?o comparados com outros produzidos por uma ferramenta computacional baseada em

Programac?a?o por Restric?o?es (PR). Esta u?ltima, ja? em uso e bem aceita na empresa, foi

desenvolvida pela Petrobras. Resultados comparativos realizados em insta?ncias reais indi-

cam que a implementac?a?o GRASP supera a ferramenta de PR produzindo soluc?o?es com

expressivos aumentos de produc?a?o.

vii



Abstract

This dissertation aimed at studying and solving a real world scheduling problem. We deal

with the scheduling of offshore oil well development activities. A simpler version of this

same problem was proved to be in NP-hard. Our approach treats this problem as faced by

Petrobras, with all its characteristics and details.

Before promising locations at petroliferous basins become productive oil wells, it is often

necessary to complete activities of drilling, completion and interconnection at these locati-

ons. The scheduling of such activities must satisfy several conflicting constraints and aim

at the maximization of oil production. The problem was solved in two parts: one without

considering resource displacements and other taking into account such displacements. For

such, we used a Greedy Randomized Adaptive Search Procedure (GRASP) metaheuristic

and used several techniques and variants in order to obtain more efficiency and produce

better solutions. The results are compared with schedules produced by a well-accepted cons-

traint programming implementation. Computational experience on real instances indicates

that the GRASP implementation is competitive, outperforming the constraint programming

implementation.

ix



Agradecimentos

Agradec?o...

A? Deus, meu Pai. Por me encorajar, me iluminar e me inspirar a sempre fazer o que e? bom.

Por ser um excelente oleiro. Por me amar e por me dar tantos e muitos outros motivos

para Lhe agradecer.

Aos meus pais, por terem me ensinado a aprender. Por terem me dado o gosto pela leitura

e, principalmente, pela escrita. Por me amarem e serem ta?o especiais!

A? minha fam??lia, por terem acreditado em mim e por sempre orarem por mim. Sou muito

grato a todos!

Aos meus orientadores, por me iniciarem no mundo da pesquisa e por trabalharem duro

junto comigo. Por me mostrarem que na seriedade de um trabalho, pode-se se divertir e

contar com excelentes amigos.

A? Josy, por me deslumbrar e deixar um escritor sem palavras...

Ao Repu?blica Futebol Clube: Vin??cius Pato, Vin??cius Beic?o, Ulisses Monge e Harry Um-

brella por momentos inesquec??veis de grande amizade.

A? Petrobras, por me empregar como terceirizado e por nos fornecer os dados para ana?lise.

Ao Fernando, por ser o “chefe” que todo empregado gostaria de ter. E aos meus colegas de

trabalho, pela amizade e companheirismo.

xi



Por que?

Por que sa?o ta?o loucas as coisas loucas

da vida?

E por que sa?o ta?o poucas?

Porque sa?o na?o ocas

Delas cria-se um universo

Fazem-se esses versos

Os fazem belos

Elos ao eterno?

Sim.

Romulo A. Pereira

“Muitos, que Digam Muito”

A ser lanc?ado

xiii



Conteu?do

Resumo vii

Abstract ix

Agradecimentos xi

1 Introduc?a?o 1

1.1 Organizac?a?o do Texto . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2

I Descric?a?o do Problema 3

2 O Escalonamento no Desenvolvimento de Poc?os de Petro?leo 5

2.1 Produc?a?o de Petro?leo e Objetivos . . . . . . . . . . . . . . . . . . . . . . . . 7

2.2 As Restric?o?es do EDP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7

2.3 Relac?a?o entre o EDP e o Job Shop Scheduling . . . . . . . . . . . . . . . . . 9

2.4 Histo?rico . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

II Fundamentos Teo?ricos 13

3 GRASP 15

4 Programac?a?o por Restric?o?es 19

III O Trabalho Desenvolvido 23

5 ORCA: Resolvedor de Programac?a?o por Restric?o?es 25

5.1 Modelo do ORCA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25

5.1.1 Algoritmos do ORCA . . . . . . . . . . . . . . . . . . . . . . . . . . . 27

5.1.2 Func?a?o Objetivo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27

xv



5.1.3 Te?cnicas de Busca . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

5.1.4 Goals para Escalonar as Atividades . . . . . . . . . . . . . . . . . . . 29

5.1.5 Resultados do ORCA . . . . . . . . . . . . . . . . . . . . . . . . . . . 30

6 O EDP sem Deslocamento de Recursos 31

1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

2 The Well Drilling Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33

3 A GRASP for the WDP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35

4 Computational Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40

5 Conclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43

6 References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45

7 O EDP com Deslocamento de Recursos 49

1 Scheduling the Development of Oil Wells . . . . . . . . . . . . . . . . . . . . 52

1.1 Oil Yield and Objectives . . . . . . . . . . . . . . . . . . . . . . . . . 53

1.2 The WDRDP Constraints . . . . . . . . . . . . . . . . . . . . . . . . 53

1.3 The Constraint Programming Solution . . . . . . . . . . . . . . . . . 55

1.4 The Resource Displacement . . . . . . . . . . . . . . . . . . . . . . . 55

2 GRASP Strategies for the WDRDP . . . . . . . . . . . . . . . . . . . . . . . 56

2.1 Greedy Randomized Adaptive Search Procedure (GRASP) . . . . . . 57

2.2 GRASP Advanced Techniques . . . . . . . . . . . . . . . . . . . . . . 58

2.3 The New GRASP Solver Implementation: GRASPW . . . . . . . . . 61

2.4 The Construction Phase . . . . . . . . . . . . . . . . . . . . . . . . . 62

2.5 The Local Search Phase . . . . . . . . . . . . . . . . . . . . . . . . . 64

3 Computational Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66

3.1 Typical Instances . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66

3.2 Setting GRASPW Parameters . . . . . . . . . . . . . . . . . . . . . . 66

3.3 The GRASPW Implementations . . . . . . . . . . . . . . . . . . . . . 69

3.4 Comparative Results . . . . . . . . . . . . . . . . . . . . . . . . . . . 73

4 Conclusions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75

5 References . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77

IV Considerac?o?es Finais 83

8 Concluso?es 85

9 Trabalhos Futuros 87

Bibliografia 88

xvi



Lista de Tabelas

Cap??tulo 4

4.1 Estrutura ba?sica de um programa em Programac?a?o por Restric?o?es . . . . . . 20

Cap??tulo 6

1 Test instances. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40

Cap??tulo 7

1 Tested Instances. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 67

2 Solvers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71

3 Values obtained by the Solvers in the Comparative Criteria . . . . . . . . . . 72

4 Rank of the Solvers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73

5 Analysis of the Rank of the Solvers . . . . . . . . . . . . . . . . . . . . . . . 74

6 Rank of the Best Solvers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75

xvii



Lista de Figuras

Cap??tulo 2

2.1 A?rvore de Natal Molhada. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6

2.2 Restric?a?o de Superf??cie. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9

Cap??tulo 3

3.1 Pseudo-co?digo da Metaheur??stica GRASP . . . . . . . . . . . . . . . . . . . 15

3.2 Pseudo-co?digo da Fase Construc?a?o . . . . . . . . . . . . . . . . . . . . . . . 17

3.3 Pseudo-co?digo da Fase Busca Local . . . . . . . . . . . . . . . . . . . . . . . 17

Cap??tulo 5

5.1 ORCA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26

Cap??tulo 6

1 Pseudo-code of the GRASP Metaheuristic. . . . . . . . . . . . . . . . . . . . . . 36

2 Pseudo-code of the Construction Phase of GRASP. . . . . . . . . . . . . . . . . 37

3 Static Sized RCL x Dynamic Sized RCL. . . . . . . . . . . . . . . . . . . . . . 41

4 BIR × FIR. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42

5 ORCA x GRASPW. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43

6 ORCA x GRASPW. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44

Cap??tulo 7

1 Schedules without and with resource displacement. . . . . . . . . . . . . . . . . 56

2 Pseudo-code of the GRASP Meta-heuristic. . . . . . . . . . . . . . . . . . . . . 57

3 Pseudo-code of the Construction Phase of GRASP. . . . . . . . . . . . . . . . . 58

4 2-exchange swap. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65

5 Static Sized RCL Solver x Dynamic Sized RCL Solver. . . . . . . . . . . . . . . 67

6 BIR x FIR: Example 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68

7 BIR x FIR. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68

xix



8 Bias Functions, I. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69

9 Bias Functions, II . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70

10 ORCA × G14, I . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74

11 ORCA × G14, II . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76

12 ORCA×G14: Example 5 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76

xx



Cap??tulo 1

Introduc?a?o

A pesquisa cient??fica sobre problemas de escalonamento (scheduling) e? intensa e tem ele-

vado teor pra?tico, existindo desde a Segunda Guerra Mundial. Notadamente, quase toda

empresa de certo porte, em que a organizac?a?o, reduc?a?o de custos e produtividade sa?o in-

dispensa?veis para competir no mercado, ja? aplica te?cnicas da pesquisa operacional. Ocorre,

pore?m, que a grande maioria destes problemas sa?o comprovadamente classificados como

NP-dif??ceis (Garey &amp;amp; Johnson (1979)). Isso praticamente exclui algoritmos determin??sticos

eficientes para solucionar esses problemas, especialmente para insta?ncias de entrada sufici-

entemente grandes. Na ause?ncia de algoritmos polinomiais, uma alternativa promissora e? o

uso de heur??sticas eficazes que possam auxiliar no processo de busca de boas soluc?o?es. Em

vista disso, e dadas as especificidades de cada problema, e? raro encontrar-se ferramentas

comerciais acabadas que atendam a?s necessidades de cada situac?a?o.

Petro?leo e ga?s sa?o combust??veis fo?sseis de larga utilizac?a?o na sociedade atual, sendo

aproveitados na fabricac?a?o de pla?sticos, tintas, querosene, combust??vel veicular e de aviac?a?o,

ga?s de cozinha e em muitas outras aplicac?o?es. Boa parte desses combust??veis fo?sseis e? hoje

extra??da de bacias ocea?nicas, como a de Marlim, no Estado do Rio de Janeiro. A variac?a?o na

oferta e nos prec?os desses combust??veis, aliada a? necessidade da reduc?a?o dos seus custos de

produc?a?o, com manutenc?a?o da produtividade, torna cada vez mais importante a utilizac?a?o

de mecanismos que permitam a organizac?a?o racional das atividades de produc?a?o de um

campo petrol??fero (Hasle et al. (1997)). Algumas das atividades inerentes ao processo de

explorac?a?o de petro?leo possuem um custo muito elevado, principalmente devido ao aluguel

de equipamentos de grande porte, tais como barcos e sondas.

A Petrobras e? uma das empresas pioneiras e l??deres na explorac?a?o de petro?leo em a?guas

profundas, sendo tambe?m uma das 20 maiores empresas petrol??feras do planeta. Ela ex-

plora diversas bacias petrol??feras, cada uma com centenas de locais promissores onde poc?os

de petro?leo podem ser colocados em produc?a?o. Entretanto, esses locais precisam ser de-

senvolvidos antes de se tornarem produtivos. Para realizar as atividades envolvidas no

1



2 Cap??tulo 1. Introduc?a?o

desenvolvimento de um poc?o de petro?leo, a Petrobras utiliza recursos — sondas e navios

— alguns alugados, outros de sua propriedade. Esses recursos sa?o limitados e de alto

custo, seja em sua aquisic?a?o ou no prec?o de aluguel, e, dessa forma, devem ser utilizados

eficientemente.

Ciente disso, a empresa resolveu utilizar ferramentas computacionais que pudessem

melhor escalonar suas atividades realizadas na Bacia Petrol??fera de Campos. Ale?m do

escalonamento das atividades, ela tambe?m deseja que o mecanismo resolvedor considere o

deslocamento dos recursos. Num primeiro passo, a empresa procurou por programas comer-

ciais que solucionassem seu problema espec??fico. Pore?m, logo verificou que tais programas

na?o esta?o dispon??veis no mercado. Assim, a Petrobras expo?s seu problema a? Unicamp e

sugeriu uma parceria de pesquisa sobre algoritmos e heur??sticas que pudessem auxiliar na

busca de uma soluc?a?o satisfato?ria (Moura &amp;amp; de Souza (2000)). Este projeto se insere no es-

copo dessa cooperac?a?o. A empresa procurou obter, com o desenvolvimento deste trabalho,

ale?m de maior produtividade e outros benef??cios, uma boa reduc?a?o de custos na operac?a?o

de seus equipamentos.

1.1 Organizac?a?o do Texto

O texto dessa dissertac?a?o encontra-se dividido em quatro partes principais:

A Parte I traz uma descric?a?o detalhada do problema tratado. Apresentamos todas as

restric?o?es operacionais e de engenharia envolvidas no escalonamento, e mostramos um breve

histo?rico de como esse problema foi resolvido.

A Parte II apresenta, resumidamente, os fundamentos teo?ricos necessa?rios para um

entendimento adequado do trabalho descrito nesta dissertac?a?o. O Cap??tulo 3 expo?e as

ide?ias ba?sicas a respeito da metaheur??stica GRASP. O Cap??tulo 4 conte?m uma introduc?a?o

a? metodologia de Programac?a?o por Restric?o?es.

Na Parte III, esta?o inclu??dos uma descric?a?o da ferramenta ORCA (Cap??tulo 5) e dois

artigos resultantes deste trabalho de mestrado. Os artigos esta?o escritos em ingle?s. A

cada um dos artigos esta?o anexadas uma nova introduc?a?o e uma nova conclusa?o estendidas,

ambas em portugue?s. O Cap??tulo 6 discute a soluc?a?o do problema de escalonamento no

desenvolvimento de poc?os de petro?leo sem deslocamento de recursos e o Cap??tulo 7 trata

do mesmo problema, mas com deslocamento de recursos.

Por fim, a Parte IV expo?e as concluso?es finais alcanc?adas com este trabalho e enu-

mera algumas poss??veis direc?o?es de pesquisa que poderiam ser tomadas no sentido de dar

continuidade a este estudo.



Parte I

Descric?a?o do Problema

3



Cap??tulo 2

O Escalonamento no

Desenvolvimento de Poc?os de

Petro?leo

Quando um ponto em alto mar e? considerado um promissor poc?o de petro?leo, sondas sa?o

enviadas ao local para realizar as devidas operac?o?es de perfurac?a?o. O desenvolvimento de

um poc?o, desde a determinac?a?o da sua localizac?a?o ate? ser colocado em produc?a?o, envolve

va?rias etapas.

Apo?s perfurado, inicia-se o processo de preparac?a?o do poc?o para a extrac?a?o de petro?leo

(completac?a?o). Em primeiro lugar, e? instalada a “A?rvore de Natal Molhada (ANM)” 1 sobre

a boca do poc?o para que a mate?ria-prima na?o extravase para o mar. Posteriormente, um

navio LSV2 leva uma tubulac?a?o da qual uma extremidade e? conectada a? ANM e a outra

extremidade e? encaixada num manifold 3, ou enta?o sobe direto para a superf??cie, sendo

conectada a uma plataforma. Esse esta?gio e? conhecido como interligac?a?o. O manifold

e? instalado por uma sonda, ou por uma BGL4, e seu uso evita que cada poc?o necessite

de tubulac?o?es exclusivas que o conecte desde o fundo do mar ate? a? superf??cie. Assim,

as mangueiras de va?rios poc?os relativamente pro?ximos podem se interligar ao manifold e,

deste, uma u?nica tubulac?a?o sobe ate? a superf??cie. Na ause?ncia de manifolds, e com o metro

de tubulac?a?o tendo alto valor, o processo todo teria valor excessivamente elevado.

Completado o processo de interligac?a?o, parte-se para a extrac?a?o do petro?leo propria-

mente dita. Para tal, sa?o colocadas bases de captura de petro?leo na superf??cie do mar, as

chamadas UEPs (Unidade Estaciona?ria de Produc?a?o), onde se armazenara? o produto ate?

1Complexa estrutura meta?lica com tubulac?o?es onde se encaixam va?lvulas para extrac?a?o do petro?leo.
Vide Figura 2.1.

2Navio de apoio.
3Um manifold e? uma estrutura para a junc?a?o de tubulac?o?es no fundo do mar.
4Barcac?a guindaste.

5



6 Cap??tulo 2. O Escalonamento no Desenvolvimento de Poc?os de Petro?leo

Figura 2.1: A?rvore de Natal Molhada.

que navios venham recolhe?-lo e leva?-lo para terra. Se a vaza?o de petro?leo for muito elevada,

pode-se optar pela instalac?a?o local de uma plataforma petrol??fera.

O problema de Escalonamento no Desenvolvimento de Poc?os de petro?leo em alto mar

(EDP) pode ser definido como: dados um conjunto de poc?os, as atividades a serem exe-

cutadas em cada poc?o e os recursos dispon??veis para a execuc?a?o dessas atividades, deter-

minar um sequ?enciamento das atividades em um dado horizonte de tempo, indicando seus

instantes de in??cio e fim e o recurso que a realizara?, de forma a otimizar uma func?a?o ob-

jetivo, a saber, maximizar a produc?a?o de petro?leo. Este sequ?enciamento deve levar em

conta diversas restric?o?es operacionais e de engenharia. Ale?m disso, pode ser considerado

o deslocamento dos recursos. Nesse trabalho, o EDP e? estudado, levando em conta as

especificidades encontradas pela Petrobras na explorac?a?o de petro?leo em a?guas profundas.

As restric?o?es operacionais e de engenharia sera?o apresentadas em detalhes, bem como uma

metaheur??stica para a resoluc?a?o do problema.

Propostas de soluc?a?o ja? foram desenvolvidas para problemas similares (do Nascimento

(2002)). Entretanto, o EDP na forma aqui estudada inclui restric?o?es de grande releva?ncia

pra?tica que na?o sa?o tratadas em outros trabalhos, e que nos foram fornecidas pela Petrobras.

Por exemplo, no EDP com deslocamento de recursos (que chamamos de EDPDR) considera-

se que a movimentac?a?o dos recursos entre os poc?os consome tempo e que, nesse per??odo,

eles ficam indispon??veis.



2.1. Produc?a?o de Petro?leo e Objetivos 7

2.1 Produc?a?o de Petro?leo e Objetivos

A produc?a?o de petro?leo de um poc?o e? calculada da seguinte forma. Cada poc?o tem uma

vaza?o associada e uma atividade cujo propo?sito e? indicar o in??cio da produc?a?o. Quando esta

u?ltima atividade e? conclu??da, o poc?o e? considerado em produc?a?o. A produc?a?o e? calculada

multiplicando-se a vaza?o de petro?leo do poc?o pelo tempo restante desde o in??cio da produc?a?o

ate? o horizonte de produc?a?o estabelecido. Se o in??cio da produc?a?o ocorrer apo?s o horizonte

de produc?a?o, a produc?a?o do poc?o correspondente na?o sera? considerada.

O objetivo e? obter um escalonamento para todas as atividades de desenvolvimento,

satisfazendo todas as restric?o?es e maximizando a produc?a?o de petro?leo. Outros objetivos a

serem atingidos sa?o:

1. Gerar soluc?o?es mais rapidamente. Soluc?o?es criadas por engenheiros levam muitas

horas, ate? dias, para serem constru??das. Um me?todo mais ra?pido permitiria a ana?lise

de diferentes cena?rios para o mesmo problema como, por exemplo, acrescentando-se

ou removendo-se recursos. Ale?m disso, imprevistos na?o resultariam em novas horas

ou dias em replanejamento.

2. Melhor alocac?a?o de recursos. Com a automac?a?o do escalonamento, engenheiros al-

tamente especializados, antes responsa?veis por planejar o escalonamento, podem ser

realocados para outras a?reas da empresa.

3. Ganhos. O escalonamento automatizado devera? gerar soluc?o?es pelo menos ta?o boas

quanto as manuais. A ferramenta desenvolvida deve tambe?m gerar soluc?o?es pelo me-

nos ta?o boas quanto a?quelas geradas pelo ORCA, uma aplicac?a?o em uso na Petrobras.

2.2 As Restric?o?es do EDP

As principais restric?o?es envolvidas no processo de escalonamento das atividades de desen-

volvimento dos poc?os de petro?leo sa?o:

C1. Precede?ncia Tecnolo?gica: estabelece uma ordem entre as atividades. Ha? quatro cate-

gorias de precede?ncia tecnolo?gica:

(a) FS(A,B): Atividade A deve terminar depois do in??cio da atividade B.

(b) SS(A,B): Atividade A deve iniciar depois do in??cio da atividade B.

(c) SF(A,B): Atividade A deve iniciar depois do fim da atividade B.

(d) FF(A,B): Atividade A deve terminar depois do fim da atividade B.



8 Cap??tulo 2. O Escalonamento no Desenvolvimento de Poc?os de Petro?leo

C2. Marco-Atividade: uma atividade deve terminar antes ou iniciar depois de uma deter-

minada data, ou marco, com ou sem lag. Essa data esta? geralmente relacionada com

algum evento externo, e.g., a instalac?a?o de uma plataforma petrol??fera.

C3. Baseline: estabelece uma data de in??cio para uma determinada atividade.

C4. Restric?o?es no Uso dos Recursos: para executar uma atividade, dependendo da sua

natureza, e? necessa?rio um recurso que atenda a?s suas caracter??sticas operacionais.

Para uma atividade que requer um barco, deve ser verificado se os equipamentos do

mesmo podem operar na profundidade especificada. Para uma atividade que requer

uma sonda, deve ser verificado:

(a) Seu tipo: ancorada, SSDP, NSDP ou navio-sonda.

(b) Suas capacidades: TOP DRIVE, HPHT, BOP 16, BOP 18, Perfurac?a?o.

(c) Sua ma?xima e m??nima profundidade de operac?a?o.

(d) Sua ma?xima profundidade de perfurac?a?o.

C5. Concorre?ncia: duas atividades do mesmo poc?o na?o podem ser executadas simulta-

neamente. Similarmente, duas atividades na?o podem ser executadas por um mesmo

recurso simultaneamente.

C6. Indisponibilidade: recursos podem estar indispon??veis por um per??odo de tempo, para

manutenc?a?o ou devido a te?rmino de contrato.

C7. Seque?ncias de Poc?os Definidas pelo Usua?rio: o usua?rio pode especificar uma seque?ncia

desejada para as atividades de perfurac?a?o ou para as atividades de “in??cio de produc?a?o”

de diferentes poc?os. A seque?ncia e? uma lista ordenada de dois ou mais poc?os de tal

forma que se o poc?o A precede o poc?o B na lista, enta?o a atividade FA do poc?o A

deve terminar antes do in??cio da atividade SB do poc?o B. As atividades FA e SB sa?o

ou atividades de “perfurac?a?o” ou atividades de “in??cio de produc?a?o” de seus respec-

tivos poc?os, dependendo do tipo da seque?ncia. Essas seque?ncias sa?o especificadas por

engenheiros de modo a evitar perda de pressa?o no campo petrol??fero.

C8. Restric?a?o de Superf??cie: tambe?m conhecida como bolha assassina, essa restric?a?o re-

presenta uma a?rea de seguranc?a, definida pelo usua?rio ao redor de cada poc?o, para

que as sondas usadas em atividades desses poc?os na?o colidam. A a?rea restrita e? espe-

cificada por um pol??gono fechado definido por coordenadas ao redor do poc?o. Quando

o centro do primeiro poc?o esta? dentro da a?rea restrita do segundo poc?o, as ativida-

des executadas por sondas nesses poc?os na?o podem ser simulta?neas. Essas restric?o?es

devem ser verificadas entre cada par de sondas mo?veis, e entre cada par de sondas



2.3. Relac?a?o entre o EDP e o Job Shop Scheduling 9

mo?veis e ancoradas. Por exemplo, na Figura 2.2, o centro do poc?o JUB-16 esta? dentro

da a?rea de seguranc?a do poc?o JUB-02-I, e portanto atividades executadas por sondas

nesses poc?os na?o podem ser simulta?neas.

Figura 2.2: Restric?a?o de Superf??cie.

C9. Cluster : uma atividade pode ser parte de um cluster, que e? um conjunto de atividades

que devem usar o mesmo recurso.

C10. Deslocamento de Sonda: Essa restric?a?o na?o aparece no EDP puro, mas e? considerada

no EDPDR. Ela estabelece que quando uma sonda se deslocar de um poc?o para outro,

um tempo de set-up5 deve ser considerado. Dessa forma, deslocamentos desnecessa?rios

devem ser evitados, por exemplo, fazendo com que uma sonda execute o ma?ximo de

atividades de um mesmo poc?o.

Pela descric?a?o do problema e de suas restric?o?es, pode ser observado que, ale?m de lidar-

mos com uma aplicac?a?o real e de grande importa?ncia, trata-se um problema com va?rias

particularidades, que o diferencia em relac?a?o a? problemas descritos na literatura (do Nas-

cimento (2002)).

2.3 Relac?a?o entre o EDP e o Job Shop Scheduling

Em va?rias deciso?es e escolhas de para?metros em nosso resolvedor, tomamos como base

estudos e te?cnicas utilizadas para o problema cla?ssico do Job Shop Scheduling (JSP). Isso

5Tempo para desancorar, deslocar, e ancorar novamente.



10 Cap??tulo 2. O Escalonamento no Desenvolvimento de Poc?os de Petro?leo

foi feito porque o EDP e o JSP podem ser facilmente relacionados, como se mostra a seguir,

apesar de o EDP ser um problema bem mais complexo.

Um JSP pode ser definido como: um conjunto M de ma?quinas, um conjunto J de

tarefas, e para cada tarefa j ? J esta? associada uma colec?a?o ordenada de operac?o?es tk[j],

1 ? k ? nj, onde nj e? o nu?mero de operac?o?es associadas com a tarefa j. Para cada operac?a?o

t (t e? uma abreviac?a?o de tk[j]) esta? associada uma durac?a?o l(t) e uma ma?quina m(t). O

problema e? encontrar um escalonamento para as operac?o?es que otimize uma dada func?a?o

objetivo. Esse escalonamento deve obedecer a? ordem das operac?o?es nas tarefas e na?o pode

permitir que a mesma ma?quina execute mais de uma operac?a?o simultaneamente. A relac?a?o

entre o JSP e o EDP pode ser observada considerando-se as tarefas como poc?os de petro?leo,

e as operac?o?es das tarefas como as atividades dos poc?os. A relac?a?o de precede?ncia entre

atividades dos poc?os corresponde a? ordem das operac?o?es das tarefas. Os recursos do EDP

seriam as ma?quinas que executam as operac?o?es no JSP. Note, entretanto, que o EDP e? um

problema bem mais complexo que o JSP, ja? que as atividades na?o te?m necessariamente um

recurso determinado para executa?-las. Ale?m disso, uma soluc?a?o do EDP deve satisfazer a

muitas e variadas restric?o?es e sua func?a?o objetivo e? a maximizac?a?o da produc?a?o de petro?leo.

Com base nessa relac?a?o, do Nascimento (2002) provou que uma versa?o mais simples do

EDP e? NP-dif??cil.

2.4 Histo?rico

Para o entendimento da magnitude do problema e de sua importa?ncia para a Petrobras,

apresentamos um breve histo?rico das etapas do desenvolvimento do projeto:

• In??cio de 2000: Ocorrem as primeiras reunio?es entre engenheiros da E&amp;amp;P (Explorac?a?o

e Produc?a?o) e desenvolvedores da TI (Tecnologia da Informac?a?o), ambas a?reas da

Petrobras. O problema e? formalmente descrito e inicia-se um estudo de como resolve?-

lo de forma automa?tica. Ate? enta?o, ele e? resolvido manualmente por engenheiros

especialistas da Petrobras.

• Meados de 2000: A Petrobras contrata uma mestranda do INPE especialista em

heur??sticas e inicia contatos com a UNICAMP (Moura &amp;amp; de Souza (2000)).

• In??cio de 2001: Os professores doutores Arnaldo Vieira Moura e Cid Carvalho de

Souza fazem reunio?es com os graduandos Romulo Albuquerque Pereira e Vin??cius

Jose? Fortuna e lhes explicam o problema.

• Meados de 2001: Aprovadas as bolsas de IC (Iniciac?a?o Cient??fica) para os alunos

Romulo e Vin??cius, que iniciam os primeiros trabalhos em relac?a?o ao problema. A

Petrobras, por sua vez, inicia trabalhos pro?prios para lidar com o problema.



2.4. Histo?rico 11

• In??cio de 2002: Juliana Martins do Nascimento inicia seu Mestrado atacando o mesmo

problema.

• Meados de 2002: Fim da IC de Romulo e Vin??cius. O primeiro desenvolveu modelos

matema?ticos, que se mostraram ruins para o problema, e modelos de programac?a?o por

restric?o?es (Pereira et al. (2002)). O segundo desenvolveu uma eficiente ferramenta que

utiliza da Busca Tabu para resoluc?a?o do problema (Fortuna et al. (2002)). Romulo

passa a trabalhar como terceirizado na Petrobras, cuidando do desenvolvimento da

ferrramenta que a Petrobras vinha fazendo.

• In??cio de 2003: Romulo inicia seu mestrado no mesmo problema, pore?m com mais

restric?o?es e dados reais.

• Fim de 2003: Juliana defende sua tese de mestrado, mostrando uma ferramenta

h??brida que utiliza programac?a?o por restric?o?es e busca tabu para atacar o problema

(do Nascimento (2002)). Como a Petrobras, voltada para seu pro?prio desenvolvi-

mento, na?o mais manteve contato, Juliana resolveu um problema parcial, incompleto

e mais simples.

• Meados de 2004: Romulo termina sua ferramenta GRASP para o EDP. A Petrobras

requisita que se considere o deslocamento de recursos.

• In??cio de 2005: Artigo do EDP e? aprovado no 4th International Workshop on Efficient

and Experimental Algorithms6 (WEA2005). Romulo vai apresentar o trabalho na

confere?ncia, realizada na ilha de Santorini, Gre?cia. O trabalho e? publicado no livro

Pereira et al. (2005a). Finda-se tambe?m um GRASP para o EDP com deslocamento

de recursos (EDPDR).

• Meados de 2005: Artigo do EDPDR sagra-se um dos vencedores do Pre?mio Petrobras

de Tecnologia7. A ferramenta desenvolvida e? incorporada ao ORCA, ferramenta da

Petrobras para o EDPDR, e passa a ser utilizada pelos engenheiros da Petrobras em

processos da Bacia de Campos e Bacia do Esp??rito Santo.

• Fim de 2005: Submissa?o do artigo do EDPDR ao Journal of Heuristics8. A tese de

mestrado de Romulo e? redigida.

6http://ru1.cti.gr/wea05/
7http://www2.petrobras.com.br/tecnologia2/port/pptecnologia.asp
8http://www.kluweronline.com/issn/1381-1231



Parte II

Fundamentos Teo?ricos

13



Cap??tulo 3

GRASP

Neste projeto foi utilizada a metodologia GRASP para buscar soluc?o?es para o problema

tratado. Alguns artigos de refere?ncia do GRASP sa?o: Resende &amp;amp; Ribeiro (2002), Souza

et al. (2004), Binato &amp;amp; Oliveira (2002), Faria et al. (2005), Srinivasan et al. (2000), Ribeiro

(2002) e Festa &amp;amp; Resende (2002).

A metodologia GRASP (Greedy Randomized Adaptive Search Procedure) e? um processo

iterativo, onde cada iterac?a?o consiste de 2 fases, Construc?a?o e Busca Local. A fase

Construc?a?o constro?i uma soluc?a?o fact??vel, onde a vizinhanc?a e? explorada posteriormente

pela fase Busca Local, sendo este processo realizado por diversas iterac?o?es. A melhor

soluc?a?o dentre todas iterac?o?es do GRASP e? selecionada como resultado final.

1: procedure GRASP(ListSize, MaxIter, Seed)
2: for k = 1 to MaxIter do
3: Solution ? Construct Solution(ListSize, Seed);
4: Solution ? Local Search(Solution);
5: Update Solution(Solution, Best Solution F ound);
6: end for
7: return Best Solution F ound;
8: end GRASP

Figura 3.1: Pseudo-co?digo da Metaheur??stica GRASP

A Figura 3.1 ilustra uma implementac?a?o gene?rica do bloco principal do GRASP, em

pseudo-co?digo. As entradas para o algoritmo incluem para?metros para o ajuste do tamanho

da lista de candidatos (ListSize), nu?mero ma?ximo de iterac?o?es do GRASP (MaxIter), ale?m

da semente aleato?ria (Seed) para uso inicial na gerac?a?o de valores aleato?rios. As iterac?o?es

do GRASP sa?o mostradas nas linhas 2 a? 6. Cada iterac?a?o do GRASP, como dito anteri-

ormente, consiste de uma fase Construc?a?o (Construct Solution), linha 3, uma fase Busca

15



16 Cap??tulo 3. GRASP

Local (Local Search), linha 4 e, se necessa?rio, uma atualizac?a?o da soluc?a?o encontrada, linha

5. O algoritmo Construct Solution gera uma soluc?a?o fact??vel para o problema, atualizando

a varia?vel Solution. De posse da soluc?a?o fact??vel gerada, o algoritmo Local Search procura

por uma soluc?a?o melhor visando a minimizac?a?o ou a maximizac?a?o de uma func?a?o objetivo,

e atualiza a varia?vel Solution. O algoritmo Update Solution compara a soluc?a?o encontrada

com a soluc?a?o armazenada, que e? a melhor soluc?a?o dentre todas que ja? foram encontradas.

Caso a soluc?a?o gerada seja melhor que a atualmente armazenada, este substitui a soluc?a?o

armazenada pela soluc?a?o atual. Este processo de Construc?a?o, Busca e Atualizac?a?o e? reali-

zado um nu?mero MaxIter de vezes relativamente grande, a fim de procurar obter a melhor

soluc?a?o poss??vel para o problema.

Fase Construc?a?o

Na fase Construc?a?o e? constru??da uma soluc?a?o fact??vel, um elemento de cada vez. Em cada

iterac?a?o da Construc?a?o, o pro?ximo elemento a ser adicionado e? determinado ordenando-

se todos os poss??veis elementos em uma lista de candidatos com respeito a uma func?a?o

gulosa (greedy) que mede o benef??cio de selecionar cada elemento. Esta lista e? chamada de

RCL (Restricted Candidate List). A componente adapta?vel da heur??stica vem do fato de

que os benef??cios associados com cada elemento sa?o atualizados em cada iterac?a?o da fase

Construc?a?o a fim de refletir as alterac?o?es incorporadas pela selec?a?o dos elementos anteriores.

A componente probabil??stica do GRASP e? caracterizada pela escolha aleato?ria de um dos

melhores candidatos da RCL, mas geralmente na?o o melhor deles. Esta maneira de realizar

a escolha permite a obtenc?a?o de diferentes soluc?o?es para cada iterac?a?o do GRASP, na?o

necessariamente descaracterizando a componente gulosa adapta?vel. As soluc?o?es geradas

pela fase Construc?a?o do GRASP na?o sa?o garantidamente o?timas com respeito a?s definic?o?es

da vizinhanc?a. Portanto, e? quase sempre bene?fico aplicar uma busca local para tentar gerar

uma soluc?a?o melhor.

A Figura 3.2 ilustra uma implementac?a?o gene?rica do bloco Construc?a?o do GRASP, em

pseudo-co?digo. As entradas para o algoritmo incluem para?metros para o ajuste do tamanho

da lista de candidatos (ListSize), ale?m da semente aleato?ria (Seed) para uso inicial na

gerac?a?o de valores aleato?rios. As iterac?o?es do bloco Construc?a?o sa?o mostradas nas linhas

de 2 a? 8.

Conforme mencionado anteriormente, este algoritmo constro?i uma soluc?a?o fact??vel atra-

ve?s da avaliac?a?o incremental dos poss??veis candidatos, selecionando os candidatos dentre

aqueles inclu??dos na RCL. A selec?a?o de um candidato s da lista e? realizada aleatoriamente

e a varia?vel Solution e? atualizada, incluindo-se o candidato selecionado. De posse deste

candidato, e? realizada uma reavaliac?a?o incremental do custo da soluc?a?o. Este processo

termina quando uma soluc?a?o e? determinada.



17

1: procedure Construct Solution(ListSize, Seed)
2: Solution ? 0;
3: Evaluate the incremental costs of the candidate elements;
4: while Solution is not a complete solution do
5: Build the RCL(ListSize);
6: Select an element s f rom the RCL at random;
7: Solution ? Solution ? {s};
8: Reevaluate the incremental costs;
9: end while

10: return Solution;
11: end Construct Solution

Figura 3.2: Pseudo-co?digo da Fase Construc?a?o

Fase Busca Local

Um algoritmo de busca local funciona de um modo iterativo, sucessivamente trocando a

soluc?a?o atual por uma soluc?a?o melhor de sua vizinhanc?a. O algoritmo termina quando na?o

e? encontrada soluc?a?o melhor na vizinhanc?a com respeito a? func?a?o objetivo.

A Figura 3.3 ilustra uma implementac?a?o gene?rica da Busca Local do GRASP em pseudo-

co?digo. A entrada para o algoritmo inclui como para?metro a Soluc?a?o encontrada na fase

Construc?a?o (Solution). As iterac?o?es da Busca Local sa?o mostradas nas linhas de 2 a? 4.

1: procedure Local Search(Solution)
2: while Solution is not locally optimal do
3: F ind s? ? N (Solution) with f (s?) &amp;lt;f (Solution);
4: Solution ? s?;
5: end while
6: return Solution;
7: end Local Search

Figura 3.3: Pseudo-co?digo da Fase Busca Local

Este algoritmo procura otimizar a soluc?a?o encontrada na fase Construc?a?o atrave?s da

busca de um vizinho melhor s?, isto e?, um elemento de menor (minimizac?a?o) ou maior (ma-

ximizac?a?o) valor segundo a func?a?o objetivo. Esta busca na vizinhanc?a pode ser implemen-

tada usando-se tanto a estrate?gia “best-improving” quanto a estate?gia “first-improving”.

No primeiro caso, best-improving, todos os vizinhos sa?o analisados e o melhor dentre eles e?

selecionado. Ja? na estrate?gia first-improving, a selec?a?o e? realizada para o primeiro candidato

que apresentar um valor melhor para a func?a?o objetivo, sendo a soluc?a?o atual atualizada



18 Cap??tulo 3. GRASP

para este valor.

Aplicac?o?es do GRASP

A metaheur??stica GRASP tem sido aplicada com sucesso em diversos tipos de problemas

de otimizac?a?o combinato?ria, incluindo-se, set covering, quadratic assigment, roteamento

de ve??culos, problemas de localizac?a?o, conjunto ma?ximo independente, feedback vertex set,

planejamento de rede de transmissa?o, e planarizac?a?o de grafos, entre outros. Para uma

bibliografia detalhada, vide Festa &amp;amp; Resende (2002).



Cap??tulo 4

Programac?a?o por Restric?o?es

O trabalho Jaffar &amp;amp; Lassez (1987) estabeleceu os fundamentos teo?ricos a partir dos quais di-

versas linguagens de programac?a?o por restric?o?es puderam ser desenvolvidas1. A ide?ia ba?sica

e? substituir o mecanismo de infere?ncia lo?gica tradicional (unificac?a?o) por um mecanismo

mais gene?rico e eficiente, conhecido como manipulac?a?o de restric?o?es. Este mecanismo ja? e?

usado no campo da Intelige?ncia Artificial desde a de?cada de 80, na resoluc?a?o dos chamados

Constraint Satisfaction Problems. (CSPs). Um CSP e? composto por

• Um conjunto de varia?veis X = {x1, ..., xn};

• Para cada varia?vel xi, um conjunto finito de valores, Di, denominado seu dom??nio;

• Um conjunto de restric?o?es, C, que atuam sobre subconjuntos das varia?veis de X,

limitando os valores que lhes podem ser atribu??dos.

Uma soluc?a?o para um CSP e? uma atribuic?a?o de valores a?s varia?veis de X, obedecendo

as restric?o?es de C.

Muitos problemas em Pesquisa Operacional, tais como escalonamento de tarefas, aloca-

c?a?o de hora?rios e outros problemas combinato?rios podem ser representados como CSPs,

e a Programac?a?o por Restric?o?es vem se afirmando como uma ferramenta poderosa para

abordar tais problemas (Lever et al. (1995), Le Pape (1994), Hasle et al. (1997), Yunes

et al. (2000a) e Yunes et al. (2000b)).

Um programa em Programac?a?o por Restric?o?es geralmente obedece a? estrutura apresen-

tada na Tabela 4.1. Note que essa estrutura se assemelha a um CSP.

As varia?veis com seus dom??nios definem o espac?o de soluc?o?es. As restric?o?es estabelecem

relac?o?es entre as varia?veis, limitando os valores que elas podem assumir concomitantemente

1Entretanto, vale ressaltar que desde a de?cada de 60 ja? existem linguagens que lidam com restric?o?es.

19



20 Cap??tulo 4. Programac?a?o por Restric?o?es

&lt;Declarac?a?o de Varia?veis e Dom??nios&gt;
&lt;Imposic?a?o de Restric?o?es&gt;

&lt;Busca por Soluc?o?es (labeling)&gt;

Tabela 4.1: Estrutura ba?sica de um programa em Programac?a?o por Restric?o?es

e reduzindo o espac?o de busca. Essa reduc?a?o se processa atrave?s de um mecanismo deno-

minado propagac?a?o de restric?o?es, cuja func?a?o e? garantir a consiste?ncia parcial do sistema

como um todo.

O mecanismo de propagac?a?o de restric?o?es funciona da seguinte forma. Sempre que

o dom??nio de uma varia?vel e? alterado, e.g. pela remoc?a?o de um de seus elementos, esta

informac?a?o e? transmitida (propagada) para as demais varia?veis associadas a ela por uma ou

mais restric?o?es. Durante esse processo, procura-se sempre manter a consiste?ncia do sistema,

i.e. a satisfac?a?o das restric?o?es do programa. Por exemplo: sejam X e Y varia?veis que podem

assumir valores inteiros no intervalo (dom??nio) [1, 10]. Isto significa que, inicialmente, os

dom??nios de X e Y sa?o os mesmos: DX = DY = [1, 10]. Impondo-se a restric?a?o de que

X &amp;lt;Y , os dom??nios se alteram para DX = [1, 9] e DY = [2, 10]. Isto porque, se X = 10 e

X &amp;lt;Y , conclui-se que Y ? 11. Contudo 11 na?o pertence ao dom??nio de Y . Analogamente,

mostra-se que Y na?o pode receber o valor 1. Suponha agora que a restric?a?o X ? 5 seja

imposta. Isto faz com que DX = [5, 9]. Como Y esta? relacionada a X pela restric?a?o X &amp;lt;Y ,

o dom??nio de Y e? automaticamente alterado para DY = [6, 10].

A consiste?ncia do sistema e? dita parcial porque na?o ha? algoritmos polinomiais conheci-

dos que garantam a consiste?ncia total de um CSP gene?rico2 (Marriott &amp;amp; Stuckey (1998)).

Ale?m disso, por questo?es de eficie?ncia, os algoritmos normalmente utilizados para detectar

violac?o?es das restric?o?es na?o sa?o capazes de identificar certos tipos de estados inconsistentes.

Um desses algoritmos, denominado arc-consistency, funciona assim: sejam duas varia?veis,

A e B, relacionadas por uma restric?a?o r, e cujos dom??nios sa?o, respectivamente, DA e DB.

Diz-se que um valor vA ? DA tem suporte no dom??nio DB se, ao atribuir-se va a A, existir

um valor vB ? DB que pode ser atribu??do a B sem violar r. O algoritmo, enta?o, removera?

do dom??nio de cada varia?vel todos aqueles valores que na?o te?m suporte no dom??nio de uma

outra varia?vel qualquer, associada a ela por alguma restric?a?o (Marriott &amp;amp; Stuckey (1998)).

Em resumo, o que acontece e? o seguinte: os dom??nios originais das varia?veis sa?o inicial-

mente reduzidos pelas restric?o?es do programa. Neste instante, e? poss??vel que haja alguma

inconsiste?ncia ainda na?o detectada. A seguir, da?-se in??cio ao processo de labeling (vide Ta-

bela 4.1) onde, a cada passo, seleciona-se uma varia?vel a? qual sera? atribu??do um valor de seu

dom??nio. A ordem de escolha das varia?veis e dos valores e? totalmente flex??vel e influencia

2CSPs pertencem a? classe de problemas NP-completos.



21

no tempo de resposta do programa. Ao se atribu??rem valores a?s varia?veis, o mecanismo de

propagac?a?o se encarrega de reduzir os outros dom??nios. Caso alguma inconsiste?ncia seja

detectada, a u?ltima atribuic?a?o de valor tem de ser desfeita (backtracking), dando lugar a

uma outra alternativa. O processo todo se repete ate? que uma soluc?a?o seja encontrada ou

ate? que se prove a inexiste?ncia de soluc?o?es via?veis (Marriott &amp;amp; Stuckey (1998), Lever et al.

(1995)).

Em certos casos, procura-se na?o somente uma soluc?a?o via?vel qualquer, mas aquela que

minimiza (ou maximiza) uma func?a?o objetivo. Uma forma de dar suporte ao conceito

de otimizac?a?o em Programac?a?o por Restric?o?es e? a seguinte. Sempre que uma soluc?a?o e?

encontrada, calcula-se o seu custo c e impo?e-se uma nova restric?a?o ao sistema indicando

que o custo da pro?xima soluc?a?o devera? ser menor que c (em caso de minimizac?a?o). Repete-

se este processo ate? que na?o haja mais soluc?o?es via?veis. Nesse ponto, a u?ltima soluc?a?o

encontrada e? uma soluc?a?o de custo o?timo (Marriott &amp;amp; Stuckey (1998), Lever et al. (1995)).

Um grande desafio da programac?a?o por restric?o?es e? a criac?a?o de um modelo que repre-

sente adequadamente as condic?o?es reais de um problema. Um modelo ruim, por exemplo,

pode gerar soluc?o?es erro?neas ou na?o satisfato?rias, e ate? mesmo na?o levar a uma soluc?a?o.

O modelo, portanto, sera? um fator que determinara? o tempo de resposta do programa e a

qualidade da soluc?a?o gerada.



Parte III

O Trabalho Desenvolvido

23



Cap??tulo 5

ORCA: Resolvedor de Programac?a?o

por Restric?o?es

Em 2000, um consultor da a?rea de Explorac?a?o e Produc?a?o (E&amp;amp;P) da Petrobras decidiu

criar um projeto para automatizar o processo de escalonamento das atividades de desenvol-

vimento de poc?os de petro?leo em alto mar e seus respectivos recursos (barcos e sondas), ate?

enta?o feito manualmente. A ferramenta tambe?m deveria otimizar a produc?a?o de petro?leo.

Algumas ana?lises foram conduzidas e o time de projeto desenvolveu um modelo de

Programac?a?o por Restric?o?es (cf., Marriott &amp;amp; Stuckey (1998)) usando as bibliotecas ILOG

Solver e ILOG Scheduler (ILOG (1999a)). Essas bibliotecas permitem fa?cil modelagem,

manutenc?a?o e entendimento do co?digo.

Depois de quatro anos de desenvolvimento, alterac?o?es, correc?o?es e melhorias, a ferra-

menta desenvolvida, de nome ORCA (“Otimizac?a?o de Recursos Cr??ticos na Atividade de

produc?a?o”), tornou-se operacional e bem sucedida.

As pro?ximas sec?o?es descrevem o modelo e os algoritmos utilizados no desenvolvimento

do ORCA.

5.1 Modelo do ORCA

A modelagem do ORCA foi feita utilizando o ILOG Solver e o ILOG Scheduler, bibliotecas

C++ de Programac?a?o por Restric?o?es da ILOG 1. Usando tal abordagem, a representac?a?o do

problema e? feita desassociada dos algoritmos usados para resolve?-lo, dessa forma oferecendo

facilidade de desenvolvimento, entendimento e adaptac?a?o (ILOG (1999b)).

O modelo consiste de dois tipos de varia?veis, ambos inteiros:

1http://www.ilog.com

25



26 Cap??tulo 5. ORCA: Resolvedor de Programac?a?o por Restric?o?es

(a) Tela Inicial (b) Tela de Busca de Soluc?a?o

Figura 5.1: ORCA

• Um que representa a data de in??cio de execuc?a?o da atividade por um recurso. E?

caracterizado por um m??nimo e ma?ximo tempo de in??cio.

• Um que representa qual recurso executara? a atividade do poc?o. E? caracterizado por

um conjunto de poss??veis recursos, dos quais um deve ser escolhido para realizar a

respectiva atividade.

Todas as restric?o?es descritas na Sec?a?o 2.2 foram impostas sobre as varia?veis descritas

acima atrave?s de me?todos predefinidos das classes da ILOG. Por examplo, sendo a e b

atividades representadas por objetos da classe ILOG IlcActivity e seja P1 o modelo repre-

sentado pela classe ILOG IlcManager, estabelecemos que a deve iniciar depois do fim de b

atrave?s do seguinte co?digo:

P1.add(a.startsAfterEnd(b));

O mecanismo de propagac?a?o das restric?o?es, responsa?vel pela reduc?a?o de dom??nio das

varia?veis, fica a cargo das bibliotecas da ILOG. Entretanto, a simples propagac?a?o das

restric?o?es na?o e? suficiente para se chegar a um valor u?nico nas varia?veis. Dessa forma,

faz-se necessa?rio utilizar de um algoritmo de busca para encontrar soluc?o?es.



5.1. Modelo do ORCA 27

5.1.1 Algoritmos do ORCA

As bibliotecas da ILOG prove?m na?o apenas um algoritmo de busca gene?rico, mas tambe?m

meios para se desenvolver um me?todo de busca pro?prio.

No ILOG Solver, a implementac?a?o de algoritmos de busca e? baseado na ide?ia de go-

als. Goals tornam poss??vel a implementac?a?o de algoritmos em que a exata seque?ncia de

operac?o?es na?o e? conhecida antecipadamente. Esse tipo de programac?a?o e? frequ?entemente

conhecida como na?o-determin??stica, ja? que seus passos na?o esta?o determinados, ainda que

a programac?a?o tenha um propo?sito ou objetivo (goal) em vista.

O mecanismo de busca explora o seguinte algoritmo: Enquanto existir alguma varia?vel

sem valor fixo,

1. escolha uma dessas varia?veis;

2. atribua a? varia?vel um dos valores do seu dom??nio;

3. propague os efeitos dessa atribuic?a?o.

Entretanto, na?o se sabe qual valor no dom??nio e? consistente com as restric?o?es. Assim,

se a atribuic?a?o levar a? inconsiste?ncias, ela deve ser desfeita e outro valor deve ser tentado.

Tal processo e? conhecido como backtracking.

5.1.2 Func?a?o Objetivo

A Petrobras na?o quer apenas uma soluc?a?o para o problema, mas uma soluc?a?o que maximize

a produc?a?o de petro?leo. Para isso, o ILOG Solver oferece meios predefinidos para minimizar

ou maximizar um crite?rio. A te?cnica usada no Solver e? o cla?ssico Branch &amp;amp; Bound (Cormen

et al. (2001)).

Para realizar a otimizac?a?o, a implementac?a?o da biblioteca ILOG segue o seguinte algo-

ritmo:

1. Busque uma soluc?a?o da forma definida pelos goals inseridos no modelo.

2. Salve a soluc?a?o encontrada.

3. Acrescente a restric?a?o que estabelece que a pro?xima soluc?a?o deve ser pelo menos uma

unidade melhor que a soluc?a?o encontrada anteriormente.

4. Repita o processo ate? que nenhuma outra soluc?a?o seja encontrada ou ate? que o tempo

de busca se esgote.

Assim, ate? o fim da busca, teremos a melhor soluc?a?o encontrada, a com a maior produc?a?o

de petro?leo.



28 Cap??tulo 5. ORCA: Resolvedor de Programac?a?o por Restric?o?es

5.1.3 Te?cnicas de Busca

O ILOG Solver implementa va?rios procedimentos de busca de pesquisa operacional e in-

telige?ncia artificial, tais como best first search (BFS), limited discrepancy search (LDS),

depth bounded discrepancy search (DDS), e interleaved depth first search (IDFS). Esses

procedimentos de busca mudam a ordem na qual os no?s da a?rvore de busca sa?o explorados.

A biblioteca implementa uma representac?a?o impl??cita dos estados de busca para arma-

zenar va?rios estados a serem explorados. Essa representac?a?o envolve um caminho na a?rvore

bina?ria de busca. O caminho consiste de uma seque?ncia de deciso?es — esquerda e direita

— na a?rvore de busca. A busca vai de uma posic?a?o na a?rvore para outra atrave?s de uma

combinac?a?o de backtracking e recomputac?a?o (Clocksin (1987)).

A busca do Solver trabalha assim: no?s abertos (isto e?, no?s que podem ser explorados) sa?o

guardados numa pilha, e, a cada passo, o Solver escolhe o melhor no? aberto de acordo com

uma func?a?o de avaliac?a?o e o explora. O Solver implementa func?o?es de avaliac?a?o predefinadas

para as seguintes te?cnicas de busca:

• Depth First Search (DFS) e? o procedimento de busca padra?o do ILOG Solver. DFS

considera as arestas de sa??da de um ve?rtice antes que os vizinhos daquele ve?rtice. O

maior problema do DFS e? que ele na?o se recupera de ma?s escolhas iniciais. Uma ma?

decisa?o tomada no in??cio pode levar a busca a percorrer inu?meros estados inconsis-

tentes ou de baixa qualidade.

• Best First Search (BFS) e? um algoritmo de busca que otimiza o Breadth First Search2

via ordenac?a?o de todos os caminhos correntes de acordo com alguma heur??stica. A

heur??stica tenta predizer qua?o perto o caminho esta? de alcanc?ar uma soluc?a?o. Ca-

minhos que sa?o tidos como mais pro?ximos de uma soluc?a?o sa?o explorados primeiro

(Nilsson (1971)). A implementac?a?o do Solver usa um para?metro ?. Ao selecionar um

no? aberto, o Solver determina o conjunto de no?s abertos cujo custo e? no ma?ximo 1 + ?

pior que o melhor no? aberto. Se o filho do no? corrente esta? nesse conjunto, o Solver

explora esse filho. Se na?o, o Solver escolhe o melhor no? aberto.

• Limited Discrepancy Search (LDS) foi definido em Harvey &amp;amp; Ginsberg (1995). A

discrepa?ncia de um no? de busca e? definida como sua profundidade direita, isto e?, o

nu?mero de vezes que a busca escolheu a ramificac?a?o direita em um ponto de escolha

(choice point) quando ia do no? raiz ate? o no? corrente. Dado um para?metro k, a busca

vai primeiro explorar no?s com discrepa?ncia menor que k. Depois que essa explorac?a?o

for completada, ele ira? explorar no?s com discrepa?ncia entre k e 2k, e assim por diante.

Dessa forma, essa busca corta a a?rvore de busca em tiras.

2Breadth first search e? um algoritmo de busca em a?rvore que comec?a no no? raiz e explora todos os no?s
vizinhos, e so? depois seus filhos.



5.1. Modelo do ORCA 29

• Depth Bounded Discrepancy Search (DDS) foi introduzido em Walsh (1997). Uma

variac?a?o do LDS, o DDS assume que ma?s escolhas sa?o provavelmente tomadas mais

pro?ximo do topo da a?rvore de busca. Por isso, esse procedimento na?o conta o nu?mero

de discrepa?ncias, mas a profundidades da u?ltima. O ILOG Solver implementa uma

versa?o aprimorada do esquema em Walsh (1997); na?o se conta a profundidade da

u?ltima discrepa?ncia, mas a da d-e?sima u?ltima, onde d e? um para?metro da busca.

• Interleaved Depth First Search (IDFS) foi introduzido em Meseguer (1997). IDFS

tenta imitar o comportamento de um nu?mero infinito de threads explorando a a?rvore

de busca. O Solver implementa uma variac?a?o que limita a profundidade deste com-

portamento.

Todas esses procedimentos de busca foram testados em insta?ncias reais do EDP. O BFS

se provou ineficiente para o problema. Em quase todas as insta?ncias, ele na?o gerou soluc?o?es

dentro da primeira hora de execuc?a?o. O DFS e o IDFS se mostraram bem melhores, mas os

melhores resultados foram obtidos usando o LDS e o DDS. Nos testes, o LDS foi levemente

superior ao DDS, ale?m de ser mais flex??vel. Isso porque o DDS e? eficiente se a heur??stica de

busca e? muito boa, i.e., se ela faz ma?s escolhas apenas no topo da a?rvore de busca (ILOG

(1999a)), o que e? algo dif??cil de se obter.

5.1.4 Goals para Escalonar as Atividades

Apresentamos agora os goals criados para guiar o processo de busca. Eles sa?o executados

na ordem em que sa?o apresentados:

1. Escolhendo os recursos: Este goal seleciona para cada atividade o recurso dis-

pon??vel que menos foi utilizado ate? o momento.

2. Tratando a restric?a?o C7: Caso haja seque?ncias de poc?os, este goal atribui datas de

in??cio de execuc?a?o para as atividades das seque?ncias. Na ordenac?a?o das atividades,

ele seleciona a varia?vel dispon??vel entre aquelas das seque?ncias que ainda na?o foi

atribu??da e que gera o maior incremento na produc?a?o de petro?leo. Da?-se prefere?ncia

a?s atividades de perfurac?a?o em detrimento das de produc?a?o.

3. Escalonando atividades de produc?a?o: Este goal atribui datas de in??cio de execu-

c?a?o para as atividades de in??cio de produc?a?o. Na ordenac?a?o das atividades, ele seleci-

ona a varia?vel dispon??vel na?o atribu??da que gera o maior incremento na produc?a?o de

petro?leo.



30 Cap??tulo 5. ORCA: Resolvedor de Programac?a?o por Restric?o?es

4. Escalonando as outras atividades: Este goal atribui a data de in??cio de todas as

atividades restantes. Na ordenac?a?o das atividades, ele seleciona a primeira ainda na?o

atribu??da.

5.1.5 Resultados do ORCA

O ORCA foi frequ?entemente utilizado por engenheiros da Petrobras para definir bons esca-

lonamentos no desenvolvimento dos poc?os de petro?leo em alto mar. Foi tambe?m usado para

analisar a necessidade de se adquirir ou alugar novos recursos. Esses usua?rios confirmaram

que o ORCA gera soluc?o?es pelo menos ta?o boas quanto as manuais. E, ale?m disso, demanda

apenas um minuto de execuc?a?o para gerar um bom escalonamento, quando manualmente

se demorava de um a dois dias. Em uma de suas utilizac?o?es numa insta?ncia real, o ORCA

mostrou ser melhor acrescentar um barco LSV a? comprar uma terceira sonda. Com isso, o

ORCA assegurou ganhos de US$15 milho?es a? Petrobras, e antecipou o in??cio de produc?a?o

dos poc?os em 26 dias.



Cap??tulo 6

O EDP sem Deslocamento de

Recursos

Pro?logo

O artigo a seguir trata o problema de escalonamento no desenvolvimento de poc?os de

petro?leo em alto mar (EDP), na?o sendo considerados deslocamentos de recursos.

Apo?s uma descric?a?o detalhada do problema e das restric?o?es envolvidas, e? apresentado um

resolvedor GRASP que supera uma ferramenta de programac?a?o por restric?o?es desenvolvida

pela Petrobras.

Este artigo e? uma versa?o reduzida do relato?rio te?cnico Pereira et al. (2005b) e foi apre-

sentado na confere?ncia Fourth International Workshop on Efficient and Experimental Al-

gorithms (WEA2005, http://ru1.cti.gr/wea05/), que ocorreu na ilha de Santorini, Gre?cia,

nos dias 10 a 13 de maio de 2005. O trabalho foi um dos 47 artigos regulares aceitos

dentre 176 submetidos e foi publicado no volume 3503 da se?rie Lecture Notes in Computer

Science, que conte?m os anais da confere?ncia (Pereira et al. (2005a)). Convidado, Romulo

foi apresentar seu trabalho na confere?ncia, tendo excelente receptividade pela comunidade

presente. O artigo tambe?m esta? sendo considerado para o Special Issue of the ACM Journal

on Experimental Algorithmics (JEA, http://www.jea.acm.org), dedicado ao evento.

O artigo esta? transcrito na sua ??ntegra, em ingle?s.

31



32 Cap??tulo 6. O EDP sem Deslocamento de Recursos

Comparative Experiments with GRASP and

Constraint Programming for the Oil Well Drilling

Problem

Romulo A. Pereira Arnaldo V. Moura Cid C. de Souza

romulo a pereira@yahoo.com.br arnaldo@ic.unicamp.br cid@ic.unicamp.br

Institute of Computing, University of Campinas

Abstract

Before promising locations become productive oil wells, it is often necessary to com-

plete drilling activities at these locations. The scheduling of such activities must

satisfy several conflicting constraints and attain a number of goals. Here, we describe

a Greedy Randomized Adaptive Search Procedure (GRASP) for the scheduling of oil

well drilling activities. The results are compared with those from a well accepted con-

straint programming implementation. Computational experience on real instances

indicates that the GRASP implementation is competitive, outperforming the con-

straint programming implementation.

1 Introduction

Oil extracted from oceanic basins is an increasingly important fraction of the total world

offer of petroleum and gas. Usually, diverse petroliferous basins are explored, each with

hundreds of promising spots where productive oil wells could be located. However, before

these places are turned into productive wells they must be developed, that is, a sequence of

engineering activities must be completed at each promising spot, to render them ready for

oil extraction. Oil derricks and ships are used to complete these activities. These resources

are limited and expensive, either in acquisition or rent value, and must be used efficiently.

The oil well drilling problem (WDP) can be summarized thus: given a set of promising

spots, the activities to be executed at each location, and the available resources, find a

scheduling of the activities and resources, fulfilling several conflicting engineering and op-

erational constraints, in such a way as to optimize some objective criteria. In this work,

the specific WDP faced by Petrobras (a leading company in deep water oil extraction) is

studied. This WDP imposes much more realistic constraints than other similar studies



2. The Well Drilling Problem 33

(do Nascimento (2002)). The constraints are presented in detail, and an heuristic strategy

is developed in order to maximize oil production within a given time horizon.

The next section describes the WDP. Section 3 discusses a GRASP implementation for

the WDP. Section 4 presents our computational results obtained with this new algorithm

and compares them to other results derived from a constraint programming implementation

presently running at Petrobras. Finally, some concluding remarks are offered in the last

section.

2 The Well Drilling Problem

After a well is drilled, the preparation for oil extraction develops in several stages. First,

oil derricks place Wet Christmas Trees (or WCTs, structures where hydraulic valves are

attached) at the mouth of the wells in order to avoid oil leakage. Later, boats connect

pipelines between WCTs and manifolds. Manifolds are metallic structures installed by

boats at the sea floor. Their use prevents the need for exclusive pipelines connecting each

well to the surface, which would be prohibitively expensive. Once this stage is completed,

oil extraction can begin. For that, Stationary Units of Production (SUPs) are anchored at

specific locations in the surface, and boats interconnect manifolds to them. SUPs are used

to process, and possibly store, the extracted products. Later, ships fetch the products from

SUPs to land storage sites or other processing units. If the oil outflow is very high or a SUP

does not have storage capacity, a petroliferous platform may be installed at the surface.

The constraints involved in the scheduling of oil development activities are:

C1. Technological Precedence: sets an order between pairs of activities. When considering

the precedence between the start and finish of the activities in each pair, any of the

four possibilities can be present.

C2. Mark-Activity: an activity must finish before or initiate after a fixed date, with or

without lag time. This date is often related to some external event.

C3. Baseline: sets the start date of the activities.

C4. Use of Resources: to execute an activity, due to its intrinsic nature, a resource used

must match some operational characteristics. For a boat, it must be verified if the

on-board equipments can operate at the specified depth. For an oil derrick, its type

and capabilities must be verified, as well as the maximum and minimum depth of

operation and drilling.

C5. Concurrence: two activities at the same well, or executed by the same resource,

cannot be simultaneous.



34 Cap??tulo 6. O EDP sem Deslocamento de Recursos

C6. Unavailability: resources may be unavailable for a period of time, either for mainte-

nance reasons or due to contract expiration.

C7. User Defined Sequences: the user can specify a sequence for the drilling or for the

“start production” activities of different wells. These sequences are specified by engi-

neers in order to avoid loss of pressure in the oil field. If well A appears before well B

in the sequence, then activity FA of well A must finish before the start of activity SB
of well B. The activities FA and SB are either the activity of drilling or the activity

of start production of their respective wells, according to the type of the sequence.

C8. Surface Constraints: represented by a polygonal security area defined around a well.

When a well is inside the restricted area of another well, activities executed at them

cannot be simultaneous. These constraints must be verified between pairs of mobile

and pairs of mobile and anchored oil derricks.

C9. Cluster Constraints: an activity can be part of a cluster, which is a set of activities

that must use the same resource.

C10. Same Derrick : it is desirable that the same oil derrick executes as much of the

activities at a well as possible, in order to avoid unnecessary displacements.

The oil yield is calculated as follows. Each well has an associated outflow and an activity

that marks the beginning of its production. When this last activity is concluded, the well is

considered in production. The yield is obtained by multiplying the oil outflow by the period

between that instant and the established time horizon. If the start production activity is

set for after the time horizon, the corresponding yield is disregarded. The objective is to

obtain a schedule of all activities, satisfying all constraints, while maximizing the oil yield.

Other goals to be attained by automating the schedule of the activities are:

1. Faster solutions. Human made solutions take many hours, even days, to be con-

structed. A faster method would permit the analysis of different scenarios for the

same problem, for example, by adding or removing resources. Furthermore, modifi-

cations in already committed plans would not result in new hours, or days, spent in

rescheduling.

2. Better resource allocation. With an automated scheduling, all highly skilled engineers

responsible for the manual scheduling can receive other duties.

From the above description, it can be seen that the WDP is a difficult combinatorial

problem. In fact, it is simple to devise a polynomial-time reduction to the classical Job

Shop Scheduling problem, showing that the WDP is NP-hard.



3. A GRASP for the WDP 35

The WDP treated here shows several differences from similar problems studied in the

literature (do Nascimento (2002)). To tackle the same problem, a project team from Petro-

bras developed a Constraint Programming (cf., Marriott &amp;amp; Stuckey (1998)) model using

ILOG’s Solver and Scheduler (ILOG (1999)). After four years of development and testing,

the tool, named ORCA (Portuguese acronym for “Optimization of Critical Resources in

the Production Activity”), became operational and very successful. Nowadays, the ORCA

solver is often used by engineers both to define a good schedule for the drilling activities

and, also, to analyze the need for acquiring or renting new resources. They confirmed that

ORCA generates better solutions than those made by humans. In one real instance, ORCA

showed that buying a third oil derrick was unnecessary and that it was better to add a new

LSV ship instead. As a result, Petrobras avoided a expenditure of US$ 15 million, while

anticipating oil production by 26 days. Despite the good performance of ORCA, searching

for even better solutions is still important, since a tenth of a percent of improvement in

the oil production may represent millions of dollars in the company’s revenue. The next

sections show how we obtain such gains using GRASP.

3 A GRASP for the WDP

Our search for alternatives to compete with ORCA started with an implementation of Tabu

Search (Glover &amp;amp; Laguna (1997)) for a simpler version of the WDP (do Nascimento (2002)).

However, some issues proved to be particularly difficult to treat, especially the definition of

an adequate neighborhood and ways to explore it. After some investigation, GRASP (Feo

&amp;amp; Resende (1995)) seemed most appropriate for the WDP. Contrary to what occurs with

other metaheuristics, such as tabu search or genetic algorithms, which use a large number of

parameters in their implementations, the basic GRASP version requires the adjustment of

fewer parameters. Despite its simplicity, GRASP is a well studied metaheuristic which has

been successfully applied to a wide variety of optimization problems (cf. Festa &amp;amp; Resende

(2001)). In particular, applications of GRASP to scheduling problems can be found in Aiex

et al. (2003), Bard &amp;amp; Feo (1989), Feo &amp;amp; Bard (1989), Feo et al. (1995) and Binato et al.

(2001).

The next paragraphs review some GRASP basics and describe our specific implemen-

tation designed to solve the WDP, named GRASP-WDP (GRASPW). The model and its

algorithms are shown in the subsequent paragraphs.

GRASP Basics. In the GRASP methodology each iteration consists of two phases: con-

struction and local search (Feo &amp;amp; Resende (1995)). Figure 1 illustrates a generic implemen-

tation of GRASP, in pseudo-code. The input includes parameters for setting the candidate

list size (ListSize), the maximum number iterations (MaxIter), and the seed (Seed) for the



36 Cap??tulo 6. O EDP sem Deslocamento de Recursos

random number generator. The iterations are carried out in lines 2-6. Each iteration con-

sists of the construction phase (line 3), the local search phase (line 4) and, if necessary, the

incumbent solution update (line 5). In the construction phase, a feasible solution is built,

updating the variable Solution. Then the local search algorithm seeks a better solution in

the neighborhood of Solution, according to a given criterion, and updates Solution. This

process of construction, search and update is executed MaxIter times.

1: procedure GRASP (ListSize, MaxIter, Seed)
2: for k = 1 a MaxIter do
3: Solution ? Construct Solution(ListSize, Seed);
4: Solution ? Local Search(Solution);
5: Update Solution(Solution, Best Solution F ound);
6: end for
7: return Best Solution F ound;
8: end GRASP

Figure 1: Pseudo-code of the GRASP Metaheuristic.

In the construction phase, a feasible solution is built one element at a time. Figure

2 illustrates a generic implementation of the construction phase, in pseudo-code. Input

includes the candidate list size (ListSize) and the seed (Seed). The iterations are carried

out in lines 2-8. At each iteration, the next element to be added is determined by adding

all possible elements to a candidate list, ordered with respect to a greedy function that

measures the, maybe myopic, benefit of selecting each element. This list is called the

Restricted Candidate List (RCL). The adaptive component of the heuristic arises from the

fact that the benefits associated with every element are updated at each iteration to reflect

the changes brought on by the selection of the element in the previous iteration. The

probabilistic component is present by the random choice of one of the best candidates in

the RCL, but usually not the best one. This way of choosing elements allows for different

solutions to be obtained at each iteration, while not necessarily jeopardizing the adaptive

greedy component. The solutions generated by the construction phase are not guaranteed

to be locally optimal. Hence, it is almost always beneficial to apply a local search to attempt

to improve each constructed solution. The search phase is a standard deterministic local

search algorithm that seeks to optimize the solution built in the construction phase.

The GRASPW Implementation. The GRASPW implementation was constructed us-

ing the C/C++ programming language. The heuristic uses two types of integer variables.

One represents the beginning of execution of each activity in the corresponding well. These

values range between a minimum and a maximum start time, with those values depending

on the current partial solution being constructed. The second type of variables represents



3. A GRASP for the WDP 37

1: procedure Construct Solution(ListSize, Seed)
2: Solution ? 0;
3: Evaluate the incremental costs of the candidate elements;
4: while Solution is not a complete solution do
5: Build the restricted candidate list, RCL(ListSize);
6: Select an element s f rom the RCL at random;
7: Solution ? Solution ? {s};
8: Reevaluate the incremental costs;
9: end while

10: return Solution;
11: end Construct Solution

Figure 2: Pseudo-code of the Construction Phase of GRASP.

which resource will execute each activity in its well. Their domains are characterized by a

set of the possible resources, of whose one must be chosen to execute the activity. All the

constraints described in Section 2 were enforced. Three constraints, namely, C2, C3 and

C4, were set while reading the problem data, before the search begins. Note that, in these

cases, all values needed to set the constraints are already defined. The other constraints

were dealt with during the search for solutions, the variables involved being assigned single

values.

The following adaptations were made to the procedure illustrated in Figure 1: (i) the

search procedure was interrupted by a time limit instead of by the number of iterations;

and (ii) During a complete run of the GRASPW heuristic, the value of ListSize can be

monotonically incremented by a fixed amount when a predefined interval of time is reached

with no improvement on the best solution. Doing so, the algorithm will explore larger

regions of the search space. Alternatively, during a run of GRASPW, the value of ListSize

can be monotonically decremented between iterations, thus focusing into a greedier heuris-

tic. With this scheme we obtain a dynamic sized RCL in opposition to the original static

sized RCL. Note that, as GRASP iterations are independent, one could think that there is

no difference between increasing and decreasing the RCL size. However, as we do not know

in advance the amount of time the algorithm will execute at each run or when the RCL

size will be altered, we can not anticipate the result of a GRASPW run, when increasing

or decreasing the RCL size.

As in the ORCA implementation, we seek solutions with the highest oil yield. To this

end the construction phase illustrated in Figure 2 was modified thus:

1. The first time ever the construction phase is initiated, we use ListSize equal to one,

when the algorithm behaves like a pure greedy heuristic. With few constraints ob-

structing the greedy heuristic, it tends to generate a good or even very good solution.



38 Cap??tulo 6. O EDP sem Deslocamento de Recursos

For example, in two out of twelve real instances, the best solution was found in the

first pass of the construction phase.

2. Before line 3, we added a function called isPressed. It verifies if any activity of any well

has a start time with a small domain and if only one resource can do it at that time.

By a start time with a small domain we mean that its minimum and maximum values

are very close, such that having only one resource able to execute it indicates that

there is almost no flexibility to schedule the activity. If there are such activities, the

function schedules their wells. Retarding the schedule of such activities could render

the solution infeasible, as other activities may occupy the period of time where those

activities would be scheduled. We schedule the wells, and not only the activities, in

order to comply with constraint C10.

3. The candidates are defined by the production wells that are available (meaning that

there are no wells yet not scheduled which must precede them), or the injection wells

that have activities of production wells succeeding them. The activities of injection

wells that do not have activities of production wells succeeding them are left to be

scheduled after all others. Note that injection wells are not productive and therefore

must not be scheduled before production wells, unless there are constraints forcing

such a schedule.

4. The evaluation of incremental costs (line 3 of Figure 2) assesses how much oil a well

can offer until the end of the time horizon. The RCL is built with those wells that

offer the highest yields of oil. Actually, not only the oil offer is considered, but also

the oil offer of the constrained successors of that well.

5. In the construction phase, the next element to be introduced in the solution is chosen

uniformly from the candidates in the RCL (line 5 of Figure 2). However, any proba-

bility distribution can be used to bias the selection.We tried to bias the selection of

the candidates proportionally to their oil offer.

6. To schedule the candidate well (line 7 of Figure 2), proceed as follows.

As long as there are activities not yet scheduled in the well: (i) choose any activity

available in the well, i.e., one not yet scheduled and such that there is no other one

not yet scheduled in the wells that must precede it; (ii) choose a resource for this

activity that can execute it, and that can complete the activity the earliest; (iii) set

the start time of the activity at the earliest possible time, i.e., the maximum between

the earliest time the resource is available to execute the activity and the minimum

start time of the activity; and (iv) all activities that are constrained to succeed the

chosen one must have their minimum start times updated to satisfy any constraints.



3. A GRASP for the WDP 39

The scheduling of a well is done so as to satisfy all constraints, including the seven

ones not yet enforced. In case of violations, and this can be tested after each activity

is scheduled, the construction of this solution is aborted and a new one is started. In-

stead, we could backtrack a few steps, but this would slow down this phase, especially

if the first steps were not appropriate.

7. After a well is scheduled, any activities that must succeed it has their minimum start

time updated to satisfy any constraints. If that is not possible, the construction of

this solution is also aborted.

For the search phase, an appropriate neighborhood was defined, so as to permit explo-

rations quickly leading to better solutions. The 2-exchange local search algorithm based on

the disjunctive graph model of Roy &amp;amp; Sussmann (1964) was used. The same neighborhood

was used in Binato et al. (2001) for a Job Shop Scheduling problem. In order to apply the

2-exchange local search to the WDP, we swap two elements in the scheduling. For example,

if in resource X the scheduling was ... ? X1 ? A ? X2 ? ... and in resource Y it was

... ? Y 1 ? B ? Y 2 ? ..., where ? represents a conjunctive arc, the result of the swap

would be a schedule like ... ? X1 ? B ? X2 ? ... and ... ? Y 1 ? A ? Y 2 ? ...,

in resources X and Y , respectively. Since the execution time of elements A and B can be

different, all activities after them may have their start times updated.

We need to decide, of course, what an element stands for. Some options are: (i) An

activity: with very small granularity, giving rise to huge neighborhoods (do Nascimento

(2002)), and, worse, moving an activity to another position would possibly force us to move

also its predecessors and successors in the same well, because of constraints C10; or (ii) A

well: with higher granularity, but since the sequence of activities in a well may be splited

in the present schedule due to constraints C1, some problems now being that moving all

activities takes time to verify all constraints, and exchanging the whole well may not be

possible even though exchanging only part of it could be; or finally (iii) Part of a well:

(that is, a maximal set of activities of the same well scheduled consecutively in the same

resource) with medium granularity and already satisfying constraint C10.

In our implementation we chose the last possibility, where the local search algorithm

exchanges all pairs of parts of two wells, no matter on what resource they have been

scheduled. That neighborhood is of size O(n2), where n is the number of parts of wells.

For practical instances, this is one order of magnitude smaller than the neighborhood that

uses activities as the moving elements.

To fully specify the local search phase we need a rule that defines how the neighborhood

is searched and which solution replaces the current one. This rule is called the pivoting rule

(Yannakakis (1997)), and examples of it are the first improvement rule (FIR) and the best

improvement rule (BIR). In the first case, the algorithm moves to a neighboring solution



40 Cap??tulo 6. O EDP sem Deslocamento de Recursos

as soon as it finds a better solution; in the second case, all neighbors are checked and the

best one is chosen. In either case, the worst case running time of each iteration is bounded

by O(n2), where n is the number of elements in the neighborhood. In the next section we

present a comparison between these two alternatives.

4 Computational Results

In this section, computational results for the GRASPW implementation are given. They

are also compared with results obtained with the ORCA implementation over the same

real instances. All tests were run on a platform equipped with a Sun SPARC Ultra 60

processor running a Solaris 9 operating system at 450 MHz and with 1024 MB of RAM.

Both GRASPW and ORCA were allowed to run for 1800 seconds on each instance.

Typical Instances. Twenty one real instances provided by Petrobras were used in our

tests. Table 1 summarizes the dataset. Columns with the same numerical data refer to

distinct instances that differ in the number of other constraints, like C9. The first part of

that table displays the instances were no C7 constraints were found. In order to reduce the

amount of time spent in testing, in some experiments we used only 7 of these instances,

eliminating instances that differed only in the number of clusters (see constraint C9, in

Section 2). The lower part shows the nine instances were C7 constraints were present. The

ORCA implementation had difficulties to handle these contraints.

Instance 1 2 3 4 5 6 7 8 9 10 11 12
# wells 29 22 29 29 17 22 22 29 29 22 29 22
# activities 98 107 98 98 111 107 128 98 98 107 98 107
# boats 1 1 2 1 1 2 1 1 1 2 1 2
# derriks 3 2 3 3 2 2 3 3 3 2 3 2
# C7 constr. 0 0 0 0 0 0 0 0 0 0 0 0

Instance 13 14 15 16 17 18 19 20 21
# wells 22 22 22 22 22 22 22 22 29
# activities 107 107 107 107 107 107 107 107 98
# boats 2 2 2 1 2 2 2 2 1
# derriks 2 2 2 2 2 2 2 2 3
# C7 constr. 1 1 1 1 1 1 1 1 2

Table 1: Test instances.

Setting GRASPW Parameters. In Section 3 we presented the idea of a dynamic sized

RCL. There are at least two ways we could exploit this idea: we may decrease the number



4. Computational Results 41

of candidates through time, using a greedier heuristic; or we may increase the number of

candidates through time, in order to drive away from a local optimum into new regions of the

search tree. In the first case, the initial RCL size is set to max(13, w), w being the number of

wells, and is decreased by one every 300 seconds without improvement. In the second case,

we start with max(5, w) for the initial RCL size and increase it by one every 300 seconds

without improvement. The first approach did not yield good results when applied to the

WDP, generating the same or worse solutions than those found by GRASPW with a static

sized RCL. However, the second approach proved promising. Figure 3.a shows the algorithm

with dynamic sized RCL generating better solutions after 150 thousand iterations, when

the RCL is increased. The same happens in Figure 3.b after 50 thousand iterations, when

another real instance is tested. Amongst twelve scenarios tested, four had better solutions

with the dynamic sized RCL, totalizing an increase of around 261 thousand barrels of oil.

In the other eight scenarios, the same solutions were found.

(a) Instance 1 (b) Instance 2

Figure 3: Static Sized RCL x Dynamic Sized RCL.

Another technique tested was to bias the selection towards some particular candidates,

those with the highest oil yield, but this strategy did not produce good results. Amongst

twelve instances tested, three had slightly worse solutions with such a bias function, totaling

a decreasing of 40 thousand barrels of oil. Worse, with the bias function in place, the

algorithm takes much more time to find the same solution than when no bias is used.

Summing up all the differences in time for the twelve scenarios, with the bias function the

algorithm took 3431 more seconds to reach the same results, an average increase of 72%.

We also considered two options for searching the neighborhood and selecting a new

neighbor: the first improvement rule (FIR) and the best improvement rule (BIR). We

tested both of them on seven instances. The BIR heuristics proved to be the best one when

finding solutions whose production was equal to a predefined target value and with the



42 Cap??tulo 6. O EDP sem Deslocamento de Recursos

least number of iterations (see Figure 4 (a) and (c)). On average, to find a solution with

a predefined production, the BIR strategy used about 60% of the number of iterations of

the FIR strategy. On the other hand, the FIR strategy was faster in most instances (see

Figure 4 (b) and (d)). On average, to find a solution with a predefined production, the FIR

strategy used 66% of the time used by the BIR strategy. That is because, on average, a

FIR iteration was almost seven times faster than a BIR iteration. Since, to users, running

time was deemed important, the FIR strategy was found to better suit this problem.

(a) Instance 1 - BIR (b) Instance 1 - FIR

(c) Instance 2 - BIR (d) Instance 2 - FIR

Figure 4: BIR × FIR.

The ORCA and the GRASPW Implementations. Our GRASPW implementation

found better solutions than the ORCA implementation on all twelve but one of the real

instances tested and, in that one, it found the same solution. GRASPW achieved 0.14%

more oil production on average which, despite being a small percentage, means an increase

of almost one million barrels of oil, in total. Perhaps, the highest gain with GRASPW was

in running time. It found solutions with the same production of those generated by ORCA,



5. Conclusions 43

on average, in only 36.3% of the time used by ORCA on the same instances. Figure 5.a

shows that the best GRASPW solution has a production 290 thousand barrels of oil higher

than the best ORCA solution. Furthermore, GRASPW found a solution with the same

oil production of the best ORCA solution within the first second, while ORCA found it

only after 2200 seconds. Similarly, Figure 5.b shows that the best GRASPW solution has

a production of almost 200 thousand barrels of oil higher than the best ORCA solution.

Again, GRASPW found a solution with the same oil yield as the best ORCA solution within

the first second, while ORCA found it only after 1000 seconds.

(a) Instance 1 (b) Instance 2

Figure 5: ORCA x GRASPW.

In all the nine tested scenarios, where the constraints C7 were present, GRASPW found

better solutions than ORCA. In one of them, ORCA could not find any solution, while

GRASPW found one with about 26 million barrels of oil production. Comparing the other

eight scenarios, GRASPW achieved 5.3% more oil production, on average, which means an

increase of around 4.6 million barrels of oil, in total. In Figure 6 we present the results over

four such instances. In all of them GRASPW was more effective than ORCA.

5 Conclusions

Scheduling activities efficiently is of paramount importance to the industry, in general.

Petrobras, a leading company in deep water exploration of oil, presented us the WDP, a

scheduling problem related to oil well drilling. Here we constrast two approaches to the

WDP: the constraint programming tool ORCA and a GRASP implementation, dubbed

GRASPW. Computational experiments were carried out on several real instances. We

conclude that GRASPW greatly outperforms ORCA. Not only it generates solutions with



44 Cap??tulo 6. O EDP sem Deslocamento de Recursos

(a) Instance 3 (b) Instance 4

(c) Instance 5 (d) Instance 6

Figure 6: ORCA x GRASPW.

higher oil production, but often it outputs solutions with the same oil production as ORCA

in much less time. We also note that ORCA already produced better results than the

manual solutions.

It is worth mentioning that ORCA is built over the ILOG Constraint Programming

suite, a set of highly expensive and sophisticated libraries with years of development. Us-

ing GRASPW, which was entirely programmed from the ground up, these costs could be

averted. In opposition, the ILOG suite favors easiness of development, of maintenance and

of understanding of the source code.

Acknowledgements The third author was supported by grants 307773/2004-3 from

CNPq and 03/09925-5 from FAPESP.



6. References 45

6 References

Aiex, R. M., Binato, S. and Resende, M. G. C., 2003, ‘Parallel GRASP with path-relinking

for job shop scheduling’, Parallel Computing 29(4), 393–430.

Bard, J. F. and Feo, T. A., 1989, ‘Operations sequencing in discrete parts manufacturing’,

Management Science 35, 249–255.

Binato, S., Hery, W. J., Loewenstern, D. and Resende, M. G. C., 2001, A GRASP for job

shop scheduling, in P. Hansen and C. C. Ribeiro, eds, ‘Essays and surveys on metaheuris-

tics’, Kluwer Academic Publishers, pp. 59–79.

do Nascimento, J. M., 2002, Hybrid computational tools for the optimization of the pro-

duction of petroleum in deep waters, Master’s thesis, Institute of Computing, University of

Campinas.

Feo, T. A. and Bard, J. F., 1989, ‘Flight scheduling and maintenance base planning’, Man-

agement Science 35, 1415–1432.

Feo, T. A., Bard, J. and Holland, S., 1995, ‘Facility-wide planning and scheduling of printed

wiring board assembly’, Operations Research 43, 219–230.

Feo, T. A. and Resende, M. G. C., 1995, ‘Greedy randomized adaptative search procedures’,

Journal of Global Optimization 6, 109–133.

Festa, P. and Resende, M. G. C., 2001, GRASP: An annotated bibliography, Technical

report, AT&amp;amp;T Labs.

Glover, F. and Laguna, M., 1997, Tabu Search, Kluwer Academic Publishers, Norwell,

Massachusetts.

ILOG, 1999, ILOG Solver 4.4 Reference Manual, ILOG.

Marriott, K. and Stuckey, P. J., 1998, Programming with Constraints: An introduction,

MIT Press, Cambridge, Massachusetts.

Roy, B. and Sussmann, B., 1964, Les proble?mes d’ordonnancement avec contraintes dis-

jonctives, in ‘Note DS No 9 bis’, SEMA, Paris.



46 Cap??tulo 6. O EDP sem Deslocamento de Recursos

Yannakakis, M., 1997, Computational complexity, in E. H. L. Aarts and J. K. Lenstra, eds,

‘Local Search in Combinatorial Optimization’, John Wiley &amp;amp; Sons, Chichester, pp. 19–55.



Ep??logo

Todos os testes realizados tiveram um limite de tempo de execuc?a?o de 1800 segundos, con-

forme ja? informado no artigo. Entretanto, engenheiros da Petrobras ao usar um resolvedor

para o problema fixam um limite de tempo de apenas 120 segundos. Isso ocorre porque

esses engenheiros realizam diversas ana?lises sobre uma mesma insta?ncia, ou seja, a testam

retirando/adicionando/trocando restric?o?es e recursos, avaliando por exemplo a necessidade

ou benef??cios de se adquirir novas sondas ou barcos. Para poder executar um bom nu?mero

de ana?lises e? prefer??vel usar um limite de tempo baixo, tendo em vista que o tempo desses

engenheiros e? limitado. E? por isso que comparamos na?o so? a soluc?a?o final dos resolvedo-

res, como tambe?m as curvas de produc?a?o gerada das soluc?o?es pelo tempo, e preferimos

resolvedores que convergem rapidamente para boas soluc?o?es.

Ja? quanto ao tempo em que se da? a alterac?a?o do tamanho da RCL, o fixamos em 1/6

do tempo total, ou 300 segundos sem melhoras na melhor soluc?a?o, conforme ja? informado

no artigo. Fixar um tempo na?o e? o ideal, pois ao se migrar para plataformas de hardware

superior, esse tempo poderia se tornar excessivo. Assim, o que poderia ser feito e? fixar essa

alterac?a?o pelo nu?mero de iterac?o?es GRASP proporcional ao limite de tempo fornecido. Tal

na?o foi feito pois para se comparar de forma mais justa as te?cnicas BIR e FIR, quer??amos

um fator igual para alterac?a?o no tamanho da RCL. Se utiliza?ssemos o nu?mero de iterac?o?es,

um resolvedor com BIR, em que as iterac?o?es sa?o mais lentas que um com FIR, teria sua

RCL alterada bem depois, prejudicando-o quando comparado a um resolvedor com FIR.

Ao se disponibilizar a ferramenta GRASP para a Petrobras, a alterac?a?o do tamanho da

RCL devera? ser feita apo?s um nu?mero de iterac?o?es sem melhorias na melhor soluc?a?o, sendo

esse nu?mero proporcional ao limite de tempo fornecido.

Um ponto importante na?o mencionado no artigo e? que, como o GRASP faz uso de

randomizac?a?o, cada insta?ncia e? testada cinco vezes, e os resultados reportados sa?o sempre

uma me?dia dos testes. Poder-se-ia fazer uma ana?lise do desvio padra?o das produc?o?es das

melhores soluc?o?es geradas pelo GRASP, verificando formalmente sua robustez, mas tal na?o

se mostrou necessa?rio. Isso porque em todos os testes realizados com um mesmo resolvedor

em uma mesma insta?ncia, a diferenc?a entre as produc?o?es de soluc?o?es diferentes nunca

superou os 0.5%. Dessa forma, um mesmo resolvedor GRASP mostra uma variac?a?o muito

pequena entre a qualidade de suas soluc?o?es para uma mesma insta?ncia.

Outro ponto que vale a pena ressaltar e? que a vizinhanc?a utilizada no GRASP tambe?m

poderia ser utilizada numa Busca Tabu. A Juliana em seu trabalho (do Nascimento 2002)

teve dificuldades na definic?a?o de uma vizinhanc?a pois usou uma vizinhanc?a de larga escala,

em que desenvolveu uma te?cnica h??brida entre programac?a?o por restric?o?es e Busca Tabu.

A escolha da utilizac?a?o da metaheur??stica GRASP nessa tese se deveu principalmente a sua

menor quantidade de para?metros a serem ajustados.

47



Apesar da ferramenta ORCA ter se apresentada robusta e eficiente, gerando ganhos ex-

pressivos a? Petrobras, nosso trabalho conseguiu gerar uma aplicac?a?o GRASP que produziu

resultados ainda melhores que aqueles obtidos pelo ORCA. Diante do fato, obtivemos apoio

da Petrobras para atacar uma versa?o estendida do EDP, agora considerando os desloca-

mentos de recursos, como e? mostrado no cap??tulo a seguir.

48



Cap??tulo 7

O EDP com Deslocamento de

Recursos

Pro?logo

Com o sucesso obtido com o GRASP no EDP, a Petrobras se comprometeu a nos fornecer

informac?o?es para tratar tambe?m o deslocamento dos recursos, o que aproximaria ainda mais

os escalonamentos gerados com os realmente executados na pra?tica. Dessa forma, surgiu o

EDPDR, uma extensa?o importante do EDP.

O artigo a seguir trata o problema de escalonamento no desenvolvimento de poc?os de

petro?leo em alto mar com deslocamento de recursos (EDPDR). O texto esta? em ingle?s,

transcrevendo na ??ntegra o artigo submetido ao Journal of Heuristics.

Apo?s uma descric?a?o detalhada do problema e das restric?o?es envolvidas, e? apresentado um

resolvedor GRASP que supera uma ferramenta de programac?a?o por restric?o?es desenvolvida

pela Petrobras. Como o problema se tornou bem mais complicado, o que prejudicou a

performance da ferramenta ORCA e a qualidade de suas soluc?o?es, incorporamos te?cnicas

mais avanc?adas ao GRASP para aumentar ainda mais os ganhos obtidos em relac?a?o ao

ORCA.

O estudo do EDPDR resultou em tre?s publicac?o?es:

• Relato?rio Te?cnico: Pereira et al. (2005c), emitido pelo Instituto de Computac?a?o da

Unicamp.

• Pre?mio Petrobras de Tecnologia: O artigo, traduzido para o portugue?s, foi o terceiro

colocado dentre 25 inscritos na categoria Produc?a?o, recebendo premiac?a?o em dinheiro

e uma bolsa de doutorado. Para mais detalhes, vide o site:

http://www2.petrobras.com.br/tecnologia2/port/pptecnologia.asp.

49



• Journal of Heuristics: O artigo foi submetido e espera o retorno dos avaliadores. Vide:

http://www.kluweronline.com/issn/1381-1231.

50



51

GRASP Strategies for Scheduling Activities

at Oil Wells with Resource Displacement

Romulo A. Pereira Arnaldo V. Moura Cid C. de Souza

romulo a pereira@yahoo.com.br arnaldo@ic.unicamp.br cid@ic.unicamp.br

Institute of Computing, University of Campinas

Abstract

Before promising locations at petroliferous basins become productive oil wells, it is

necessary to complete development activities at these locations. The scheduling of

such activities must satisfy several conflicting constraints and attain a number of goals.

Moreover, resource displacements between wells are also important. We describe a

Greedy Randomized Adaptive Search Procedure (GRASP) for the scheduling of oil

well development activities with resource displacement. The results are compared

with schedules produced by a well accepted constraint programming implementation.

Computational experience on real instances indicates that the GRASP implementa-

tion is competitive, outperforming the constraint programming implementation.

Today, oil and gas are fossil fuels of wide use in our society. They are important

ingredients in the processes of making plastics, dyes, kerosene, gasoline, gas and many

other products. A significant amount of these fossil fuels is extracted from oceanic basins,

e.g., from the offshore Marlin basin in Rio de Janeiro, Brazil. Petrobras is a company with

recognized expertise in oil exploration in deep sea waters, being also one of the twenty

biggest oil companies in the world. Usually, Petrobras explores diverse petroliferous basins,

each with hundreds of promising spots where productive oil wells could be located. However,

before these places are turned into productive wells they must be developed, that is, a

sequence of engineering activities must be completed at each promising spot, to render

them ready for oil extraction. Oil derricks and ships are used to complete these activities.

These resources have to move from one spot to another and such displacements must be

considered when sequencing the activities. Furthermore, such resources are limited and

expensive, either in acquisition or rent value, and must be used efficiently.

The oil well development with resource displacement problem (WDRDP) can be sum-

marized thus: given a set of promising spots, the activities to be executed at each location,



52 Cap??tulo 7. O EDP com Deslocamento de Recursos

and the available resources, find a scheduling of the activities and resources, fulfilling sev-

eral conflicting engineering and operational constraints, including the displacements of the

resources, in such a way as to optimize some objective criteria. In this work, the specific

WDRDP faced by Petrobras is studied.

This WDRDP imposes much more realistic constraints than other similar studies (do

Nascimento (2002), Pereira et al. (2005)). Actually, Pereira et al. (2005) is an early

version of this paper, which did not consider the displacement of the resources. Here, we

will take this special characteristic into account. In addition, in this paper, we discuss other

advanced techniques not explored in Pereira et al. (2005).

In the sequel, the constraints are presented in detail and our GRASP heuristic strate-

gies are developed, maximizing oil production within a given time horizon. The GRASP

implementations were built and tested over several real instances provided by Petrobras.

The best implementation indicated a gain of almost 16 million barrels of oil, or more

than US$ 830 millions, summing up over the average solutions of all the instances, when

compared to solutions generated by the constraint programming scheduler in use by the

company. As another advantage, our methods rely on non commercial libraries, whereas

the constraint programming implementation relied on expensive third party constraint pro-

gramming solvers.

The next section describes the WDRDP. Section 2 discusses GRASP implementations

for the WDRDP. Section 3 presents our computational results and compares them to

other results derived from the constraint programming implementation presently running

at Petrobras. Finally, some concluding remarks are offered in the last section.

1 Scheduling the Development of Oil Wells

When a spot is considered a promising oil well, oil derricks are sent there to accomplish the

due drilling operations. After a well is drilled, the preparation for oil extraction develops

in several stages.

First, in the stage called completion, oil derricks place Wet Christmas Trees (or WCTs,

structures where hydraulic valves are attached) at the mouth of the wells in order to avoid

oil leakage. Later, boats connect pipelines between WCTs and manifolds, this stage being

called interconnection. Manifolds are metallic structures installed by boats at the sea floor.

Their use prevents the need for exclusive pipelines connecting each well to the surface,

which would be prohibitively expensive. Once this stage is completed, oil extraction can

begin. For that, Stationary Units of Production (SUPs) are anchored at specific locations

in the surface and boats interconnect manifolds to them. SUPs are used to process, and

possibly store, the extracted products. Later, ships fetch the products from SUPs to land

storage sites or other processing units. If the oil outflow is very high or a SUP does not



1. Scheduling the Development of Oil Wells 53

have storage capacity, a petroliferous platform may be installed at the surface.

There are two types of wells that may be developed: (i) productive wells, which are

those who have an oil yield; and (ii) injection wells, where only maintenance activities are

executed and oil is not extracted from them.

1.1 Oil Yield and Objectives

The oil yield is calculated as follows. Each well has an associated outflow and an activity

that marks the beginning of its production. When this last activity is concluded, the well

is considered in production. The yield is obtained by multiplying the oil outflow by the

period between that instant and the established time horizon of production. If the start

production activity is set for a time after the horizon, the corresponding yield is disregarded.

The objective is to obtain a scheduling of all activities, satisfying all constraints, while

maximizing the oil yield.

Other goals to be attained by automating the scheduling of the activities are:

1. Faster solutions. Human made solutions take many hours, even days, to be con-

structed. A faster method would permit the analysis of different scenarios for the

same problem, for example, by adding or removing resources. Furthermore, modifi-

cations in already committed plans would not result in new hours, or days, spent in

rescheduling.

2. Better resource allocation. With an automated scheduling, all highly skilled engineers

responsible for the manual scheduling can receive other duties.

3. Savings. The automated schedule will, usually, result in a better use of boats and

derricks, thereby saving considerable operational resources.

1.2 The WDRDP Constraints

The constraints involved in the scheduling of oil well development activities are:

C1. Technological Precedence: sets an order between pairs of activities. When considering

the precedence between the start and finish of the activities in each pair, any of the

four possible combinations can be present.

C2. Mark-Activity: an activity must finish before or initiate after a fixed date, or mark,

with or without lag time. This date is often related to some external event, e.g., the

installation of a petroliferous platform.

C3. Baseline: sets the start date of the activities.



54 Cap??tulo 7. O EDP com Deslocamento de Recursos

C4. Use of Resources: to execute an activity, due to its intrinsic nature, a resource used

must match some operational characteristics. For a boat, it must be verified if the

on-board equipments can operate at the specified depth. For an oil derrick, its type

and capabilities must be verified, as well as its maximum and minimum depth of

operation and drilling.

C5. Concurrence: two activities at the same well, or executed by the same resource, can

not be simultaneous.

C6. Unavailability: resources may be unavailable for a period of time, either for mainte-

nance reasons or due to contract expiration.

C7. User Defined Sequences: the user can specify a sequence for the drilling activities or

for the “start production” activities of different wells, depending to the type of this

sequence. These sequences are specified by engineers in order to avoid loss of pressure

in the oil field. If well A appears before well B in the sequence, then the activity of

well A must terminate before the start of activity of well B can be scheduled.

C8. Surface Constraints: represented by a polygonal security area defined around a well.

When the center of a well is inside the restricted area of another well, activities

executed at both wells cannot be simultaneous. These constraints must be verified

between pairs of mobile and pairs of mobile and anchored oil derricks.

C9. Cluster Constraints: an activity may be part of a cluster, which is a set of activities

that must use the same resource.

C10. Oil Derrick Displacements: when an oil derrick moves between two wells, a set-up

time1 will be considered. Therefore, unnecessary displacements must be avoided,

for example, by making the same oil derrick execute as much activities at a well as

possible. For more details, see Subsection 1.4.

From the above description, it can be seen that the WDRDP is a difficult combinatorial

optimization problem. In fact, it is simple to devise a polynomial-time reduction from

the classical Job Shop Scheduling Problem (JSP) to the WDRDP, thus showing that the

WDRDP is NP-hard. The WDRDP treated here shows several differences from similar

problems studied in the literature (do Nascimento (2002), Pereira et al. (2005)).

1Time to unanchor, move and anchor in a new place.



1. Scheduling the Development of Oil Wells 55

1.3 The Constraint Programming Solution

To tackle the same problem, a project team from Petrobras developed a Constraint Pro-

gramming (cf., Marriott &amp;amp; Stuckey (1998)) model using ILOG’s Solver and Scheduler2

(ILOG (1999b)). After four years of development and testing, the tool, named ORCA3,

became operational and very successful. Nowadays, the ORCA solver is often used by en-

gineers both to define a good scheduling for the drilling activities and, also, to analyze the

need for acquiring or renting new resources. They confirmed that ORCA generates better

solutions than those made by humans. In one real instance, ORCA showed that buying a

third oil derrick was unnecessary and that it was better to add a new LSV ship instead. As

a result, an expenditure of US$ 15 million was avoided, while anticipating oil production

by 26 days. Despite the good performance of ORCA, searching for even better solutions is

still important, since a tenth of a percent improvement in the oil production may represent

an increase of millions of dollars in the company’s revenue.

1.4 The Resource Displacement

As already mentioned, here we will deal with a new facet of the problem, the resource

displacement. This constraint forces a period of “inactivity” for the resource, so that it can

unanchor, travel between two wells and anchor in the new spot. We call this period the

set-up time. It is set between activities of different wells which are scheduled consecutively.

In Figure 1.a we see a typical schedule with no resource displacement. Each square in

the “Schedule” area represents a different well. A square in dark gray represents a group

of activities of the same well which are executed by the resource, the light gray square,

which is in the same horizontal line. In Figure 1.b, we present a schedule with resource

displacement. Note that between each well there is a void period of time, which is the

set-up time.

The set-up time is a constant for each resource. It is calculated by engineers, based

on the average speed of the resource and the average distance between spots in the field,

plus the average time to anchor and unanchor. As engineers noted when scheduling the

activities at wells of an oil basin, the average distance between these wells does not differ

much from the average distance traveled by the resources. The weather, which influences

the speed of the resource, was also considered in the average speed.

However, different resources may have different set-up times. Consider, for example,

resources X and Y in Figure 1.b. Note that the set-up time of Y is twice longer than the

set-up time of X. This may alter the selection of which resource will execute activities

at a well. For example, if both resources X and Y are available at the same instant and

2Registered trade marks of ILOG Inc.
3Portuguese acronym for “Optimization of Critical Resources in the Production Activity”.



56 Cap??tulo 7. O EDP com Deslocamento de Recursos

(a) No Displacement (b) With Displacement

Figure 1: Schedules without and with resource displacement.

can execute the next well to be scheduled, it does matter which resource we choose. This

would not be the case if both resources had the same set-up times. Thus, a good selection of

which resource will execute the activity is even more important when resource displacement

is considered.

The constraint programming solver had many difficulties when treating the resource

displacement. A first approach used created virtual activities to represent the set-up time.

But, since as it is not known in advance if an activity from another well will be scheduled

consecutively, it would be necessary to create virtual activities dynamically, during the

search for solutions. Of course they would have to be destroyed when backtracking. This

process was quite complex and slowed down the search considerably, and so this approach

was abandoned. Instead, an if-then constraint was set, imposing that if the previous activity

executed by the resource was from another well, then the current activity was shifted by

the corresponding set-up time. Of course, as this constraint needed to hold between each

pair of activities, the number of constraints added to the problem was n? (n?1)/2, where

n is the number of activities. This increase in the number of constraints also slowed down

the execution of ORCA, and it did not generate very good solutions for many instances.

2 GRASP Strategies for the WDRDP

Our search for alternatives to compete with ORCA started with an implementation of a tabu

search strategy (Glover &amp;amp; Laguna (1997)) for a simpler version of the WDRDP (do Nasci-

mento (2002)). However, some issues proved to be particularly difficult to treat, especially

the definition of an adequate neighborhood and ways to explore it. After some investigation,

the GRASP (Feo &amp;amp; Resende (1995)) method seemed to be a more appropriate approach for

the WDRDP. Contrary to what occurs with other meta-heuristics, such as tabu search or

genetic algorithms which use a large number of parameters in their implementations, the



2. GRASP Strategies for the WDRDP 57

basic GRASP version requires the adjustment of fewer parameters. Despite its simplicity,

GRASP is a well studied meta-heuristic which has been successfully applied to a wide va-

riety of optimization problems (cf. Festa &amp;amp; Resende (2002)). In particular, applications of

GRASP to scheduling problems can be found in Bard &amp;amp; Feo (1989), Feo &amp;amp; Bard (1989),

Feo et al. (1995), Bard et al. (1996) and Binato et al. (2002). It is worth mentioning that

GRASP proved itself very valuable in dealing with the well development problem without

resource displacement (Pereira et al. (2005)).

The next paragraphs review some GRASP basics and describe our specific implemen-

tation designed to solve the WDRDP, named GRASP-WDRDP (or GRASPW, for short).

In the sequel, we present some advanced GRASP techniques that were used to improve our

solver. The model and its algorithms are also shown in detail in the subsequent paragraphs.

2.1 Greedy Randomized Adaptive Search Procedure (GRASP)

In the GRASP methodology each iteration consists of two phases: construction and

local search (Feo &amp;amp; Resende (1995)). Figure 2 illustrates a generic implementation of

GRASP, in pseudo-code. The input includes parameters for setting the candidate list size

(ListSize), the maximum number of iterations (MaxIter), and the seed (Seed) for the

random number generator. The iterations are carried out in lines 2-6. Each iteration

consists of the construction phase (line 3), the local search phase (line 4) and, if necessary,

the incumbent solution update (line 5). In the construction phase, a feasible solution is built,

updating the variable Solution. Then the local search algorithm seeks a better solution in

the neighborhood of Solution, according to a given criterion, and updates Solution. This

process of construction, search and update is executed MaxIter times.

1: procedure GRASP (ListSize, MaxIter, Seed)
2: for k = 1 to MaxIter do
3: Solution ? Construct Solution(ListSize, Seed);
4: Solution ? Local Search(Solution);
5: Update Solution(Solution, Best Solution F ound);
6: end for
7: return Best Solution F ound;
8: end GRASP

Figure 2: Pseudo-code of the GRASP Meta-heuristic.

In the construction phase, a feasible solution is built one element at a time. Figure

3 illustrates a generic implementation of the construction phase, in pseudo-code. Input

includes the candidate list size (ListSize) and the seed (Seed). The iterations are carried

out in lines 2-8. At each iteration, the next element is selected from all possible elements



58 Cap??tulo 7. O EDP com Deslocamento de Recursos

added to the candidate list. These elements are ordered with respect to a greedy function

that measures the, maybe myopic, benefit of selecting each element. This list is called the

Restricted Candidate List (RCL). The adaptive component of the heuristic arises from the

fact that the benefits associated with every element are updated at each iteration to reflect

the changes brought on by the selection of the candidate in the previous iteration. The

probabilistic component is present by the random choice of one of the best candidates in

the RCL, but usually not the best one. This way of choosing elements allows for different

solutions to be obtained at each iteration, while not necessarily jeopardizing the adaptive

greedy component.

The solutions generated by the construction phase are not guaranteed to be locally op-

timal. Hence, it is almost always beneficial to apply a local search procedure to improve the

constructed solution. The search phase is a standard deterministic local search algorithm

that seeks to optimize the solution built in the construction phase.

1: procedure Construct Solution(ListSize, Seed)
2: Solution ? 0;
3: Evaluate the incremental costs of the candidate elements;
4: while Solution is not a complete solution do
5: Build the restricted candidate list, RCL(ListSize);
6: Select an element s f rom the RCL at random;
7: Solution ? Solution ? {s};
8: Reevaluate the incremental costs;
9: end while

10: return Solution;
11: end Construct Solution

Figure 3: Pseudo-code of the Construction Phase of GRASP.

2.2 GRASP Advanced Techniques

As the problem increased in complexity, compared to the problem with no resource dis-

placement studied in Pereira et al. (2005), we decided to consider some improvements and

alternative techniques to be introduced in the basic GRASP procedure.

Bias Function: In the construction procedure of the basic GRASP, the next element to

be introduced in the solution is chosen at random from the candidates in the RCL.

The elements of the RCL are assigned equal probabilities of being chosen. However,

any probability distribution can be used to bias the selection toward some particular

candidates. Bresina (1996) proposed a construction mechanism based on the rank

r(?) assigned to each candidate element ?, according to its value, measured by the



2. GRASP Strategies for the WDRDP 59

greedy function, v(?). However, as the sorting of elements to obtain the rank has

time complexity O(n log n), where n is the number of elements in the RCL, and since

the sorting must be repeated at each choice of an element, this process could slow

down the implementation. Thus, we decided to use directly the value v(?) of the

candidates to create the following bias functions:

• uniform: bias(?) = 1

• linear: bias(?) = v(?)

• log: bias(?) = ln v(?)

• exponential: bias(?) = ev(?)

• quadratic: bias(?) = v(?)2

• square root: bias(?) =
?

v(?)

Once the value of the bias function is evaluated for all elements of the RCL, the

probability of the candidate ? being chosen is:

bias(?)
?

???RCL
bias(??)

Proximate Optimality Principle (POP): This technique is based in the idea that

“good solutions at one level are likely to be found ‘close to’ good solutions at an

adjacent level” (Glover &amp;amp; Laguna (1997)). Fleurent &amp;amp; Glover (1999) provided a

GRASP interpretation of this principle. They suggested that imperfections introduced

during steps of the GRASP construction phase can be ironed out by applying local

search during (and not only at the end of) the GRASP construction phase. Due to

efficiency considerations, a practical use of the POP in a GRASP implementation

would be to apply a local search during a few points in the construction phase, and

not at the end of each construction iteration. Binato et al. (2002), when dealing with

a JSP, applied a local search when 40% and 80% of the construction moves have been

taken, as well as at the end of the construction phase. Due to the relation between

the JSP and the WDRDP (see Section 1.2), and after some promising tests, the same

values were used in our GRASP solver.

One possible shortcoming of the basic GRASP method is the independence of its iter-

ations, i.e., the fact that it does not learn from the history of solutions found in previous

iterations. This is so because the standard algorithm discards information about any so-

lution encountered that does not improve the incumbent solution. Information gathered

from good solutions can be used to implement memory-based procedures. We show some

of these strategies below.



60 Cap??tulo 7. O EDP com Deslocamento de Recursos

Intensification: Fleurent &amp;amp; Glover (1999) observed that the standard GRASP does not

use long term memory and proposed a scheme to use this kind of memory in the

heuristic. Long term memory is one of the pillars of tabu search. The idea of the

approach is to maintain a set of elite solutions. To be included in this set, a solution

must either be better than all elite solutions according to some objective function, or

must be better than the worst solution of the set, while being sufficiently different

from all elite solutions. In our problem, a solution is considered sufficiently different

from another if the number of activities that have different start dates in both, or the

number of different resources allocated to both is higher than the number of activities

divided by the number of resources. As the number of resources is usually smaller

than five, two solutions will be sufficiently different if at least 20% of their activities

have a different start date or resource allocated to both.

We show next how the elite solutions will bias the selection of the candidates in the

GRASP construction phase. To each candidate ? we evaluate the intensity function

Int(?) as follows:

Int(?) =

?

ei?S
P rod(ei)

Maxej ?EP rod(ej)
.

In this function, S is the set of elite solutions in which the element ? has the same

start date and resource allocated when compared to the solution being built; P rod()

is the value of oil yield associated with a solution, E is the set of elite solutions, and

Max returns the maximum value in the indicated set.

Let iter be the amount of iterations executed and k a parameter, we define the bias

function using the intensity function as follows:

biasInt(?) = bias(?) +
Int(?) · iter

k

The fraction iter/k is used to give emphasis to the intensity function as the number of

iterations increases, and thus the quality of the elite solutions in which the intensity

function is based also possibly increases.

Path-Relinking (P-R): This technique was originally proposed in Glover (1996) as

an intensification strategy exploring trajectories connecting elite solutions obtained

by tabu search or scatter search methods (Glover (2000), Glover &amp;amp; Laguna (1997),

Glover et al. (2000)). Starting from one or more elite solutions, paths in the solution

space leading towards other elite solutions are generated and explored in the search

for better solutions. This is accomplished by selecting moves that introduce, in the



2. GRASP Strategies for the WDRDP 61

moving solution, attributes contained in the target solution. Path-relinking may be

viewed as a strategy that seeks to incorporate attributes of high quality solutions, by

favoring these attributes in the selected moves.

The use of path-relinking within a GRASP procedure was first proposed in Glover

et al. (2000). It was followed by several extensions, improvements and successful

applications (Aiex et al. (2000), Canuto et al. (2001), Resende &amp;amp; Ribeiro (2001)).

Two basic strategies are:

• path-relinking is applied as a post-optimization step to all pairs of elite solutions.

• path-relinking is applied as an intensification strategy to each local optimum

obtained after the local search phase.

According to Resende &amp;amp; Ribeiro (2002) the second strategy is more promising. An-

other consideration, also from Resende &amp;amp; Ribeiro (2002), is that exploring the two

trajectories, in both directions, between two solutions results in small gains and de-

mands twice the time. Thus, it is usually more appropriate to explore only one path,

the one from the best solution to the other, as better solutions are more often found

near the neighborhood of the best solutions (Resende &amp;amp; Ribeiro (2002)).

Selective Local Search (SLS): Another approach that can be used within the standard

GRASP procedure is to apply local search only in those solutions sufficiently different

from the elite solutions, or that have a good quality, i.e., better than the worst of

the elite solutions. In other words, we try to apply local search only where there are

higher chances of obtaining better solutions, improving the efficiency of the algorithm.

2.3 The New GRASP Solver Implementation: GRASPW

The GRASPW implementation was constructed using the C/C++ programming language.

Our model uses two types of integer variables. One represents the beginning of execution

of each activity in the corresponding well. These values range between a minimum and

a maximum start time, depending on the current partial solution being constructed. The

second type of variables represents which resource will execute each activity in a well. Their

domains are characterized by a set of the possible resources, of whose one must be chosen

to execute the corresponding activity.

All the constraints described in Section 1 were enforced. Three constraints, namely,

C2, C3 e C4, were set while reading the problem data, before the search begins. Note

that, in these cases, all values needed to set the constraints are already defined. The other

constraints were dealt with during the search for solutions, the variables involved being

assigned single values.



62 Cap??tulo 7. O EDP com Deslocamento de Recursos

Constraint C10, that deals with resource displacement and which was responsible for a

loss of performance of the ORCA search algorithm, was treated here in a simple way. As we

do not use a mechanism of constraint propagation, we displace the current activity by at

least the amount of the set-up time, if the previous activity scheduled in the same resource

is from a different well.

Of course, we could also have imposed constraint C10 during the search in ORCA

instead of writing such constraints directly in the model. However this was not done for

two reasons:

• First, this goes against the fundamental design principle in constraint programming,

which dissociates the representation of the problem from strategies for its resolution

(ILOG (1999c), ILOG (1999a)). This approach is known as declarative programming.

In other words, this separation of the model from the search has a number of prac-

tical implications: it shortens development time, decreases maintenance problems

and heightens adaptability of the application. Furthermore, such separation makes

it easier to experiment with different strategies and different algorithms without re-

designing the model, and even allows for the addition of further constraints to the

problem without having to rewrite the search method.

• Besides generating solutions to the WDRDP, ORCA has also the functionality of

validating the model. If the data of the problem generates inconsistencies, ORCA

will inform the user that there is no feasible solution to the problem. In order to

validate the import data, all the constraints must be imposed in the model, including

the C10 constraints. Our GRASP solver does not have this functionality.

2.4 The Construction Phase

The following two adaptations were made to the procedure illustrated in Figure 2:

• The search procedure was interrupted by a time limit instead of by the number of

iterations; and

• During a complete run of the GRASPW meta-heuristic, the value of ListSize can

be monotonically incremented by a fixed amount when a predefined interval of time

is reached with no improvement on the best solution. This allows the algorithm to

explore larger regions of the search space. Alternatively, during a run of GRASPW,

the value of ListSize can be monotonically decremented between iterations, thus

focusing into a greedier heuristic. With this scheme we obtain a dynamic sized RCL,

in opposition to the original static sized RCL. Note that, as GRASP iterations are

independent, one could imagine that there is no difference between increasing and



2. GRASP Strategies for the WDRDP 63

decreasing the RCL size. However, as we do not know in advance the amount of time

the algorithm will execute in each run, or when the RCL size will be altered, we can

not anticipate the result of a GRASPW run, when increasing or decreasing the RCL

size.

As in the ORCA implementation, we seek solutions with the highest oil yield. To this

end, the construction phase illustrated in Figure 3 was modified thus:

1. The first time the construction phase is initiated, we use ListSize equals to one, when

the algorithm behaves like a greedy heuristic. With few constraints obstructing the

greedy heuristic, it tends to generate good or even very good solutions. For example,

in six out of seventeen real instances, the best solution was found in the first pass of

the construction phase.

2. The candidates are defined by the production wells that are available (meaning that

there are no wells yet not scheduled which must precede them), or the injection wells

that have activities of production wells succeeding them. The activities of injection

wells that do not have activities of production wells succeeding them are left to be

scheduled after all others. Note that injection wells are not productive and there-

fore must not be scheduled before production wells, unless there are technological

constraints forcing such a schedule. We schedule the wells and not single activi-

ties because otherwise the solution would have a huge number of displacements of

resources between wells, which would affect the oil production negatively.

3. The evaluation of incremental costs (line 3 of Figure 3) assesses how much oil a well

can offer until the end of the time horizon. The RCL is built with those wells that

offer the highest yields of oil. Actually, not only the oil offer is considered, but also

the oil offer of the constrained successors of a well.

4. In the construction phase, the next element to be introduced in the solution is chosen

uniformly from the candidates in the RCL (line 5 of Figure 3). However, any proba-

bility distribution can be used to bias the selection (see Section 2.2). We tried some

bias functions in the selection of the candidates, as will be discussed later.

5. To schedule the candidate well (line 7 of Figure 3), the routine is as follows.

As long as there are activities not yet scheduled in the well:

(a) choose any activity available in the well, i.e., one not yet scheduled and such

that there is no other activity not yet scheduled in the wells that must precede

it;



64 Cap??tulo 7. O EDP com Deslocamento de Recursos

(b) choose a resource for this activity that can execute it, and that can complete the

activity the earliest;

(c) set the start time of the activity at the earliest possible time, i.e., the maximum

between the earliest time the resource is available to execute the activity (con-

sidering the constraints, including the set-up time) and the minimum start time

of the activity; and

(d) all activities that are constrained to succeed the chosen one must have their

minimum start times updated so that all constraints are satisfied.

The scheduling of a well is done so as to satisfy all constraints, including the seven

ones not yet enforced while reading the problem data. In case of violations, and

this can be tested after each activity is scheduled, the construction of this solution is

aborted and a new one is started. We could, instead, backtrack a few steps, but this

would slow down this phase, especially if the first steps were not appropriate.

6. After a well is scheduled, any activities that must succeed it have their minimum start

times updated to satisfy all constraints. If that is not possible, the construction of

this solution is also aborted.

2.5 The Local Search Phase

As we have no guaranties that the solution found in the construction phase is locally opti-

mum, a local search is used to improve the solution. For the search phase, an appropriate

neighborhood was defined, so as to permit explorations that quickly lead to better solu-

tions. The 2-exchange local search algorithm based on the disjunctive graph model of Roy

&amp;amp; Sussmann (1964) was used. The same neighborhood was used in Binato et al. (2002)

for a Job Shop Scheduling problem. In order to apply the 2-exchange local search to the

WDRDP, we swap two elements in the scheduling. For example, consider the schedule

presented in Figure 4.a. The elements (light gray squares) are executed by the resource

(dark gray squares) which is depicted in the same horizontal line. The size of the squares

represents the execution time of the corresponding elements. We swap elements A and B,

which results in the schedule shown in Figure 4.b. Since the execution time of elements A

and B can be different, all activities after them may have their start times updated.

We need to decide, of course, what an element stands for. Some options are:

1. An activity. Very small granularity, giving rise to huge neighborhoods (do Nascimento

(2002)) and, worse, moving an activity to another position would possibly force its

predecessors and successors in the same well to be moved as well, in order to avoid

the displacements that may result from constraints of type C10;



2. GRASP Strategies for the WDRDP 65

(a) Before (b) After

Figure 4: 2-exchange swap.

2. A well. With higher granularity. But since the sequence of activities in a well may be

splitted in the present schedule due to constraints of type C1, moving all activities

takes time to verify all constraints, and exchanging the whole well may not be possible

even though exchanging only part of it could be;

3. Part of a well. That means a maximal set of activities of the same well scheduled con-

secutively in the same resource. With medium granularity, it avoids the displacements

that may result from constraints of type C10.

In our implementation, we chose the last alternative, where the local search algorithm

exchanges all pairs of parts of wells, no matter on what resource they have been scheduled.

That neighborhood is of size O(n2), where n is the number of parts of wells. For practical

instances, this is one order of magnitude smaller than the neighborhood that uses activities

as the moving elements.

To fully specify the local search phase we need a rule that defines how the neighborhood

is searched and which solution replaces the current one. This rule is called the pivoting rule

(Yannakakis (1997)), and examples of it are the first improvement rule (FIR) and the best

improvement rule (BIR). In the first case, the algorithm moves to a neighboring solution

as soon as it finds a better solution; in the second case, all neighbors are checked and the

best one is chosen. In either case, the worst case running time of each iteration is bounded

by O(n2), where n is the number of elements in the neighborhood. In the next section we

present a comparison between these two alternatives.

Besides the improvements proposed above to the standard GRASP procedure, all the

advanced techniques presented in Section 2.2 were implemented and tested.



66 Cap??tulo 7. O EDP com Deslocamento de Recursos

3 Computational Results

In this section, computational results for the GRASPW implementation are discussed. They

are also compared with results obtained with the ORCA implementation over the same real

instances. All tests were run on a platform equipped with a Sun SPARC Ultra 60 processor,

running a Solaris 9 operating system at 450 MHz and with 1024 MB of RAM. Both the

GRASPW and the ORCA implementations were allowed to run for 1800 seconds on each

instance.

3.1 Typical Instances

Twenty two real instances provided by Petrobras were used in our tests. Table 1 summarizes

the dataset. Columns with the same numerical data, like columns 8 and 9, refer to distinct

instances that differ in the number of other constraints not shown in the table, like C9. The

first part of that table displays the instances were no C7 constraints were found. In order

to reduce the amount of time spent in testing, in some experiments we used only 7 of these

instances, eliminating instances that differed only by a few constraints. The lower part of

Table 1 shows the ten instances were C7 constraints were present. It is worth mentioning

that, as GRASP makes use of randomization, each instance was tested five times, and the

results being reported always reflect the average of the tests.

The horizon of production ranges from a thousand to three thousand days. Note that,

after every well has been scheduled, the oil yield is the same between all solutions until

the horizon of production. Thus, any gains in production, when comparing two solutions,

happen before all wells are scheduled. If we considered the full horizon to compute yields,

these gains, in percent, would be smaller. Therefore, for each instance we use as the horizon

of production the end date of the last activity of the well scheduled the latest, among all

solutions of the solvers.

3.2 Setting GRASPW Parameters

In Section 2 we presented the idea of a dynamic sized RCL. There are at least two ways

we could exploit this idea: we may decrease monotonically the number of candidates using

a greedier heuristic; or we may increase monotonically the number of candidates in order

to drive away from a local optimum into new regions of the search tree. In the first case,

the initial RCL size is set to max(13, w), w being the number of wells, and is decreased by

one every 300 seconds without improvement. In the second case, we start with max(5, w)

for the initial RCL size and increase it by one every 300 seconds without improvement.

The first approach did not yield good results when applied to the WDRDP, generating the

same or worse solutions than those found by GRASPW with a static sized RCL. However,



3. Computational Results 67

Instance 1 2 3 4 5 6 7 8 9 10 11 12
# wells 29 22 29 29 17 22 22 29 29 22 29 22
# activities 98 107 98 98 111 107 128 98 98 107 98 107
# boats 1 1 2 1 1 2 1 1 1 2 1 2
# derricks 3 2 3 3 2 2 3 3 3 2 3 2
# C7 0 0 0 0 0 0 0 0 0 0 0 0

Instance 13 14 15 16 17 18 19 20 21 22
# wells 22 22 22 22 22 22 22 22 29 65
# activities 107 107 107 107 107 107 107 107 98 338
# boats 2 2 2 1 2 2 2 2 1 1
# derricks 2 2 2 2 2 2 2 2 3 2
# C7 1 1 1 1 1 1 1 1 2 2

Table 1: Tested Instances.

the second approach proved promising. Figure 5.a shows the algorithm with dynamic sized

RCL generating better solutions after 150 thousand iterations, when the RCL is increased.

The same happens in Figure 5.b after 50 thousand iterations, when another real instance is

tested. Amongst twelve scenarios tested, four had better solutions with the dynamic sized

RCL, summing up an increase of around 261 thousand barrels of oil. In the other eight

scenarios, the same solutions were found.

(a) Example 1 (b) Example 2

Figure 5: Static Sized RCL Solver x Dynamic Sized RCL Solver.

We also considered two options for searching the neighborhood and selecting a new

neighbor: the first improvement rule (FIR) and the best improvement rule (BIR) strategy.

Tests were executed and FIR has proved to be better. The BIR heuristics found solutions

whose production was equal to a predefined target value with the least number of iterations



68 Cap??tulo 7. O EDP com Deslocamento de Recursos

(see Figure 6.a). On average, to find a solution with a predefined production, the BIR

strategy used about 60% of the number of iterations of the FIR strategy. On the other

hand, the FIR strategy was faster in most instances (see Figure 6.b). On the average, to

find a solution with a predefined production, the FIR strategy used 66% of the time used by

the BIR strategy. That is because, on the average, a FIR iteration was almost seven times

faster than a BIR iteration. Note that, to users, running time is deemed important. Note

also that the FIR solver built solutions with a slightly higher oil production, as can be seen

in Figures 6 and 7. Summing up all instances, the gain was almost 80 thousand barrels of

oil. We concluded that the FIR strategy was the one that better suited this problem.

(a) (b)

Figure 6: BIR x FIR: Example 1

(a) Example 2 (b) Example 3

Figure 7: BIR x FIR.

Another technique tested was to bias the selection towards some particular candidates,



3. Computational Results 69

those with the highest oil yield. Five probability distributions, besides the uniform distrib-

ution, were considered, as presented in Section 2.2. Comparative experiments showed that

the exponential and quadratic bias functions generated much worse solutions, with pro-

duction of more than 2 millions barrels of oil smaller than the other approaches, summing

up over all instances. Among the other bias functions, the function based on square root

proved to be the best one for this problem, as can be seen in Figures 8.a and 9.a. For a

better view over this two examples, we zoom comparing square root to others bias functions

on Figures 8.(b,c,d) and 9.(b,c,d).

(a) Example 1 (b) Example 1: Square root X Linear

(c) Example 1: Square root X Uniform (d) Example 1: Square root X Log

Figure 8: Bias Functions, I.

3.3 The GRASPW Implementations

In Section 2.2, we presented some advanced techniques that can be included in the basic

GRASP procedure. Many combinations of these were tested, but not all possible com-

binations. With 6 distinct techniques (five advanced plus the pivoting rule), all possible



70 Cap??tulo 7. O EDP com Deslocamento de Recursos

(a) Example 2 (b) Example 2: Square root X Linear

(c) Example 2: Square root X Uniform (d) Example 2: Square root X Log

Figure 9: Bias Functions, II

combinations would number 64 distinct solvers. It was simply too time consuming to exe-

cute broad tests with each and every one of these solvers. We choose the best combinations

based on faster tests, selecting a pool of 27 solvers. To simplify the visualization and data

analysis, we show only 14 solvers, besides the ORCA solver. See Table 2.

As there are many solvers and in many tests there were ties between them, we elaborated

five criteria to analyze which would be the best solver. We list these criteria below:

1. Sum of the oil production of the best solutions for all instances.

2. Sum of the oil production of the average solutions for all instances.

3. Average of the rank obtained sorting decreasingly the solver solutions of each instance

using the Ranking1 Rule (R1), explained below. The sorting was according to the

average oil production and average time of execution to find the best solution. We

ranked all solvers.



3. Computational Results 71

Techniques C.P. GRASP POP Bias Int P-R SLS BIR
ORCA •
G1 •
G2 • •
G3 • • •
G4 • •
G5 • •
G6 • •
G7 • •
G8 • • •
G9 • • •
G10 • • •
G11 • • • •
G12 • • • • •
G13 • • • • •
G14 • • • • • •

C.P. Constraint Programming
GRASP Greedy Randomized Adaptive Search Procedure
POP Proximate Optimality Principle
Bias Bias Function (Square Root)
Int Intensification
P-R Path-Relinking
SLS Selective Local Search
BIR BIR

Table 2: Solvers

4. Average of the rank obtained sorting decreasingly the solver solutions of each instance

using the Ranking2 Rule (R2), explained below. The sorting was according to the

average oil production and average time of execution to find the best solution. We

ranked all solvers.

5. Number of instances for which the solver obtained the best solution known to that

instance.

Ranking1 Rule is a rank where, if s solvers are drawn in rank r, the next solvers would

come in rank r + 1. Ranking2 Rule, in the same example, would put the next solvers in

rank r + s.

Table 3 presents the values of the criteria achieved by the 15 solvers created for the

WDRDP. Values in boldface are the best results among the solvers for each criteria. Note

that G14 stands out being the best solver according to three criteria, followed closely by

G7 which was the best in two criteria. However we can not say yet that G14 is the best

solver, because if it behaves poorly in the other two criteria, another solver could prove



72 Cap??tulo 7. O EDP com Deslocamento de Recursos

to be more appropriate for the WDRDP. According to these values, we elaborated Table

4, where we show the rank of the solvers in each criterion. Note that there are significant

variations in the rank of the solvers when using different criteria.

Criterion 1 2 3 4 5
ORCA 331.043.827 331.043.827 9,588235 23,47059 2
G1 354.428.768 346.325.637 7,682353 10,47059 7
G2 354.421.217 346.255.908 8,035294 11,11765 6
G3 354.528.275 346.318.220 7,470588 10,23529 6
G4 354.379.849 346.255.508 8 11,41176 6
G5 354.428.768 346.342.803 6,823529 9,176471 7
G6 354.432.875 346.377.716 4,623529 8,235294 7
G7 354.838.320 346.807.529 2,941176 4,352941 8
G8 354.838.320 346.744.587 4,352941 5,764706 8
G9 354.838.320 346.801.864 3,470588 5,294118 8
G10 354.929.689 346.782.341 4,411765 6,588235 7
G11 354.929.689 346.762.940 4,294118 6,411765 9
G12 354.929.689 346.762.060 4,588235 6,941176 7
G13 354.932.391 346.765.955 4,058824 6 7
G14 354.888.020 346.814.967 2,941176 4,764706 9

Table 3: Values obtained by the Solvers in the Comparative Criteria

In order to make a decision about which would be the best solver, we again ranked the

solvers according to the average rank they obtained in each criterion. We made this rank

using both R1 and R2 type rules, as can be seen in Table 5. Using this table, we obtained

the rank of the best solvers, presented in Table 6. We conclude that G14 is actually the

best GRASP solver that we developed for the WDRDP.

This solver makes use of many advanced techniques for GRASP heuristics, like POP,

bias function based on square root, intensification, Path-Relinking and SLS (see Section

2.2). Our second best solver for the problem was G7, which makes use only of the POP

technique. As can be seen in Table 3, and by the average rank in Table 5, G7 is almost as

good as G14. Hence, the other advanced techniques used in solver G14, besides POP, give

only marginal gains to G14. POP, on the other hand, improves drastically the performance

of a solver for this problem. This can be seen comparing G1 (basic GRASP) to G7 (basic

GRASP with POP) in the same tables mentioned above, or comparing the group of solvers

G1 until G6 (solvers without POP) to the group of G7 and the other solvers, that is, the

group of solvers that implemented POP. When POP is applied, a great leap in quality can

be seen. Note, for example, that G1 is just the eleventh best solver, while G7 is the second

best.

Note also that G7 is better than G10, G11, G12 and G13, solvers which combine POP

and other advanced techniques. This happened because these advanced techniques required



3. Computational Results 73

Criterion 1 2 3 4 5
G13 G14 G7-G14 G7 G11-G14

G10-G11-G12 G7 G9 G14 G7-G8-G9
G14 G9 G13 G9 G1-G5-G6-G10-G12-G13

G7-G8-G9 G10 G11 G8 G2-G3-G4
G3 G13 G8 G13 ORCA
G6 G11 G10 G11

G1-G5 G12 G12 G10
G2 G8 G6 G12
G4 G6 G5 G6

ORCA G5 G3 G5
G1 G1 G3
G3 G4 G1
G2 G2 G2
G4 ORCA G4

ORCA ORCA

Table 4: Rank of the Solvers

longer processing times from the solvers, and the gains were not sufficient to justify their

use. Solver G7 could only be overcame when all the advanced techniques were combined

in G14, and even so it was just slightly overcame.

With the above facts in mind, we concluded that POP is the best advanced technique

to solve the WDRDP.

3.4 Comparative Results

As can be seen in Section 3.3, the G14 solver was considered the best GRASPW implemen-

tation. Note that the constraint programming solver, ORCA, was much worse than all the

GRASPW solvers, even when compared to the standard GRASP procedure, G1.

Compared to ORCA, the G14 solver generated gains of more than 16 millions barrels of

oil, summing up the average solutions of all instances. This means an increase of 4,5% in

the oil production. Note that, with the oil barrel price around US$ 52, the use of the G14

solver, instead of the ORCA solver, would yield gains of almost US$ 832 million. Besides,

even generating better solutions, G14 takes, to find its best solution, only 95% of the time

ORCA takes to find its best solution. And to find better solutions than the ORCA’s best

one, G14 takes only 45% of the time taken by ORCA. Among the 17 instances tested, G14

generates, within the first second of execution, better solutions than ORCA’s best solution,

in 14 instances. Two examples of that can be seen in Figure 10. In Figure 11, we show

two instances where G14 does not generate, within the first second of execution, solutions

better that the ORCA best solution.



74 Cap??tulo 7. O EDP com Deslocamento de Recursos

Analysis of Criteria R1 R2 Average R1-R2
ORCA 11,8 15 13,4
G1 8,8 10,4 9,6
G2 10,2 13 11,6
G3 8,4 11 9,7
G4 10,6 13,4 12
G5 7,8 9,4 8,6
G6 7 8,6 7,8
G7 2 2,6 2,3
G8 4,6 5,4 5
G9 2,8 3,6 3,2
G10 4,4 5,2 4,8
G11 3,8 4 3,9
G12 5,4 6,2 5,8
G13 3,4 4,2 3,8
G14 1,6 2 1,8

Table 5: Analysis of the Rank of the Solvers

However, there is an instance where ORCA was competitive compared to G14, as can

be seen in Figure 12. Here, ORCA’s best solution was found in 5 seconds and G14 only

generated a better solution than that after 1134 seconds. Nevertheless, after 1522 seconds,

G14 generated a solution with an oil production almost 63 thousand barrels superior than

ORCA’s best solution.

We conclude that our GRASPW implementation is much more efficient and generate

better solutions than the ORCA solver.

(a) Example 1 (b) Example 2

Figure 10: ORCA × G14, I



4. Conclusions 75

Solver
G14
G7
G9
G13
G11
G10
G8
G12
G6
G5
G1
G3
G2
G4

ORCA

Table 6: Rank of the Best Solvers

4 Conclusions

Scheduling activities efficiently is of paramount importance to the industry, in general.

Petrobras, a leading company in deep water oil exploration, presented us the WDRDP,

a scheduling problem related to oil well development. Here we constrast two approaches

to the WDRDP: the constraint programming tool ORCA and a GRASP implementation,

dubbed GRASPW.

Computational experiments were carried out on several real instances. We conclude

that GRASPW greatly outperforms ORCA. Not only it generates solutions with higher oil

production, but often it outputs solutions with the same oil production as ORCA, but in

much less time. We recall that ORCA already produced better results than the manual

solutions.

It is worth mentioning that ORCA is built using the ILOG Constraint Programming

suite, a set of expensive and sophisticated libraries with years of development. Using

GRASPW, which was entirely programmed from the ground up, these costs could be

averted. In opposition, the ILOG suite favors easiness of development, of maintenance

and of understanding of the source code.



76 Cap??tulo 7. O EDP com Deslocamento de Recursos

(a) Example 3 (b) Example 4

Figure 11: ORCA × G14, II

Figure 12: ORCA×G14: Example 5



5. References 77

5 References

Aiex, R. M., Resende, M. G. C. and Toraldo, G., 2000, GRASP with path-relinking for the

three-index assignment problem, Technical report, AT&amp;amp;T Labs.

Bard, J. F. and Feo, T. A., 1989, ‘Operations sequencing in discrete parts manufacturing’,

Management Science 35, 249–255.

Bard, J., Feo, T. and Holland, S., 1996, ‘A GRASP for scheduling printed wiring board

assembly’, I.I.E. Transactions 28, 155–165.

Binato, S., Hery, W. J., Loewenstern, D. and Resende, M. G. C., 2001, A GRASP for job

shop scheduling, in P. Hansen and C. C. Ribeiro, eds, ‘Essays and surveys on metaheuris-

tics’, Kluwer Academic Publishers, pp. 59–79.

Bresina, J. L., 1996, Heuristic-biased stochastic sampling, in ‘Proceedings of the Thirteenth

National Conference on Artificial Intelligence’, pp. 271–278.

Canuto, S. A., Resende, M. G. C. and Ribeiro, C. C., 2001, ‘Local search with perturba-

tions for the prize-collecting steiner tree problem in graphs’, Networks 38, 50–58.

do Nascimento, J. M., 2002, Hybrid computational tools for the optimization of the pro-

duction of petroleum in deep waters, Master’s thesis, Institute of Computing, University of

Campinas.

Feo, T. A. and Bard, J. F., 1989, ‘Flight scheduling and maintenance base planning’, Man-

agement Science 35, 1415–1432.

Feo, T. A., Bard, J. and Holland, S., 1995, ‘Facility-wide planning and scheduling of printed

wiring board assembly’, Operations Research 43, 219–230.

Feo, T. A. and Resende, M. G. C., 1995, ‘Greedy randomized adaptative search procedures’,

Journal of Global Optimization 6, 109–133.

Festa, P. and Resende, M. G. C., 2001, GRASP: An annotated bibliography, Technical

report, AT&amp;amp;T Labs.

Fleurent, C. and Glover, F., 1999, ‘Improved constructive multistart strategies for the



78 Cap??tulo 7. O EDP com Deslocamento de Recursos

quadratic assignment problem using adaptive memory’, INFORMS Journal on Computing

11, 198–204.

Glover, F., 1996, Tabu search and adaptive memory programming — advances, applica-

tions and challenges, in R. S. Barr, R. V. Helgason and J. L. Kennington, eds, ‘Interfaces

in Computer Science and Operations Research’, Kluwer, pp. 1–75.

Glover, F., 2000, Multi-start and strategic oscillation methods — principles to exploit

adaptive memory, in M. Laguna and J. L. Gonza?les-Velarde, eds, ‘Computing Tools for

Modeling, Optimization and Simulation: Interfaces in Computer Science and Operations

Research’, Kluwer, pp. 1–24.

Glover, F., Laguma, M. and Mart??, R., 2000, Fundamentals of scatter search and path re-

linking, in M. Laguna and J. L. Gonza?les-Velarde, eds, ‘Control and Cybernetics’, Vol. 39,

Kluwer, pp. 653–684.

Glover, F. and Laguna, M., 1997, Tabu Search, Kluwer Academic Publishers, Norwell,

Massachusetts.

ILOG, 1999a, ILOG Solver 4.4 Getting Started, ILOG.

ILOG, 1999, ILOG Solver 4.4 Reference Manual, ILOG.

ILOG , 1999c, ILOG Solver 4.4 User’s Manual, ILOG.

Marriott, K. and Stuckey, P. J., 1998, Programming with Constraints: An introduction,

MIT Press, Cambridge, Massachusetts.

Pereira, R. A., Moura, A. V. and de Souza, C. C., 2005, Comparative experiments with

GRASP and constraint programming for the oil well drilling problem, in S. E. Nikoletseas,

ed., ‘Experimental and Efficient Algorithms - WEA 2005, LNCS 3503’, Springer,

pp. 328–340.

Resende, M. G. C. and Ribeiro, C. C., 2001, A GRASP with path-relinking for private

virtual circuit routing, Technical report, AT&amp;amp;T Labs.

Resende, M. G. C. and Ribeiro, C. C., 2002, ‘Greedy randomized adaptive search proce-

dure’, AT&amp;amp;T Labs Research Technical Report TD53RSJY.



5. References 79

Roy, B. and Sussmann, B., 1964, Les proble?mes d’ordonnancement avec contraintes dis-

jonctives, in ‘Note DS No 9 bis’, SEMA, Paris.

Yannakakis, M., 1997, Computational complexity, in E. H. L. Aarts and J. K. Lenstra, eds,

‘Local Search in Combinatorial Optimization’, John Wiley &amp;amp; Sons, Chichester, pp. 19–55.



Ep??logo

Foi explicado no artigo que um dos motivos para a na?o imposic?a?o das restric?o?es de deslo-

camento de recursos diretamente na busca e? o princ??pio fundamental da programac?a?o por

restric?o?es, que defende a dissociac?a?o entre modelo e busca. Assim, o ORCA consome um

tempo de execuc?a?o considera?vel na propagac?a?o das restric?o?es de deslocamento, que sa?o de

ordem O(n2), e portanto perde eficie?ncia. Ainda assim, o ORCA preferiu seguir o princ??pio

da programac?a?o por restric?o?es. Isso porque, por exemplo, no ORCA atual se fosse decidido

que as restric?o?es de deslocamento na?o sa?o mais necessa?rias, apenas o modelo seria alterado.

Ja? se essas restric?o?es estivessem definidas na busca, toda ela teria de ser remodelada. Ou

seja, nesse u?ltimo caso, uma alterac?a?o de modelagem implicaria numa alterac?a?o no algo-

ritmo de busca. Isso dificulta a manutenc?a?o do co?digo, pois para alterar a modelagem um

indiv??duo deve conhecer na?o so? o modelo, como tambe?m a busca.

Assim como no primeiro artigo, optamos por na?o fazer uma ana?lise do desvio padra?o das

produc?o?es das melhores soluc?o?es geradas pelo GRASP e, portanto, de sua robustez. Isso

porque em todos os testes realizados com um mesmo resolvedor em uma mesma insta?ncia,

a diferenc?a entre as produc?o?es de soluc?o?es diferentes nunca superou os 0.5%. Dessa forma,

um mesmo resolvedor GRASP mostra uma variac?a?o muito pequena entre a qualidade de

suas soluc?o?es para uma mesma insta?ncia.

No artigo, foi explicado duas regras, dentre outras, para a escolha dos melhores resolve-

dores GRASP, a saber as regras Ranking1 Rule (R1) e Ranking2 Rule (R2). Para esclarecer

melhor essas regras, suponha um exemplo em que os resolvedores X e Y geram as melhores

soluc?o?es, ambos com uma me?dia ide?ntica na produc?a?o de suas soluc?o?es. Assim, ambos

esta?o na posic?a?o 1, tanto em R1 como em R2, ja? que sa?o os melhores. O resolvedor Z,

por sua vez, vem logo apo?s os resolvedores anteriores na qualidade das soluc?o?es geradas.

Quanto a R1, Z esta? na posic?a?o 2, pois gera as soluc?o?es de segunda melhor qualidade. Ja?

quanto a R2, Z esta? na posic?a?o 3, pois e? o terceiro melhor resolvedor. Essas duas regras

foram utilizadas por representarem visualizac?o?es diferentes e importantes para a escolha do

melhor resolvedor.

Outro fato a ser mencionado aqui e? que, diferentemente de outras publicac?o?es, tais como

Aiex et al. (2001), Resende &amp;amp; Ribeiro (2001) e Aiex et al. (2003), o path-relinking gerou

poucos ganhos em nosso GRASP. Como explicado no artigo, a estrate?gia do path-relinking

consiste em explorar caminhos que levam de uma soluc?a?o a? outra. Esse “caminho”, por sua

vez, pode ser definido de va?rias formas. Em nosso trabalho, optamos por levar um poc?o a?

uma posic?a?o na ordem de execuc?a?o de um recurso igual a?quela em que ocorre na soluc?a?o

sendo comparada. Ou seja, ao caminharmos da soluc?a?o E2 para a E1, tomamos o poc?o P 1

que foi o primeiro executado pelo barco B1 em E1 e o fazemos o primeiro executado pelo

mesmo B1 em E2. Isso e? feito via 2-exchange (Roy &amp;amp; Sussmann (1964)), ou seja, colocamos

80



P 1 em primeiro e colocamos o que antes era primeiro onde estava P 1 no escalonamento. O

processo e? repetido para todos os recursos e todas as posic?o?es de execuc?o?es nos recursos.

Dessa forma E2 convergira? para uma soluc?a?o igual ou semelhante a? E1.

Entretanto, ha? um problema intr??nseco nessa abordagem. Devido a?s mir??ades de res-

tric?o?es do problema, poc?os podem ter sido particionados no escalonamento tanto na soluc?a?o

E2 como na E1, mas na?o necessariamente os mesmos poc?os e da mesma forma. Assim,

para aproximarmos E2 de E1, precisar??amos unir as atividades dos poc?os particionados

em E2 que na?o se particionaram em E1, e separar as atividades dos poc?os unidos de E2

que esta?o particionadas em E1. Ale?m disso, um poc?o pode estar particionado em E1 e

em E2, mas de formas diferentes. Enta?o, aproximar duas soluc?o?es quando ha? particiona-

mentos torna-se um problema razoa?vel de codificac?a?o e, muito pior, demanda um tempo

computacional significativo, prejudicando a performance do algoritmo. Ou seja, se imple-

mentada essa aproximac?a?o, o path-relinking iria tornar as iterac?o?es do GRASP bem mais

lentas. Dessa forma, optamos por aproximar as soluc?o?es apenas com os poc?os que na?o esta?o

particionados em ambas as soluc?o?es, limitando pore?m a aproximac?a?o entre elas. Logo, o

path-relinking implementado e? incompleto.

Outra questa?o e? que nas publicac?o?es ja? citadas opta-se por sempre escolher o melhor

movimento na vizinhanc?a de uma soluc?a?o em direc?a?o a? soluc?a?o guia. Nesta tese, na?o

escolhemos necessariamente o melhor movimento, isso porque decidir qual e? o melhor mo-

vimento poderia demandar um tempo computacional excessivo. Entretanto, escolhemos

movimentos que tendem a ter maior impacto na produc?a?o final, e que portanto tendem a

ser os melhores, ja? que nossos movimentos se concentram nos primeros poc?os escalonados

diferentemente nas soluc?o?es. Uma opc?a?o a ser testada futuramente e? sempre escolher o

melhor movimento, mas aplicar o path-relinking apenas a?s soluc?o?es que superem um certo

crite?rio de qualidade, assim evitando um consumo excessivo de tempo computacional. Para

acelerar ainda mais o algoritmo, pode-se tambe?m truncar o caminho entre as soluc?o?es.

Outro ide?ia seria selecionar a soluc?a?o elite a ser combinada com a soluc?a?o GRASP

aleatoriamente, mas com probabilidades proporcionais ao nu?mero de elementos diferentes

entre essas soluc?o?es. Isso tende a gerar caminhos mais longos entre as duas soluc?o?es, levando

a mais chances de encontrar soluc?o?es melhores (Resende &amp;amp; Ribeiro (2003)).

Ainda outra alternativa e? aplicar a busca local em soluc?o?es encontradas no caminho do

path-relinking. A aplicac?a?o da busca local deve se dar de tempos em tempos, de acordo com

algum para?metro de frequ?e?ncia ou crite?rio de qualidade, para evitar perda de eficie?ncia do

algoritmo.

Assim, melhorias no esquema de path-relinking podem ser tentadas em trabalhos futu-

ros.

81



Parte IV

Considerac?o?es Finais

83



Cap??tulo 8

Concluso?es

O GRASP e? uma metaheur??stica bem estudada e aplicada em diversos problemas NP-

dif??cieis. Entretanto, a Petrobras enfrenta um particular tipo de problema de escalonamento

para o qual na?o existe ferramenta comercial pronta, nem algoritmos eficientes sob estudo.

O GRASP nunca foi testado nesse problema. Assim, pioneiramente, aplicamos o GRASP

ao problema enfrentado pela Petrobras para lidar com escalonamento de recursos em alto

mar. A ferramenta desenvolvida na?o so? automatiza o processo, antes manual, como otimiza

esse processo e supera uma ferramenta desenvolvida pela empresa para o mesmo fim. O

problema e?, provavelmente, tambe?m enfrentado por outras empresas petrol??feras ao redor

do globo, tornando o inovador estudo do problema ainda mais abrangente.

Nosso estudo na?o so? aumentou os conhecimentos sobre a metaheur??stica GRASP, testan-

do-a sob um novo prisma, como criou melhores formas de tratar o problema de escalona-

mento de recursos em alto mar. Para a Petrobras, os ganhos sa?o de cerca de 1 milha?o de

barris de petro?leo por escalonamento, quando comparada a uma ferramenta ja? superior ao

processo manual. Com o barril de petro?leo a US$581, os ganhos sa?o de cerca de US$58

milho?es, por escalonamento. A Petrobras faz em me?dia 2 ou 3 escalonamentos por ano.

Outro ponto importante e? que, apesar de o GRASP fazer uso de randomizac?a?o, em todos

os testes realizados com um mesmo resolvedor em uma mesma insta?ncia, a diferenc?a entre

as produc?o?es de soluc?o?es diferentes nunca superou os 0.5%. Dessa forma, os resolvedores

GRASP se mostraram robustos. Isso e? relevante para os engenheiros da Petrobras, pois o

GRASP dificilmente seria aceito se suas execuc?o?es variassem entre soluc?o?es boas, me?dias,

ruins e situac?o?es de na?o soluc?a?o.

No meio acade?mico, o trabalho foi bem recebido, e um artigo inicial descrevendo a abor-

dagem adotada foi aprovado no 4th International Workshop on Efficient and Experimental

Algorithms (WEA 2005 - http://ru1.cti.gr/wea05/). Convidado, Romulo foi apresentar o

trabalho no congresso, realizado na Ilha de Santorini, Gre?cia. O artigo tambe?m foi publi-

1Cotac?a?o de 16/11/2005.

85



cado no volume 35032 da se?rie Lecture Notes in Computer Science, da editora Springer.

Esse artigo inicial, por ter participado do WEA2005, podera? vir a ser publicado numa

edic?a?o especial do ACM Journal on Experimental Algorithmics (www.jea.acm.org) dedi-

cado ao evento. Um segundo artigo foi premiado no Pre?mio Petrobras de Tecnologia como

terceiro colocado na categoria Produc?a?o3 e foi submetido ao Journal of Heuristics4, uma

importante publicac?a?o da a?rea de otimizac?a?o combinato?ria.

Devido ao sucesso da ferramenta desenvolvida, ela ja? foi implantada na Petrobras e ja?

esta? em uso em processos na Bacia de Campos e Bacia do Esp??rito Santo.

Ao mesmo tempo em que procurou estudar o problema de escalonamento no desen-

volvimento de poc?os de petro?leo em alto mar enfrentado pela Petrobras, essa dissertac?a?o

teve como objetivo adicional comparar os resultados de uma implementac?a?o espec??fica de

programac?a?o por restric?o?es e uma implementac?a?o espec??fica da metaheur??stica GRASP. Ex-

perimentos computacionais foram conduzidos em insta?ncias reais do problema. Conclu??mos

que o GRASP desenvolvido gera soluc?o?es com maior produc?a?o petrol??fera que aquelas gera-

das pelo resolvedor ORCA, que usa programac?a?o por restric?o?es. Tal se deu tanto no EDP,

quanto no EDPDR, quando se adotou te?cnicas mais avanc?adas do GRASP. Os resultados

tambe?m provam que o GRASP supera o resolvedor ORCA quando gera soluc?o?es de mesma

produc?a?o em menor tempo de execuc?a?o.

E? va?lido mencionar que o resolvedor ORCA foi constru??do com a su??te de Programac?a?o

por Restric?o?es da ILOG, que consiste de sofisticadas bibliotecas com mais de uma de?cada

de desenvolvimento5 . Ale?m disso, essa su??te e? de prec?o elevado, tanto no valor de aquisic?a?o,

quanto no valor de manutenc?a?o da licenc?a. Dessa forma, usando o GRASP desenvolvido,

a Petrobras pode evitar esses custos. Note, entretanto, que a su??te da ILOG favorece a

facilidade de desenvolvimento, de manutenc?a?o e de entendimento do co?digo fonte. Note

tambe?m que os resultados gerados pelo ORCA superam resultados manuais, i.e., soluc?o?es

desenvolvidas por engenheiros.

De uma maneira geral, acredita-se que os objetivos dessa dissertac?a?o foram alcanc?ados

satisfatoriamente. Insta?ncias reais do problema original foram resolvidas em tempos de

computac?a?o aceita?veis. Ale?m disso, foi poss??vel conhecer mais a fundo todas as te?cnicas

utilizadas e as dificuldades intr??nsecas do problema tratado. Desse modo, contribuiu-se

positivamente para o sucesso de futuros empreendimentos nessa a?rea.

2http://www.springeronline.com/sgw/cda/frontpage/0,11855,4-149-22-48266374-0,00.html
3Vide: http://www2.petrobras.com.br/tecnologia2/port/pptecnologia.asp
4http://www.kluweronline.com/issn/1381-1231
5Vide http://www.ilog.com

86



Cap??tulo 9

Trabalhos Futuros

O trabalho desenvolvido nesta dissertac?a?o pode ser estendido de diversas maneiras:

• Diferentemente de outras publicac?o?es, tais como Aiex et al. (2001), Resende &amp;amp; Ribeiro

(2001) e Aiex et al. (2003), o path-relinking gerou poucos ganhos em nosso GRASP.

Poder-se-ia tentar adaptar essa te?cnica de uma melhor forma para o EDP, usando por

exemplo as abordagens citadas no ep??logo do Cap??tulo 7.

• A Petrobras vem incorporando clusters de processadores ao seu parque computacio-

nal. Dessa forma, seria interessante adaptar a ferramenta GRASP aqui desenvolvida

para atuar paralelamente, utilizando o paralelismo dos clusters.

• Testar te?cnicas de “perturbac?o?es nos custos” (cost perturbations) no GRASP, como

em Canuto et al. (2001), Ribeiro et al. (2002) e Resende &amp;amp; Ribeiro (2002).

• Testar te?cnicas h??bridas, como GRASP com busca tabu (Ribeiro et al. (2002), Colome?

&amp;amp; Serra (1998)) ou GRASP com algoritmos gene?ticos (Lourenc?o et al. (1998)).

• Testar outras te?cnicas, como busca tabu e algoritmos gene?ticos para o EDP, e com-

para?-las ao GRASP.

87



Bibliografia

Aiex, R. M., Binato, S. &amp;amp; Resende, M. G. C. (2003), ‘Parallel GRASP with path-relinking

for job shop scheduling’, Parallel Computing 29(4), 393–430.

Aiex, R. M., Resende, M. G. C. &amp;amp; Toraldo, G. (2001), GRASP with path-relinking for the

three-index assignment problem, Technical report, AT&amp;amp;T Labs.

Binato, S. &amp;amp; Oliveira, G. (2002), ‘A reactive GRASP for transmission network expansion

planning’, Essays And Surveys In Metaheuristics - Kluwer Academic Publishers .

Canuto, S. A., Resende, M. G. C. &amp;amp; Ribeiro, C. C. (2001), ‘Local search with perturbations

for the prize-collecting steiner tree problem in graphs’, Networks 38, 50–58.

Clocksin, W. (1987), ‘Principles of the delphi parallel inference machine’, Computer Journal

30(5), 386–392.

Colome?, R. &amp;amp; Serra, D. (1998), ‘Consumer choice in competitive location models: Formu-

lations and heuristics’, Economics Working Papers (290).

Cormen, T. H., Leiserson, C. E., Rivest, R. L. &amp;amp; Stein, C. (2001), Introduction to Algo-

rithms, 2nd edn, MIT Press.

do Nascimento, J. M. (2002), Hybrid computational tools for the optimization of the produc-

tion of petroleum in deep waters, Master’s thesis, Institute of Computing, University

of Campinas.

Faria, H., Binato, S., Resende, M. &amp;amp; Falca?o, D. M. (2005), ‘Power transmission network

design by a greedy randomized adaptive path relinking approach’, IEEE Transactions

on Power Systems 20(1), 43–49.

Festa, P. &amp;amp; Resende, M. (2002), ‘GRASP: An annotated bibliography’, Essays And Surveys

In Metaheuristics - Kluwer Academic Publishers .

Fortuna, V. J., Moura, A. V. &amp;amp; de Souza, C. C. (2002), Relato?rio 2 de iniciac?a?o cient??fica,

Relato?rio FAPESP, Instituto de Computac?a?o, Unicamp.

89



Garey, M. R. &amp;amp; Johnson, D. S. (1979), Computers and intractability: A guide to the theory

of NP-Completeness, W. H. Freeman and Company, San Francisco, California.

Harvey, W. D. &amp;amp; Ginsberg, M. L. (1995), ‘Limited discrepancy search’, Proceedings of the

International Joint Conference on Artificial Intelligence (IJCAI) 1, 607–613.

Hasle, G., Haut, R., Johansen, B. &amp;amp; Ølberg, T. (1997), Well activity scheduling – an ap-

plication of constraint reasoning, in ‘Proceedings of PACT’97 (The 1997 International

Conference on Parallel Architectures and Compilation Techniques)’, San Francisco,

Callifornia.

ILOG (1999a), ILOG Solver 4.4 Reference Manual, ILOG.

ILOG (1999b), ILOG Solver 4.4 User’s Manual, ILOG.

Jaffar, J. &amp;amp; Lassez, J. (1987), Constraint logic programming, in ‘14 th ACM Symposium on

Principles of Programming Languages’, Munique, Alemanha, pp. 111–119.

Le Pape, C. (1994), ‘Implementation of resource constraints in ILOG SCHEDULE: a li-

brary for the development of constraint-based scheduling systems’, Intelligent Systems

Engineering 3(2), 55–66.

Lever, J., Wallace, M. &amp;amp; Richards, B. (1995), ‘Constraint logic programming for scheduling

and planning’, BT Technology Journal 13(1), 73–80.

Lourenc?o, H. R., Paixa?o, J. &amp;amp; Portugal, R. (1998), Metaheuristics for the bus-driver sche-

duling problem, in ‘Economics Working Papers’, Vol. 304, Department of Economics

and Business, Universitat Pompeu Fabra.

Marriott, K. &amp;amp; Stuckey, P. J. (1998), Programming with Constraints: An introduction, MIT

Press, Cambridge, Massachusetts.

Meseguer, P. (1997), ‘Interleaved depth-first search’, Proceedings of the International Joint

Conference on Artificial Intelligence (IJCAI) 2, 1382–1387.

Moura, A. V. &amp;amp; de Souza, C. C. (2000), ‘Reunio?es com Engenheiros da Petrobras, estacio-

nados na Bacia Petrol??fera de Campos — notas na?o publicadas’.

Nilsson, N. J. (1971), Problem Solving Methods in Artificial Intelligence, McGraw-Hill.

Pereira, R. A., Moura, A. V. &amp;amp; de Souza, C. C. (2002), Estudo e desenvolvimento de ferra-

mentas para sequenciamento de atividades no desenvolvimento de poc?os de petro?leo:

Uso de programac?a?o por restric?o?es, Relato?rio FAPESP, Instituto de Computac?a?o, Uni-

camp.

90



Pereira, R. A., Moura, A. V. &amp;amp; de Souza, C. C. (2005a), Comparative experiments with

GRASP and constraint programming for the oil well drilling problem, in S. E. Nikolet-

seas, ed., ‘Experimental and Efficient Algorithms - WEA 2005, LNCS 3503’, Springer,

pp. 328–340.

Pereira, R. A., Moura, A. V. &amp;amp; de Souza, C. C. (2005b), Constraint programming

and grasp approaches to schedule oil well drillings, Relato?rio te?cnico IC-05-001,

http://www.ic.unicamp.br/reltec-ftp/2005/titles.html, Instituto de Computac?a?o, Uni-

camp.

Pereira, R. A., Moura, A. V. &amp;amp; de Souza, C. C. (2005c), Grasp strategies for schedu-

ling activities at oil wells with resource displacement, Relato?rio te?cnico IC-05-028,

http://www.ic.unicamp.br/reltec-ftp/2005/titles.html, Instituto de Computac?a?o, Uni-

camp.

Resende, M. G. C. &amp;amp; Ribeiro, C. C. (2001), A GRASP with path-relinking for private

virtual circuit routing, Technical report, AT&amp;amp;T Labs.

Resende, M. G. C. &amp;amp; Ribeiro, C. C. (2002), ‘Greedy randomized adaptive search procedure’,

AT&amp;amp;T Labs Research Technical Report TD53RSJY .

Resende, M. G. C. &amp;amp; Ribeiro, C. C. (2003), GRASP and path-relinking: Recent advances

and applications, Technical report td-5tu726, AT&amp;amp;T Labs Research.

Ribeiro, C. C., Uchoa, E. &amp;amp; Werneck, R. F. (2002), ‘A hybrid GRASP with perturbations

for the steiner problem in graphs’, INFORMS Journal on Computing 14, 228–246.

Ribeiro, M. (2002), ‘A GRASP for job shop scheduling’, Essays And Surveys In Metaheu-

ristics pp. 59–79.

Roy, B. &amp;amp; Sussmann, B. (1964), Les proble?mes d’ordonnancement avec contraintes disjonc-

tives, in ‘Note DS No 9 bis’, SEMA, Paris.

Souza, M., Duhamel, C. &amp;amp; Ribeiro, C. (2004), ‘A GRASP heuristic for the capacitated

minimum spanning tree problem using a memory-based local search strategy’, Applied

Optimization pp. 627–657.

Srinivasan, A., Ramakrishnan, K. &amp;amp; Kumaran, K. (2000), ‘Optimal design of signaling

networks for internet telephony’, Lucent Technologies, Labs Innovations .

Walsh, T. (1997), ‘Depth-bounded discrepancy search’, Proceedings of the International

Joint Conference on Artificial Intelligence (IJCAI) 2, 1388–1393.

91



Yunes, T. H., Moura, A. V. &amp;amp; de Souza, C. C. (2000a), A hybrid approach for solving large

scale crew scheduling problems, in ‘Lecture Notes in Computer Science, vol. 1753’,

Boston, MA, EUA, pp. 293–307. Anais do Second International Workshop on Practical

Aspects of Declarative Languages (PADL’00).

Yunes, T. H., Moura, A. V. &amp;amp; de Souza, C. C. (2000b), Solving very large crew scheduling

problems to optimality, in ‘14 th ACM Symposium on Applied Computing (SAC’00)’,

Como, Ita?lia, pp. 446–451.

92




</field>
	</doc>
</add>