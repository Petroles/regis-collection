<?xml version="1.0" encoding="utf-8"?>
<add>
	<doc>
		<field name="docid">BR-TU.14655</field>
		<field name="filename">21017_TCC_CleitonJanke.pdf</field>
		<field name="filetype">PDF</field>
		<field name="text">
  

UNIVERSIDADE FEDERAL DE SANTA CATARINA 

 

 

 

 

 

DESENVOLVIMENTO DE APLICAÇÃO PARA A ETAPA 

DE ESPECIFICAÇÃO DA METODOLOGIA DE 

DESENVOLVIMENTO DE ONTOLOGIAS EM REDE NEON. 

 

 

 

 

 

 

 

Cleiton Edgar Janke Duarte 

 

 

 

 

 

 

 

Florianópolis – SC 

2009/1 



  

UNIVERSIDADE FEDERAL DE SANTA CATARINA 

DEPARTAMENTO DE INFORMÁTICA E ESTATÍSTICA 

CURSO DE SISTEMAS DE INFORMAÇÃO 

 

 

DESENVOLVIMENTO DE APLICAÇÃO PARA A ETAPA DE 

ESPECIFICAÇÃO DA METODOLOGIA DE 

DESENVOLVIMENTO DE ONTOLOGIAS EM REDE NEON. 

 

 

 

Cleiton Edgar Janke Duarte 

 

 

 

Trabalho de conclusão de curso 

apresentado como parte dos 

requisitos para obtenção do grau 

de Bacharel em Sistemas de Informação. 

 

 

 

 

 

Florianópolis – SC 

2009/1 



  

Cleiton Edgar Janke Duarte 

 

DESENVOLVIMENTO DE APLICAÇÃO PARA A ETAPA DE 

ESPECIFICAÇÃO DA METODOLOGIA DE DESENVOLVIMENTO DE 

ONTOLOGIAS EM REDE NEON. 

 

 

 

Trabalho de conclusão de curso 

apresentado como parte dos 

requisitos para obtenção do grau 

de Bacharel em Sistemas de Informação. 

 

 

 

Banca Examinadora: 

 

 

__________________________________ 

Prof. Dr. José Leomar Todesco 

Universidade Federal de Santa Catarina  

Orientador 

 

__________________________________ 

Prof. Dr. Fernando Alvaro Ostuni Gauthier 

Universidade Federal de Santa Catarina  

Co-orientador 

 

__________________________________ 

Prof. Dr. Rogério Cid Bastos  

Universidade Federal de Santa Catarina 



  

SUMÁRIO 

LISTA DE FIGURAS ................................................................................................6 

RESUMO ....................................................................................................................7 

1) INTRODUÇÃO ......................................................................................................8 

1.1) OBJETIVO GERAL ..............................................................................................8 

1.2) OBJETIVO ESPECÍFICO .......................................................................................8 

2) ENGENHARIA DE ONTOLOGIAS ...................................................................9 

2.1) ONTOLOGIA.......................................................................................................9 

2.1.1) Classificação de Ontologias ...................................................................11 

2.1.2) Uso de Ontologias ..................................................................................13 

2.1.3) A Engenharia de Ontologias e suas Atividades......................................15 

2.2) METODOLOGIAS PARA CONSTRUÇÃO DE ONTOLOGIAS ...................................17 

2.2.1) Metodologia On-to-Knowledge ..............................................................18 

2.2.2) Metodologia METHONTOLOGY ...........................................................19 

2.2.3) Metodologia NeOn .................................................................................20 

2.3) FERRAMENTAS ................................................................................................23 

2.3.1) Protégé ...................................................................................................24 

2.3.2) OntoKEM................................................................................................25 

2.3.3) NeOn Toolkit ..........................................................................................26 

3) A FASE DE ESPECIFICAÇÃO DE ONTOLOGIAS ......................................27 

3.1) COMO É VISTO NO NEON.................................................................................27 

3.2) COMO FOI VISTO NO ONTOKEM ......................................................................30 

3.3) CONSIDERAÇÕES .............................................................................................33 

4) APLICAÇÃO PARA A FASE DE ESPECIFICAÇÃO ....................................34 

4.1) UM POUCO SOBRE O MVP ...............................................................................35 

4.2) ESPECIFICAÇÃO DA APLICAÇÃO ......................................................................37 

4.3) O XML PARA PERSISTÊNCIA ...........................................................................42 

4.4) DETALHAMENTO DA ESTRUTURA DA APLICAÇÃO...........................................46 

4.4.1) O Pacote “Data”....................................................................................48 

4.4.2) O Pacote “Beans” ..................................................................................50 

4.4.3) A classe “ExtractController” e a extração de termos............................52 

4.4.4) O Pacote “View”....................................................................................53 

4.5) RESULTADOS APRESENTADOS .........................................................................55 



  

5) CONCLUSÃO ......................................................................................................63 

5.1) CONSIDERAÇÕES FINAIS..................................................................................63 

5.2) TRABALHOS FUTUROS.....................................................................................64 

6) REFERÊNCIAS BIBLIOGRÁFICAS ...............................................................65 

ANEXO A – CÓDIGO-FONTE DA APLICAÇÃO. .............................................69 

ANEXO B — ARTIGO..........................................................................................197 

 



  

LISTA DE FIGURAS 

FIGURA 1 – NÍVEIS DE ABSTRAÇÃO PARA ONTOLOGIAS ............................................................11 

FIGURA 2 – CLASSIFICAÇÃO DE ONTOLOGIA POR HIERARQUIA..................................................12 

FIGURA 3 – PROCESSO DE DESENVOLVIMENTO DA METODOLOGIA ON-TO-KNOWLEDGE ..........18 

FIGURA 4 – PROCESSO DE DESENVOLVIMENTO E CICLO DE VIDA DA METODOLOGIA 

METHONTOLOGY .......................................................................................................20 

FIGURA 5 – ETAPAS E CENÁRIOS PARA CONSTRUÇÃO DE ONTOLOGIAS EM REDE PRESENTES NA 

METODOLOGIA NEON ......................................................................................................23 

FIGURA 6 – TELA DE EXEMPLO DA FERRAMENTA PROTÉGÉ, USANDO A ONTOLOGIA DE EXEMPLO 

WINES...............................................................................................................................24 

FIGURA 7 – TELA DE EXEMPLO DA FERRAMENTA ONTOKEM, MÓDULO “VOCABULÁRIO” ........26 

FIGURA 8 – TELA DE EXEMPLO DA FERRAMENTA NEON-TOOLKIT............................................26 

FIGURA 9 – MODELO DO DOCUMENTO OSRD, DA METODOLOGIA NEON..................................30 

FIGURA 10 – TELA DE EXEMPLO DO MÓDULO DE “PROJETO” DO ONTOKEM ............................32 

FIGURA 11 – TELA DE EXEMPLO DO MÓDULO DE “PERGUNTAS DE COMPETÊNCIA” DO 

ONTOKEM.......................................................................................................................32 

FIGURA 12 – REPRESENTAÇÃO DO PADRÃO DE PROJETO MVP NA ESTRUTURA PASSIVE VIEW...36 

FIGURA 13 – DIAGRAMA DE CASOS DE USO DA APLICAÇÃO ......................................................37 

FIGURA 14 – ESTRUTURA DE CLASSES DA APLICAÇÃO COM O PADRÃO MVP ............................40 

FIGURA 15 – SUBESTRUTURA DA APLICAÇÃO SOBRE A PARTE DE MODELAGEM DAS REGRAS DE 

NEGÓCIO DA ETAPA DE ESPECIFICAÇÃO. ..........................................................................42 

FIGURA 16 – ESTRUTURA DO ARQUIVO XML DE PERSISTÊNCIA................................................43 

FIGURA 17 — PACOTE “BEANS” E SUAS CLASSES PARA COMUNICAÇÃO ENTRE AS CAMADAS. .51 

FIGURA 18 — O PACOTE “VIEW” E AS CLASSES DE REPRESENTAÇÃO E MANIPULAÇÃO DOS 

MÓDULOS DA APLICAÇÃO. ...............................................................................................54 

FIGURA 19 — TELA INICIAL DA APLICAÇÃO..............................................................................58 

FIGURA 20 — MENU “FILE” E AS OPÇÕES DE INÍCIO DE USO DE UM PROJETO. ...........................58 

FIGURA 21 — ABA DO MÓDULO “PROJECT”, NO ESTADO DE EXIBIÇÃO (ACIMA) E NO ESTADO DE 

EDIÇÃO (ABAIXO). ...........................................................................................................60 

FIGURA 22 — MÓDULO “COMPETENCE QUESTIONS”. ..............................................................61 

FIGURA 23 — MÓDULO “TERMS”. ............................................................................................62 

 



  

RESUMO 

 

O propósito das páginas que seguem é o de apresentar o 

trabalho de conclusão de curso sobre “Desenvolvimento de aplicação 

para a etapa de especificação da metodologia de desenvolvimento de 

ontologias em rede NeOn”. Nesse trabalho os objetivos foram 

conhecer e apresentar a metodologia NeOn, com foco na sua etapa de 

especificação, passando na seqüencia à elaboração de um sistema 

que desse suporte a esta atividade. Estruturalmente o trabalho 

descreve os conceitos mais importantes do escopo de trabalho 

(ontologias, engenharia de ontologias, etc.) nos quais está a 

metodologia NeOn, fazendo em seguida uma análise da etapa de 

especificação desta metodologia. É também apresentada a 

modelagem dos requisitos da aplicação, feita com base na análise 

anterior, descrevendo detalhadamente em seguida o processo de 

desenvolvimento da aplicação e sua estrutura. Para finalizar, 

conclusões sobre a referida aplicação bem como sobre a etapa a qual 

ela se propõe a dar suporte. 

 

Palavras-chaves: ontologia, ontologia em rede, metodologia 

NeOn, etapa de especificação. 



  

 

1) INTRODUÇÃO 

O aumento gradativo do uso das ontologias tem exigido cada 

vez mais ferramentas que automatizem o processo de construção 

destas. Nesse sentido, surgiu na Europa o projeto NeOn. Este projeto 

propôs uma metodologia que prevê o desenvolvimento de ontologias 

em rede, visando o reuso e a reengenharia de ontologias já existentes 

para elaboração de novas. Para suportar esta metodologia, foi 

concebido o NeOn Toolkit, um plataforma que integra várias 

ferramentas específicas para atender a diferentes atividades 

relacionadas a metodologia NeOn. 

Observando a falta de uma ferramenta que suportasse a etapa 

de especificação dessa metodologia este trabalho propõe o 

“Desenvolvimento de uma aplicação para a etapa de especificação da 

metodologia de desenvolvimento de ontologias em rede NeOn”. 

 

1.1) Objetivo Geral 

Desenvolvimento de uma aplicação que suporte a etapa de 

especificação da metodologia de desenvolvimento de ontologias em 

rede NeOn. 

 

1.2) Objetivo Específico 

• Conhecer o projeto NeOn, seus objetivos e estrutura. 

• Conhecer a metodologia de desenvolvimento de ontologias em 

rede do NeOn. 

• Elaborar uma estrutura de classes que realize o suporte à etapa 

de especificação de ontologias da metodologia NeOn. 



  

• Desenvolver uma aplicação com base na estrutura de classes 

elaborada. 

 

2) ENGENHARIA DE ONTOLOGIAS 

Este capítulo aborda alguns conceitos e processos envolvidos 

na Engenharia de Ontologias. Mais exatamente, discorrerá a respeito 

de ontologia — seu conceito, classificações possíveis e formas de 

utilização —, sobre a própria Engenharia de Ontologias — 

descrevendo os estágios envolvidos no processo de desenvolvimento 

de uma ontologia —, também sobre algumas metodologias existentes 

para desenvolvimento de ontologias e, por fim, sobre algumas 

ferramentas computacionais existentes nesse escopo. 

 

2.1) Ontologia 

O conceito de ontologia variou de definição desde seu 

surgimento na Filosofia até as sua aplicação atual no âmbito da 

Ciência da Computação e Engenharia do Conhecimento (KIRYAKOV, 

2006). Em sua origem o conceito era de uma disciplina dedicada ao 

estudo da natureza e da existência dos elementos. Já na Ciência da 

Computação, trata da representação do conhecimento, a organização 

e estruturação dos conhecimentos sobre um determinado domínio. 

A definição inicialmente utilizada na Ciência da Computação 

veio, segundo Kiryakov (2006), por Gruber (1993) que define o 

conceito de ontologia como “uma especificação explícita de uma 

conceitualização”. Um outro autor, Borst (1997) atribuiu mais detalhes 

a definição, sendo que para ele “ontologia é uma especificação formal 

e explícita de uma conceitualização compartilhada”. 



  

Devedzic (2002) interpreta ontologia como um sistema de 

conceitos e das relações existentes entre esses conceitos, sendo os 

conceitos definidos e interpretados declarativamente. O sistema 

modelaria um determinado domínio definindo o vocabulário de termos 

do mesmo e as restrições das combinações possíveis entre esses 

termos. 

Segundo Hepp et al. (2007) ontologias poderiam ser definidas 

como representações formais de domínios, como um entendimento 

compartilhado sobre um domínio. Sua construção se daria por um 

processo social entre os especialistas do domínio e os engenheiros do 

conhecimento definindo assim esse entendimento comum, como um 

contrato. A construção da ontologia se dá, segundo o autor, de forma 

dinâmica, havendo, por parte dos participantes do processo, inclusões, 

modificações e descartes de elementos da ontologia. 

Kiryakov (2006) expressa formalmente ontologia como um 

relacionamento de quatro elementos representando isso pela 

quádrupla: 

O = {C, R, I, A} 

Sendo “O” a ontologia, os demais elementos são: 

• C: conjunto de classes que representam os conceitos de um 

determinado domínio; 

• R: conjunto das relações ou associações existentes entre os 

conceitos; 

• I: conjunto das instâncias advindas das classes 

• A: conjunto de axiomas do domínio, que definem as restrições e 

regras que atuam sobre as instâncias. 

Daconta et al. (2003) mencionam que ontologias inserem 

definições computáveis (passíveis de processamento e interpretação 

por computadores) para conceitos de um dado domínio e para os 



  

relacionamentos entre esses conceitos. Eles acrescentam ainda que 

para ser computável, três níveis de abstração são importantes ao 

desenvolvimento da ontologia, como pode ser visto na Figura 1. No 

nível mais alto estão os elementos da ontologia (classes, relações 

entre as classes, propriedades das classes, instâncias e os axiomas), 

sendo este o nível da linguagem de representação do conhecimento. 

Abaixo, no nível de conceitos da ontologia, estão os conceitos do 

domínio de interesse na linguagem de representação do 

conhecimento. Já no último nível, de instâncias da ontologia, estão 

representados os objetos do domínio, com os respectivos valores para 

as propriedades. 

 
Figura 1 – Níveis de abstração para ontologias 

Fonte: Adaptado e traduzido de Daconta et al. (2003). 

 

2.1.1) Classificação de Ontologias 

Ontologias podem ser classificadas de diferentes formas, 

tomando por base sua hierarquia ou então a expressividade da 

mesma. 

Em termos de hierarquia há três níveis de classificação 

aplicáveis (GUARINO, 1998): 

? Ontologias de alto nível: nesse grupo estão as ontologias 

que descrevem conceitos de aplicação geral, que são independentes 

de um problema ou domínio específico, por exemplo, conceitos de 

espaço, tempo, objetos, etc. Tem boa aplicação para reuso na 



  

construção de outras ontologias, mais específicas, que envolvam 

esses conceitos mais gerais. 

? Ontologias de domínio e de tarefa: as de domínio 

descrevem conceitos genéricos de um domínio em particular (como no 

exemplo citado em RAUTEMBERG (2009), o termo “doença” no 

domínio de “Medicina”). As ontologias de tarefa descrevem o conjunto 

de ações ou tarefas realizadas em um determinado domínio (exemplo, 

a ação de “diagnosticar” também no domínio de “Medicina” 

(RAUTEMBERG, 2009)). 

? Ontologias de aplicação: As desse nível descrevem 

conceitos que integram os das ontologias do nível anterior (de domínio 

e de tarefas), sendo uma especialização dessas normalmente. 

Na Figura 2 é possível ter uma representação visual da 

classificação acima descrita. 

 
Figura 2 – Classificação de ontologia por hierarquia 

Fonte: Adaptado e traduzido de Guarino (1998). 

 

Na classificação por expressividade (GOMÉZ-PÉREZ; 

CORCHO, 2002) tem-se dois grupos possíveis, determinados pelo tipo 



  

de linguagem de representação aplicada e pelos elementos 

constituintes da ontologia, sendo esses grupos: 

? Ontologias de menor expressividade: as que modelam 

informação sobre um domínio (conceitos e taxonomia), não vinculando 

os axiomas e restrições. Por justamente não apresentar uma 

expressividade tão alta em relação ao domínio abordado (pela não 

necessidade dos axiomas e restrições) é que a inferência 

computacional sobre a mesma é dificultada. 

? Ontologias de maior expressividade: essas incorporam os 

axiomas e restrições do domínio, o que requer maior expressividade, 

tornando também o raciocínio, por parte dos computadores, mais fácil. 

 

2.1.2) Uso de Ontologias 

Ontologias estão geralmente associadas à informação e 

conhecimento sobre domínios sendo utilizadas para a representação 

desse conhecimento em aplicações computacionais. Como exemplos 

de uso podem ser mencionados a integração e recuperação de 

informações na web e a gestão de conhecimento sobre um domínio 

(STUDER et al., 1998). Outros autores (GRUNINGER; LEE, 2002) 

apresentam ainda outras aplicações para ontologias: 

? Comunicação: entre sistemas computacionais, seres 

humanos, ou ainda entre ambos. 

? Inferência computacional: usadas internamente na 

representação e manipulação de informações, além de também serem 

usadas para análise de estruturas, algoritmos e, entradas e saídas de 

sistemas. 

? Reuso e utilização do conhecimento: possibilitam definir 

bibliotecas ou repositórios de informações. 



  

Ainda no contexto do conhecimento, focando na engenharia 

sobre a mesma, ontologias podem ser empregadas para (MIKA; 

AKKERMANS, 2005): 

? Comunicação do conhecimento: processo no qual estão as 

tarefas ligadas à compreensão dos conceitos. 

? Integração do conhecimento: processo onde estão as 

atividades que definem o relacionamento entre os conceitos. 

? Raciocínio com conhecimento: processo com tarefas 

relacionadas à produção de novos conhecimentos. 

Quando se altera o foco no conhecimento para a gestão do 

mesmo, ainda destacam-se mais aplicações para as ontologias 

(GSEVIC et al., 2006): 

? Colaboração: ontologias podem servir como um “esqueleto 

unificado do conhecimento” para projetos onde a equipe envolvida é 

interdisciplinar, possibilitando assim uma melhor comunicação e 

entendimento entre os membros sobre os conceitos relacionados ao 

domínio. 

? Interoperabilidade: uma ontologia pode facilitar a integração 

de diferentes fontes de dados para busca de informações, por 

exemplo, desde que essas distintas fontes reconheçam a mesma 

ontologia, facilitando assim a conversão de dados quando necessário, 

por exemplo. 

? Educação: ontologias podem servir como fonte de referência 

para estudos pesquisas e propagação do conhecimento de um 

determinado domínio, isso quando a ontologia representa um 

consenso comum dos conceitos desse domínio. 

? Modelagem: ontologias podem, no contexto de Sistemas 

Baseados em Conhecimento, servir como um “bloco de construção 

reutilizável” (RAUTEMBERG, 2009) podendo este ser utilizado em 



  

aplicações distintas. Exemplo: uma ontologia sobre carros pode servir 

a um sistema web para venda de automóveis, onde pode trazer 

sugestões de carros para compras como também informações e 

conhecimentos pertinentes sobre os carros vendidos. 

 

2.1.3) A Engenharia de Ontologias e suas 

Atividades 

A Engenharia de Ontologias é a disciplina responsável por 

administrar e se preocupar com as atividades, processos, ciclos de 

vida, métodos e metodologias envolvidos no desenvolvimento de 

ontologias, bem como nas ferramentas e linguagens envolvidos na 

construção dessas ontologias (GÓMEZ-PÉREZ et al., 2004). 

A terminologia envolvida na Engenharia de Ontologias foi 

baseada na Engenharia de Software, advindo daí a semelhança nas 

atividades envolvidas no desenvolvimento de ontologias com as de 

desenvolvimento de software (PINTO; MARTINS, 2004 e YE et al., 

2007). 

A seguir, as atividades presentes no desenvolvimento de 

ontologias: 

? Especificação: etapa onde são identificados propósito e 

escopo da ontologia a ser desenvolvida. Podem ser aplicadas as 

perguntas “Por que a ontologia é construída?” e “Quais são as 

intenções de uso e usuários da ontologia?”, pois as respostas destas 

serão as definições, respectivamente, do propósito e do escopo. 

? Conceitualização: é onde se define um modelo conceitual da 

ontologia, que represente os conceitos do domínio abordado e as 

relações entre estes. A definição se baseia nas informações colhidas 

na atividade anterior (especificação). 



  

? Formalização: nesta atividade o modelo conceitual 

anteriormente definido é formalizado, aplicando-se restrições e 

axiomas aos conceitos já estabelecidos. Dessa forma é feita a 

restrição das interpretações desses termos e feita a organização 

hierárquica dos mesmos (através de relações estruturais como “é-um” 

ou “parte-de”).? Implementação: a ontologia é implementada através 

de uma linguagem de representação do conhecimento, que deve ser 

escolhida adequadamente para cada caso. 

? Manutenção: como no desenvolvimento de softwares, é onde 

são feitas correções e atualizações na ontologia, algumas vezes 

provocados por novos requisitos que surgem, ou são visualizados, 

durante o desenvolvimento. 

Além dessas etapas pré-definidas há outras que também são 

importantes, não apenas em um dado momento do desenvolvimento, 

mas durante todo o ciclo de vida da ontologia (PINTO; MARTINS, 

2004): 

? Aquisição do conhecimento: como o nome indica seria 

adquirir conhecimento a respeito do domínio da ontologia, fazendo 

isso através de especialistas nesse domínio ou então de bibliografia 

sobre o mesmo. Algumas técnicas possíveis para aquisição de tal 

seriam brainstorming, entrevistas, análises de textos, etc. 

? Avaliação: julgamento técnico da qualidade da ontologia, que 

pode ser: 

? Avaliação técnica: é utilizado um framework de referência 

para o julgamento, sendo que essa avaliação envolve as atividades 

de: 

? verificação, que garante a correção segundo fontes de 

conhecimento especializadas; 



  

? validação, que garante o alinhamento à finalidade 

estabelecida para a ontologia, de acordo com os resultados da etapa 

de especificação. 

? Avaliação de usuários: é feito o julgamento de usabilidade e 

utilidade da ontologia, do ponto de vista do usuário. 

? Documentação: registro de toda a ontologia e de todo o 

processo de desenvolvimento, etapa por etapa (o que, como e por que 

foi feito), incluindo os documentos finais de cada etapa, a fim de gerar 

um material completo para o entendimento, uso e reuso, e 

manutenção da ontologia. 

Essas atividades são as mais comuns no que diz respeito a 

desenvolvimento de ontologias, sendo que existem outras atividades 

ligadas a metodologias mais específicas da Engenharia de Ontologias. 

Nesse trabalhão o foco estará concentrado na primeira etapa 

apresentada: Especificação. 

 

2.2) Metodologias para Construção de Ontologias 

Ainda não há uma metodologia que tenha se definido como 

padrão para desenvolvimento de ontologias (PINTO; MARTINS, 2004). 

Um dos argumentos lançados para isso é que as metodologias 

possuem atividades que não estão compreendidas entre si, 

necessitando-se assim a combinação de metodologias para abrangir 

as atividades necessárias ao desenvolvimento de uma ontologia 

(FERNADEZ-LÓPEZ; GÓMEZ-PÉREZ, 2002). 

Nessa sessão serão apresentadas, brevemente, algumas 

metodologias comuns no desenvolvimento de ontologias — a On-to-

Knowledge e a METHONTOLOGY — e a metodologia NeOn, sobre a 

qual se dará o desenvolvimento do trabalho. 



  

 

2.2.1) Metodologia On-to-Knowledge 

Tendo sido desenvolvida em uma cooperação entre várias 

entidades européias (FENSEL; HERMELEN, 2008) a metodologia On-

to-Knowledge teve como foco de concepção a utilização em Sistemas 

de Gestão do Conhecimento. Essa metodologia é dividida em cinco 

fases, como pode ser visto na Figura 3, descritas a seguir (SURE; 

STUDER, 2003): 

 
Figura 3 – Processo de desenvolvimento da metodologia On-to-Knowledge 

Fonte: Adaptado e traduzido de Sure e Studer (2003). 

 

? Estudo de viabilidade: é uma fase pré-desenvolvimento, 

anterior ao real início da metodologia. O estudo realizado nessa fase 

visa mapear todo o contexto envolvido no desenvolvimento, 

identificando, por exemplo, os problemas ou oportunidades que a 

organização envolvida no projeto tem e verificando se existe a 

necessidade real de uma ontologia para a mesma. O estudo é 

realizado utilizando CommonKADS como metodologia (SCHREIBER 

et al., 2002). 

? Início da ontologia: aqui realmente inicia a metodologia. 

Trata-se da fase de especificação descrita anteriormente na sessão 

2.1.3, onde são definidos os requisitos para desenvolvimento, o 

domínio abrangido, as fontes de conhecimento, os atores e cenários, 



  

as questões de competência — que irão definir os termos envolvidos 

no domínio, que passarão depois a ser os conceitos e relações de tal 

— além de outros itens. 

? Refinamento: é onde é feito o desenvolvimento da ontologia, 

muitas vezes juntamente com os especialistas no domínio, onde são 

feitas análises sobre a ontologia a fim de evoluir e estendê-la, de 

acordo com o que foi anteriormente definido. O produto final desta fase 

é uma versão estável da ontologia. 

? Avaliação: aqui é feita a verificação da ontologia mediante os 

requisitos estabelecidos na fase inicial do desenvolvimento. Por muitas 

vezes são utilizadas as perguntas de competência como base para 

analisar se a ontologia responde satisfatoriamente essas questões, 

representando assim bem o domínio. 

? Manutenção e Evolução: é uma fase pós-desenvolvimento 

que visa aumentar a representatividade da ontologia ou adaptá-la a 

um novo requisito, por exemplo, cabendo a responsabilidade dessa 

fase à organização detentora da ontologia. 

 

2.2.2) Metodologia METHONTOLOGY 

Esta metodologia nasceu em um grupo de pesquisa em 

Engenharia de Ontologias da Universidade Politécnica de Madri, e tem 

forte embasamento nas metodologias de Engenharia de Software e 

Engenharia do Conhecimento (GOMÉZ-PÉREZ et al., 2004). Nessa 

metodologia, o ciclo de vida de uma ontologia é baseado em protótipos 

— a cada etapa do processo de desenvolvimento (especificação, 

conceitualização e demais, veja sessão 2.1.3) é gerado um protótipo 

da ontologia até aquele ponto. As atividades dessa metodologia têm 

foco na gerência, desenvolvimento e suporte ao ciclo de vida, como 



  

visto na Figura 4, tendo esta característica forte ligação com a 

Engenharia de Software. 

 
Figura 4 – Processo de desenvolvimento e ciclo de vida da metodologia 

METHONTOLOGY 
Fonte: Adaptado e traduzido de Gómez-Peréz et al. (2004). 

 

As etapas do processo são as descritas anteriormente na 

sessão 2.1.3, como pode ser confirmado no bloco “Atividades de 

Desenvolvimento”, na Figura 4. A sua principal característica em 

relação a outras metodologias é a geração de artefatos de 

documentação ao final de cada etapa do processo de 

desenvolvimento, gerando uma documentação bastante rica. 

 

2.2.3) Metodologia NeOn 

O projeto NeOn — acrônimo para Networked Ontologies — foi 

criado a partir de um consórcio de instituições européias. O projeto 

trabalha com a idéia de desenvolvimento colaborativo de ontologias, 

permitindo o reuso de ontologias para construção de novas, 

promovendo isso através de ontologias distribuídas em rede, em 



  

diferentes locais e compartilhadas via web (SUÁREZ-FIGUEROA et 

al., 2007). Assim não seria mais necessário construir uma ontologia 

totalmente do zero, ou então replicar elementos de uma ontologia já 

existente para criar uma nova, bastaria compartilhar a já existente e 

estendê-la para gerar a nova criação. 

Para esse novo conceito de desenvolvimento o projeto propôs 

uma metodologia para tal (SUÁREZ-FIGUEROA et al., 2008). A 

metodologia aplicada, porém, varia de acordo com o cenário de 

construção de uma ontologia em rede que se apresenta para o caso. 

São nove os cenários encontrados durante as pesquisas do projeto, 

sendo eles (SUÁREZ-FIGUEROA et al., 2008): 

? Cenário 1: Construção total — a partir do zero, reuso de 

ontologias já existentes — sem o reuso de recursos de conhecimento. 

? Cenário 2: Construção de ontologia em rede a partir do reuso 

e reengenharia de recursos de conhecimento. 

? Cenário 3: Construção de ontologia em rede a partir do reuso 

de recursos ontológicos. 

? Cenário 4: Construção de ontologia em rede a partir de reuso 

e reengenharia de recursos ontológicos. 

? Cenário 5: Construção de ontologia em rede a partir do reuso 

e integração de recursos ontológicos. 

? Cenário 6: Construção de ontologia em rede a partir do reuso, 

integração e reengenharia de recursos ontológicos. 

? Cenário 7: Construção de ontologia em rede a partir do reuso 

de padrões de design de ontologias. 

? Cenário 8: Construção de ontologia em rede a partir da 

reestruturação de recursos ontológicos. 



  

? Cenário 9: Construção de ontologia em rede a partir da 

localização de recursos ontológicos. 

A partir da leitura de Suárez-Figueroa (2008) entende-se por 

recursos de conhecimento (ou recursos não-ontológicos) estruturas 

que representam informações de conhecimento sobre um domínio e 

que não foram formalizadas através de ontologias (ex.: thesauri, 

dicionários glossários, etc.). Já recursos ontológicos seriam seleções 

de elementos extraídos de ontologias para resolução de um dado 

problema, sendo que esses recursos podem ser: ontologias 

completas, módulos de ontologias, padrões de design de ontologias ou 

declarações de ontologias. 

Os cenários propostos no estudo em Suárez-Figueroa (2008) 

podem ser combinados em grupos. A divisão mais considerada na 

metodologia NeOn é de separar os cenários onde há reuso de 

recursos ontológicos daqueles onde há reuso e reengenharia de 

recurso não-ontológicos (recursos de conhecimento), havendo ainda o 

caso especial do cenário 7, onde há o reuso de padrões de design de 

ontologias. 

Na Figura 5 é possível visualizar todos os processos e 

atividades envolvidos no desenvolvimento com a metodologia NeOn — 

os números indicam as partes envolvidas em cada cenário de 

construção de ontologias em rede, citados anteriormente. Pode-se 

observar na Figura 5 também as etapas básicas presentes na 

metodologia: especificação, conceitualização, formalização e 

implementação (visíveis na figura como “O. Specification, O. 

Conceptualization, O. Formalization, O. Implementation”). Essas 

etapas são como as descritas anteriormente na sessão 2.1.3 desse 

trabalho. O que muda é que, dependendo do cenário, há o acréscimo 

de uma etapa, além de atividades e processos distintos entre as 

etapas de já existentes, em especial conceitualização e formalização. 



  

As etapas acrescidas são: Localização (na figura, “O. localization”), 

presente no cenário 9 e, Reestruturação da Ontologia (na figura, 

“Ontology Restructuring”), presente no cenário 8, onde são aplicadas 

atividades de extensão, especialização, modularização, etc. sobre os 

recursos ontológicos usados na construção. 

 
Figura 5 – Etapas e cenários para construção de ontologias em rede presentes na 

metodologia NeOn 
Fonte: Suárez-Figueroa (2008). 

 

2.3) Ferramentas 

No desenvolvimento de ontologias é importante o uso de 

ferramentas computacionais que suportam a manipulação dos 

elementos da ontologia, para que esta não seja tão complexa e mais 

consistente (GRAU et al., 2008). 

Nesse trabalho serão apresentadas algumas dessas 

ferramentas, que são: Protégé, OntoKEM e NeOn Toolkit. 



  

 

2.3.1) Protégé 

Dentre as mais conhecidas ferramentas para manipulação e 

desenvolvimento de ontologias está o Protégé. Trata-se de uma 

plataforma — um conjunto de ferramentas específicas de 

manipulação, criação e visualização — baseada na política open-

source — política de código aberto que possibilita o acesso ao código 

da aplicação para possibilitar alterações evoluções e 

desenvolvimentos de novas funcionalidades — que tem por objetivo a 

construção de modelos de domínios e aplicações baseadas em 

conhecimento com ontologias (PROTÉGÉ, 2009). Na Figura 6 é 

possível visualizar a interface gráfica da ferramenta. 

 
Figura 6 – Tela de exemplo da ferramenta Protégé, usando a ontologia de exemplo 

wines 
Fonte: RAUTEMBERG (2009). 

 



  

2.3.2) OntoKEM 

O ontoKEM — que significa ontology for Knowledge Engineering 

and Management — é uma ferramenta web, desenvolvida em meio 

acadêmico, que suporta a construção e documentação de ontologias 

(RAUTEMBERG et al., 2008). Nessa ferramenta o desenvolvimento é 

baseado em artefatos de documentação fundamentados nas 

metodologias On-to-Knowledge e METHONTOLOGY (já vistas 

anteriormente, nas seções 2.2.1 e 2.2.2 respectivamente) e também 

no processo de desenvolvimento apresentado pelo guia intitulado 

Ontology Development 101 (referência sobre o guia em NOY 

GUINESS, 2008). Esta ferramenta será usada no próximo capítulo 

como exemplo de comparação entre as formas de especificação das 

metodologias On-to-Knowledge e METHONTOLOGY (aplicadas no 

ontoKEM) e da metodologia NeOn (aplicada nesse trabalho). Na 

Figura 7 segue uma visualização do ontoKEM na sua atual versão, 

para fins ilustrativos. 

 



  

Figura 7 – Tela de exemplo da ferramenta ontoKEM, módulo “Vocabulário” 

 

2.3.3) NeOn Toolkit 

Trata-se da ferramenta computacional que suporta o projeto 

NeOn, já descrito anteriormente na sessão 2.2.3. O NeOn Toolkit é 

uma plataforma dotada de um conjunto de ferramentas específicas 

para construção de ontologias em rede, como é a proposta da 

metodologia NeOn (NEON, 2008). A ferramenta foi elaborada 

utilizando-se da estrutura da interface de desenvolvimento e 

programação Eclipse SDK e é expansível através de plugins que 

executam funções específicas das etapas de desenvolvimento da 

metodologia. A plataforma ainda não está completa, pois o próprio 

projeto NeOn ainda está em desenvolvimento. Na Figura 8 segue uma 

visualização da interface gráfica do NeOn Toolkit. 

 
Figura 8 – Tela de exemplo da ferramenta NeOn-Toolkit 

Fonte: NeOn (2008). 

 



  

3) A FASE DE ESPECIFICAÇÃO DE ONTOLOGIAS 

O objetivo deste breve capítulo é o de apresentar 

especificadamente a etapa de especificação segundo a metodologia 

NeOn. É essa etapa da metodologia que a aplicação proposta nesse 

trabalho visa dar suporte. De um modo geral, a especificação na 

Engenharia de Ontologia já foi descrita na sessão 2.1.3, sendo que 

nesse capítulo a primeira sessão trará os detalhes da etapa propostos 

no projeto NeOn. Na segunda sessão será apresentado como foi 

implementada a etapa mencionada na ferramenta de desenvolvimento 

de ontologias ontoKEM (que usa as metodologias On-to-Knowledge e 

METHONTOLOGY, como já descrito na sessão 2.3.2 desse trabalho), 

afim de destacar as diferenças e similaridades entre as metodologias 

já conhecidas e o NeOn. 

 

3.1) Como é visto no NeOn 

Como já mencionado anteriormente, na Engenharia de 

Ontologias a etapa de especificação visa identificar o propósito e 

escopo da ontologia a ser desenvolvida, respondendo respectivamente 

as perguntas “Por que a ontologia é construída?” e “Quais são as 

intenções de uso e usuários da ontologia?” (PINTO; MARTINS, 2004 e 

YE et al., 2007) e também definir quais tipos de usuários, cenários de 

usos e nível de formalização que a ontologia irá suportar e os 

requisitos que a mesma deve atender (SUÁREZ-FIGUEROA, 2008). 

Para a metodologia NeOn foi proposta a técnica de perguntas de 

competência (GRÜNINGER; FOX, 1995) para o levantamento dos 

requisitos da ontologia. Através das perguntas de competência é que 

se levantará “o que” a ontologia deve responder — ao final serão 

essas perguntas que a mesma deverá responder. Os termos extraídos 



  

dessas perguntas é que passarão, na etapa seguinte da metodologia, 

a formar os conceitos e relações entre conceitos da ontologia. 

Como documento de resultado da etapa de especificação a 

metodologia NeOn propõe o OSRD (“Ontology Requirements 

Specification Document” ou “Documento de Especificação de 

Requisitos da Ontologia”), um modelo padrão que apresenta os 

requisitos da ontologia, sendo eles (SUÁREZ-FIGUEROA, 2008): 

? Propósito (“Ontology purpose”): aqui é onde são 

detalhados os objetivos, as finalidades ao qual a ontologia se propõe. 

? Escopo (“Ontology scope”): identifica qual será a 

abrangência e a granularidade da ontologia, até que profundidade a 

ontologia abordará o domínio representado. 

? Nível de Formalismo (“Level of Formality”): indica qual o 

grau de formalização que se pretende adotar na implementação da 

ontologia. Um exemplo de descrição de Nível de Formalismo seria: “A 

ontologia será implementada na linguagem OWL”. 

? Usuários desejados (“Intended Users”): o objetivo neste 

item é criar as descrições dos perfis de usuários desejados para essa 

ontologia. Através dessas descrições é possível, após a elaboração da 

ontologia, desenvolver aplicações melhor focadas nos perfis mais 

desejados, por exemplo. 

? Usos (Cenários) desejados (“Intended Uses”): este item 

detalhar os cenários de uso que a ontologia deverá prover suporte ao 

estar concluída. Estes cenários podem ser descritos através de 

linguagem natural ou até mesmo através de diagramas UML, como 

diagramas casos de uso. Também facilita o desenvolvimento de 

aplicações mais focadas. 

? Grupos de Perguntas de Competência (“Groups of 

Competence Questions”): é onde são inseridas as perguntas de 



  

competências elaboradas, bem como as suas respectivas respostas. 

As perguntas devem ser categorizadas conforme a necessidade e 

também deve ser atribuída a prioridade de cada uma. 

A partir desses grupos, e de suas perguntas de competência, é 

que serão extraídos os termos e objetos para a ontologia. No projeto 

NeOn a proposta é que essa extração seja automática: é feita uma 

busca nas perguntas e extraídos os termos, que então são exibidos ao 

usuário desenvolvedor que, por sua vez, pode selecionar quais são 

relevantes. 

? Termos (“Terms”): representam os termos extraídos das 

perguntas, sendo estes normalmente conceitos ou relações entre 

conceitos da ontologia. Sempre apresentam a freqüência com a qual 

aparecem na listagem total de perguntas de competência e podem 

também receber ordenação de prioridade. 

? Objetos (“Objects”): representam os objetos extraídos das 

perguntas, sendo estes objetos normalmente instâncias da ontologia. 

Possuem as mesmas características de freqüência e prioridade dos 

termos. 

Na Figura 9 é possível visualizar o modelo de documento OSRD 

proposto no NeOn. 



  

 
Figura 9 – Modelo do documento OSRD, da metodologia NeOn 

Fonte: Suárez-Figueroa (2008). 

 

3.2) Como foi visto no ontoKEM 

Na ferramenta ontoKEM, desenvolvida sob as metodologias On-

to-Knowledge e METHONTOLOGY, pode-se notar algumas distinções 

em relação a proposta da metodologia NeOn, mas que possuem uma 

certa semelhança de objetivo. No ontoKEM (RAUTEMBERG et al., 

2008) a etapa de especificação é dividida em dois módulos: o de 

“Projeto” e o de “Perguntas de Competência”. 

No de “Projeto” é especificado, além do nome da ontologia, a 

descrição da mesma — além da descrição da versão na qual se 

encontra a mesma. Em relação ao NeOn esse campo de “descrição” 



  

seria um equivalente aos campos descritivos de “propósito” e “escopo” 

unificados. Na mesma “descrição” poderiam ser incluídos os campos 

“nível de formalismo” e até “usuários desejados” e “usos (cenários) 

desejados” do NeOn, que não possuem correspondentes diretos no 

ontoKEM. O problema seria o de que todas essas informações seriam 

repassadas juntas e na forma de texto livre. 

Tanto no ontoKEM quanto no NeOn é proposta a técnica de 

perguntas de competência para o levantamento de requisitos, cabendo 

a gerência disto ao módulo de “Perguntas de competência”. Ali, além 

dos cadastrados da perguntas, é feito o cadastro dos termos para 

cada uma das perguntas. A extração destes, porém, é feita 

manualmente pelo usuário desenvolvedor da ontologia — ao contrário 

da proposta de extração automática do NeOn. Após o término do 

cadastro das perguntas e termos é possível fazer uma visualização e 

seleção dos termos, permitindo assim exportar os relevantes para a 

próxima etapa do desenvolvimento da ontologia. 

Na Figura 10 é possível visualizar o módulo de “Projeto” do 

ontoKEM, e Figura 11 o de “Perguntas de competência”. 



  

 
Figura 10 – Tela de exemplo do módulo de “Projeto” do ontoKEM 

 
Figura 11 – Tela de exemplo do módulo de “Perguntas de Competência” do ontoKEM 

 



  

3.3) Considerações 

Em relação aos procedimentos da etapa de especificação 

adotados nas duas soluções, podemos fazer algumas comparações. 

A divisão proposta pelo NeOn para os requisitos mais 

descritivos da ontologia — propósitos, escopo, nível de formalismo — 

permite uma definição mais clara de cada um por parte de quem 

especifica a ontologia. Apenas um campo descritivo pode permitir uma 

maior liberdade, mas com isso o desenvolvedor pode acabar 

esquecendo alguma dessas informações, deixando a especificação 

mais pobre. 

A listagem de usuários desejados e dos cenários de uso da 

ontologia, propostas estas do NeOn, permitem uma definição mais 

clara dos objetivos e aplicações da ontologia, facilitando até o 

desenvolvimento posterior de aplicações sobre a ontologia — podendo 

estas serem focadas sobre determinados usuários ou cenários de 

usos. 

O uso de perguntas de competência é bem semelhante em 

ambos, sendo que no NeOn também são requeridas as respostas 

respectivas a cada questão. A extração dos termos é que faz a grande 

diferença nesta parte — manual no ontoKEM e automática através de 

técnicas de extração terminológicas (SUÁREZ-FIGUEROA, 2008) no 

NeOn. A extração automática, com possibilidade de posterior seleção 

dos mais relevantes, facilita bastante o levantamento dos termos da 

ontologia, não havendo a necessidade de um usuário ficar analisando 

cada pergunta e/ou resposta de competência para verificar quais os 

termos que podem existir. 

O modelo proposto pela metodologia NeOn parece interessante 

e eficaz como modelo de especificação de ontologias. Observado isso, 

o documento OSRD e seus itens servirão de base para o 



  

desenvolvimento de uma aplicação para suporte da etapa de 

especificação da metodologia NeOn, que é a proposta desse trabalho. 

 

4) APLICAÇÃO PARA A FASE DE ESPECIFICAÇÃO 

Em Suárez-Figueroa (2008), ao final das explicações a respeito 

da etapa de especificação da metodologia NeOn, há uma sugestão de 

implementação. Sugere-se o desenvolvimento de uma aplicação 

acoplável — um plugin — para a plataforma de desenvolvimento de 

ontologias em rede NeOn Toolkit, sendo que esta aplicação deve 

seguir os processos e atividades propostas na etapa de especificação 

da metodologia NeOn. 

Nesse trabalho o foco não foi no desenvolvimento somente de 

um plugin para o NeOn Toolkit, mas sim em uma aplicação para 

especificação de ontologias baseada na metodologia NeOn e que 

permitisse liberdade de acoplamento, tanto na parte visual quando na 

parte de saídas resultantes — documentos que podem ser gerados ou 

formas de persistência dos dados. Para isso houve a aplicação 

adaptada do padrão de projeto conhecido por MVP, tanto na camada 

de visualização quanto na de externalização e persistência de dados. 

Neste capítulo serão apresentados os conceitos e 

procedimentos adotados no desenvolvimento da aplicação proposta no 

trabalho. Inicialmente será brevemente apresentado o MVP, para 

melhor entendimento da estrutura e especificação da aplicação que 

será o item seguinte. Como terceiro item virá a descrição do XML para 

persistência dos dados, seguido de um detalhamento dos módulos e 

classes usados, em “Detalhamento da Estrutura da Aplicação”. Como 

última sessão comenta-se os resultados apresentados, numa forma de 

considerações finais sobre o desenvolvimento. 

 



  

4.1) Um pouco sobre o MVP 

O MVP — acrônimo para “Model-View-Presenter” ou “Modelo-

Visualização-Apresentar”, em tradução livre — é um padrão de projeto 

(FOWLER, 2009) que visa separar o desenvolvimento de uma 

aplicação em três camadas principais: 

? Model: é onde ficam as regras de negócio da aplicação, onde, 

por exemplo, é feita toda a manipulação dos dados conforme o 

objetivo da aplicação. 

? View: é onde está toda a parte de interfaces de comunicação 

(gráficas ou não) da aplicação, que realizam a interação com os 

usuários da mesma (sejam estes pessoas, máquinas ou outros 

sistemas). 

? Presenter: seria a camada responsável por intermediar as 

ações e informações repassadas entre o as duas camadas anteriores, 

executando, por exemplo, tratamento dos dados para possibilitar a 

visualização (alterando o tipo do dado, sem alterar a informação 

vinculada nele) e vice-versa. 

Fowler (2009) propôs a divisão do padrão em duas arquiteturas 

possíveis: “Supervising Controller” (“Controle Supervisionado”, em 

tradução livre) e “Passive View” (“Visão Passiva”, em tradução livre). 

Nesse trabalho foi adotada a estrutura “Passive View”, explicada a 

seguir. 

Nessa estrutura a camada “View” possui apenas o 

comportamento inerente aos seus componentes, não possuindo 

nenhum comportamento referente às regras de negócio da aplicação. 

Exemplificando: no caso de uma interface gráfica, o View apresentará 

apenas os componentes e campos para visualização e os tratamentos 

e comportamentos inerentes a estes (como monitores para eventos de 

botões e outros campos, por exemplo). A proposta do Passive View 



  

com isso é separar bem os comportamentos permitindo que os testes 

das regras de negócio possam ser feitos independentes da camada 

visual (eliminando assim a possibilidade um erro proveniente de um 

componente visual ser refletido em um teste das regras de negócio). 

Outra vantagem apresentada nessa estrutura é separar 

tecnologicamente as camadas de visualização e negócio, permitindo 

uma troca da camada de visão sem grandes alterações (ou até 

nenhuma) na camada de negócios. 

No Passive View todo o comportamento que antes ficaria no 

elemento (ou classe) de visualização — como recuperar um dado 

específico de uma base de dados e atribuí-lo a um campo visual, por 

exemplo — passa a um novo elemento chamado “Controller” (ou 

“Presenter”). O Controller é que se torna responsável por recuperar os 

dados necessários e repassá-los à camada visual, bem como 

recuperar os dados da camada visual e tratá-los conforme o 

necessário. Para manter o desacoplamento do View o Controller 

acessa o mesmo através de interfaces, que o View por sua vez deve 

implementar. Já o View possui acesso direto ao Controller, afim de não 

complicar muito a implementação através da estrutura. Na Figura 12 

segue uma visualização do padrão MVP e da estrutura Passive View. 

 
Figura 12 – Representação do padrão de projeto MVP na estrutura Passive View 

Fonte: Fowler (2009). 

 



  

Nesse trabalho, além da camada visual, a camada de 

persistência dos dados também foi abstraída sobre o conceito do 

“MVP – Passive View”, sendo que a comunicação entre a aplicação e 

os módulos de persistência é feita através de interfaces, como poderá 

ser visto na sessão seguinte. 

 

4.2) Especificação da Aplicação 

A partir da elaboração de um diagrama de casos de uso (Figura 

13) foi possível levantar os requisitos necessários para o 

desenvolvimento da aplicação. O diagrama teve como ponto de partida 

o processo descrito na etapa de especificação da metodologia NeOn 

(ver sessão 2.2.3). 

 
Figura 13 – Diagrama de casos de uso da aplicação 

 

Apenas um tipo usuário foi identificado para uso da aplicação, 

sendo este usuário denominado no diagrama como “usuário 



  

desenvolvedor”. A etapa de especificação de uma ontologia conta 

normalmente com a interação de várias pessoas, geralmente 

especialistas do domínio abordado, e desenvolvedores de ontologias, 

mas para desenvolvimento da aplicação aqui proposta basta a 

abstração de um usuário, podendo este ser qualquer membro da 

equipe de especificação. 

A partir da definição do usuário e próximo passo foi definir 

macro processo envolvidos. Três foram observados: 

? Criar o Projeto: nesse processo são informados os requisitos 

gerais da especificação — o nome do projeto de especificação (nome 

da ontologia), autores, propósito da ontologia, escopo, nível de 

formalismo, usuários desejados e cenários de uso da ontologia. Ao 

abstrair esse processo também foi definida a forma de persistência 

dos dados armazenados, que seria feita em um arquivo XML, melhor 

detalhado posteriormente na sessão 4.3. Ao criar o projeto já é gerada 

uma versão inicial do arquivo XML, guardando os requisitos gerais 

cadastrados. 

? Criação de categorias e perguntas de competência: é o 

processo onde são criadas as perguntas de competência e as 

categorias que as armazenam. Por padrão, ao criar o projeto já é 

criada uma categoria intitulada “default” (o nome pode ser alterado) 

para receber as perguntas. Mais categorias podem ser criadas 

conforme a necessidade. As perguntas podem ter uma sentença 

(sendo esta apenas a pergunta em si) ou então duas sentenças (a 

pergunta e a sua resposta). Cada pergunta pode ser classificada a 

apenas uma categoria, podendo haver mudança posterior à 

classificação inicial. 

? Identificação dos termos das perguntas de competência: 

este processo é mais automatizado pela própria aplicação. Nele é 

realizada a extração automática dos termos das perguntas de 



  

competência (tanto das perguntas em si quanto das respostas quando 

estas existirem). A extração é feita a partir de todo o conjunto de 

perguntas ou do conjunto de perguntas de uma categoria específica. O 

conjunto dos termos encontrados são exibidos ao usuário 

desenvolvedor para que este possa selecionar quais termos são 

relevantes para o projeto. Há a possibilidade também de realizar a 

combinação entre termos durante a seleção, a fim de criar um termo 

composto que a extração automática não capturou nas sentenças. 

 

Com o término da elaboração do diagrama de casos de uso o 

próximo passo foi a elaboração das classes da aplicação. 

Estruturalmente a aplicação segue o padrão de projeto MVP, descrito 

anteriormente, permitindo distinguir claramente as classes 

responsáveis pela parte de visualização (View), apresentação 

(Presenter) e modelagem do negócio (Model). Na Figura 14 está 

representada, sem detalhamento das classes, essa divisão. 



  

 
Figura 14 – Estrutura de classes da aplicação com o padrão MVP 

 



  

Na parte de modelagem do negócio houve mais uma divisão 

estrutural, também seguindo a linha de desenvolvimento do MVP. Esta 

subestrutura é composta por: 

? Classe “Ambiente” (Environment): controla a inicialização 

da aplicação e criação dos seus objetos de controle. 

? Pacote de classes de dados (Data Package): responsável 

pela manipulação, em tempo de desenvolvimento, dos dados 

envolvidos no processo de especificação (dados de propósito, escopo, 

dados das perguntas de competência, dos termos, etc.). 

? Classe de controle de saída (OutputController): é a 

responsável direta pela comunicação com as classes responsáveis por 

gerarem o documento OSRD e pela persistência do XML. 

? Classe de controle da extração dos termos 

(ExtractController): realiza a extração dos termos a partir das 

perguntas de competência selecionadas (todas ou de uma categoria 

específica). 

Na Figura 15 é possível visualizar a subestrutura ainda a pouco 

descrita. Na sessão 4.4 haverá um maior detalhamento dessas 

classes mencionadas. 



  

 
Figura 15 – Subestrutura da aplicação sobre a parte de modelagem das regras de 

negócio da etapa de especificação. 

 

4.3) O XML para persistência 

Para a persistência dos dados levantados pela aplicação, no 

processo de especificação de ontologia, optou-se pelo uso do XML. 

Poderia ter sido utilizado a persistência em um banco de dados ou em 



  

outro tipo de repositório de dados, mas o uso do XML permite à 

aplicação uma maior comunicação com outros tipos de sistemas, 

ferramentas ou aplicações. 

Para uma aplicação externa interpretar o XML de persistência 

basta que ela conheça a estrutura do mesmo e possa fazer leitura de 

arquivos do tipo XML. Esse procedimento é bem mais simples do que 

exigir que uma aplicação externa conheça, por exemplo, o mesmo 

banco de dados que a aplicação de especificação. 

A estrutura do XML segue uma abstração dos itens presentes 

no documento OSRD proposto na etapa de especificação do NeOn. 

Na Figura 16 está representado essa estrutura do arquivo XML. 

 
Figura 16 – Estrutura do arquivo XML de persistência 



  

 

Analisando a Figura 16 podemos descrever a estrutura — 

importante observar a sessão 3.1 para melhor entendimento — sendo 

ela composta pelos seguintes elementos: 

?&amp;lt;project&gt;: é o elemento raiz do XML. Representa o conceito 

de especificação de ontologia (ou projeto) como um todo. O XML 

poderia, dessa forma, conter várias especificações de ontologias 

(vários projetos), cada um com seus elementos específicos. 

?&amp;lt;name&gt;: representa o nome do projeto, sendo também o 

identificador único do mesmo. O nome também é usado para 

identificar o arquivo XML em si. 

?&amp;lt;autor&gt;: representa o(s) nome(s) do(s) autor(es) do projeto 

de ontologia. 

?&amp;lt;createDate&gt;: indica a data em que foi criado o projeto de 

ontologia. 

?&amp;lt;purpose&gt;: representa o item “propósito” do documento 

OSRD do NeOn. 

?&amp;lt;scope&gt;: representa o item “escopo” do documento OSRD do 

NeOn. 

?&amp;lt;formalityLevel&gt;: representa o item “nível de formalismo” do 

documento OSRD do NeOn. 

?&amp;lt;users&gt;: indica o subnível que descreve os “usuários 

desejados”, como no documento OSRD. Este subnível pode possuir 

um ou mais elementos como o descrito a seguir: 

?&amp;lt;userDescription&gt;: indica a descrição de um usuário em 

específico. 

?&amp;lt;usesScenarios&gt;: trata-se de mais um subnível, este 

indicando o item “usos (cenários) desejados” do documento OSRD. 



  

Também pode possuir um ou mais elementos internos como o descrito 

a seguir: 

?&amp;lt;scenario&gt;: indica a descrição de um cenário de uso em 

específico. 

?&amp;lt;category&gt;: subnível que indica uma categoria de perguntas 

de competência. Por default há no mínimo uma categoria para 

englobar as perguntas de competência. O elemento possui como 

atributo o nome da categoria. 

O elemento “category” possui a seguinte hierarquia de 

elementos: 

?&amp;lt;competenceQuestion&gt;: indica a pergunta de competência 

como um todo. Como atributo possui um código identificador — sendo 

este incremental para todo o projeto — que será usado para 

referenciar os termos mais adiante. Possui duas divisões internas, 

sendo elas: 

?&amp;lt;question&gt;: este elemento é obrigatório na pergunta de 

competência, indica a pergunta que deve ser respondida ao fim do 

desenvolvimento da ontologia. 

?&amp;lt;answer&gt;: é a resposta que deve ser data à pergunta de 

competência, sendo este elemento não obrigatório. 

Após os subníveis “category” encontra-se o último subnível do 

XML: 

?&amp;lt;selectedTerms&gt;: neste subnível estão indicados todos os 

termos selecionados a partir das perguntas de competência. A 

estrutura deste subnível é: 

?&amp;lt;term&gt;: trata-se de um termo selecionado em específico. 

Possui como conteúdo o nome (ou descrição) do termo. Seus atributos 

indicam as perguntas de competência onde o termo aparece (além de 



  

indicarem de qual elemento dessa pergunta ele veio: “question” ou 

“answer”). A quantidade de perguntas de origem vai indicar a 

freqüência de ocorrência do termo. A ordem com a qual os termos 

aparecem pode ser definida pela freqüência, ou então através de uma 

ordem pré-estabelecida à criação do XML. 

Para gravar o arquivo a aplicação utilizará o processo de 

serialização de objetos existente na própria linguagem de 

programação. Será construído um objeto, com uma estrutura interna 

como a descrita para o XML nessa sessão, e que será preenchido com 

as informações pertinentes, para então ser gravado em um local 

definido pelo usuário da aplicação. 

 

4.4) Detalhamento da Estrutura da Aplicação 

Após a definição dos casos de uso da aplicação, da estrutura de 

classes da mesma e da estrutura do XML de persistência dos dados 

foi dado início à parte de codificação. 

Como linguagem de programação foi escolhida a linguagem 

Java, não apenas por ser uma das linguagens orientadas a objeto 

mais usadas atualmente, mas também com o foco em trabalhos 

futuros, devido à portabilidade do Java, e da existência de outras 

ferramentas de desenvolvimento de ontologias também elaboradas 

com esta linguagem, possibilitando assim uma integração mais 

simples. Como opção de ferramenta de programação veio o Eclipse 

SDK, pela já maior familiaridade de uso. 

Todas as partes — de visualização (interfaces gráficas), de 

persistência e saída de dados (persistência do XML e geração do 

documento OSRD), de extração dos termos e, da parte principal, de 

modelagem de regras de negócio da etapa de especificação (em 

resumo, a estrutura de classes vista na Figura 14) — foram tratadas 



  

como projetos separados. Como a parte principal realiza sua 

comunicação através de interfaces, esta não necessita conhecer 

diretamente as outras partes, podendo as mesmas ser desenvolvidas 

sob outra tecnologia (em uma linguagem diferente, por exemplo, 

bastando que esta última possa implementar as interfaces definidas). 

Para facilitar o desenvolvimento, todas as outras partes 

vinculadas à principal também foram desenvolvidas na linguagem 

Java, inclusive a parte visual, onde foi usado o pacote de classes 

visual “swing” do Java, que já trás componentes visuais prontos, 

havendo apenas a necessidade de montar a tela e realizar a interação 

entre sistema e componentes. 

Como a parte de persistência dos dados já mencionada ao final 

da sessão 4.3, após o detalhamento do XML de persistência, 

passamos então ao detalhamento da parte principal, de modelagem de 

regras de negócio da etapa de especificação. 

Cinco classes formam o grupo principal de controle da 

aplicação: 

? Environment: É a classe que gerencia os outros controllers 

da aplicação e é por esta classe que se dá o início do funcionamento 

da parte principal da aplicação. É ela que instancia os outros 

controladores e que permite a comunicação entre os mesmos. 

? DataController: na aplicação a um pacote denominado “Data” 

(que será descrito posteriormente, na sessão 4.4.1) o DataController é 

a sua classe de gerência. Esta classe realiza todas as transações e 

comunicações entre as classes do pacote Data e o resto do sistema. 

? ViewController: Como o próprio nome já sugere é a classe 

que gerencia os presenters das telas do sistema. Ela realiza os 

tratamentos necessários para visualização dos dados advindos do 



  

pacote Data, os direcionando também para os respectivos presenters, 

e vice-versa.  

? OutputController: É o controlador de saída do sistema. 

Comunica-se com as classes responsáveis pela persistência do XML 

de dados e pela geração do documento OSRD. Ao contrário do 

DataController e do ViewController, que possuem a mesmo ciclo de 

vida do Environment, este só é instanciado quando há a necessidade 

de persistência ou geração do documento. 

? ExtractController: É um controlador que possui um ciclo de 

vida bem reduzido, existindo apenas quando é solicitada a extração 

automática dos termos, ficando ele responsável pela extração dos 

termos nas perguntas de competência requeridas. 

 

4.4.1) O Pacote “Data” 

Para a aplicação havia a necessidade de fazer uma abstração 

dos requisitos observados no documento OSRD do NeOn, algo que 

pudesse permanecer “em memória”, evitando assim constantes 

leituras de arquivos em disco, atividade esta bastante lenta. Assim foi 

concebido o pacote de classes “Data” (nome advindo de “Dados”, em 

inglês). 

Este pacote é formado pelo controlador já descrito 

DataController e por mais quatro classes, destinadas ao 

armazenamento de dados. As classes de dados nada mais são do que 

representações em código dos elementos do XML de persistência. A 

seguir uma descrição dessas classes de dados: 

? Project: Esta classe de dados, ao contrário das demais, 

representa o nó raiz da estrutura do XML de persistência e, portanto, 

engloba todo o conjunto de elementos hierarquicamente inferiores a 

este nó raiz (ou seja, todos os outros elementos descritos no XML). 



  

Caso a aplicação suportasse mais de um projeto por manipulação, 

existiriam duas instâncias ativas da classe Project no sistema por vez. 

Dos elementos que são subníveis no XML (users, usesScenarios, 

category, e selectedTerms) apenas users e usesScenarios estão 

totalmente inseridos na classe (na forma de listagens de literais ou 

“strings”), nos outros apenas as referências aos objetos são 

armazenadas, pois a classes específicas para esses elementos. 

? Category: Esta classe representa cada subnível de categoria 

de perguntas de competência que existir na especificação. Possui, 

além do seu nome, os códigos identificadores das perguntas de 

competência (no caso, os códigos dos objetos da classe 

CompetenceQuestion), que lhe pertencem. 

? CompetenceQuestion: Representa as perguntas de 

competência. A referência a seus objetos quem armazena é a 

instância de Project, pois as perguntas estão ligadas diretamente ao 

projeto, sendo as categorias apenas para classificação. Possui um 

código identificador, único no projeto, e duas classes internas, 

Question e Answer: 

? Question: classe interna de CompetenceQuestion que 

representa a sentença correspondente à pergunta. É obrigatória sua 

existência nas perguntas de competência. Possui também uma 

listagem dos códigos dos termos extraídos de sua sentença. 

? Answer: classe interna de CompetenceQuestion que 

representa a sentença correspondente à resposta da pergunta. Não há 

obrigatoriedade de sua existência nas perguntas de competência. 

Possui, igualmente a Question, uma listagem dos códigos dos termos 

extraídos de sua sentença. 

? Terms: Esta classe representa os termos que foram 

selecionados na extração automática. Possui como atributos o nome 



  

(ou descrição) do termo, os códigos das “Question’s” de origem, bem 

como das “Answer’s”, a freqüência de ocorrência no projeto (que é 

calculado de acordo com a quantidade de sentenças de origem 

existentes na própria classe) e um indicar de ordem, pois o “usuário 

desenvolvedor” pode escolher uma ordem distinta à ordem padrão, 

que é pela freqüência. 

Esse pacote Data pode ser visualizado na Figura 15, 

anteriormente apresentada na sessão 4.2. 

 

4.4.2) O Pacote “Beans” 

Com a separação das camadas de visualização e de 

armazenamento e tratamento dos dados, houve a necessidade de 

uma forma de transportar as informações necessárias entre as duas 

camadas que atendesse a todas as necessidades de dados e que 

fosse simples; assim foi implementado o pacote “Beans”. 

Nesse pacote estão contidas classes que representam os dados 

requeridos por cada módulo de visualização de informações da 

aplicação: Projeto (“ProjectBean”), Perguntas de Competência 

(“CompetenceQuestionsBean”), que também engloba as categorias de 

perguntas de competência, e Termos (“TermsBean”). Na Figura 17 é 

possível visualizar o pacote e suas classes. 



  

 
Figura 17 — Pacote “Beans” e suas classes para comunicação entre as camadas. 

 

Os bean possuem atributos que representam os dados que 

serão necessários aos presenters de cada módulo para exibir as 

informações solicitadas. Estes beans “trafegam” — são repassados de 

método em método entre as camadas — sempre que uma grande 

quantidade de informações é solicitada. Como exemplo, pode ser 

citado a solicitação da listagem de perguntas de uma determinada 

categoria de perguntas de competência. 

Tratamento de operações mais simples, como a adição de uma 

pergunta de categoria, por exemplo, são tratadas aparte dos beans, 

sendo a informação repassada diretamente através de método entre 

as camadas. 

Os beans normalmente são instanciados no DataController, 

onde recebem a carga inicial de dados, mas podem ser gerados em 

qualquer parte dos sistema, pois sempre recebem solicitações e nunca 

invocam informações a outras classes externas, servindo assim como 

estruturas auxiliares independentes. Em analogia, seriam como 

veículos de transporte que carregam materiais de um local a outro. 



  

Estas classes não possuem métodos de tratamento das regras 

de negócio, apenas tratamentos relacionados aos dados que lhes 

pertencem, como por exemplo, o fornecimento dos termos ordenados 

de acordo com um padrão (alfabético, freqüência, etc.) no caso do 

TermsBean. 

 

4.4.3) A classe “ExtractController” e a extração de 

termos 

Como já mencionado anteriormente, dentre as quatro classes 

controladoras do sistema duas possuem um tempo de vida reduzido, 

pois realizam atividades específicas e isoladas; a classe 

ExtractController é uma delas. 

Esta classe é a responsável por receber as sentenças das 

perguntas de competência (tanto as perguntas em si quanto as 

respostas das mesmas) e realizar a extração automática dos termos.  

Sua instanciação e sempre executada pela classe Environment 

(bem como os demais controladores) sendo esta instanciação 

requerida pelo DataController que repassa o conjunto de perguntas de 

competência da categoria solicitada pelo módulo de Termos. Após 

receber as sentenças o ExtractController trabalha executando a 

seguinte seqüência de atividades sobre cada uma: 

? Inicialmente é feita a “limpeza” da sentença: são removidos os 

sinais de pontuação e caracteres especiais existentes. Para isto é 

empregado uma expressão regular, através da própria classe String da 

linguagem Java, que identifica os caracteres de pontuação e os 

remove; 

? Com a “sentença limpa” é feita a “tokenização” da mesma. 

Nessa atividade através da classe StringTokenizer, também nativa da 

linguagem Java, a sentença é separada em tokens (símbolos) que 



  

nesse caso seriam os termos presentes na sentença. A separação é 

feita tomando por referência os espaços em branco da sentença, por 

isso a importância de permitir a combinação de termos extraídos, para 

gerar termos compostos; 

? Através do StringTokenizer é possível realizar a iteração 

sobre os termos separados da sentença, sendo assim possível a 

análise em separado de cada token. Para cada uma é feita a 

verificação se não se trata de uma stop word — palavras que isoladas 

não trazem nenhuma informação importante, sendo normalmente 

preposições e artigos, como “o”, “a”, “para”, “de”, “em”, etc. Se for uma 

stop word o termo é descartado. 

? Por último, se o termo não foi descartado, este recebe a 

referência de qual pergunta de competência (distinguindo entre 

pergunta ou resposta) o mesmo foi extraído, para posterior 

persistência do termo caso este venha a ser escolhido como relevante 

para a especificação, isto já no módulo de Termos. 

Através do TermsBean os termos extraídos são repassados de 

volta ao DataController que os retorna ao módulo de Termos para 

utilização do usuário da aplicação. 

 

4.4.4) O Pacote “View” 

As classes que efetivamente implementam as interfaces 

gráficas não fazem parte da aplicação proposta, pois a mesma, como 

já explicado anteriormente, propõem-se a ser independente de 

camada de visualização — permitindo a implementação de interfaces 

gráficas distintas tecnologias que utilizam todas a mesma aplicação 

como base.  

Mas para permitir essa independência visual é necessário um 

conjunto de classes que realiza a comunicação entre o projeto visual e 



  

a aplicação em si, um conjunto de classes que represente os módulos 

que se requisita encontrar no projeto visual; é neste ponto que entra o 

pacote “View”. Na Figura 18 é possível visualizar a estrutura do 

pacote. 

 
Figura 18 — O pacote “View” e as classes de representação e manipulação dos 

módulos da aplicação. 

 

Observando a Figura 18 vamos à descrição da estrutura do 

pacote. Os módulos da aplicação sempre trabalham em uma dupla de 

elementos: a interface que descreve o serviço oferecido pelo módulo 

— trata-se dos elementos do diagrama que possuem o estereótipo 

“«interface»” e o identificador “Form” ao final do nome — e as classes 

que são responsáveis por receber as informações e requisições da 

tela e repassarem ao sistema (e vice-versa), os chamados 

“presenters” da estrutura MVP — estão identificados no diagrama pelo 

sufixo “Presenter” no nome. O módulo Main consiste, na prática, no 

ambiente visual da aplicação, onde estão inseridos os demais 

módulos, sendo a alteração entre um módulo e outro realizada através 

dele. 

A classe ViewController é o controlador principal da camada 

visual. É através dele efetivamente que a camada visual se comunica 



  

com o resto do sistema fazendo, por exemplo, a requisição de 

informações das classes de dados da aplicação. Quando há a 

necessidade de comunicação entre os módulos a mesma também é 

feita pelo ViewController, sendo ele assim um coordenador dos 

módulos. 

As classes presenters são responsáveis por realizar os 

tratamentos pertinentes à execução e resposta de ações vindas da 

camada visual. Um exemplo seria a adição de uma nova pergunta de 

competência: cabe ao presenter validar as informações recebidas da 

camada visual e informar caso algum item esteja incorreto — a falta de 

um item obrigatório, por exemplo. Tratamentos de formas de 

visualização de dados são pertinentes à camada visual e não aos 

presenters — por exemplo, o tratamento de passar um valor numérico 

para um literal, pois o componente da interface gráfica apenas trabalha 

com valores literais. 

As interfaces Form possuem a descrição dos métodos mínimos 

a serem implementados na camada visual, para cada módulo, para 

que os presenters possam realizar a interação com esta camada. 

Também possuem atributos que necessitam ser de conhecimento 

tanto da camada visual quanto dos presenters, como constantes de 

tipos de erros de validação, por exemplo. 

 

4.5) Resultados apresentados 

Na sessão 4.4 anteriormente apresentada foi apresentada a 

estrutura interna da aplicação e como a mesma se propõe a funcionar. 

Contudo, para entendimento completo da aplicação e das atividades 

para a qual a mesma foi proposta, havia a necessidade de que fosse 

desenvolvida uma camada visual para interagir com o sistema e 

demonstrar seus resultados. 



  

Portanto esse capítulo apresenta a aplicação pela ótica do 

usuário, demonstrando a camada visual desenvolvida para a aplicação 

e as respostas das funcionalidades descritas desta última. 

É importante salientar que a camada visual foi desenvolvida 

com o objetivo único de apresentar as funcionalidades da aplicação 

proposta. Sendo assim, pontos como usabilidade e configuração 

(internacionalização e localização, por exemplo) não foram tomados 

como prioridade, podendo estar um pouco limitados ou com 

possibilidade de melhorias. 

Tecnologicamente a camada visual foi desenvolvida na 

linguagem de programação Java, utilizando as classes e componetes 

visuais da própria linguagem, em especial do pacote “javax.swing”. 

Como interface de desenvolvimento foi utilizada a ferramenta Eclipse 

SDK — já empregada no desenvolvimento da aplicação em si — 

munida de um plugin próprio da ferramenta para desenvolvimento de 

interfaces gráficas, o Visual Editor. 

Para facilitar a explicação, a apresentação se dará como um 

“tour” através do aplicativo, como se o leitor fosse um usuário. 

Na Figura 19 está a visualização inicial da aplicação. Os 

campos e componentes da mesma não possuem funcionalidade, pois 

nenhum projeto de especificação está em uso no momento — fato 

indicado ao usuário pela mensagem “&lt;no open project&gt;” exibida na 

barra de título da aplicação. 

Estruturalmente a interface gráfica da aplicação está dividida 

em um menu superior, intitulado “File” (“Arquivo”, em tradução livre) e 

um conjunto de três abas que representam os módulos de trabalho da 

aplicação: “Project”, “Competence Questions” e “Terms”. 



  

De início apenas o menu “File” e suas opções estão ativas 

nesse momento. Nesse menu há duas opções para início de uso de 

um projeto de especificação, como pode ser visto na Figura 20: 

? “New...”: permite o início de um novo projeto de 

especificação. Ao clicar na função solicitado ao usuário indicar onde o 

projeto será salvo e qual o nome dado ao mesmo. A partir disso a 

aplicação já atribui o nome dado ao projeto e cria um arquivo de 

persistência XML, afim de já possibilitar posteriores persistências dos 

dados. 

? “Open...”: Essa opção permite abrir um arquivo XML 

posteriormente salvo através da aplicação. Ao abrir o arquivo os dados 

neles contidos são automaticamente carregados na estrutura de dados 

da aplicação, passando assim a estarem disponíveis para alterações. 

O último item do menu, “Persist project...” realiza a 

persistência dos dados presentes na estrutura de classes do pacote 

“Data” para o arquivo XML de persistência definido para o projeto. 

 



  

Figura 19 — Tela inicial da aplicação. 

 
Figura 20 — Menu “File” e as opções de início de uso de um projeto. 

 

Com um projeto aberto já há a possibilidade de navegar entre 

as abas dos módulos. 

O primeiro módulo, Figura 21, chama-se “Project” e é composto 

das informações diretamente relacionadas à identificação do projeto 

de especificação. Nele é possível alterar dados como: nome do 

projeto, autor, proposta do projeto, escopo do mesmo, nível de 

formalidade, e também listar as descrições para os usuários e cenários 

de uso desejados — estes itens já foram descritos anteriormente na 

sessão 3.1. 

Para alterar as informações existentes no módulo é necessário 

executar o solicitar explicitamente tal função através do botão “Edit” na 

parte inferior do módulo. Isso faz com que os campos tornem-se 

editáveis e a troca entre abas e a abertura do menu “File”, garantindo 



  

assim que nenhuma informação seja perdida durante o processo de 

alteração dos dados de identificação por conta da execução de uma 

outra função não pertinente à tarefa. 

 



  

 
Figura 21 — Aba do módulo “Project”, no estado de exibição (acima) e no estado de 

edição (abaixo). 

 



  

Na aba seguinte — veja Figura 22 — está o módulo 

“Competence Questions”. É ele o responsável pela gerência das 

perguntas de competência do projeto e de suas categorias. As 

funcionalidades de “adicionar”, “editar” e “remover” são comuns tanto 

às perguntas quanto às categorias, possuindo as perguntas ainda a 

opção de serem movidas de uma categoria a outra. A única exceção 

de alteração desse módulo é em relação a uma categoria padrão que 

é criada automaticamente com o início projeto, sempre atribuída ao 

identificar 1 de categorias — na Figura 22, aparece com o nome 

“Default” — esta não pode ser removida, apenas pode ter o nome 

alterado. 

 
Figura 22 — Módulo “Competence Questions”. 

 

Na listagem de perguntas, as perguntas em si são identificadas 

pelo prefixo “&lt;???&gt;” enquanto que suas respostas são identificadas 

pelo prefixo “&lt;ANS&gt;” (de “answer”, “resposta” em inglês). Isto se deve 



  

a uma limitação na formatação de exibição do componente, o que 

geraria um esforço extra na resolução da questão e fugiria da proposta 

de desenvolvimento da camada visual: apresentar as funcionalidades 

da aplicação. 

O último módulo trata-se do “Terms”, o módulo responsável por 

gerenciar os termos vinculados ao projeto, que foram extraídos das 

perguntas de competência. Na Figura 23 é possível visualizar este 

módulo. 

 
Figura 23 — Módulo “Terms”. 

 

Os termos são exibidos em listas, sempre no formato de caixa 

alta e seguidos de informações a respeito de sua origem (números 

identificadores das perguntas e respostas de onde os mesmos se 

originam) e de atributos pertinentes, como ordem e identificador. 

Na lista da esquerda estão os termos extraídos das perguntas 

da categoria que foi selecionada ao executar a ação de extração de 



  

termos, através do botão “Extract...” existente acima dessa lista. É 

possível a extração tanto de uma categoria específica quanto de todas 

as categorias, extraindo assim de todas as perguntas existentes. 

Na lista da direita ficam os termos que efetivamente foram 

escolhidos como relevantes. Logo acima estão botões que possibilitam 

as funcionalidades de remoção de termos (Remove), de ordenação 

(Order...) e de persistência dos escolhidos (Persist), esta não em 

arquivo XML, mas na estrutura de classes de dados da aplicação. 

Ao centro estão as funcionalidades de adicionar termos extraído 

aos escolhidos e também de combinar termos extraídos, afim de gerar 

um termo composto que então será adicionado aos escolhidos 

(exemplo: termo composto “UNIVERSIDADE FEDERAL DE SANTA 

CATARINA”, composição dos termos “UNIVERSIDADE”, “FEDERAL”, 

“SANTA” e “CATARINA”). O importante para essa última 

funcionalidade é que os termos devem ter todos, ao menos, uma 

pergunta ou resposta de origem em comum, pois o termo composto 

será atribuído como originário desta pergunta ou resposta. 

 

5) CONCLUSÃO 

 

5.1) Considerações Finais 

Em relação à metodologia NeOn, mais exatamente sobre a 

etapa de especificação de ontologias, o ponto que mais se destaca é a 

tentativa de aproximar o processo de desenvolvimento de ontologias à 

maturidade hoje observada na Engenharia de Software, como 

inclusive é citado em Suárez-Figueroa (2008). 

O documento OSRD proposto na etapa de especificação da 

metodologia traz um padrão exato das informações relevantes à etapa 



  

durante o desenvolvimento da ontologia, organizando as informações 

para que estas sirvam de subsídio para as etapas seguintes do 

processo de desenvolvimento. 

Com a aplicação há a possibilidade de automatizar o 

desenvolvimento desse documento além de permitir uma comunicação 

facilitada com outras aplicações durante o processo, responsáveis por 

outras etapas do mesmo, sendo isto possível a partir de um arquivo 

XML cuja estrutura seja de conhecimento comum, possibilitando a 

implementação da correta forma de leitura e interpretação do mesmo. 

 

5.2) Trabalhos Futuros 

Alinhamento da aplicação proposta à plataforma NeOn Toolkit 

do projeto NeOn, desenvolvendo nova parte visual para adequação à 

concepção de plugin. 

Desenvolvimento de nova camada visual que vise melhor 

usabilidade e melhor configuração, observando já critérios de 

internacionalização e localização de software. 

 



  

6) REFERÊNCIAS BIBLIOGRÁFICAS 

 

BORST, W. N. Construction of Engineering Ontologies. Tese, 
University of Tweenty – Centre for Telematica and Information 
Technology, Enschede, Nederland, 1997. 

 

DACONTA, M. C.; et al. The Semantic Web: A Guide to the Future 
of XML, Web Services, and Knowledge Management. Wiley 
Publishing, 2003. 

 

DEVEDZIC, V. Understanding Ontological Engineering. 
Communications of the ACM, v. 45, n. 4, p. 136-144, 2002. 

 

FENSEL, D.; HERMELEN, F. van. On-To-Knowledge: Content-
Driven Knowledge Management Tools through Evolving 
Ontologies. Disponível em: 
&lt;http://www.ontoknowledge.org/downl/del33.pdf&gt;. Acesso em: 02 abril 
2008 17:00. 

 

FERNÁNDEZ-LÓPEZ, M.; GÓMEZ-PÉREZ, A. Overview and analysis 
of methodologies for building ontologies. The Knowledge 
Engineering Review, v. 17, n. 2, p. 129-156, 2002. 

 

FOWLER, M. Retirement note for Model View Presenter Pattern. 
Disponível em: &amp;lt;
http://martinfowler.com/eaaDev/ModelViewPresenter.html&gt;. Acesso 
em: 11 mai. 2009. 19:00. 

 

GÓMEZ-PÉREZ, A.; CORCHO, O. Ontology Languages for the 
Semantic Web. IEEE Inteligent Systems, v. 17, n. 1, p. 54-60, 2002. 

 

GÓMEZ-PÉREZ, A; et al. Ontologic Engineering: with examples 
from the areas of knowledge management, e-commerce and the 
semantic web. Springer-Verlag, 2004. 

 



  

GRAU, B. C.; et al. Modular Reuse of Ontologies: Theory and Practice. 
Journal of Artificial Intelligence Research, v. 31, n. 1, p. 273-318, 
2008. 

 

GRUBER, T. A translation approach  to portable ontology specification. 
Knowledge Acquisition, v. 5, n. 2, p. 199-220, 1993.  

 

GRUNINGER, M.; FOX, M. S. Methodology for the design and 
evaluation of ontologies. In Skuce D (ed) IJCAI95 Workshop on 
Basic Ontological Issues in Knowledge Sharing, pp 6.1–6.10.,1995. 

 

GRUNINGER, M.; LEE, J. Ontology Applications and Design. 
Communications of the ACM, v. 45, n. 2, p. 39–41, 2002.  

 

GSEVIC, D.; et al. Model Driven Architecture and Ontology 
Development. Springer, 2006.  

 

GUARINO, N. Formal Ontology in Information Systems. In: GUARINO, 
N. (ed). Formal Ontology in Information Systems. Amsterdam: IOS 
Press, 1998. 

 

HEPP, M.; et al. Harvesting Wiki Consensus Using Wikipedia Entries 
as Vocabulary for Knowledge Management. Internet Computing, v. 
11, n. 5, p. 54-65, 2007. 

 

KIRYAKOV, A. Ontologies for Knowledge Management. In: DAVIES, 
J.; et al. (eds). Semantic Web Technologies: trends and research in 
ontology-based systems, p. 115-138, 2006. 

 

MIKA, P.; AKKERMANS, H.  Towards a new synthesis of ontology 
technology and knowledge management. The Knowledge 
Engineering Review, v. 19, n. 4, p. 317-345, 2005. 

 

NEON. NeOn Toolkit Portal. Disponível em: &amp;lt;http://www.neon-
toolkit.org/&gt;. Acesso em: 10 mai. 2009. 17:00. 

 



  

NOY, N. F.; MCGUINNESS, D. L. Ontology Development 101: A 
Guide to Creating Your First Ontology. Disponível em: 
&lt;http://wwwksl.stanford.edu/people/dlm/papers/ontology-tutorial-noy-
mcguinness.pdf&gt;. 

 

PINTO, H. S.; MARTINS, J. P. Ontologies: how can they be built? 
Knowledge and Information Systems, v. 6, n. 4, p. 441-464, 2004. 

 

PROTÉGÉ. What is Protégé? Disponível em: 
&lt;http://protege.stanford.edu/overview&gt;. Acesso em: 09 mai. 2009. 
14:00. 

 

RAUTENBERG, S.; et al. ontoKEM: uma ferramenta para 
construção e documentação de ontologias. In: Seminário de 
Pesquisa  em Ontologia no Brasil, Niterói, Brasil, Agosto, 2008. Anais 
do 1º Seminário de Pesquisa em Ontologia no Brasil, 2008. 

 

RAUTENBERG, S. Modelo de Conhecimento para Mapeamento de 
Instrumentos da Gestão do Conhecimento e de Agentes 
Computacionais da Engenharia do Conhecimento Baseado em 
Ontologias. Exame de Qualificação, Universidade Federal de Santa 
Catarina – Programa de Pós-Graduação em Engenharia e Gestão do 
Conhecimento, Florianópolis, Santa Catarina, Brasil, mar. 2009. 

 

SCHREIBER, G.; et al. Knowledge engineering and management: 
the commonKADS methodology. MIT Press, 2002. 

 

STUDER, R.; et al. Knowledge Engineering: Principles and methods. 
Data &amp;amp; Knowledge Engineering, v. 25, n. 1, p. 161-197, 1998. 

 

SUÁREZ-FIGUEROA, M. C.; et al., D5.3.1 NeOn Development 
Process and Ontology Life Cycle. NeOn: Lifecycle Support for 
Networked Ontologies, Integrated Project (IST-2005-027595), NeOn-
Project.org, 2007. 

 

SUÁREZ-FIGUEROA, M.; et al., C. D5.4.1. NeOn Methodology for 
Building Contextualized Ontology Networks. NeOn: Lifecycle 
Support for Networked Ontologies, Integrated Project (IST-2005-
027595), NeOn-Project.org, 2008. 



  

 

SURE, Y.; STUDER, R. A Methodology for Ontology-based 
Knowledge Management. In: DAVIES, John; et al (eds). Towards The 
Semantic Web: Ontology-Driven Knowledge Management. John Wiley 
&amp;amp; Sons, p. 33-46, 2003. 

 



  

 

ANEXO A – CÓDIGO-FONTE DA APLICAÇÃO. 

 

? Projeto “CQPlugin” — projeto da aplicação proposta. 
 

? Pacote “Beans”: 

? Classe CompetenceQuestionsBean.java: 
package beans; 
 
import java.util.Collection; 
import java.util.LinkedHashMap; 
import java.util.Map; 
import java.util.Set; 
 
import data.CQ; 
import data.Category; 
 
public class CompetenceQuestionsBean { 
  
 private Map&lt;Integer, Category&gt; categoriesMap = null; 
 private Map&lt;Integer, CQ&gt; competenceQuestionsMap = null; 
  
 private OneCategory oneCategory = null; 
 private OneCompetenceQuestion oneCompetenceQuestion = null; 
  
 public CompetenceQuestionsBean() {} 
  
 /** 
  * @return the categoriesMap 
  */ 
 public Map&lt;Integer, Category&gt; getCategoriesMap() { 
  return this.categoriesMap; 
 } 
  
 /** 
  * @param categoriesMap the categoriesMap to set 
  */ 
 public void setCategoriesMap(Map&lt;Integer, Category&gt; categoriesMap) { 
  final int length = (categoriesMap != null ? categoriesMap.size() 
: 0); 
  this.categoriesMap = new LinkedHashMap&lt;Integer, 
Category&gt;(length); 
  if (length &gt; 0) { 
   this.categoriesMap.putAll(categoriesMap); 
  } 
 } 
  
 /** 
  * @return the competenceQuestionsMap 
  */ 
 public Map&lt;Integer, CQ&gt; getCompetenceQuestionsMap() { 
  return this.competenceQuestionsMap; 
 } 
  
 /** 
  * @param competenceQuestionsMap the competenceQuestionsMap to set 
  */ 
 public void setCompetenceQuestionsMap(Map&lt;Integer, CQ&gt; 
competenceQuestionsMap) { 
  final int length = (competenceQuestionsMap != null ? 
competenceQuestionsMap.size() : 0); 
  this.competenceQuestionsMap = new LinkedHashMap&lt;Integer, 
CQ&gt;(length); 
  if (length &gt; 0) { 



  

  
 this.competenceQuestionsMap.putAll(competenceQuestionsMap); 
  } 
 } 
  
 /** 
  * @return the oneCategory 
  */ 
 public OneCategory getOneCategory() { 
  return oneCategory; 
 } 
 
 /** 
  * @param oneCategory the oneCategory to set 
  */ 
 public void setOneCategory(OneCategory oneCategory) { 
  this.oneCategory = oneCategory; 
 } 
  
 /** 
  * @return the oneCompetenceQuestion 
  */ 
 public OneCompetenceQuestion getOneCompetenceQuestion() { 
  return oneCompetenceQuestion; 
 } 
 
 /** 
  * @param oneCompetenceQuestion the oneCompetenceQuestion to set 
  */ 
 public void setOneCompetenceQuestion(OneCompetenceQuestion 
oneCompetenceQuestion) { 
  this.oneCompetenceQuestion = oneCompetenceQuestion; 
 } 
  
 public static class OneCategory { 
  private final Integer idCode; 
  private final String name; 
  private final String description; 
   
  public OneCategory(final Integer idCode, final String name, 
final String description) { 
   this.idCode = idCode; 
   this.name = name; 
   this.description = description; 
  } 
 
  public Integer getIdCode() { 
   return idCode; 
  } 
 
  public String getName() { 
   return name; 
  } 
 
  public String getDescription() { 
   return description; 
  } 
 } 
  
 public static class OneCompetenceQuestion { 
  private final Integer idCode; 
  private final String question; 
  private final String answer; 
  private final int quantQuestionTerms; 
  private final int quantAnswerTerms; 
   
  public OneCompetenceQuestion(final Integer idCode, 
    final String question, final String answer, 
    final int quantQuestionTerms, final int 
quantAnswerTerms) { 
   this.idCode = idCode; 
   this.question = question; 
   this.answer = answer; 
   this.quantQuestionTerms = quantQuestionTerms; 
   this.quantAnswerTerms = quantAnswerTerms; 
  } 
 
  public Integer getIdCode() { 
   return idCode; 
  } 



  

 
  public String getQuestion() { 
   return question; 
  } 
 
  public String getAnswer() { 
   return answer; 
  } 
 
  public int getQuantQuestionTerms() { 
   return quantQuestionTerms; 
  } 
 
  public int getQuantAnswerTerms() { 
   return quantAnswerTerms; 
  } 
 } 
  
 /*-------------------- 
  * Validation Methods: 
  --------------------*/ 
  
 public boolean existCategoryName(final Integer idCode, final String 
name) { 
  if (this.categoriesMap != null &amp;amp;&amp;amp; categoriesMap.size() &gt; 0) { 
   Collection&lt;Category&gt; categories = 
this.categoriesMap.values(); 
   for (Category category : categories) { 
    if 
(category.getName().trim().equalsIgnoreCase(name.trim()) &amp;amp;&amp;amp; 
      category.getIdCode() != idCode) { 
     return true; 
    } 
   } 
  } 
  return false; 
 } 
  
 /*--------------- 
  * Other Methods: 
  ---------------*/ 
 
 public Map&lt;String, Integer&gt; getAvailableCategoriesToMove(final Integer 
sourceCategoryID) { 
  final Map&lt;String, Integer&gt; destinationOptionsMap = new 
LinkedHashMap&lt;String, Integer&gt;(0); 
   
  final Set&lt;Integer&gt; categoryIDs = this.categoriesMap.keySet(); 
  for (Integer idCode : categoryIDs) { 
   if (sourceCategoryID != idCode) { 
    final Category category = 
this.categoriesMap.get(idCode); 
    destinationOptionsMap.put(category.getName(), 
idCode); 
   } 
  } 
   
  return destinationOptionsMap; 
 } 
} 
 
 

? Classe IOBean.java: 
package beans; 
 
import java.text.DateFormat; 
import java.text.ParseException; 
import java.util.ArrayList; 
import java.util.Date; 
import java.util.LinkedHashSet; 
import java.util.List; 
import java.util.Set; 
import java.util.StringTokenizer; 
 
import system.utils.UtilClass; 
 
public class IOBean { 
  



  

 //*Endereço do arquivo 
 private final String fileAddress; 
  
 //*Atributos de dados: 
 private String projectName; 
 private String autor; 
 private Date createDate; 
 private String purpose; 
 private String scope; 
 private String formalityLevel; 
  
 private List&lt;String&gt; usersDescriptions = new ArrayList&lt;String&gt;(0); 
 private List&lt;String&gt; usesScenarios = new ArrayList&lt;String&gt;(0); 
  
 private List&lt;CategoryIO&gt; categories = new ArrayList&lt;CategoryIO&gt;(0); 
  
 private List&lt;TermIO&gt; terms = new ArrayList&lt;TermIO&gt;(0); 
  
 /*----------- 
  * Construtor 
  -----------*/ 
 public IOBean(final String fileAddress) { 
  this.fileAddress = fileAddress; 
 } 
  
 public void addCategoryIO(final CategoryIO categoryIO) { 
  if (categories == null) { 
   categories = new ArrayList&lt;CategoryIO&gt;(0); 
  } 
  if (categoryIO != null) { 
   this.categories.add(categoryIO); 
  } 
 } 
  
 public void addTermIO(final TermIO termIO) { 
  if (terms == null){ 
   terms = new ArrayList&lt;TermIO&gt;(0); 
  } 
  if (termIO != null) { 
   this.terms.add(termIO); 
  } 
 } 
  
 public static class CategoryIO { 
  private String name; 
  private List&lt;CQsIO&gt; cqs = new ArrayList&lt;CQsIO&gt;(0); 
   
  public void addCQsIO(CQsIO cqIO) { 
   if (cqs == null) { 
    cqs = new ArrayList&lt;CQsIO&gt;(0); 
   } 
   if (cqIO != null) { 
    this.cqs.add(cqIO); 
   } 
  } 
   
  public static class CQsIO { 
   private int id; 
   private String question; 
   private String answer; 
    
   public int getId() { 
    return id; 
   } 
   public String getQuestion() { 
    return question; 
   } 
   public String getAnswer() { 
    return answer; 
   } 
   public void setId(int id) { 
    this.id = id; 
   } 
   public void setQuestion(String question) { 
    this.question = UtilClass.removeAccent(question); 
   } 
   public void setAnswer(String answer) { 
    this.answer = UtilClass.removeAccent(answer); 
   } 
  } 



  

 
  public String getName() { 
   return name; 
  } 
  public List&lt;CQsIO&gt; getCqs() { 
   if (cqs != null) { 
    return cqs; 
   } 
   return new ArrayList&lt;CQsIO&gt;(0); 
  } 
  public void setName(String name) { 
   this.name = UtilClass.removeAccent(name); 
  } 
  public void setCqs(List&lt;CQsIO&gt; cqs) { 
   this.cqs = cqs; 
  } 
 } 
  
 public static class TermIO { 
  private int[] originQuestion; 
  private int[] originAnswers; 
  private String term; 
  private Integer orderPosition; 
   
  public int[] getOriginQuestion() { 
   if (originQuestion != null) { 
    return originQuestion;     
   } 
   return new int[]{}; 
  } 
  public String getStringOfOriginQuestions() { 
   return 
this.getStringOfIntArray(this.getOriginQuestion()); 
  } 
  public int[] getOriginAnswers() { 
   if (originAnswers != null) { 
    return originAnswers;     
   } 
   return new int[]{}; 
  } 
  public String getStringOfOriginAnswers() { 
   return 
this.getStringOfIntArray(this.getOriginAnswers()); 
  } 
  private String getStringOfIntArray(final int[] intArray) { 
   StringBuilder strBuilder = new StringBuilder(); 
   final int length = (intArray != null ? intArray.length : 
0); 
   for (int i=0; i &amp;lt;length; i++) { 
    if (strBuilder.length() &gt; 0) { 
     strBuilder.append(","); 
    } 
    strBuilder.append(intArray[i]); 
   } 
   String returnStr = strBuilder.toString(); 
   return (returnStr != null ? returnStr : new String()); 
  } 
  public String getTerm() { 
   return term; 
  } 
  public Integer getOrderPosition() { 
   return orderPosition; 
  } 
  public void setOriginQuestion(int[] originQuestion) { 
   this.originQuestion = originQuestion; 
  } 
  public void setOriginQuestion(String originQuestion) { 
   this.originQuestion = 
this.getOriginsArrayFromString(originQuestion); 
  } 
  public void setOriginAnswers(int[] originAnswers) { 
   this.originAnswers = originAnswers; 
  } 
  public void setOriginAnswers(String originAnswers) { 
   this.originAnswers = 
this.getOriginsArrayFromString(originAnswers); 
  } 
  private int[] getOriginsArrayFromString(final String strOrigins) 
{ 



  

   final Set&lt;Integer&gt; originsSet = new 
LinkedHashSet&lt;Integer&gt;(0); 
   if (strOrigins != null &amp;amp;&amp;amp; !strOrigins.trim().isEmpty()) 
{ 
    String cleanString = 
UtilClass.removePuncts(strOrigins, " "); 
    StringTokenizer tokenizer = new 
StringTokenizer(cleanString); 
    while (tokenizer.hasMoreTokens()) { 
     String token = 
tokenizer.nextToken().trim(); 
     final int idOrigin = 
Integer.parseInt(token); 
     originsSet.add(idOrigin); 
    } 
   } 
   return 
UtilClass.convertArrayIntegerToArrayInt(originsSet.toArray(new Integer[]{})); 
  } 
  public void setTerm(String term) { 
   this.term = UtilClass.removeAccent(term); 
  } 
  public void setOrderPosition(Integer orderPosition) { 
   this.orderPosition = orderPosition; 
  } 
  public void setOrderPosition(String orderPosition) { 
   if (orderPosition != null &amp;amp;&amp;amp; 
!orderPosition.trim().isEmpty()) { 
    try { 
     this.orderPosition = 
Integer.parseInt(orderPosition.trim()); 
    } catch (NumberFormatException e) { 
     this.orderPosition = null; 
    } 
   } else { 
    this.orderPosition = null; 
   } 
  } 
 } 
  
 /*--------- 
  * GETTERS: 
  ---------*/ 
 
 public String getFileAddress() { 
  return fileAddress; 
 } 
 
 public String getProjectName() { 
  return projectName; 
 } 
 
 public String getAutor() { 
  return autor; 
 } 
 
 public Date getCreateDate() { 
  return createDate; 
 } 
 public String getStringOfCreateDate() { 
  if (createDate != null) { 
   return createDate.toString(); 
  } 
  return null; 
 } 
 
 public String getPurpose() { 
  return purpose; 
 } 
 
 public String getScope() { 
  return scope; 
 } 
 
 public String getFormalityLevel() { 
  return formalityLevel; 
 } 
 
 public List&lt;String&gt; getUsersDescriptions() { 
  return usersDescriptions; 



  

 } 
 
 public List&lt;String&gt; getUsesScenarios() { 
  return usesScenarios; 
 } 
 
 public List&lt;CategoryIO&gt; getCategories() { 
  if (categories != null) { 
   return categories; 
  } 
  return new ArrayList&lt;CategoryIO&gt;(0); 
 } 
 
 public List&lt;TermIO&gt; getTerms() { 
  if (terms != null) { 
   return terms; 
  } 
  return new ArrayList&lt;TermIO&gt;(0); 
 } 
 
 /*--------- 
  * SETTERS: 
  ---------*/ 
  
 public void setProjectName(String projectName) { 
  this.projectName = UtilClass.removeAccent(projectName); 
 } 
 
 public void setAutor(String autor) { 
  this.autor = UtilClass.removeAccent(autor); 
 } 
 
 public void setCreateDate(Date createDate) { 
  this.createDate = createDate; 
 } 
 public void setCreateDate(String createDate) { 
  try { 
   this.createDate = 
(DateFormat.getInstance()).parse(createDate); 
  } catch (ParseException e) { 
   this.createDate = new Date(); 
  } 
 } 
 
 public void setPurpose(String purpose) { 
  this.purpose = UtilClass.removeAccent(purpose); 
 } 
 
 public void setScope(String scope) { 
  this.scope = UtilClass.removeAccent(scope); 
 } 
 
 public void setFormalityLevel(String formalityLevel) { 
  this.formalityLevel = UtilClass.removeAccent(formalityLevel); 
 } 
 
 public void setUsersDescriptions(List&lt;String&gt; usersDescriptions) { 
  this.usersDescriptions = 
UtilClass.removeAccentFromStringList(usersDescriptions); 
 } 
 
 public void setUsesScenarios(List&lt;String&gt; usesScenarios) { 
  this.usesScenarios = 
UtilClass.removeAccentFromStringList(usesScenarios); 
 } 
 
 public void setCategories(List&lt;CategoryIO&gt; categories) { 
  this.categories = categories; 
 } 
 
 public void setTerms(List&lt;TermIO&gt; terms) { 
  this.terms = terms; 
 } 
} 
 
 

? Classe ProjectBean.java: 
package beans; 



  

 
import java.util.Date; 
import java.util.List; 
 
 
public class ProjectBean { 
  
 public static class Params { 
   
  private String name; 
  private String autor; 
  private String purpose; 
  private String scope; 
  private String formalityLevel; 
  private List&lt;String&gt; usersDescriptionsList; 
  private List&lt;String&gt; usesScenariosList; 
 
  public String getName() { 
   return name; 
  } 
 
  public String getAutor() { 
   return autor; 
  } 
 
  public String getPurpose() { 
   return purpose; 
  } 
 
  public String getScope() { 
   return scope; 
  } 
 
  public String getFormalityLevel() { 
   return formalityLevel; 
  } 
 
  public List&lt;String&gt; getUsersDescriptionsList() { 
   return usersDescriptionsList; 
  } 
 
  public List&lt;String&gt; getUsesScenariosList() { 
   return usesScenariosList; 
  } 
 
  public void setName(final String name) { 
   this.name = name; 
  } 
 
  public void setAutor(final String autor) { 
   this.autor = autor; 
  } 
 
  public void setPurpose(final String purpose) { 
   this.purpose = purpose; 
  } 
 
  public void setScope(final String scope) { 
   this.scope = scope; 
  } 
 
  public void setFormalityLevel(final String formalityLevel) { 
   this.formalityLevel = formalityLevel; 
  } 
 
  public void setUsersDescriptionsList(final List&lt;String&gt; 
usersDescriptionsList) { 
   this.usersDescriptionsList = usersDescriptionsList; 
  } 
 
  public void setUsesScenariosList(final List&lt;String&gt; 
usesScenariosList) { 
   this.usesScenariosList = usesScenariosList; 
  }  
 } 
  
 private Date createDate; 
  
 private final Params initParams; 
 private Params changedParams; 



  

  
 public ProjectBean(final ProjectBean.Params initParams, final Date 
projectCreateDate) { 
  if (initParams != null) { 
   this.initParams = initParams; 
  } else { 
   this.initParams = new Params(); 
  } 
  this.createDate = projectCreateDate; 
 } 
  
 private Params getChangedParams() { 
  if (this.changedParams == null) { 
   this.changedParams = new Params(); 
  } 
  return this.changedParams; 
 } 
  
 public void setName(final String name) { 
  this.getChangedParams().setName(name); 
 } 
 public void setAutor(final String autor) { 
  this.getChangedParams().setAutor(autor); 
 } 
 public void setPurpose(final String purpose) { 
  this.getChangedParams().setPurpose(purpose); 
 } 
 public void setScope(final String scope) { 
  this.getChangedParams().setScope(scope); 
 } 
 public void setFormalityLevel(final String formalityLevel) { 
  this.getChangedParams().setFormalityLevel(formalityLevel); 
 } 
 public void setUsersDescriptionList(final List&lt;String&gt; 
usersDescriptionsList) { 
 
 this.getChangedParams().setUsersDescriptionsList(usersDescriptionsList)
; 
 } 
 public void setUsesScenariosList(final List&lt;String&gt; usesScenariosList) 
{ 
  this.getChangedParams().setUsesScenariosList(usesScenariosList); 
 } 
  
 public boolean hasNewName() { 
  if (this.changedParams != null) { 
   return this.isDiferent(this.initParams.getName(), 
this.changedParams.getName()); 
  } 
  return false; 
 } 
  
 public String getName() { 
  if (this.changedParams != null) { 
   return this.changedParams.getName(); 
  } else { 
   return this.initParams.getName(); 
  } 
 } 
 public String getAutor() { 
  if (this.changedParams != null) { 
   return this.changedParams.getAutor(); 
  } else { 
   return this.initParams.getAutor(); 
  } 
 } 
 public String getPurpose() { 
  if (this.changedParams != null) { 
   return this.changedParams.getPurpose(); 
  } else { 
   return this.initParams.getPurpose(); 
  } 
 } 
 public String getScope() { 
  if (this.changedParams != null) { 
   return this.changedParams.getScope(); 
  } else { 
   return this.initParams.getScope(); 
  } 
 } 



  

 public String getFormalityLevel() { 
  if (this.changedParams != null) { 
   return this.changedParams.getFormalityLevel(); 
  } else { 
   return this.initParams.getFormalityLevel(); 
  } 
 } 
 public List&lt;String&gt; getUsersDescriptionsList() { 
  if (this.changedParams != null) { 
   return this.changedParams.getUsersDescriptionsList(); 
  } else { 
   return this.initParams.getUsersDescriptionsList(); 
  } 
 } 
 public List&lt;String&gt; getUsesScenariosList() { 
  if (this.changedParams != null) { 
   return this.changedParams.getUsesScenariosList(); 
  } else { 
   return this.initParams.getUsesScenariosList(); 
  } 
 } 
  
 public Date getCreateDate() { 
  return this.createDate; 
 } 
  
 private boolean isDiferent(final String init, final String changed) { 
  return (init == null ? changed != null : 
!init.equalsIgnoreCase(changed)); 
 } 
 private boolean isListDiferent(final List&lt;String&gt; init, final 
List&lt;String&gt; changed) { 
  return (init == null ? changed != null : !init.equals(changed)); 
 } 
 
 public boolean hasChanges() { 
  if (this.changedParams != null) { 
   if ( this.isDiferent(this.initParams.getName(), 
this.changedParams.getName()) ) { 
    return true; 
   } else if ( this.isDiferent(this.initParams.getAutor(), 
this.changedParams.getAutor()) ) { 
    return true; 
   } else if ( 
this.isDiferent(this.initParams.getPurpose(), this.changedParams.getPurpose()) 
) { 
    return true; 
   } else if ( this.isDiferent(this.initParams.getScope(), 
this.changedParams.getScope()) ) { 
    return true; 
   } else if ( 
this.isDiferent(this.initParams.getFormalityLevel(), 
this.changedParams.getFormalityLevel()) ) { 
    return true; 
   } else if ( 
this.isListDiferent(this.initParams.getUsersDescriptionsList(), 
this.changedParams.getUsersDescriptionsList()) ) { 
    return true; 
   } else if ( 
this.isListDiferent(this.initParams.getUsesScenariosList(), 
this.changedParams.getUsesScenariosList()) ) { 
    return true; 
   } 
  } 
  return false; 
 } 
  
 public void clearChanges() { 
  this.changedParams = null; 
 } 
} 
 
 

? Classe TermsBean,java: 
package beans; 
 
import java.util.ArrayList; 
import java.util.Collection; 



  

import java.util.Collections; 
import java.util.LinkedHashMap; 
import java.util.LinkedHashSet; 
import java.util.List; 
import java.util.Map; 
import java.util.Set; 
 
import system.utils.UtilClass; 
import system.utils.UtilClass.ValidationErrors; 
import view.terms.TermsForm.OrderByOptions; 
 
import data.Term; 
 
public class TermsBean { 
  
 private Map&lt;String, MappedTerm&gt; initTermsMap; 
  
 private Map&lt;String, MappedTerm&gt; chosenTermsMap; 
  
 private Map&lt;String, MappedTerm&gt; extractedTermsMap; 
  
 private Map&lt;String, Integer&gt; availableCategoriesToExtract; 
  
 public TermsBean() { 
  this.extractedTermsMap = new LinkedHashMap&lt;String, 
MappedTerm&gt;(0); 
     
  this.initTermsMap = new LinkedHashMap&lt;String, MappedTerm&gt;(0); 
  this.chosenTermsMap = new LinkedHashMap&lt;String, MappedTerm&gt;(0); 
 } 
  
 public void loadInitData(final Map&lt;Integer, Term&gt; allTermsMap) { 
  final int length = (allTermsMap != null ? allTermsMap.size() : 
0); 
  if (length &gt; 0) { 
   this.loadMapToMap(allTermsMap, this.initTermsMap); 
   this.loadMapToMap(allTermsMap, this.chosenTermsMap); 
  } 
 } 
 
 private void loadMapToMap(final Map&lt;Integer, Term&gt; allTermsMap, 
   final Map&lt;String, MappedTerm&gt; targetTermsMap) { 
  targetTermsMap.clear(); 
  final Set&lt;Integer&gt; keySet = allTermsMap.keySet(); 
  for (Integer id : keySet) { 
   final Term term = allTermsMap.get(id); 
   MappedTerm mappedTerm = new MappedTerm(); 
    
   mappedTerm.setIdCode(term.getIdCode()); 
   mappedTerm.setOrderPosition(term.getOrderPosition()); 
   mappedTerm.setTerm(term.getDescription()); 
  
 mappedTerm.setOriginQuestions(term.getOriginQuestions()); 
   mappedTerm.setOriginAnswers(term.getOriginAnswers()); 
    
   targetTermsMap.put( 
    
 UtilClass.formatTermsMapKey(mappedTerm.term), mappedTerm); 
  } 
 } 
  
 public void reloadInitTermsMap(final Map&lt;Integer, Term&gt; allTermsMap) { 
  if (this.initTermsMap != null) { 
   this.loadMapToMap(allTermsMap, this.initTermsMap); 
  } 
 } 
  
 public void clearExtractedTermsMap() { 
  this.extractedTermsMap.clear(); 
 } 
  
 public void addAllExtractedTermsFromQuestion(final Set&lt;String&gt; 
extractedTerms, final int questionID) { 
  this.addAllExtractedTerms(extractedTerms, questionID, null); 
 } 
  
 public void addAllExtractedTermsFromAnswer(final Set&lt;String&gt; 
extractedTerms, final int answerID) { 
  this.addAllExtractedTerms(extractedTerms, null, answerID); 
 } 



  

  
 private void addAllExtractedTerms(final Set&lt;String&gt; extractedTerms, 
   final Integer questionID, final Integer answerID) { 
  if (extractedTerms != null) { 
   for (String term : extractedTerms) { 
    MappedTerm mappedTerm = 
    
 this.extractedTermsMap.get(UtilClass.formatTermsMapKey(term)); 
    if (mappedTerm == null) { 
     mappedTerm = new MappedTerm(); 
     mappedTerm.term = term; 
     this.extractedTermsMap.put( 
      
 UtilClass.formatTermsMapKey(mappedTerm.term), mappedTerm); 
    } 
    if (questionID != null) { 
    
 mappedTerm.originQuestions.add(questionID); 
    } 
    if (answerID != null) { 
     mappedTerm.originAnswers.add(answerID); 
    } 
   } 
  } 
 } 
  
 public int getFrequency(final String term) { 
  MappedTerm mappedTerm = this.chosenTermsMap.get(term); 
  if (mappedTerm != null) { 
   return mappedTerm.getFrequency(); 
  } 
  return 0; 
 } 
  
 public Collection&lt;MappedTerm&gt; valuesOfExtractedTermsMap(final 
OrderByOptions orderOption) { 
  Map&lt;String, MappedTerm&gt; returnMap = 
this.compareExtractedWithChosenMap(); 
  if (orderOption != null) { 
   return this.valuesOfTermsMap(returnMap, orderOption); 
  } 
  return returnMap.values(); 
 } 
  
 public Collection&lt;MappedTerm&gt; valuesOfChosenTermsMap(final 
OrderByOptions orderOption) { 
  if (orderOption != null) { 
   return this.valuesOfTermsMap(this.chosenTermsMap, 
orderOption); 
  } 
  return this.chosenTermsMap.values(); 
 } 
  
 private Collection&lt;MappedTerm&gt; valuesOfTermsMap(final Map&lt;String, 
MappedTerm&gt; termsMap, 
   final OrderByOptions orderOption) { 
  switch (orderOption) { 
   case POSITION: { 
    return this.getValuesOrderByPosition(termsMap); 
   } 
   case FREQUENCY: { 
    return this.getValuesOrderByFrequency(termsMap); 
   } 
   default: { 
    return this.getValuesOrderByAlphabet(termsMap); 
   } 
  } 
 } 
  
 private Collection&lt;MappedTerm&gt; getValuesOrderByAlphabet( 
   final Map&lt;String, MappedTerm&gt; termsMap) { 
  final int length = (termsMap != null ? termsMap.size() : 0); 
  Collection&lt;MappedTerm&gt; returnValues = new 
ArrayList&lt;MappedTerm&gt;(length); 
  if (length &gt; 0) { 
   final List&lt;String&gt; keyList = new 
ArrayList&lt;String&gt;(termsMap.keySet()); 
   Collections.sort(keyList); 
   for (String key : keyList) { 



  

    final String term = 
UtilClass.formatTermsMapKey(key); 
    returnValues.add(termsMap.get(term)); 
   } 
  } 
  return returnValues; 
 } 
 
 private Collection&lt;MappedTerm&gt; getValuesOrderByFrequency( 
   final Map&lt;String, MappedTerm&gt; termsMap) { 
  final int length = (termsMap != null ? termsMap.size() : 0); 
  Collection&lt;MappedTerm&gt; returnValues = new 
ArrayList&lt;MappedTerm&gt;(length); 
  if (length &gt; 0) { 
   Map&lt;Integer, List&lt;MappedTerm&gt;&gt; orderedMap = new 
LinkedHashMap&lt;Integer, List&lt;MappedTerm&gt;&gt;(0); 
   Collection&lt;MappedTerm&gt; values = termsMap.values(); 
   for (MappedTerm mappedTerm : values) { 
    final int frequency = mappedTerm.getFrequency(); 
    final List&lt;MappedTerm&gt; list = 
(orderedMap.containsKey(frequency) ? 
       orderedMap.get(frequency) : 
new ArrayList&lt;MappedTerm&gt;(0)); 
    list.add(mappedTerm); 
    orderedMap.put(frequency, list); 
   } 
   List&lt;Integer&gt; keyList = new 
ArrayList&lt;Integer&gt;(orderedMap.keySet()); 
   Collections.sort(keyList, Collections.reverseOrder()); 
   for (Integer key : keyList) { 
    returnValues.addAll(orderedMap.get(key)); 
   } 
  } 
  return returnValues; 
 } 
 
 private Collection&lt;MappedTerm&gt; getValuesOrderByPosition( 
   final Map&lt;String, MappedTerm&gt; termsMap) { 
  final int length = (termsMap != null ? termsMap.size() : 0); 
  Collection&lt;MappedTerm&gt; returnValues = new 
ArrayList&lt;MappedTerm&gt;(length); 
  if (length &gt; 0) { 
   Map&lt;Integer, MappedTerm&gt; positionMap = new 
LinkedHashMap&lt;Integer, MappedTerm&gt;(0); 
   Map&lt;Integer, List&lt;MappedTerm&gt;&gt; frequencyMap = new 
LinkedHashMap&lt;Integer, List&lt;MappedTerm&gt;&gt;(0); 
   Collection&lt;MappedTerm&gt; values = termsMap.values(); 
   for (MappedTerm mappedTerm : values) { 
    final Integer orderPosition = 
mappedTerm.getOrderPosition(); 
    if (orderPosition != null) { 
     positionMap.put(orderPosition, 
mappedTerm); 
    } else { 
     final int frequency = 
mappedTerm.getFrequency(); 
     final List&lt;MappedTerm&gt; list = 
(frequencyMap.containsKey(frequency) ? 
       frequencyMap.get(frequency) 
: new ArrayList&lt;MappedTerm&gt;(0)); 
     list.add(mappedTerm); 
     frequencyMap.put(frequency, list); 
    } 
   } 
   List&lt;Integer&gt; positionList = new 
ArrayList&lt;Integer&gt;(positionMap.keySet()); 
   Collections.sort(positionList); 
   for (Integer position : positionList) { 
    returnValues.add(positionMap.get(position)); 
   } 
   List&lt;Integer&gt; frequencyList = new 
ArrayList&lt;Integer&gt;(frequencyMap.keySet()); 
   Collections.sort(frequencyList, 
Collections.reverseOrder()); 
   for (Integer frequency : frequencyList) { 
    returnValues.addAll(frequencyMap.get(frequency)); 
   } 
  } 
  return returnValues; 
 } 



  

 
 public boolean isChosenEqualsInitMap() { 
  boolean equals = true; 
   
  final int lengthChosen = this.chosenTermsMap.size(); 
  final int lengthInit = this.initTermsMap.size(); 
  if (lengthChosen != lengthInit) { 
   equals = false; 
  } else { 
   for (String key : this.chosenTermsMap.keySet()) { 
    final String term = 
UtilClass.formatTermsMapKey(key); 
    if (!this.compareMappedTerms( 
      this.chosenTermsMap.get(term), 
this.initTermsMap.get(term))) { 
     equals = false; 
     break; 
    } 
   } 
  } 
   
  return equals; 
 } 
  
 private boolean compareMappedTerms(final MappedTerm chosenTerm, 
   final MappedTerm initTerm) { 
  boolean equals = true; 
   
  final Object[] detailsChosenTerm = new Object[]{ 
    chosenTerm.idCode, chosenTerm.term, 
chosenTerm.orderPosition  
  }; 
  final Object[] detailsInitTerm = new Object[]{ 
    initTerm.idCode, initTerm.term, 
initTerm.orderPosition 
  }; 
  for (int i=0; i &amp;lt;3; i++) { 
   if (detailsChosenTerm[i] != null) { 
    if 
(!detailsChosenTerm[i].equals(detailsInitTerm[i])) { 
     equals = false; 
     break; 
    } 
   } else if (detailsInitTerm[i] != null) { 
    equals = false; 
    break; 
   } 
  } 
   
  if (equals) { 
   for (Integer question : chosenTerm.originQuestions) { 
    if (!initTerm.originQuestions.contains(question)) 
{ 
     equals = false; 
     break; 
    } 
   } 
   if (equals) { 
    for (Integer answer : chosenTerm.originAnswers) { 
     if 
(!initTerm.originAnswers.contains(answer)) { 
      equals = false; 
      break; 
     } 
    } 
   } 
  } 
   
  return equals; 
 } 
 
 public Map&lt;String, Integer&gt; getAvailableCategoriesToExtract() { 
  return availableCategoriesToExtract; 
 } 
 
 public void setAvailableCategoriesToExtract( 
   Map&lt;String, Integer&gt; availableCategoriesToExtract) { 
  this.availableCategoriesToExtract = 
availableCategoriesToExtract; 
 } 



  

  
 public Map&lt;String, MappedTerm&gt; compareExtractedWithChosenMap() { 
  Map&lt;String, MappedTerm&gt; returnMap = new LinkedHashMap&lt;String, 
MappedTerm&gt;(0); 
  returnMap.putAll(this.extractedTermsMap); 
   
  for (String key : this.extractedTermsMap.keySet()) { 
   final String term = UtilClass.formatTermsMapKey(key); 
   boolean termMustRemoved = true; 
   if (this.chosenTermsMap.containsKey(term)) { 
    final MappedTerm extractedTerm = 
this.extractedTermsMap.get(term); 
    final MappedTerm chosenTerm = 
this.chosenTermsMap.get(term); 
     
    for (Integer question : 
extractedTerm.originQuestions) { 
     if 
(!chosenTerm.originQuestions.contains(question)) { 
      termMustRemoved = false; 
      break; 
     } 
    } 
     
    if (termMustRemoved) { 
     for (Integer answer : 
extractedTerm.originAnswers) { 
      if 
(!chosenTerm.originAnswers.contains(answer)) { 
       termMustRemoved = false; 
       break; 
      } 
     } 
    } 
   } else { 
    termMustRemoved = false; 
   } 
    
   if (termMustRemoved) { 
    returnMap.remove(term); 
   } 
  } 
   
  return returnMap; 
 } 
  
 public void moveTermsToChosenMap(final List&lt;String&gt; extractedTermsList) 
{ 
  for (String key : extractedTermsList) { 
   final String term = UtilClass.formatTermsMapKey(key); 
   final MappedTerm extractedTerm = 
this.extractedTermsMap.get(term); 
   if (this.chosenTermsMap.containsKey(term)) { 
    final MappedTerm chosenTerm = 
this.chosenTermsMap.get(term); 
     
    for (Integer question : 
extractedTerm.originQuestions) { 
     if 
(!chosenTerm.originQuestions.contains(question)) { 
     
 chosenTerm.originQuestions.add(question); 
     } 
    } 
     
    for (Integer answer : 
extractedTerm.originAnswers) { 
     if 
(!chosenTerm.originAnswers.contains(answer)) { 
     
 chosenTerm.originAnswers.add(answer); 
     } 
    } 
   } else { 
    this.chosenTermsMap.put(term, extractedTerm); 
   } 
  } 
 } 
  



  

 public void addCombinedTermsToChosenMap(final List&lt;String&gt; 
combinedTermsList, 
   final Set&lt;Integer&gt; commonQuestions, final Set&lt;Integer&gt; 
commonAnswers) throws Exception { 
  if (combinedTermsList != null &amp;amp;&amp;amp; combinedTermsList.size() &gt; 0) { 
   final StringBuilder strBuilder = new StringBuilder(); 
   for (String partialTerm : combinedTermsList) { 
    if (strBuilder.length() &gt; 0) { 
     strBuilder.append(" "); 
    } 
    strBuilder.append(partialTerm); 
   } 
   final String term = 
UtilClass.formatTermsMapKey(strBuilder.toString()); 
   if (!this.chosenTermsMap.containsKey(term)) { 
    final MappedTerm mappedTerm = new MappedTerm(); 
    mappedTerm.setTerm(term); 
    mappedTerm.setOriginQuestions(commonQuestions); 
    mappedTerm.setOriginAnswers(commonAnswers); 
    this.chosenTermsMap.put(term, mappedTerm); 
   } else { 
    throw new 
Exception(ValidationErrors.EXISTED_VALUE.toString()); 
   } 
  } 
 } 
  
 public List&lt;Integer&gt; removeNotPersistedChosenTerms(final List&lt;String&gt; 
termsList) { 
  final List&lt;Integer&gt; persistedTermIDs = new 
ArrayList&lt;Integer&gt;(0); 
  for (String key : termsList) { 
   final String term = UtilClass.formatTermsMapKey(key); 
   final MappedTerm chosenTerm = 
this.chosenTermsMap.remove(term); 
   if (chosenTerm != null) { 
    if (chosenTerm.idCode != null) { 
     persistedTermIDs.add(chosenTerm.idCode); 
    } 
   } 
  } 
  return persistedTermIDs; 
 } 
  
 public static class MappedTerm { 
   
  private Integer idCode = null; 
  private String term; 
  private Set&lt;Integer&gt; originQuestions = new 
LinkedHashSet&lt;Integer&gt;(0); 
  private Set&lt;Integer&gt; originAnswers = new 
LinkedHashSet&lt;Integer&gt;(0); 
  private Integer orderPosition = null; 
 
  public Integer getIdCode() { 
   return idCode; 
  } 
 
  public String getTerm() { 
   return term; 
  } 
 
  public Set&lt;Integer&gt; getOriginQuestions() { 
   return originQuestions; 
  } 
 
  public Set&lt;Integer&gt; getOriginAnswers() { 
   return originAnswers; 
  } 
 
  public Integer getOrderPosition() { 
   return orderPosition; 
  } 
 
  public void setIdCode(Integer idCode) { 
   this.idCode = idCode; 
  } 
 
  public void setTerm(String term) { 
   this.term = term; 



  

  } 
 
  public void setOriginQuestions(Set&lt;Integer&gt; originQuestions) { 
   this.originQuestions = this.getListing(originQuestions); 
  } 
 
  public void setOriginAnswers(Set&lt;Integer&gt; originAnswers) { 
   this.originAnswers = this.getListing(originAnswers); 
  } 
 
  public void setOrderPosition(Integer orderPosition) { 
   this.orderPosition = orderPosition; 
  } 
   
  private Set&lt;Integer&gt; getListing(final Set&lt;Integer&gt; originIDs) { 
   final int length = (originIDs != null ? originIDs.size() 
: 0); 
   final Set&lt;Integer&gt; listing = new 
LinkedHashSet&lt;Integer&gt;(length); 
   if (length &gt; 0) { 
    listing.addAll(originIDs); 
   } 
   return listing; 
  } 
   
  public int getFrequency() { 
   return (originQuestions.size() + originAnswers.size()); 
  } 
 } 
 
 public Map&lt;String, MappedTerm&gt; getInitTermsMap() { 
  return initTermsMap; 
 } 
 
 public Map&lt;String, MappedTerm&gt; getChosenTermsMap() { 
  return chosenTermsMap; 
 } 
 
 public Map&lt;String, MappedTerm&gt; getExtractedTermsMap() { 
  return extractedTermsMap; 
 }  
} 
 
 

? Pacote “Data”: 

? Classe DataController,java: 
package data; 
 
import java.util.ArrayList; 
import java.util.Collection; 
import java.util.Date; 
import java.util.LinkedHashMap; 
import java.util.List; 
import java.util.Map; 
import java.util.Set; 
 
import system.Environment; 
import system.ExtractController; 
import system.OutputController; 
import system.utils.UtilClass; 
import beans.CompetenceQuestionsBean; 
import beans.IOBean; 
import beans.ProjectBean; 
import beans.TermsBean; 
import beans.CompetenceQuestionsBean.OneCategory; 
import beans.CompetenceQuestionsBean.OneCompetenceQuestion; 
import beans.IOBean.CategoryIO; 
import beans.IOBean.TermIO; 
import beans.IOBean.CategoryIO.CQsIO; 
import beans.TermsBean.MappedTerm; 
 
public class DataController { 
  
 private Environment environment; 
  



  

 private Project project = null; 
  
 private String openProjectAddress = null; 
 private Project initLoadedProject = null; 
 
 public DataController(Environment environment) { 
  this.environment = environment; 
 } 
  
 public void setProject(final Project projectInstance) { 
  this.project = projectInstance; 
 } 
  
 public void setInitLoadedProject(final Project projectInstance) { 
  this.initLoadedProject = new Project(projectInstance.getName()); 
  this.initLoadedProject.setAutor(projectInstance.getAutor()); 
  this.initLoadedProject.setPurpose(projectInstance.getPurpose()); 
  this.initLoadedProject.setScope(projectInstance.getScope()); 
 
 this.initLoadedProject.setFormalityLevel(projectInstance.getFormalityLe
vel()); 
 
 this.initLoadedProject.setUsersDescriptionsList(projectInstance.getUser
sDescriptionsList()); 
 
 this.initLoadedProject.setUsesScenariosList(projectInstance.getUsesScen
ariosList()); 
 
 this.initLoadedProject.setCreateDate(projectInstance.getCreateDate()); 
 
 this.initLoadedProject.setAllCategories(projectInstance.getAllCategorie
s()); 
  this.initLoadedProject.setAllCQs(projectInstance.getAllCQs()); 
 
 this.initLoadedProject.setAllTerms(projectInstance.getAllTerms()); 
 } 
 
 public boolean hasProjectInstance() { 
  return (this.project != null); 
 } 
  
 public String getProjectTitle() { 
  if (this.hasProjectInstance()) { 
   return this.project.getName(); 
  } 
  return null; 
 } 
  
 public boolean persistProject() { 
  final IOBean bean = new IOBean(this.openProjectAddress); 
   
  bean.setProjectName(this.project.getCurrentDefinedName()); 
  bean.setAutor(this.project.getAutor()); 
  bean.setCreateDate(this.project.getCreateDate()); 
  bean.setPurpose(this.project.getPurpose()); 
  bean.setScope(this.project.getScope()); 
  bean.setFormalityLevel(this.project.getFormalityLevel()); 
 
 bean.setUsersDescriptions(this.project.getUsersDescriptionsList()); 
  bean.setUsesScenarios(this.project.getUsesScenariosList()); 
  this.loadCategoriesForOutput(bean); 
  this.loadTermsForOutput(bean); 
   
  OutputController oc = this.environment.getOutputController(); 
  return oc.outputToXML(bean); 
 } 
 
 private void loadCategoriesForOutput(final IOBean bean) { 
  Collection&lt;Category&gt; categories = 
this.project.getAllCategories().values(); 
  for (Category category : categories) { 
   CategoryIO categIO = new CategoryIO(); 
   categIO.setName(category.getName()); 
   this.loadCQsForOutput(categIO, category.getListOfCQs()); 
   bean.addCategoryIO(categIO); 
  } 
 } 
 
 private void loadCQsForOutput(final CategoryIO categIO, final 
List&lt;Integer&gt; cqsList) { 



  

  if (cqsList != null &amp;amp;&amp;amp; cqsList.size() &gt; 0) { 
   for (Integer cqID : cqsList) { 
    CQ cq = this.project.getCQ(cqID); 
    if (cq != null) { 
     CQsIO ioCQ = new CQsIO(); 
     ioCQ.setId(cq.getIdCode()); 
    
 ioCQ.setQuestion(cq.getQuestion().getSentence()); 
    
 ioCQ.setAnswer(cq.getAnswer().getSentence()); 
      
     categIO.addCQsIO(ioCQ); 
    } 
   } 
  } 
 } 
 
 private void loadTermsForOutput(final IOBean bean) { 
  Collection&lt;Term&gt; terms = this.project.getAllTerms().values(); 
  for (Term term : terms) { 
   TermIO termIO = new TermIO(); 
   termIO.setTerm(term.getDescription()); 
   termIO.setOrderPosition(term.getOrderPosition()); 
   final Integer[] questonsArray = 
term.getOriginQuestions().toArray(new Integer[]{}); 
  
 termIO.setOriginQuestion(UtilClass.convertArrayIntegerToArrayInt(questo
nsArray)); 
   final Integer[] answersArray = 
term.getOriginAnswers().toArray(new Integer[]{}); 
  
 termIO.setOriginAnswers(UtilClass.convertArrayIntegerToArrayInt(answers
Array)); 
    
   bean.addTermIO(termIO); 
  } 
 } 
 
 public ProjectBean getProjectBean() { 
  if (this.hasProjectInstance()) { 
   ProjectBean.Params initParams = new 
ProjectBean.Params(); 
  
 initParams.setName(this.project.getCurrentDefinedName()); 
   initParams.setAutor(this.project.getAutor()); 
   initParams.setPurpose(this.project.getPurpose()); 
   initParams.setScope(this.project.getScope()); 
  
 initParams.setFormalityLevel(this.project.getFormalityLevel()); 
  
 initParams.setUsersDescriptionsList(this.project.getUsersDescriptionsLi
st()); 
  
 initParams.setUsesScenariosList(this.project.getUsesScenariosList()); 
   return new ProjectBean(initParams, 
this.project.getCreateDate()); 
  } 
  return null; 
 } 
  
 public CompetenceQuestionsBean getCompetenceQuestionsBean() { 
  if (this.hasProjectInstance()) { 
   CompetenceQuestionsBean bean = new 
CompetenceQuestionsBean(); 
   bean.setCategoriesMap(this.project.getAllCategories()); 
   return bean; 
  } 
  return null; 
 } 
  
 public TermsBean getTermsBean() { 
  if (this.hasProjectInstance()) { 
   final TermsBean bean = new TermsBean(); 
   bean.loadInitData(this.project.getAllTerms()); 
   this.loadAvailableCategoriesToExtract(bean); 
   return bean; 
  } 
  return null; 
 } 
  



  

 private void loadAvailableCategoriesToExtract(final TermsBean bean) { 
  final Collection&lt;Category&gt; allCategories = 
this.project.getAllCategories().values(); 
  final int length = (allCategories != null ? allCategories.size() 
: 0); 
  final Map&lt;String, Integer&gt; availableCategories = new 
LinkedHashMap&lt;String, Integer&gt;(length); 
  if (length &gt; 0) { 
   availableCategories.put(UtilClass.ALL_CATEGORIES_LABEL, 
UtilClass.ALL_CATEGORIES_ID); 
   for (Category category : allCategories) { 
    if (category.getListOfCQs().size() &gt; 0) { 
    
 availableCategories.put(category.getName(), category.getIdCode()); 
    } 
   } 
  } 
  bean.setAvailableCategoriesToExtract(availableCategories); 
 } 
 
 public void loadAllCQs(CompetenceQuestionsBean bean) { 
  Map&lt;Integer, CQ&gt; cqMap = new LinkedHashMap&lt;Integer, CQ&gt;(0); 
  cqMap.putAll(this.project.getAllCQs()); 
  bean.setCompetenceQuestionsMap(cqMap); 
 } 
  
 public void loadCQsByCategory( 
   final CompetenceQuestionsBean bean, Integer categoryID) 
{ 
  final Category category = this.project.getCategory(categoryID); 
  final List&lt;Integer&gt; listOfCQs = category.getListOfCQs(); 
   
  Map&lt;Integer, CQ&gt; cqMap = this.getCQMap(listOfCQs); 
   
  bean.setCompetenceQuestionsMap(cqMap); 
 } 
  
 private Map&lt;Integer, CQ&gt; getCQMap(final List&lt;Integer&gt; listOfCQs) { 
  Map&lt;Integer, CQ&gt; cqMap = null; 
  if (listOfCQs != null) { 
   cqMap = new LinkedHashMap&lt;Integer, 
CQ&gt;(listOfCQs.size()); 
   for (Integer id : listOfCQs) { 
    cqMap.put(id, this.project.getCQ(id)); 
   } 
  } 
  return cqMap; 
 } 
 
 public void loadOneCategory(final CompetenceQuestionsBean bean, 
   final Integer categoryID) { 
  final Category category = this.project.getCategory(categoryID); 
  final OneCategory oneCategory; 
  if (category != null) { 
   oneCategory = new OneCategory( 
     category.getIdCode(), category.getName(), 
category.getDescription()); 
  } else { 
   oneCategory = null; 
  } 
  bean.setOneCategory(oneCategory); 
 } 
  
 public void loadOneCQ(final CompetenceQuestionsBean bean, 
   final Integer cqID) { 
  final CQ cq = this.project.getCQ(cqID); 
  final OneCompetenceQuestion oneCQ; 
  if (cq != null) { 
   oneCQ = new OneCompetenceQuestion(cq.getIdCode(), 
     cq.getQuestion().getSentence(), 
cq.getAnswer().getSentence(), 
     cq.getQuestion().getTerms().size(), 
cq.getAnswer().getTerms().size()); 
  } else { 
   oneCQ = null; 
  } 
  bean.setOneCompetenceQuestion(oneCQ); 
 } 
  
 public void startNewFile(String fileName, String fileAddress) { 



  

  this.openProjectAddress = fileAddress; 
  Project newProject = this.getNewProjectInstance( 
    UtilClass.removeExtensionFromFileName(fileName), 
new Date()); 
  this.createDefaultCategory(newProject); 
   
  // Operações iniciais de carga do projeto: 
  this.setProject(newProject); 
  this.setInitLoadedProject(newProject); 
   
  // Solicitando persistência inicial do arquivo 
  this.persistProject(); 
 } 
  
 public Project getNewProjectInstance(final String projectName, final 
Date projectCreateDate) { 
  final Project projectInstance = new Project(projectName); 
  projectInstance.setCreateDate(projectCreateDate); 
  return projectInstance; 
 } 
  
 private void createDefaultCategory(final Project projectInstance) { 
  Category defaultCategory = 
projectInstance.getCategory(UtilClass.DEFAULT_CATEGORY_ID); 
  if (defaultCategory == null) { 
   defaultCategory = new 
Category(UtilClass.DEFAULT_CATEGORY_ID); 
  
 defaultCategory.setName(Category.DEFAULT_CATEGORY_INIT_NAME); 
  
 defaultCategory.setDescription(Category.DEFAULT_CATEGORY_INIT_DESCRIPTI
ON); 
   projectInstance.inputCategory(defaultCategory); 
  } 
 } 
  
 public void openFile(final String fileName, final String fileAddress) 
throws Exception { 
  this.openProjectAddress = fileAddress; 
  final IOBean bean = new IOBean(this.openProjectAddress); 
  OutputController oc = this.environment.getOutputController(); 
  oc.inputFromXML(bean); 
   
  final Project newProject = 
   this.getNewProjectInstance(bean.getProjectName(), 
bean.getCreateDate()); 
   
  newProject.setAutor(bean.getAutor()); 
  newProject.setPurpose(bean.getPurpose()); 
  newProject.setScope(bean.getScope()); 
  newProject.setFormalityLevel(bean.getFormalityLevel()); 
 
 newProject.setUsersDescriptionsList(bean.getUsersDescriptions()); 
  newProject.setUsesScenariosList(bean.getUsesScenarios()); 
  this.loadCategoriesToProject(newProject, bean); 
  this.loadTermsToProject(newProject, bean); 
   
  // Operações iniciais de carga do projeto: 
  this.setProject(newProject); 
  this.setInitLoadedProject(newProject); 
 } 
 
 private void loadCategoriesToProject(final Project newProject, final 
IOBean bean) { 
  final List&lt;CategoryIO&gt; categIOList = bean.getCategories(); 
  if (categIOList != null) { 
   for (CategoryIO categIO : categIOList) { 
    Category category = newProject.getNewCategory(); 
    category.setName(categIO.getName()); 
    this.loadCQsToProject(newProject, category, 
categIO); 
     
    newProject.inputCategory(category); 
   } 
  } 
 } 
  
 private void loadCQsToProject(final Project newProject, final Category 
category, 
   final CategoryIO categIO) { 



  

  final List&lt;CQsIO&gt; ioCQList = categIO.getCqs(); 
  if (ioCQList != null) { 
   for (CQsIO ioCQ : ioCQList) { 
    final CQ cq = new CQ(ioCQ.getId()); 
    cq.setParentCategory(category.getIdCode()); 
    cq.getQuestion().setSentence(ioCQ.getQuestion()); 
    cq.getAnswer().setSentence(ioCQ.getAnswer()); 
     
    category.addCQ(cq.getIdCode()); 
    newProject.inputCQ(cq); 
   } 
  } 
 } 
 
 private void loadTermsToProject(final Project newProject, final IOBean 
bean) { 
  final List&lt;TermIO&gt; termIOList = bean.getTerms(); 
  if (termIOList != null) { 
   for (TermIO termIO : termIOList) { 
    final Term term = newProject.getNewTerm(); 
    term.setDescription(termIO.getTerm()); 
    term.setOrderPosition(termIO.getOrderPosition()); 
    term.setOriginQuestions( 
     
 UtilClass.convertArrayIntToSetInteger(termIO.getOriginQuestion())); 
    term.setOriginAnswers( 
     
 UtilClass.convertArrayIntToSetInteger(termIO.getOriginAnswers())); 
     
    newProject.inputTerm(term); 
   } 
  } 
 } 
 
 public void saveProjectBean(final ProjectBean bean) { 
  if (bean.hasChanges()) { 
   if (bean.hasNewName()) { 
    this.project.updateName(bean.getName()); 
   } 
   this.project.setAutor(bean.getAutor()); 
   this.project.setPurpose(bean.getPurpose()); 
   this.project.setScope(bean.getScope()); 
  
 this.project.setFormalityLevel(bean.getFormalityLevel()); 
  
 this.project.setUsersDescriptionsList(bean.getUsersDescriptionsList()); 
  
 this.project.setUsesScenariosList(bean.getUsesScenariosList()); 
  } 
 } 
  
 public void addCategory(final CompetenceQuestionsBean bean, 
   final String name, final String description) { 
  final Category newCategory = this.project.getNewCategory(); 
  newCategory.setName(name); 
  newCategory.setDescription(description); 
  this.project.inputCategory(newCategory); 
  bean.setCategoriesMap(this.project.getAllCategories()); 
 } 
  
 public void editCategory(final int idCode, 
   final String name, final String description) { 
  final Category category = this.project.getCategory(idCode); 
  category.setName(name); 
  category.setDescription(description); 
 } 
  
 public boolean hasCQs(final List&lt;Integer&gt; categoryIDsList) { 
  for (Integer categoryID : categoryIDsList) { 
   if (this.project.hasCQs(categoryID)) { 
    return true; 
   } 
  } 
  return false; 
 } 
  
 public void removeCategories(final CompetenceQuestionsBean bean, final 
List&lt;Integer&gt; categoryIDsList) { 
  final Category defaultCategory = 
this.project.getCategory(UtilClass.DEFAULT_CATEGORY_ID); 



  

  for (Integer idCode : categoryIDsList) { 
   final Category category = 
this.project.removeCategory(idCode); 
   this.addListOfCQsToCategory(defaultCategory, 
category.getListOfCQs()); 
  } 
  bean.setCategoriesMap(this.project.getAllCategories()); 
 } 
  
 private void addListOfCQsToCategory(final Category category, 
   final List&lt;Integer&gt; cqIDsList) { 
  if (category != null &amp;amp;&amp;amp; 
    cqIDsList != null &amp;amp;&amp;amp; !cqIDsList.isEmpty()) { 
   final Integer parentCategory = category.getIdCode(); 
   for (Integer CQidCode : cqIDsList) { 
    category.addCQ(CQidCode); 
   
 this.project.getCQ(CQidCode).setParentCategory(parentCategory); 
   } 
  } 
 } 
  
 public void addCompetenceQuestion(final CompetenceQuestionsBean bean, 
   final Integer categoryID, final String question, final 
String answer) { 
  final CQ newCQ = this.project.getNewCQ(); 
  newCQ.setParentCategory(categoryID); 
  newCQ.getQuestion().setSentence(question); 
  newCQ.getAnswer().setSentence(answer); 
  this.project.inputCQ(categoryID, newCQ); 
  this.loadCQsByCategory(bean, categoryID); 
 } 
  
 public void editCompetenceQuestion(final Integer cqID, 
   final String question, final String answer) { 
  final CQ cq = this.project.getCQ(cqID); 
  cq.getQuestion().setSentence(question); 
  cq.getAnswer().setSentence(answer); 
 } 
  
 public void removeCompetenceQuestions(final CompetenceQuestionsBean 
bean, 
   final Integer categoryID, final List&lt;Integer&gt; cqIDsList) 
{ 
  final boolean isAllCategories = (UtilClass.ALL_CATEGORIES_ID == 
categoryID); 
  if (isAllCategories) { 
   for (Integer cqID : cqIDsList) { 
    final CQ cq = this.project.removeCQ(cqID); 
    final Category parent = 
this.project.getCategory(cq.getParentCategory()); 
    if (parent != null) { 
     parent.removeCQ(cqID); 
    } 
   } 
   this.loadAllCQs(bean); 
  } else { 
   final Category category = 
this.project.getCategory(categoryID); 
   for (Integer cqID : cqIDsList) { 
    this.project.removeCQ(cqID); 
    category.removeCQ(cqID); 
   } 
   this.loadCQsByCategory(bean, categoryID); 
  } 
 } 
  
 public void moveCompetenceQuestions(final CompetenceQuestionsBean bean, 
   final Integer sourceCategoryID, final Integer 
targetCategoryID, 
   final List&lt;Integer&gt; cqIDsList) { 
  final Category source = 
this.project.getCategory(sourceCategoryID); 
  final Category target = 
this.project.getCategory(targetCategoryID); 
  for (Integer cqID : cqIDsList) { 
   source.removeCQ(cqID); 
   target.addCQ(cqID); 
  
 this.project.getCQ(cqID).setParentCategory(targetCategoryID); 



  

  } 
  this.loadCQsByCategory(bean, sourceCategoryID); 
 } 
  
 public void extractTerms(final TermsBean bean, final Integer 
categoryID) throws Exception { 
  final Collection&lt;CQ&gt; cqCollection = new ArrayList&lt;CQ&gt;(0); 
  final ExtractController ec = 
this.environment.getExtractController(); 
  if (categoryID == UtilClass.ALL_CATEGORIES_ID) { 
   cqCollection.addAll(this.project.getAllCQs().values()); 
  } else { 
   final Category category = 
this.project.getCategory(categoryID); 
   if (category != null &amp;amp;&amp;amp; category.getListOfCQs().size() &gt; 
0) { 
    cqCollection.addAll( 
     
 this.getCQMap(category.getListOfCQs()).values()); 
   } 
  } 
  ec.extractTerms(bean, cqCollection); 
 } 
  
 public void removePersistedTerms(final TermsBean bean, 
   final List&lt;Integer&gt; persistedTermIDs) { 
  for (Integer termID : persistedTermIDs) { 
   final Term term = this.project.removeTerm(termID); 
   this.removeTermIDFromCQs(termID, 
term.getOriginQuestions(), term.getOriginAnswers()); 
  } 
  bean.reloadInitTermsMap(this.project.getAllTerms()); 
 } 
  
 private void removeTermIDFromCQs(final Integer termID, 
   final Set&lt;Integer&gt; originQuestions, final Set&lt;Integer&gt; 
originAnswers) { 
  for (Integer question : originQuestions) { 
   final CQ cq = this.project.getCQ(question); 
   cq.getQuestion().getTerms().remove(termID); 
  } 
  for (Integer answer : originAnswers) { 
   final CQ cq = this.project.getCQ(answer); 
   cq.getAnswer().getTerms().remove(termID); 
  } 
 } 
  
 public void persistTerms(final TermsBean bean) { 
  final Collection&lt;MappedTerm&gt; chosenTermCollection = 
   bean.getChosenTermsMap().values(); 
  for (MappedTerm chosenTerm : chosenTermCollection) { 
   final Term term; 
   final Integer idCode = chosenTerm.getIdCode(); 
   if (idCode == null) { 
    term = this.project.getNewTerm(); 
    this.project.inputTerm(term); 
   } else { 
    term = this.project.getTerm(idCode); 
   } 
   term.setDescription(chosenTerm.getTerm()); 
   term.setOrderPosition(chosenTerm.getOrderPosition()); 
   this.compareCQidCodesOnTerm(term, 
     chosenTerm.getOriginQuestions(), 
chosenTerm.getOriginAnswers()); 
  } 
  bean.loadInitData(this.project.getAllTerms()); 
 } 
 
 private void compareCQidCodesOnTerm(final Term term, 
   final Set&lt;Integer&gt; originQuestions, final Set&lt;Integer&gt; 
originAnswers) { 
  for (Integer question : originQuestions) { 
   final Set&lt;Integer&gt; termOriginQuestions = 
term.getOriginQuestions(); 
   if (!termOriginQuestions.contains(question)) { 
    termOriginQuestions.add(question); 
    final CQ cq = this.project.getCQ(question); 
   
 cq.getQuestion().getTerms().add(term.getIdCode()); 
   } 



  

  } 
  for (Integer answer : originAnswers) { 
   final Set&lt;Integer&gt; termOriginAnswers = 
term.getOriginAnswers(); 
   if (!termOriginAnswers.contains(answer)) { 
    termOriginAnswers.add(answer); 
    final CQ cq = this.project.getCQ(answer); 
    cq.getAnswer().getTerms().add(term.getIdCode()); 
   } 
  } 
 } 
} 
 

? Classe CQ.java: 
package data; 
 
import java.util.ArrayList; 
import java.util.List; 
 
public class CQ { 
  
 private final Integer idCode; 
 private Integer parentCategory; 
 private final Question question; 
 private final Answer answer; 
  
 public CQ(final Integer idCode) { 
  this.idCode = idCode; 
  this.question = new Question(); 
  this.answer = new Answer(); 
 } 
  
 public class Question { 
   
  private String sentence; 
  private List&lt;Integer&gt; terms; 
   
  public Question() { 
   this.terms = new ArrayList&lt;Integer&gt;(0); 
  } 
 
  public String getSentence() { 
   return sentence; 
  } 
 
  public void setSentence(String sentence) { 
   this.sentence = sentence; 
  } 
 
  public List&lt;Integer&gt; getTerms() { 
   return terms; 
  } 
 
  public void setTerms(List&lt;Integer&gt; terms) { 
   this.terms = terms; 
  } 
   
 } 
  
 public class Answer { 
   
  private String sentence; 
  private List&lt;Integer&gt; terms; 
   
  public Answer() { 
   this.terms = new ArrayList&lt;Integer&gt;(0); 
  } 
 
  public String getSentence() { 
   return sentence; 
  } 
 
  public void setSentence(String sentence) { 
   this.sentence = sentence; 
  } 
 
  public List&lt;Integer&gt; getTerms() { 
   return terms; 



  

  } 
 
  public void setTerms(List&lt;Integer&gt; terms) { 
   this.terms = terms; 
  } 
   
 } 
 
 public Integer getParentCategory() { 
  return parentCategory; 
 } 
 
 public void setParentCategory(Integer parentCategory) { 
  this.parentCategory = parentCategory; 
 } 
 
 public Integer getIdCode() { 
  return idCode; 
 } 
 
 public Question getQuestion() { 
  return question; 
 } 
 
 public Answer getAnswer() { 
  return answer; 
 } 
  
} 
 

? Classe Category.java: 
package data; 
 
import java.util.ArrayList; 
import java.util.List; 
 
public class Category { 
  
 protected static final String DEFAULT_CATEGORY_INIT_NAME = "Default"; 
 protected static final String DEFAULT_CATEGORY_INIT_DESCRIPTION = 
"Default category of the Project"; 
  
 private final Integer idCode; 
 private String name; 
 private String description; 
 private List&lt;Integer&gt; listOfCQs; 
  
 public Category(final Integer idCode) { 
  this.idCode = idCode; 
  this.listOfCQs = new ArrayList&lt;Integer&gt;(0); 
 } 
 
 public String getName() { 
  return name; 
 } 
 
 public void setName(String name) { 
  this.name = name; 
 } 
 
 public String getDescription() { 
  return description; 
 } 
 
 public void setDescription(String description) { 
  this.description = description; 
 } 
 
 public List&lt;Integer&gt; getListOfCQs() { 
  return listOfCQs; 
 } 
 
 public void setListOfCQs(List&lt;Integer&gt; listOfCQs) { 
  this.listOfCQs = listOfCQs; 
 } 
 
 public Integer getIdCode() { 
  return idCode; 



  

 } 
  
 public void addCQ(final Integer CQidCode) { 
  if ( ! this.listOfCQs.contains(CQidCode)) { 
   this.listOfCQs.add(CQidCode); 
  } 
 } 
  
 public boolean removeCQ(final Integer CQidCode) { 
  if (this.listOfCQs.contains(CQidCode)) { 
   return this.listOfCQs.remove(CQidCode); 
  } 
  return false; 
 } 
} 
 

? Classe Project.java: 
package data; 
 
import java.util.Collections; 
import java.util.Date; 
import java.util.LinkedHashMap; 
import java.util.List; 
import java.util.Map; 
import java.util.Set; 
 
public class Project { 
  
 private final String name; 
 private String newName = null; 
 private String autor; 
 private Date createDate; 
 private String purpose; 
 private String scope; 
 private String formalityLevel; 
 private List&lt;String&gt; usersDescriptionsList; 
 private List&lt;String&gt; usesScenariosList; 
  
 private Map&lt;Integer, Category&gt; allCategories; 
 private Map&lt;Integer, CQ&gt; allCQs; 
 private Map&lt;Integer, Term&gt; allTerms; 
  
 public Project(final String name) { 
  this.name = name; 
  this.allCategories = new LinkedHashMap&lt;Integer, Category&gt;(); 
  this.allCQs = new LinkedHashMap&lt;Integer, CQ&gt;(); 
  this.allTerms = new LinkedHashMap&lt;Integer, Term&gt;(); 
 } 
  
 public void updateName(final String newName) { 
  this.newName = newName; 
 } 
  
 /*------------------------------------------- 
  * Métodos para obter novos objetos de dados. 
  -------------------------------------------*/ 
  
 /** 
  * Método que fornece uma nova instância do tipo 'categoria'. 
  * @return Category: objeto do tipo Category 
  */ 
 public Category getNewCategory() { 
  final Integer newCode = 
this.getNewCode(this.allCategories.keySet()); 
  return new Category(newCode); 
 } 
  
 /** 
  * Método que fornece uma nova instância do tipo 'questão de 
competência'. 
  * @return CQ: objeto do tipo CQ 
  */ 
 public CQ getNewCQ() { 
  final Integer newCode = this.getNewCode(this.allCQs.keySet()); 
  return new CQ(newCode); 
 } 
  
 /** 



  

  * Método que fornece uma nova instância do tipo 'termo'. 
  * @return Term: objeto do tipo Term 
  */ 
 public Term getNewTerm() { 
  final Integer newCode = this.getNewCode(this.allTerms.keySet()); 
  return new Term(newCode); 
 } 
  
 /*------------------------------------------- 
  * Métodos para inserção/atualização de objetos de dados. 
  -------------------------------------------*/ 
  
 /** 
  * Método que insere um determinado objeto do tipo 'categoria'. 
  * @param category Category: objeto a ser inserido. 
  */ 
 public void inputCategory(Category category) { 
  this.allCategories.put(category.getIdCode(), category); 
 } 
  
 /** 
  * Método que insere um determinado objeto do tipo 'questão de 
competência'. 
  * @param competenceQuestion CQ: objeto a ser inserido. 
  */ 
 public void inputCQ(final CQ competenceQuestion) { 
  this.allCQs.put(competenceQuestion.getIdCode(), 
competenceQuestion); 
 } 
  
 /** 
  * Método que insere um determinado objeto do tipo 'questão de 
competência'. 
  * @param competenceQuestion CQ: categoria na qual o objeto será 
inserido. 
  * @param competenceQuestion CQ: objeto a ser inserido. 
  */ 
 public void inputCQ(final Integer categoryID, final CQ 
competenceQuestion) { 
  final Integer CQidCode = competenceQuestion.getIdCode(); 
  this.allCQs.put(CQidCode, competenceQuestion); 
  this.getCategory(categoryID).addCQ(CQidCode); 
 } 
  
 /** 
  * Método que insere um determinado objeto do tipo 'termo'. 
  * @param term Term: objeto a ser inserido. 
  */ 
 public void inputTerm(Term term) { 
  this.allTerms.put(term.getIdCode(), term); 
 } 
  
 /*------------------------------------------- 
  * Métodos que fornecem os objetos de dados. 
  -------------------------------------------*/ 
  
 /** 
  * Método que fornece um determinado objeto do tipo 'categoria'. 
  * @param idCode Integer: código identificador do objeto 
  * @return Category: instância do objeto Category requerida pelo idCode 
  */ 
 public Category getCategory(Integer idCode) { 
  if (idCode != null &amp;amp;&amp;amp; idCode &gt; 0) { 
   return this.allCategories.get(idCode); 
  } 
  return null; 
 } 
  
 /** 
  * Método que fornece um determinado objeto do tipo 'questão de 
competência'. 
  * @param idCode Integer: código identificador do objeto 
  * @return CQ: instância do objeto CQ requerida pelo idCode 
  */ 
 public CQ getCQ(Integer idCode) { 
  if (idCode != null &amp;amp;&amp;amp; idCode &gt; 0) { 
   return this.allCQs.get(idCode); 
  } 
  return null; 
 } 



  

  
 /** 
  * Método que fornece um determinado objeto do tipo 'termo'. 
  * @param idCode Integer: código identificador do objeto 
  * @return Term: instância do objeto Term requerida pelo idCode 
  */ 
 public Term getTerm(Integer idCode) { 
  if (idCode != null &amp;amp;&amp;amp; idCode &gt; 0) { 
   return this.allTerms.get(idCode); 
  } 
  return null; 
 } 
  
 /*------------------------------------------- 
  * Método auxiliares. 
  -------------------------------------------*/ 
  
 /** 
  * Método que fornece um novo código para criação de um novo objeto de 
dado (Category, CQ ou Term). 
  * @param keySet Set&lt;Integer&gt;: coleção com os códigos existentes para 
aquele objeto de dado. 
  * @return Integer: retorna um código acima do último encontrado 
('último código' + 1). 
  */ 
 private Integer getNewCode(Set&lt;Integer&gt; keySet) { 
  if (keySet != null &amp;amp;&amp;amp; keySet.size() &gt; 0) { 
   final Integer lastCode = Collections.max(keySet); 
   if (lastCode != null &amp;amp;&amp;amp; lastCode != 0) { 
    return (lastCode + 1); 
   } 
  } 
  return 1; 
 } 
  
 /*------------------------------------------- 
  * Métodos GET e SET. 
  -------------------------------------------*/ 
 
 public String getAutor() { 
  return autor; 
 } 
 
 public void setAutor(String autor) { 
  this.autor = autor; 
 } 
 
 public Date getCreateDate() { 
  return createDate; 
 } 
 
 public void setCreateDate(Date createDate) { 
  this.createDate = createDate; 
 } 
 
 public String getPurpose() { 
  return purpose; 
 } 
 
 public void setPurpose(String purpose) { 
  this.purpose = purpose; 
 } 
 
 public String getScope() { 
  return scope; 
 } 
 
 public void setScope(String scope) { 
  this.scope = scope; 
 } 
 
 public String getFormalityLevel() { 
  return formalityLevel; 
 } 
 
 public void setFormalityLevel(String formalityLevel) { 
  this.formalityLevel = formalityLevel; 
 } 
  
 public List&lt;String&gt; getUsersDescriptionsList() { 



  

  return usersDescriptionsList; 
 } 
 
 public void setUsersDescriptionsList(List&lt;String&gt; 
usersDescriptionsList) { 
  this.usersDescriptionsList = usersDescriptionsList; 
 } 
 
 public List&lt;String&gt; getUsesScenariosList() { 
  return usesScenariosList; 
 } 
 
 public void setUsesScenariosList(List&lt;String&gt; usesScenariosList) { 
  this.usesScenariosList = usesScenariosList; 
 } 
  
 public Map&lt;Integer, Category&gt; getAllCategories() { 
  return allCategories; 
 } 
 
 public void setAllCategories(Map&lt;Integer, Category&gt; allCategories) { 
  this.allCategories = allCategories; 
 } 
 
 public Map&lt;Integer, CQ&gt; getAllCQs() { 
  return allCQs; 
 } 
 
 public void setAllCQs(Map&lt;Integer, CQ&gt; allCQs) { 
  this.allCQs = allCQs; 
 } 
 
 public Map&lt;Integer, Term&gt; getAllTerms() { 
  return allTerms; 
 } 
 
 public void setAllTerms(Map&lt;Integer, Term&gt; allTerms) { 
  this.allTerms = allTerms; 
 } 
 
 public String getName() { 
  return name; 
 } 
 
 public String getNewName() { 
  return newName; 
 } 
  
 public String getCurrentDefinedName() { 
  if (this.newName != null &amp;amp;&amp;amp; !this.newName.isEmpty()) { 
   return this.newName; 
  } 
  return this.name; 
 } 
 
 public boolean hasCQs(final Integer categoryID) { 
  final Category category = this.getCategory(categoryID); 
  if (category != null &amp;amp;&amp;amp; 
    category.getListOfCQs().size() &gt; 0) { 
   return true; 
  } 
  return false; 
 } 
 
 public Category removeCategory(final Integer categoryID) { 
  return this.allCategories.remove(categoryID); 
 } 
  
 public CQ removeCQ(final Integer CQidCode) { 
  return this.allCQs.remove(CQidCode); 
 } 
 
 public Term removeTerm(final Integer termID) { 
  return this.allTerms.remove(termID); 
 } 
} 
 

? Classe Term.java: 



  

package data; 
 
import java.util.LinkedHashSet; 
import java.util.Set; 
 
public class Term { 
  
 private final Integer idCode; 
 private String description; 
 private Set&lt;Integer&gt; originQuestions; 
 private Set&lt;Integer&gt; originAnswers; 
 private Integer orderPosition = null; 
 
 public Term(final Integer idCode) { 
  this.idCode = idCode; 
  this.originQuestions = new LinkedHashSet&lt;Integer&gt;(0); 
  this.originAnswers = new LinkedHashSet&lt;Integer&gt;(0); 
 } 
 
 public String getDescription() { 
  return description; 
 } 
 
 public void setDescription(String description) { 
  this.description = description; 
 } 
 
 public Set&lt;Integer&gt; getOriginQuestions() { 
  return originQuestions; 
 } 
 
 public void setOriginQuestions(Set&lt;Integer&gt; originQuestions) { 
  this.originQuestions = originQuestions; 
 } 
 
 public Set&lt;Integer&gt; getOriginAnswers() { 
  return originAnswers; 
 } 
 
 public void setOriginAnswers(Set&lt;Integer&gt; originAnswers) { 
  this.originAnswers = originAnswers; 
 } 
 
 public Integer getOrderPosition() { 
  return orderPosition; 
 } 
 
 public void setOrderPosition(Integer orderPosition) { 
  this.orderPosition = orderPosition; 
 } 
 
 public Integer getIdCode() { 
  return idCode; 
 } 
} 
 

? Pacote “System”: 

? Classe Environment.java: 
package system; 
 
import view.ViewController; 
import view.ViewParams; 
import view.main.MainForm; 
import view.project.ProjectForm; 
import view.questions.CompetenceQuestionsForm; 
import view.terms.TermsForm; 
import data.DataController; 
 
public class Environment { 
 
 private DataController dataController; 
 private ViewController viewController; 
  
 public Environment(MainForm mainForm, ProjectForm projectForm, 
   CompetenceQuestionsForm cqForm, TermsForm termsForm) { 



  

  this.dataController = new DataController(this); 
   
  ViewParams viewParams = new ViewParams(mainForm, projectForm, 
cqForm, termsForm); 
  this.viewController = new ViewController(this, viewParams); 
 } 
  
 public DataController getDataController() { 
  return this.dataController; 
 } 
  
 public ViewController getViewController() { 
  return this.viewController; 
 } 
  
 public ExtractController getExtractController() { 
  return new ExtractController(); 
 } 
  
 public OutputController getOutputController() { 
  return new OutputController(); 
 } 
  
 public static void start(MainForm mainForm, ProjectForm projectForm, 
   CompetenceQuestionsForm cqForm, TermsForm termsForm) { 
  new Environment(mainForm, projectForm, cqForm, termsForm); 
 } 
} 
 

? Classe ExtractController.java: 
package system; 
 
import java.util.ArrayList; 
import java.util.Collection; 
import java.util.LinkedHashSet; 
import java.util.List; 
import java.util.Set; 
import java.util.StringTokenizer; 
 
import system.utils.UtilClass; 
import beans.TermsBean; 
import data.CQ; 
 
public class ExtractController { 
  
 public void extractTerms(final TermsBean bean, final Collection&lt;CQ&gt; 
cqCollection) throws Exception { 
  bean.clearExtractedTermsMap(); 
  final int length = (cqCollection != null ? cqCollection.size() : 
0); 
  if (length &gt; 0) { 
   for (CQ cq : cqCollection) { 
    //* Extração de 'question': 
    bean.addAllExtractedTermsFromQuestion( 
     
 this.extractFromSentence(cq.getQuestion().getSentence()), 
      cq.getIdCode()); 
    //* Extração de 'answer': 
    bean.addAllExtractedTermsFromAnswer( 
     
 this.extractFromSentence(cq.getAnswer().getSentence()), 
      cq.getIdCode()); 
   } 
  } 
 } 
  
 private Set&lt;String&gt; extractFromSentence(final String sentence) throws 
Exception { 
  final Set&lt;String&gt; termsList = new LinkedHashSet&lt;String&gt;(0); 
  if (sentence != null &amp;amp;&amp;amp; !sentence.isEmpty()) { 
   String cleanSentence = UtilClass.removePuncts(sentence); 
    
   StringTokenizer tokenizer = new 
StringTokenizer(cleanSentence); 
   while (tokenizer.hasMoreTokens()) { 
    String token = tokenizer.nextToken(); 
    if (!UtilClass.isStopWord(token)) { 
     termsList.add( 



  

      
 UtilClass.formatTermsMapKey(token)); 
    } 
   } 
  } 
  return termsList; 
 } 
} 
 

? Classe OutputController.java: 
package system; 
 
import java.io.File; 
import java.io.FileInputStream; 
import java.io.FileWriter; 
import java.io.IOException; 
import java.util.ArrayList; 
import java.util.List; 
 
import javax.xml.parsers.DocumentBuilderFactory; 
import javax.xml.stream.XMLOutputFactory; 
import javax.xml.stream.XMLStreamException; 
import javax.xml.stream.XMLStreamWriter; 
 
import org.w3c.dom.Document; 
import org.w3c.dom.Element; 
import org.w3c.dom.NodeList; 
 
import system.utils.Tags; 
import beans.IOBean; 
import beans.IOBean.CategoryIO; 
import beans.IOBean.TermIO; 
import beans.IOBean.CategoryIO.CQsIO; 
 
public class OutputController { 
  
 public OutputController() {} 
  
 public boolean outputToXML(final IOBean bean) { 
  boolean outputOK = false; 
  if (bean != null &amp;amp;&amp;amp; 
    bean.getFileAddress() != null &amp;amp;&amp;amp; 
    !bean.getFileAddress().isEmpty()) { 
    
   XMLOutputFactory factory = 
XMLOutputFactory.newInstance(); 
   XMLStreamWriter wr = null; 
    
   try { 
    wr = factory.createXMLStreamWriter(new 
FileWriter(bean.getFileAddress())); 
     
    wr.writeStartDocument(); 
    wr.writeStartElement(Tags.PROJECT); 
    // 
    wr.writeStartElement(Tags.NAME); 
    wr.writeCharacters(bean.getProjectName()); 
    wr.writeEndElement(); 
     
    wr.writeStartElement(Tags.AUTOR); 
    wr.writeCharacters(bean.getAutor()); 
    wr.writeEndElement(); 
     
    wr.writeStartElement(Tags.CREATE_DATE); 
    wr.writeCharacters(bean.getStringOfCreateDate()); 
    wr.writeEndElement(); 
     
    wr.writeStartElement(Tags.PURPOSE); 
    wr.writeCharacters(bean.getPurpose()); 
    wr.writeEndElement(); 
     
    wr.writeStartElement(Tags.SCOPE); 
    wr.writeCharacters(bean.getScope()); 
    wr.writeEndElement(); 
     
    wr.writeStartElement(Tags.FORMALITY_LEVEL); 
    wr.writeCharacters(bean.getFormalityLevel()); 
    wr.writeEndElement(); 



  

     
    wr.writeStartElement(Tags.USERS); 
    final List&lt;String&gt; usersDescriptions = 
bean.getUsersDescriptions(); 
    if (usersDescriptions != null &amp;amp;&amp;amp; 
usersDescriptions.size() &gt; 0) { 
     for (String user : usersDescriptions) { 
     
 wr.writeStartElement(Tags.USER_DESCRIPTION); 
      wr.writeCharacters(user); 
      wr.writeEndElement(); 
     } 
    } 
    wr.writeEndElement(); 
     
    wr.writeStartElement(Tags.USES_SCENARIOS); 
    final List&lt;String&gt; usesScenarios = 
bean.getUsesScenarios(); 
    if (usesScenarios != null &amp;amp;&amp;amp; usesScenarios.size() 
&gt; 0) { 
     for (String scenario : usesScenarios) { 
     
 wr.writeStartElement(Tags.SCENARIO); 
      wr.writeCharacters(scenario); 
      wr.writeEndElement(); 
     } 
    } 
    wr.writeEndElement(); 
     
    final List&lt;CategoryIO&gt; categories = 
bean.getCategories(); 
    for (CategoryIO categoryIO : categories) { 
     wr.writeStartElement(Tags.CATEGORY); 
     wr.writeAttribute(Tags.Attrib.NAME, 
categoryIO.getName()); 
     final List&lt;CQsIO&gt; cqs = 
categoryIO.getCqs(); 
     for (CQsIO cqIO : cqs) { 
      wr.writeStartElement(Tags.CQ); 
      wr.writeAttribute(Tags.Attrib.ID, 
String.valueOf(cqIO.getId())); 
     
 wr.writeStartElement(Tags.QUESTION); 
     
 wr.writeCharacters(cqIO.getQuestion()); 
      wr.writeEndElement(); 
      final String answer = 
cqIO.getAnswer(); 
      if (answer != null &amp;amp;&amp;amp; 
!answer.isEmpty()) { 
      
 wr.writeStartElement(Tags.ANSWER); 
       wr.writeCharacters(answer); 
       wr.writeEndElement(); 
      } 
      wr.writeEndElement(); 
     } 
     wr.writeEndElement(); 
    } 
     
    wr.writeStartElement(Tags.SELECTED_TERMS); 
    final List&lt;TermIO&gt; terms = bean.getTerms(); 
    for (TermIO termIO : terms) { 
     wr.writeStartElement(Tags.TERM); 
    
 wr.writeAttribute(Tags.Attrib.ORIGIN_QUESTIONS, 
termIO.getStringOfOriginQuestions()); 
    
 wr.writeAttribute(Tags.Attrib.ORIGIN_ANSWERS, 
termIO.getStringOfOriginAnswers()); 
     final Integer orderPosition = 
termIO.getOrderPosition(); 
     if (orderPosition != null) { 
     
 wr.writeAttribute(Tags.Attrib.ORDER_POSITION, 
Integer.toString(orderPosition)); 
     } 
     wr.writeCharacters(termIO.getTerm()); 
     wr.writeEndElement(); 
    } 



  

    wr.writeEndElement(); 
    // 
    wr.writeEndElement(); 
    wr.writeEndDocument(); 
     
    wr.flush(); 
    wr.close(); 
     
    outputOK = true; 
     
   } catch (XMLStreamException e) { 
    e.printStackTrace(); 
   } catch (IOException e) { 
    e.printStackTrace(); 
   } finally { 
    if (wr != null) { 
     wr = null; 
    } 
   } 
  } 
  return outputOK; 
 } 
  
 public boolean inputFromXML(final IOBean bean) throws Exception { 
  boolean inputOK = false; 
  if (bean != null &amp;amp;&amp;amp; 
    bean.getFileAddress() != null &amp;amp;&amp;amp; 
    !bean.getFileAddress().isEmpty()) { 
   try { 
    Document xmlDoc = 
    
 DocumentBuilderFactory.newInstance().newDocumentBuilder().parse( 
      new FileInputStream(new 
File(bean.getFileAddress()))); 
     
    //* Recuperando elemento raíz Project: 
    Element elemProject = (Element) 
xmlDoc.getElementsByTagName(Tags.PROJECT).item(0); 
     
    //* Recuperando elemento Name: 
   
 bean.setProjectName(this.getValueFromOneElementNodeList(elemProject, 
Tags.NAME)); 
    //* Recuperando elemento Autor: 
   
 bean.setAutor(this.getValueFromOneElementNodeList(elemProject, 
Tags.AUTOR)); 
    //* Recuperando elemento Create Date: 
   
 bean.setCreateDate(this.getValueFromOneElementNodeList(elemProject, 
Tags.CREATE_DATE)); 
    //* Recuperando elemento Purpose: 
   
 bean.setPurpose(this.getValueFromOneElementNodeList(elemProject, 
Tags.PURPOSE)); 
    //* Recuperando elemento Scope: 
   
 bean.setScope(this.getValueFromOneElementNodeList(elemProject, 
Tags.SCOPE)); 
    //* Recuperando elemento Formality Level: 
   
 bean.setFormalityLevel(this.getValueFromOneElementNodeList(elemProject, 
Tags.FORMALITY_LEVEL)); 
     
    //* Recuperando elementos Users Descriptions: 
    { 
     Element elemUsers = (Element) 
elemProject.getElementsByTagName(Tags.USERS).item(0); 
     NodeList listOfUserDescr = 
elemUsers.getElementsByTagName(Tags.USER_DESCRIPTION); 
     final int length = 
listOfUserDescr.getLength(); 
     final List&lt;String&gt; usersDescriptionsList 
= new ArrayList&lt;String&gt;(length); 
     for (int i=0; i &amp;lt;length; i++) { 
      Element elemUserDescr = (Element) 
listOfUserDescr.item(i); 
     
 usersDescriptionsList.add(elemUserDescr.getTextContent()); 
     } 



  

    
 bean.setUsersDescriptions(usersDescriptionsList); 
    } 
    //* Recuperando elementos Uses Scenarios: 
    { 
     Element elemUsesScenarios = (Element) 
elemProject.getElementsByTagName(Tags.USES_SCENARIOS).item(0); 
     NodeList listOfScenario = 
elemUsesScenarios.getElementsByTagName(Tags.SCENARIO); 
     final int length = 
listOfScenario.getLength(); 
     final List&lt;String&gt; usesScenariosList = 
new ArrayList&lt;String&gt;(length); 
     for (int i=0; i &amp;lt;length; i++) { 
      Element elemScenario = (Element) 
listOfScenario.item(i); 
     
 usesScenariosList.add(elemScenario.getTextContent()); 
     } 
     bean.setUsesScenarios(usesScenariosList); 
    } 
     
    //* Recuperando elementos Categories: 
    { 
     NodeList listOfCategory = 
elemProject.getElementsByTagName(Tags.CATEGORY); 
     final int length = 
listOfCategory.getLength(); 
     for (int i=0; i &amp;lt;length; i++) { 
      Element elemCategory = (Element) 
listOfCategory.item(i); 
       
      final CategoryIO categoryIO = new 
CategoryIO(); 
     
 categoryIO.setName(elemCategory.getAttribute(Tags.Attrib.NAME)); 
     
 categoryIO.setCqs(this.getCQsIOList(elemCategory)); 
       
      bean.addCategoryIO(categoryIO); 
     } 
    } 
     
    //* Recuperando elementos Terms: 
    { 
     NodeList listOfSelectedTerms = 
elemProject.getElementsByTagName(Tags.SELECTED_TERMS); 
     if (listOfSelectedTerms.getLength() == 1) 
{ 
      NodeList listOfTerm = ((Element) 
listOfSelectedTerms.item(0)).getElementsByTagName(Tags.TERM); 
      final int length = 
listOfTerm.getLength(); 
      for (int i=0; i &amp;lt;length; i++) { 
       Element elemTerm = 
(Element) listOfTerm.item(i); 
        
       final TermIO termIO = new 
TermIO(); 
      
 termIO.setTerm(elemTerm.getTextContent()); 
      
 termIO.setOrderPosition(elemTerm.getAttribute(Tags.Attrib.ORDER_POSITIO
N)); 
      
 termIO.setOriginQuestion(elemTerm.getAttribute(Tags.Attrib.ORIGIN_QUEST
IONS)); 
      
 termIO.setOriginAnswers(elemTerm.getAttribute(Tags.Attrib.ORIGIN_ANSWER
S)); 
        
       bean.addTermIO(termIO); 
      } 
     } 
    } 
     
    inputOK = true; 
     
   } catch (Exception e) { 
    e.printStackTrace(); 



  

    throw e; 
   } 
  } 
  return inputOK; 
 } 
  
 private List&lt;CQsIO&gt; getCQsIOList(final Element elemCategory) throws 
Exception { 
  if (elemCategory != null) { 
   NodeList listOfCQ = 
elemCategory.getElementsByTagName(Tags.CQ); 
   final int length = listOfCQ.getLength(); 
   final List&lt;CQsIO&gt; auxList = new 
ArrayList&lt;CQsIO&gt;(length); 
   for (int i=0; i &amp;lt;length; i++) { 
    Element elemCQ = (Element) listOfCQ.item(i); 
     
    final CQsIO ioCQ = new CQsIO(); 
    final String id = 
elemCQ.getAttribute(Tags.Attrib.ID); 
    ioCQ.setId(Integer.parseInt(id)); 
   
 ioCQ.setQuestion(this.getValueFromOneElementNodeList(elemCQ, 
Tags.QUESTION)); 
    ioCQ.setAnswer(this.getAnswerFromCQ(elemCQ)); 
     
    auxList.add(ioCQ); 
   } 
   return auxList; 
  } 
  return null; 
 } 
 
 private String getAnswerFromCQ(final Element elemCQ) throws Exception { 
  if (elemCQ != null) { 
   NodeList listOfAnswer = 
elemCQ.getElementsByTagName(Tags.ANSWER); 
   if (listOfAnswer.getLength() == 1) { 
    Element elemAnswer = (Element) 
listOfAnswer.item(0); 
    return elemAnswer.getTextContent(); 
   } 
  } 
  return null; 
 } 
 
 private String getValueFromOneElementNodeList( 
   final Element elemSuper, final String tag) throws 
Exception { 
  Element elemChild = (Element) 
elemSuper.getElementsByTagName(tag).item(0); 
  return elemChild.getTextContent(); 
 } 
} 
 

? Sub-pacote “mvp”: 

? Interface PassiveView.java: 
package system.mvp; 
 
public interface PassiveView { 
  
&amp;lt;T extends Presenter&gt; void registerPresenter(T presenter); 
  
} 
 

? Classe Presenter.java: 
package system.mvp; 
 
public abstract class Presenter { 
 
 protected abstract void registerItselfInForm(); 
  
 public abstract void fillIn(); 



  

  
 public abstract void fillOut(); 
  
} 
 

? Sub-pacote “utils”: 

? Classe Tags.java: 
package system.utils; 
 
public final class Tags { 
  
 public static final String PROJECT = "project";  
  
 public static final String NAME = "name"; 
 public static final String AUTOR = "autor"; 
 public static final String CREATE_DATE = "createDate"; 
 public static final String PURPOSE = "purpose"; 
 public static final String SCOPE = "scope"; 
 public static final String FORMALITY_LEVEL = "formalityLevel"; 
  
 public static final String USERS = "users"; 
 public static final String USER_DESCRIPTION = "userDescription"; 
  
 public static final String USES_SCENARIOS = "usesScenarios"; 
 public static final String SCENARIO = "scenario"; 
  
 public static final String CATEGORY = "category"; 
 public static final String CQ = "competenceQuestion"; 
 public static final String QUESTION = "question"; 
 public static final String ANSWER = "answer"; 
  
 public static final String SELECTED_TERMS = "selectedTerms"; 
 public static final String TERM = "term"; 
  
  
 public static final class Attrib { 
   
  /** 
   * Attribute of CATEGORY tag. 
   */ 
  public static final String NAME = "name"; 
   
  /** 
   * Attribute of CQ tag. 
   */ 
  public static final String ID = "id"; 
   
  /** 
   * Attribute of TERM tag. 
   */ 
  public static final String ORDER_POSITION = "orderPosition"; 
   
  /** 
   * Attribute of TERM tag. 
   */ 
  public static final String ORIGIN_QUESTIONS = "originQuestions"; 
  /** 
   * Attribute of TERM tag. 
   */ 
  public static final String ORIGIN_ANSWERS = "originAnswers"; 
   
 } 
} 
 

? Classe UtilClass.java: 
package system.utils; 
 
import java.util.ArrayList; 
import java.util.HashSet; 
import java.util.LinkedHashSet; 
import java.util.List; 
import java.util.Set; 
import java.util.StringTokenizer; 



  

 
 
public final class UtilClass { 
  
 public enum ValidationErrors { 
  NULL_FIELD, 
  EXISTED_VALUE 
 } 
  
 public enum MESSAGES { 
  EXTRACT_TERMS_EXCEPTION, 
  COMBINE_TERMS_EXCEPTION, 
  NO_COMMON_ORIGINS, 
  TERM_ALLREADY_EXIST, 
  NO_PROJECT_TO_PERSIST, 
  FAIL_ON_PROJECT_PERSISTENCE, 
  PROJECT_PERSISTED, 
  FAIL_ON_OPEN_PROJECT 
 } 
  
 public static List&lt;ValidationErrors&gt; getOneItemList( 
   final ValidationErrors error) { 
  List&lt;ValidationErrors&gt; errorList = new 
ArrayList&lt;ValidationErrors&gt;(1); 
  errorList.add(error); 
  return errorList; 
 } 
  
 public static String formatTermsMapKey(final String term) { 
  if (term != null &amp;amp;&amp;amp; !term.isEmpty()) { 
   return term.toUpperCase(); 
  } 
  return ""; 
 } 
  
 public static final String APP_FILE_EXT = "xml"; 
  
 public static final int APP_WIDTH = 800; 
 public static final int APP_HEIGTH = 600; 
  
 public static final String APP_NO_OPEN_PROJECT_TITLE = "&lt;no open 
project&gt; - CQPlugin"; 
 public static final String APP_OPEN_PROJECT_TAG = "Open Project: [{0}] 
- CQPlugin {1}"; 
 public static final String APP_TITLE_SIGNAL_NEED_PERSISTENCE = " - 
!PROJECT NEED PERSISTENCE!"; 
  
 public static final String NO_CREATE_DATE_LABEL = "&lt;no create date&gt;"; 
  
 public static final int NO_SELECTED_CATEGORY = -1; 
  
 public static final int ALL_CATEGORIES_ID = 0; 
 public static final String ALL_CATEGORIES_LABEL = "&lt;All Categories&gt;"; 
  
 public static final int DEFAULT_CATEGORY_ID = 1; 
  
 public static final String CATEGORY_PREFIX = ") "; 
  
 public static final String QUESTION_PREFIX = " -&amp;lt;???&gt; - "; 
 public static final String ANSWER_PREFIX = " -&amp;lt;ANS&gt; - "; 
  
 public static final String TERMS_INIT_DETAILS_TAG = " --|--"; 
 public static final String TERMS_IDCODE_TAG = "&amp;lt;ID: {0}&gt;"; 
 public static final String TERMS_ORIGIN_QUESTIONS_TAG = "&amp;lt;questions: 
{0}&gt;"; 
 public static final String TERMS_ORIGIN_ANSWERS_TAG = "&amp;lt;answers: 
{0}&gt;"; 
 public static final String TERMS_ORDER_TAG = "&amp;lt;order: {0}&gt;"; 
  
 
 private UtilClass() {} 
  
 public static boolean isNullOrEmpty(final String value) { 
  if (value == null || value.isEmpty()) { 
   return true; 
  } 
  return false; 
 } 
  
 /** 



  

  * The &amp;amp;quot;o&amp;amp;quot; character. 
  */ 
 public static final String O_CHARACTER = "o"; 
  
 /** 
  * The space character. 
  */ 
 public static final String BLANK_SPACE = " "; 
 
 private static final Set&lt;String&gt; STOP_WORDS = loadStopWords(); 
  
 /** 
  * Loads the list of stop words. 
  * 
  * @return the stop list. 
  */ 
 public static Set&lt;String&gt; loadStopWords() { 
  final Set&lt;String&gt; stopWord = new HashSet&lt;String&gt;(); 
  stopWord.add("a"); 
  stopWord.add("abaixo"); 
  stopWord.add("about"); 
  stopWord.add("above"); 
  stopWord.add("abroad"); 
  stopWord.add("acaso"); 
  stopWord.add("acerca"); 
  stopWord.add("acima"); 
  stopWord.add("acha"); 
  stopWord.add("acho"); 
  stopWord.add("acola"); 
  stopWord.add("across"); 
  stopWord.add("ademais"); 
  stopWord.add("adentro"); 
  stopWord.add("adiante"); 
  stopWord.add("afim"); 
  stopWord.add("afin"); 
  stopWord.add("afins"); 
  stopWord.add("afora"); 
  stopWord.add("after"); 
  stopWord.add("against"); 
  stopWord.add("agora"); 
  stopWord.add("ahead"); 
  stopWord.add("ai"); 
  stopWord.add("ailleurs"); 
  stopWord.add("ainda"); 
  stopWord.add("aiansi"); 
  stopWord.add("alem"); 
  stopWord.add("algo"); 
  stopWord.add("alguem"); 
  stopWord.add("algum"); 
  stopWord.add("alguma"); 
  stopWord.add("algumas"); 
  stopWord.add("algunas"); 
  stopWord.add("algunos"); 
  stopWord.add("alguns"); 
  stopWord.add("ali"); 
  stopWord.add("alias"); 
  stopWord.add("all"); 
  stopWord.add("alli"); 
  stopWord.add("alo"); 
  stopWord.add("alone"); 
  stopWord.add("along"); 
  stopWord.add("alors"); 
  stopWord.add("also"); 
  stopWord.add("although"); 
  stopWord.add("always"); 
  stopWord.add("ambas"); 
  stopWord.add("ambito"); 
  stopWord.add("ambos"); 
  stopWord.add("among"); 
  stopWord.add("amongst"); 
  stopWord.add("amplo"); 
  stopWord.add("an"); 
  stopWord.add("and"); 
  stopWord.add("anex"); 
  stopWord.add("another"); 
  stopWord.add("ante"); 
  stopWord.add("antes"); 
  stopWord.add("anti"); 
  stopWord.add("any"); 
  stopWord.add("ao"); 



  

  stopWord.add("aonde"); 
  stopWord.add("aos"); 
  stopWord.add("apenas"); 
  stopWord.add("apesar"); 
  stopWord.add("apos"); 
  stopWord.add("apres"); 
  stopWord.add("aquela"); 
  stopWord.add("aquelas"); 
  stopWord.add("aquele"); 
  stopWord.add("aqueles"); 
  stopWord.add("aqui"); 
  stopWord.add("aquilo"); 
  stopWord.add("are"); 
  stopWord.add("as"); 
  stopWord.add("assim"); 
  stopWord.add("at"); 
  stopWord.add("ate"); 
  stopWord.add("ati"); 
  stopWord.add("atras"); 
  stopWord.add("atraves"); 
  stopWord.add("attendant"); 
  stopWord.add("atual"); 
  stopWord.add("aucun"); 
  stopWord.add("aucune"); 
  stopWord.add("auquel"); 
  stopWord.add("aussi"); 
  stopWord.add("aussitot"); 
  stopWord.add("autant"); 
  stopWord.add("autour"); 
  stopWord.add("auxquelles"); 
  stopWord.add("auxquels"); 
  stopWord.add("avante"); 
  stopWord.add("avec"); 
  stopWord.add("b"); 
  stopWord.add("back"); 
  stopWord.add("baixissima"); 
  stopWord.add("baixissimas"); 
  stopWord.add("baixissimo"); 
  stopWord.add("baixissimos"); 
  stopWord.add("balela"); 
  stopWord.add("barato"); 
  stopWord.add("baseada"); 
  stopWord.add("basicamente"); 
  stopWord.add("basta"); 
  stopWord.add("bastante"); 
  stopWord.add("be"); 
  stopWord.add("beaucoup"); 
  stopWord.add("because"); 
  stopWord.add("been"); 
  stopWord.add("before"); 
  stopWord.add("bem"); 
  stopWord.add("best"); 
  stopWord.add("better"); 
  stopWord.add("between"); 
  stopWord.add("beyond"); 
  stopWord.add("big"); 
  stopWord.add("both"); 
  stopWord.add("but"); 
  stopWord.add("by"); 
  stopWord.add("c"); 
  stopWord.add("ca"); 
  stopWord.add("cada"); 
  stopWord.add("capaz"); 
  stopWord.add("capazes"); 
  stopWord.add("caro"); 
  stopWord.add("caros"); 
  stopWord.add("caso"); 
  stopWord.add("casos"); 
  stopWord.add("cela"); 
  stopWord.add("celle"); 
  stopWord.add("celles"); 
  stopWord.add("celui"); 
  stopWord.add("cependant"); 
  stopWord.add("cerca"); 
  stopWord.add("certa"); 
  stopWord.add("certain"); 
  stopWord.add("certaine"); 
  stopWord.add("certaines"); 
  stopWord.add("certains"); 
  stopWord.add("certas"); 



  

  stopWord.add("certo"); 
  stopWord.add("certos"); 
  stopWord.add("ces"); 
  stopWord.add("cet"); 
  stopWord.add("cette"); 
  stopWord.add("ceux"); 
  stopWord.add("chacun"); 
  stopWord.add("chacune"); 
  stopWord.add("chaque"); 
  stopWord.add("chez"); 
  stopWord.add("chose"); 
  stopWord.add("cima"); 
  stopWord.add("coisa"); 
  stopWord.add("com"); 
  stopWord.add("combien"); 
  stopWord.add("comigo"); 
  stopWord.add("comme"); 
  stopWord.add("comment"); 
  stopWord.add("como"); 
  stopWord.add("comuns"); 
  stopWord.add("concernant"); 
  stopWord.add("conforme"); 
  stopWord.add("conformidade"); 
  stopWord.add("conosco"); 
  stopWord.add("conseguinte"); 
  stopWord.add("consequentemente"); 
  stopWord.add("consigo"); 
  stopWord.add("contida"); 
  stopWord.add("contidas"); 
  stopWord.add("contido"); 
  stopWord.add("contidos"); 
  stopWord.add("contigo"); 
  stopWord.add("contra"); 
  stopWord.add("contre"); 
  stopWord.add("contudo"); 
  stopWord.add("convosco"); 
  stopWord.add("corp"); 
  stopWord.add("could"); 
  stopWord.add("cuando"); 
  stopWord.add("cuja"); 
  stopWord.add("cujas"); 
  stopWord.add("cujo"); 
  stopWord.add("cujos"); 
  stopWord.add("d"); 
  stopWord.add("da"); 
  stopWord.add("dans"); 
  stopWord.add("daquela"); 
  stopWord.add("daquelas"); 
  stopWord.add("daquele"); 
  stopWord.add("daqueles"); 
  stopWord.add("daqui"); 
  stopWord.add("daquilodas"); 
  stopWord.add("das"); 
  stopWord.add("de"); 
  stopWord.add("debaixo"); 
  stopWord.add("dedans"); 
  stopWord.add("defronte"); 
  stopWord.add("dehors"); 
  stopWord.add("deja"); 
  stopWord.add("del"); 
  stopWord.add("dela"); 
  stopWord.add("delas"); 
  stopWord.add("dele"); 
  stopWord.add("deles"); 
  stopWord.add("della"); 
  stopWord.add("delle"); 
  stopWord.add("demais"); 
  stopWord.add("dentre"); 
  stopWord.add("depois"); 
  stopWord.add("depressa"); 
  stopWord.add("depuis"); 
  stopWord.add("des"); 
  stopWord.add("desde"); 
  stopWord.add("desquelles"); 
  stopWord.add("desquels"); 
  stopWord.add("dessa"); 
  stopWord.add("dessas"); 
  stopWord.add("desse"); 
  stopWord.add("desses"); 
  stopWord.add("dessus"); 



  

  stopWord.add("desta"); 
  stopWord.add("destas"); 
  stopWord.add("deste"); 
  stopWord.add("destes"); 
  stopWord.add("detras"); 
  stopWord.add("diante"); 
  stopWord.add("disso"); 
  stopWord.add("disto"); 
  stopWord.add("do"); 
  stopWord.add("donc"); 
  stopWord.add("donde"); 
  stopWord.add("donne"); 
  stopWord.add("dont"); 
  stopWord.add("doutra"); 
  stopWord.add("doutras"); 
  stopWord.add("doutro"); 
  stopWord.add("doutros"); 
  stopWord.add("dos"); 
  stopWord.add("du"); 
  stopWord.add("dum"); 
  stopWord.add("duma"); 
  stopWord.add("duns"); 
  stopWord.add("duquel"); 
  stopWord.add("duramente"); 
  stopWord.add("durant"); 
  stopWord.add("durante"); 
  stopWord.add("during"); 
  stopWord.add("e"); 
  stopWord.add("each"); 
  stopWord.add("easy"); 
  stopWord.add("either"); 
  stopWord.add("el"); 
  stopWord.add("ela"); 
  stopWord.add("elas"); 
  stopWord.add("ele"); 
  stopWord.add("eles"); 
  stopWord.add("ell"); 
  stopWord.add("ella"); 
  stopWord.add("elle"); 
  stopWord.add("elles"); 
  stopWord.add("ello"); 
  stopWord.add("em"); 
  stopWord.add("embaixo"); 
  stopWord.add("embora"); 
  stopWord.add("en"); 
  stopWord.add("encore"); 
  stopWord.add("enough"); 
  stopWord.add("enquanto"); 
  stopWord.add("entanto"); 
  stopWord.add("entao"); 
  stopWord.add("entre"); 
  stopWord.add("entretanto"); 
  stopWord.add("essa"); 
  stopWord.add("essas"); 
  stopWord.add("esse"); 
  stopWord.add("esses"); 
  stopWord.add("esta"); 
  stopWord.add("estas"); 
  stopWord.add("este"); 
  stopWord.add("estes"); 
  stopWord.add("et"); 
  stopWord.add("etaient"); 
  stopWord.add("etait"); 
  stopWord.add("etant"); 
  stopWord.add("etc"); 
  stopWord.add("eu"); 
  stopWord.add("eux"); 
  stopWord.add("ever"); 
  stopWord.add("every"); 
  stopWord.add("everybody"); 
  stopWord.add("everyone"); 
  stopWord.add("everything"); 
  stopWord.add("everywhere"); 
  stopWord.add("f"); 
  stopWord.add("facil"); 
  stopWord.add("favor"); 
  stopWord.add("few"); 
  stopWord.add("fim"); 
  stopWord.add("fin"); 
  stopWord.add("finali"); 



  

  stopWord.add("fins"); 
  stopWord.add("for"); 
  stopWord.add("fora"); 
  stopWord.add("forward"); 
  stopWord.add("from"); 
  stopWord.add("fulano"); 
  stopWord.add("furent"); 
  stopWord.add("g"); 
  stopWord.add("grace"); 
  stopWord.add("grandemente"); 
  stopWord.add("h"); 
  stopWord.add("had"); 
  stopWord.add("has"); 
  stopWord.add("have"); 
  stopWord.add("he"); 
  stopWord.add("hem"); 
  stopWord.add("her"); 
  stopWord.add("here"); 
  stopWord.add("hers"); 
  stopWord.add("herself"); 
  stopWord.add("him"); 
  stopWord.add("himself"); 
  stopWord.add("his"); 
  stopWord.add("hoje"); 
  stopWord.add("hormis"); 
  stopWord.add("hors"); 
  stopWord.add("how"); 
  stopWord.add("however"); 
  stopWord.add("hoy"); 
  stopWord.add("hum"); 
  stopWord.add("i"); 
  stopWord.add("ici"); 
  stopWord.add("if"); 
  stopWord.add("igual"); 
  stopWord.add("igualmente"); 
  stopWord.add("il"); 
  stopWord.add("ils"); 
  stopWord.add("in"); 
  stopWord.add("inc"); 
  stopWord.add("inter"); 
  stopWord.add("into"); 
  stopWord.add("is"); 
  stopWord.add("isso"); 
  stopWord.add("isto"); 
  stopWord.add("it"); 
  stopWord.add("item"); 
  stopWord.add("its"); 
  stopWord.add("itself"); 
  stopWord.add("iusque"); 
  stopWord.add("j"); 
  stopWord.add("ja"); 
  stopWord.add("jadis"); 
  stopWord.add("jamais"); 
  stopWord.add("je"); 
  stopWord.add("jeito"); 
  stopWord.add("juntamente"); 
  stopWord.add("junto"); 
  stopWord.add("juntos"); 
  stopWord.add("jusqu"); 
  stopWord.add("jusque"); 
  stopWord.add("just"); 
  stopWord.add("justa"); 
  stopWord.add("justo"); 
  stopWord.add("k"); 
  stopWord.add("l"); 
  stopWord.add("la"); 
  stopWord.add("lado"); 
  stopWord.add("lados"); 
  stopWord.add("laquelle"); 
  stopWord.add("las"); 
  stopWord.add("last"); 
  stopWord.add("le"); 
  stopWord.add("lequel"); 
  stopWord.add("les"); 
  stopWord.add("lesquelles"); 
  stopWord.add("lesquels"); 
  stopWord.add("less"); 
  stopWord.add("leur"); 
  stopWord.add("leurs"); 
  stopWord.add("lha"); 



  

  stopWord.add("lhas"); 
  stopWord.add("lhe"); 
  stopWord.add("lhes"); 
  stopWord.add("lho"); 
  stopWord.add("lhos"); 
  stopWord.add("lo"); 
  stopWord.add("lors"); 
  stopWord.add("lorsque"); 
  stopWord.add("los"); 
  stopWord.add("ltda"); 
  stopWord.add("lui"); 
  stopWord.add("m"); 
  stopWord.add("mais"); 
  stopWord.add("malgre"); 
  stopWord.add("maneira"); 
  stopWord.add("maneiras"); 
  stopWord.add("many"); 
  stopWord.add("mas"); 
  stopWord.add("me"); 
  stopWord.add("mediante"); 
  stopWord.add("meme"); 
  stopWord.add("memes"); 
  stopWord.add("menos"); 
  stopWord.add("mera"); 
  stopWord.add("meramente"); 
  stopWord.add("meras"); 
  stopWord.add("mero"); 
  stopWord.add("meros"); 
  stopWord.add("mes"); 
  stopWord.add("mesma"); 
  stopWord.add("mesmas"); 
  stopWord.add("mesmo"); 
  stopWord.add("mesmos"); 
  stopWord.add("meu"); 
  stopWord.add("meus"); 
  stopWord.add("mien"); 
  stopWord.add("mienne"); 
  stopWord.add("miennes"); 
  stopWord.add("miens"); 
  stopWord.add("mim"); 
  stopWord.add("minha"); 
  stopWord.add("minhas"); 
  stopWord.add("moins"); 
  stopWord.add("moment"); 
  stopWord.add("mon"); 
  stopWord.add("more"); 
  stopWord.add("most"); 
  stopWord.add("moyennant"); 
  stopWord.add("mr"); 
  stopWord.add("mrs"); 
  stopWord.add("my"); 
  stopWord.add("myself"); 
  stopWord.add("mz"); 
  stopWord.add("muita"); 
  stopWord.add("muitas"); 
  stopWord.add("muito"); 
  stopWord.add("muitos"); 
  stopWord.add("n"); 
  stopWord.add("na"); 
  stopWord.add("nada"); 
  stopWord.add("nao"); 
  stopWord.add("naquela"); 
  stopWord.add("naquelas"); 
  stopWord.add("naquele"); 
  stopWord.add("naqueles"); 
  stopWord.add("naquilo"); 
  stopWord.add("nas"); 
  stopWord.add("ne"); 
  stopWord.add("near"); 
  stopWord.add("neither"); 
  stopWord.add("nela"); 
  stopWord.add("nelas"); 
  stopWord.add("nele"); 
  stopWord.add("neles"); 
  stopWord.add("nenhum"); 
  stopWord.add("nenhuma"); 
  stopWord.add("nenhumas"); 
  stopWord.add("nenhuns"); 
  stopWord.add("nesse"); 
  stopWord.add("nesses"); 



  

  stopWord.add("nesta"); 
  stopWord.add("nestas"); 
  stopWord.add("neste"); 
  stopWord.add("nestes"); 
  stopWord.add("never"); 
  stopWord.add("ni"); 
  stopWord.add("ninguem"); 
  stopWord.add("nisso"); 
  stopWord.add("no"); 
  stopWord.add("non"); 
  stopWord.add("none"); 
  stopWord.add("nos"); 
  stopWord.add("nossa"); 
  stopWord.add("nossas"); 
  stopWord.add("nosso"); 
  stopWord.add("nossos"); 
  stopWord.add("not"); 
  stopWord.add("notamment"); 
  stopWord.add("notres"); 
  stopWord.add("nous"); 
  stopWord.add("now"); 
  stopWord.add("nulle"); 
  stopWord.add("nulles"); 
  stopWord.add("num"); 
  stopWord.add("numa"); 
  stopWord.add("numas"); 
  stopWord.add("nunca"); 
  stopWord.add("nuns"); 
  stopWord.add(O_CHARACTER); 
  stopWord.add("of"); 
  stopWord.add("often"); 
  stopWord.add("oi"); 
  stopWord.add("ola"); 
  stopWord.add("on"); 
  stopWord.add("onde"); 
  stopWord.add("one"); 
  stopWord.add("only"); 
  stopWord.add("or"); 
  stopWord.add("os"); 
  stopWord.add("other"); 
  stopWord.add("ou"); 
  stopWord.add("our"); 
  stopWord.add("ourselves"); 
  stopWord.add("out"); 
  stopWord.add("outra"); 
  stopWord.add("outras"); 
  stopWord.add("outrem"); 
  stopWord.add("outro"); 
  stopWord.add("outros"); 
  stopWord.add("over"); 
  stopWord.add("p"); 
  stopWord.add("par"); 
  stopWord.add("para"); 
  stopWord.add("parce"); 
  stopWord.add("parmi"); 
  stopWord.add("pela"); 
  stopWord.add("pelas"); 
  stopWord.add("per"); 
  stopWord.add("perante"); 
  stopWord.add("perto"); 
  stopWord.add("plus"); 
  stopWord.add("plusieurs"); 
  stopWord.add("pode"); 
  stopWord.add("pois"); 
  stopWord.add("por"); 
  stopWord.add("poucos"); 
  stopWord.add("pour"); 
  stopWord.add("pourquoi"); 
  stopWord.add("pres"); 
  stopWord.add("proxima"); 
  stopWord.add("proximamente"); 
  stopWord.add("proximas"); 
  stopWord.add("proximos"); 
  stopWord.add("psiu"); 
  stopWord.add("puis"); 
  stopWord.add("puisque"); 
  stopWord.add("q"); 
  stopWord.add("quais"); 
  stopWord.add("quaisquer"); 
  stopWord.add("qual"); 



  

  stopWord.add("qualquer"); 
  stopWord.add("quand"); 
  stopWord.add("quando"); 
  stopWord.add("quant"); 
  stopWord.add("quanta"); 
  stopWord.add("quantas"); 
  stopWord.add("quanto"); 
  stopWord.add("quantos"); 
  stopWord.add("quase"); 
  stopWord.add("que"); 
  stopWord.add("quel"); 
  stopWord.add("quelle"); 
  stopWord.add("quelqu''un"); 
  stopWord.add("quelqu''une"); 
  stopWord.add("quelque"); 
  stopWord.add("quelques-unes"); 
  stopWord.add("quelques-uns"); 
  stopWord.add("quels"); 
  stopWord.add("quem"); 
  stopWord.add("quiconque"); 
  stopWord.add("quoi"); 
  stopWord.add("quoique"); 
  stopWord.add("r"); 
  stopWord.add("rather"); 
  stopWord.add("s"); 
  stopWord.add("sa"); 
  stopWord.add("sans"); 
  stopWord.add("sauf"); 
  stopWord.add("says"); 
  stopWord.add("se"); 
  stopWord.add("seguinte"); 
  stopWord.add("selon"); 
  stopWord.add("sem"); 
  stopWord.add("sempre"); 
  stopWord.add("senao"); 
  stopWord.add("sendo"); 
  stopWord.add("ses"); 
  stopWord.add("seu"); 
  stopWord.add("seus"); 
  stopWord.add("shall"); 
  stopWord.add("she"); 
  stopWord.add("should"); 
  stopWord.add("si"); 
  stopWord.add("sien"); 
  stopWord.add("sienne"); 
  stopWord.add("siennes"); 
  stopWord.add("siens"); 
  stopWord.add("sim"); 
  stopWord.add("simplesmente"); 
  stopWord.add("since"); 
  stopWord.add("sob"); 
  stopWord.add("sobre"); 
  stopWord.add("small"); 
  stopWord.add("soi"); 
  stopWord.add("soi-meme"); 
  stopWord.add("soit"); 
  stopWord.add("some"); 
  stopWord.add("somente"); 
  stopWord.add("sont"); 
  stopWord.add("soon"); 
  stopWord.add("sous"); 
  stopWord.add("still"); 
  stopWord.add("sua"); 
  stopWord.add("suas"); 
  stopWord.add("such"); 
  stopWord.add("suis"); 
  stopWord.add("t"); 
  stopWord.add("ta"); 
  stopWord.add("tal"); 
  stopWord.add("talvez"); 
  stopWord.add("tambem"); 
  stopWord.add("tampouco"); 
  stopWord.add("tandis"); 
  stopWord.add("tant"); 
  stopWord.add("tanta"); 
  stopWord.add("tantas"); 
  stopWord.add("tanto"); 
  stopWord.add("tantos"); 
  stopWord.add("te"); 
  stopWord.add("telle"); 



  

  stopWord.add("telles"); 
  stopWord.add("tem"); 
  stopWord.add("teremos"); 
  stopWord.add("tes"); 
  stopWord.add("teus"); 
  stopWord.add("than"); 
  stopWord.add("that"); 
  stopWord.add("the"); 
  stopWord.add("their"); 
  stopWord.add("themselves"); 
  stopWord.add("then"); 
  stopWord.add("there"); 
  stopWord.add("these"); 
  stopWord.add("they"); 
  stopWord.add("thing"); 
  stopWord.add("this"); 
  stopWord.add("those"); 
  stopWord.add("though"); 
  stopWord.add("through"); 
  stopWord.add("tienne"); 
  stopWord.add("tiennes"); 
  stopWord.add("tiens"); 
  stopWord.add("toda"); 
  stopWord.add("todas"); 
  stopWord.add("todavia"); 
  stopWord.add("today"); 
  stopWord.add("todo"); 
  stopWord.add("todos"); 
  stopWord.add("toi"); 
  stopWord.add("tomara"); 
  stopWord.add("ton"); 
  stopWord.add("to"); 
  stopWord.add("too"); 
  stopWord.add("toujours"); 
  stopWord.add("tous"); 
  stopWord.add("toute"); 
  stopWord.add("toutes"); 
  stopWord.add("tranquila"); 
  stopWord.add("tranquilamente"); 
  stopWord.add("tranquilas"); 
  stopWord.add("tranquilo"); 
  stopWord.add("tranquilos"); 
  stopWord.add("tras"); 
  stopWord.add("tres"); 
  stopWord.add("trop"); 
  stopWord.add("tu"); 
  stopWord.add("tua"); 
  stopWord.add("tuas"); 
  stopWord.add("tudo"); 
  stopWord.add("u"); 
  stopWord.add("ulterior"); 
  stopWord.add("um"); 
  stopWord.add("uma"); 
  stopWord.add("umas"); 
  stopWord.add("un"); 
  stopWord.add("una"); 
  stopWord.add("under"); 
  stopWord.add("uno"); 
  stopWord.add("uns"); 
  stopWord.add("until"); 
  stopWord.add("up"); 
  stopWord.add("upon"); 
  stopWord.add("upres"); 
  stopWord.add("v"); 
  stopWord.add("vai"); 
  stopWord.add("varia"); 
  stopWord.add("varias"); 
  stopWord.add("vario"); 
  stopWord.add("varios"); 
  stopWord.add("vem"); 
  stopWord.add("very"); 
  stopWord.add("vez"); 
  stopWord.add("vezes"); 
  stopWord.add("voce"); 
  stopWord.add("voces"); 
  stopWord.add("vos"); 
  stopWord.add("vossa"); 
  stopWord.add("vossas"); 
  stopWord.add("vosso"); 
  stopWord.add("vossos"); 



  

  stopWord.add("votre"); 
  stopWord.add("votres"); 
  stopWord.add("vous"); 
  stopWord.add("vu"); 
  stopWord.add("vide"); 
  stopWord.add("w"); 
  stopWord.add("was"); 
  stopWord.add("we"); 
  stopWord.add("were"); 
  stopWord.add("what"); 
  stopWord.add("when"); 
  stopWord.add("where"); 
  stopWord.add("which"); 
  stopWord.add("while"); 
  stopWord.add("who"); 
  stopWord.add("whom"); 
  stopWord.add("whose"); 
  stopWord.add("will"); 
  stopWord.add("with"); 
  stopWord.add("within"); 
  stopWord.add("without"); 
  stopWord.add("would"); 
  stopWord.add("www"); 
  stopWord.add("x"); 
  stopWord.add("y"); 
  stopWord.add("yet"); 
  stopWord.add("you"); 
  stopWord.add("your"); 
  stopWord.add("yours"); 
  stopWord.add("yourself"); 
  stopWord.add("yourselves"); 
  stopWord.add("z"); 
  stopWord.add("us"); 
  stopWord.add("ours"); 
  stopWord.add("them"); 
  stopWord.add("theirs"); 
  stopWord.add("am"); 
  stopWord.add("being"); 
  stopWord.add("having"); 
  stopWord.add("does"); 
  stopWord.add("did"); 
  stopWord.add("doing"); 
  stopWord.add("can"); 
  stopWord.add("may"); 
  stopWord.add("might"); 
  stopWord.add("must"); 
  stopWord.add("ought"); 
  stopWord.add("below"); 
  stopWord.add("down"); 
  stopWord.add("off"); 
  stopWord.add("again"); 
  stopWord.add("further"); 
  stopWord.add("once"); 
  stopWord.add("why"); 
  stopWord.add("nor"); 
  stopWord.add("own"); 
  stopWord.add("same"); 
  stopWord.add("so"); 
  stopWord.add("least"); 
  stopWord.add("say"); 
  stopWord.add("said"); 
  stopWord.add("get"); 
  stopWord.add("go"); 
  stopWord.add("goes"); 
  stopWord.add("made"); 
  stopWord.add("make"); 
  stopWord.add("put"); 
  stopWord.add("see"); 
  stopWord.add("seen"); 
  stopWord.add("whether"); 
  stopWord.add("like"); 
  stopWord.add("well"); 
  stopWord.add("even"); 
  stopWord.add("way"); 
  stopWord.add("take"); 
  stopWord.add("two"); 
  stopWord.add("three"); 
  stopWord.add("four"); 
  stopWord.add("five"); 
  stopWord.add("first"); 



  

  stopWord.add("second"); 
  stopWord.add("new"); 
  stopWord.add("old"); 
  stopWord.add("high"); 
  stopWord.add("long"); 
  return stopWord; 
 } 
  
 /** 
  * Checks whether the informed content is a stop word. 
  * 
  * @param word 
  *            the content to be checked. 
  * @return whether the parameter is or not a stop word. 
  * @throws Exception 
  *             unexpected error. 
  */ 
 public static boolean isStopWord(final String word) throws Exception { 
  return 
STOP_WORDS.contains(removeAccent(word.trim().toLowerCase())); 
 } 
  
 /** 
  * Clears the string content modifying accented character. 
  * http://www.columbia.edu/kermit/utf8-t1.html 
  * 
  * @param content 
  *            content to be changed. 
  * @return the string without accent. 
  */ 
 public static String removeAccent(final String content) { 
  if (content == null || content.trim().isEmpty()) { 
   return content; 
  } 
  final char[] aryLAcento = 
"\u00E1\u00C1\u00E3\u00C3\u00E2\u00C2\u00E0\u00C0\u00E4\u00C4\u00E9\u00C9\u00E
A\u00CA\u00E8\u00C8\u00EB\u00CB\u00ED\u00CD\u00EF\u00CF\u00EC\u00CC\u00EE\u00C
E\u00F3\u00D3\u00F5\u00D5\u00F4\u00D4\u00F2\u00D2\u00F6\u00D6\u00FA\u00DA\u00F
B\u00DB\u00F9\u00D9\u00FC\u00DC\u00E7\u00C7\u00FF\u0178\u00FD\u00DD\u00F1\u00D
1" 
   .toCharArray(); 
  final char[] aryLSAcento = 
"aAaAaAaAaAeEeEeEeEiIiIiIiIoOoOoOoOoOuUuUuUuUcCyYyYnN" 
   .toCharArray(); 
  final char[] aryLConteudo = content.toCharArray(); 
  final StringBuffer stbLRetorno = new StringBuffer(); 
  char chrLCarc; 
  for (int intLIdx = 0; intLIdx &amp;lt;aryLConteudo.length; intLIdx++) 
{ 
   chrLCarc = aryLConteudo[intLIdx]; 
   for (int intLAcento = 0; intLAcento &amp;lt;aryLAcento.length; 
intLAcento++) { 
    if (chrLCarc == aryLAcento[intLAcento]) { 
     chrLCarc = aryLSAcento[intLAcento]; 
     break; 
    } 
   } 
   stbLRetorno.append(chrLCarc); 
  } 
  return stbLRetorno.toString(); 
 } 
  
 public static List&lt;String&gt; removeAccentFromStringList(final 
List&lt;String&gt; listOfString) { 
  final int length = (listOfString != null ? listOfString.size() : 
0); 
  List&lt;String&gt; auxList = new ArrayList&lt;String&gt;(0);  
  if (length &gt; 0) { 
   for (String content : listOfString) { 
    auxList.add(UtilClass.removeAccent(content)); 
   } 
  } 
  return auxList; 
 } 
  
 /** 
  * If exists consecutive blank characters replace them for one blank. 
  * 
  * @param content 
  *            content to be changed. 



  

  * @return a string without consecutive blank characters. 
  */ 
 public static String removeBlanks(final String content) { 
  return content.replaceAll("\\s+", BLANK_SPACE).trim(); 
 } 
  
 public static boolean validateFileName(final String fileName) { 
  if (fileName != null &amp;amp;&amp;amp; !fileName.isEmpty()) { 
   String cleanedName = UtilClass.cleanFileName(fileName); 
   if (!fileName.equalsIgnoreCase(cleanedName)) { 
    StringTokenizer tokenizer = new 
StringTokenizer(cleanedName); 
    final int lastElement = tokenizer.countTokens(); 
    int count = 0; 
    while (tokenizer.hasMoreElements()) { 
     String token = tokenizer.nextToken(); 
     count++; 
     if (count == lastElement) { 
      if 
(APP_FILE_EXT.equalsIgnoreCase(token)) { 
       return true; 
      } 
     } 
    } 
   } 
  } 
  return false; 
 } 
  
 public static String cleanFileName(final String fileName) { 
  return removePuncts(fileName, " "); 
 } 
 /** 
  * Replacement is ""(empty). 
  * @param content 
  * @return 
  */ 
 public static String removePuncts(final String content) { 
  return removePuncts(content, ""); 
 } 
 public static String removePuncts(final String content, final String 
replacement) { 
  return content.replaceAll("\\p{Punct}", replacement).trim(); 
 } 
  
 public static String removeExtensionFromFileName(final String fileName) 
{ 
  StringBuilder returnName = new StringBuilder(); 
  String cleanedName = cleanFileName(fileName); 
  StringTokenizer tokenizer = new StringTokenizer(cleanedName); 
  final int lastElement = tokenizer.countTokens(); 
  int count = 0; 
  while (tokenizer.hasMoreElements()) { 
   String token = tokenizer.nextToken(); 
   count++; 
   if (count != lastElement) { 
    if (returnName.length() &gt; 0) { 
     returnName.append(" "); 
    } 
    returnName.append(token); 
   } 
  } 
  return returnName.toString(); 
 } 
 
 public static int[] convertArrayIntegerToArrayInt(Integer[] 
integerArray) { 
  final int length = (integerArray != null ? integerArray.length : 
0); 
  int[] intArray = new int[length]; 
  for (int i=0; i &amp;lt;length; i++) { 
   intArray[i] = integerArray[i].intValue(); 
  } 
  return intArray; 
 } 
  
 public static Set&lt;Integer&gt; convertArrayIntToSetInteger(final int[] 
intArray) { 
  final int length = (intArray != null ? intArray.length : 0); 
  final Set&lt;Integer&gt; auxSet = new LinkedHashSet&lt;Integer&gt;(length); 



  

  for (int i=0; i &amp;lt;length; i++) { 
   auxSet.add(intArray[i]); 
  } 
  return auxSet; 
 } 
} 
 

? Pacote “view”: 

? Classe ViewController.java: 
package view; 
 
import java.text.MessageFormat; 
import java.util.List; 
 
import system.Environment; 
import system.utils.UtilClass; 
import view.main.MainPresenter; 
import view.project.ProjectPresenter; 
import view.questions.CompetenceQuestionsPresenter; 
import view.terms.TermsPresenter; 
import beans.CompetenceQuestionsBean; 
import beans.ProjectBean; 
import beans.TermsBean; 
import data.DataController; 
 
public class ViewController { 
  
 private Environment environment; 
  
 private MainPresenter mainPresenter; 
 private ProjectPresenter projectPresenter; 
 private CompetenceQuestionsPresenter cqPresenter; 
 private TermsPresenter termsPresenter; 
 
 public ViewController(final Environment environment, final ViewParams 
viewParams) { 
  this.environment = environment; 
  this.initPresenters(viewParams); 
 } 
 
 private void initPresenters(final ViewParams viewParams) { 
  this.mainPresenter = new MainPresenter(this, 
viewParams.getMainForm()); 
  this.projectPresenter = new ProjectPresenter(this, 
viewParams.getProjectForm()); 
  this.cqPresenter = new CompetenceQuestionsPresenter(this, 
viewParams.getCqForm()); 
  this.termsPresenter = new TermsPresenter(this, 
viewParams.getTermsForm()); 
  this.doFirstLoad(); 
 } 
  
 private void doFirstLoad() { 
  this.loadProjectView(); 
  final DataController dc = this.environment.getDataController(); 
  if (dc.hasProjectInstance()) { 
   final String projectTitle = dc.getProjectTitle();  
   this.mainPresenter.setAppTitle( 
    
 MessageFormat.format(UtilClass.APP_OPEN_PROJECT_TAG, projectTitle, 
"")); 
  } else { 
   this.setNoOpenProjectMode(); 
  } 
 } 
  
 private void loadProjectView() { 
  this.mainPresenter.selectProjectView(); 
  final DataController dc = this.environment.getDataController(); 
  this.projectPresenter.loadBean(dc.getProjectBean()); 
 } 
 
 public CompetenceQuestionsBean getCompetenceQuestionsBean() { 
  final DataController dc = this.environment.getDataController(); 
  return dc.getCompetenceQuestionsBean(); 



  

 } 
  
 public TermsBean getTermsBean() { 
  final DataController dc = this.environment.getDataController(); 
  return dc.getTermsBean(); 
 } 
  
 public void loadAllCQs(final CompetenceQuestionsBean bean) { 
  final DataController dc = this.environment.getDataController(); 
  dc.loadAllCQs(bean); 
 } 
  
 public void loadCQsByCategory(final CompetenceQuestionsBean bean, 
   final Integer categoryID) { 
  final DataController dc = this.environment.getDataController(); 
  dc.loadCQsByCategory(bean, categoryID); 
 } 
  
 public void setMainFormEnabled(final boolean enabled) { 
  this.mainPresenter.setFormEnabled(enabled); 
 } 
  
 public void loadOneCategory(final CompetenceQuestionsBean bean, 
   final Integer categoryID) { 
  final DataController dc = this.environment.getDataController(); 
  dc.loadOneCategory(bean, categoryID); 
 } 
  
 public void loadOneCQ(final CompetenceQuestionsBean bean, 
   final Integer competenceQuestionID) { 
  final DataController dc = this.environment.getDataController(); 
  dc.loadOneCQ(bean, competenceQuestionID); 
 } 
  
 private void setNoOpenProjectMode() { 
  this.mainPresenter.allowViewChanges(false); 
 
 this.mainPresenter.setAppTitle(UtilClass.APP_NO_OPEN_PROJECT_TITLE); 
 } 
 
 public void startNewFile(String fileName, String fileAddress) { 
  final DataController dc = this.environment.getDataController(); 
  dc.startNewFile(fileName, fileAddress); 
  this.doFirstLoad(); 
 } 
  
 public void openFile(final String fileName, final String fileAddress) 
throws Exception { 
  final DataController dc = this.environment.getDataController(); 
  dc.openFile(fileName, fileAddress); 
  this.doFirstLoad(); 
 } 
 
 public void saveProjectBean(ProjectBean bean) { 
  final DataController dc = this.environment.getDataController(); 
  dc.saveProjectBean(bean); 
  this.loadProjectView(); 
 } 
 
 public void addCategory(final CompetenceQuestionsBean bean, 
   final String name, final String description) { 
  final DataController dc = this.environment.getDataController(); 
  dc.addCategory(bean, name, description); 
 } 
 
 public void editCategory(final int idCode, 
   final String name, final String description) { 
  final DataController dc = this.environment.getDataController(); 
  dc.editCategory(idCode, name, description); 
 } 
 
 public boolean hasCQs(final List&lt;Integer&gt; categoryIDsList) { 
  final DataController dc = this.environment.getDataController(); 
  return dc.hasCQs(categoryIDsList); 
 } 
 
 public void removeCategories(final CompetenceQuestionsBean bean, final 
List&lt;Integer&gt; categoryIDsList) { 
  final DataController dc = this.environment.getDataController(); 
  dc.removeCategories(bean, categoryIDsList); 



  

 } 
 
 public void addCompetenceQuestion(final CompetenceQuestionsBean bean, 
   final Integer categoryID, final String question, final 
String answer) { 
  final DataController dc = this.environment.getDataController(); 
  dc.addCompetenceQuestion(bean, categoryID, question, answer); 
 } 
 
 public void editCompetenceQuestion(final Integer cqID, 
   final String question, final String answer) { 
  final DataController dc = this.environment.getDataController(); 
  dc.editCompetenceQuestion(cqID, question, answer); 
 } 
 
 public void removeCompetenceQuestions(final CompetenceQuestionsBean 
bean, 
   final Integer categoryID, final List&lt;Integer&gt; cqIDsList) 
{ 
  final DataController dc = this.environment.getDataController(); 
  dc.removeCompetenceQuestions(bean, categoryID, cqIDsList); 
 } 
 
 public void moveCompetenceQuestions(final CompetenceQuestionsBean bean, 
   final Integer sourceCategoryID, final Integer 
targetCategoryID, 
   final List&lt;Integer&gt; cqIDsList) { 
  final DataController dc = this.environment.getDataController(); 
  dc.moveCompetenceQuestions(bean, sourceCategoryID, 
targetCategoryID, cqIDsList); 
 } 
 
 public void extractTerms(final TermsBean bean, final Integer 
categoryID) throws Exception { 
  final DataController dc = this.environment.getDataController(); 
  dc.extractTerms(bean, categoryID); 
 } 
 
 public void removePersistedTerms(final TermsBean bean, 
   final List&lt;Integer&gt; persistedTermIDs) { 
  final DataController dc = this.environment.getDataController(); 
  dc.removePersistedTerms(bean, persistedTermIDs); 
 } 
 
 public void persistTerms(final TermsBean bean) { 
  final DataController dc = this.environment.getDataController(); 
  dc.persistTerms(bean); 
 } 
 
 public Boolean persistProject() { 
  final DataController dc = this.environment.getDataController(); 
  if (dc.hasProjectInstance()) { 
   return dc.persistProject(); 
  } else { 
   return null; 
  } 
 } 
} 
 

? Classe ViewParams.java: 
package view; 
 
import view.main.MainForm; 
import view.project.ProjectForm; 
import view.questions.CompetenceQuestionsForm; 
import view.terms.TermsForm; 
 
public class ViewParams { 
  
 private final MainForm mainForm; 
 private final ProjectForm projectForm; 
 private final CompetenceQuestionsForm cqForm; 
 private final TermsForm termsForm; 
  
 public ViewParams(MainForm mainForm, ProjectForm projectForm, 
   CompetenceQuestionsForm cqForm, TermsForm termsForm) { 
  this.mainForm = mainForm; 
  this.projectForm = projectForm; 



  

  this.cqForm = cqForm; 
  this.termsForm = termsForm; 
 } 
 
 public MainForm getMainForm() { 
  return mainForm; 
 } 
 
 public ProjectForm getProjectForm() { 
  return projectForm; 
 } 
 
 public CompetenceQuestionsForm getCqForm() { 
  return cqForm; 
 } 
 
 public TermsForm getTermsForm() { 
  return termsForm; 
 } 
} 
 

? Sub-pacote “main”: 

? Interface MainForm.java: 
package view.main; 
 
import system.mvp.PassiveView; 
import system.utils.UtilClass.MESSAGES; 
 
public interface MainForm extends PassiveView { 
  
 void close(); 
  
 void setAppTitle(String appTitle); 
  
 void setMainFormEnabled(boolean enabled); 
 
 void allowViewChanges(boolean allowed); 
 
 void selectProjectView(); 
 
 void selectCompetenceQuestionsView(); 
 
 void selectTermsView(); 
 
 void showMessage(MESSAGES message); 
 
} 
 

? Classe MainFormImpl.java: 
package view.main; 
 
import system.mvp.Presenter; 
import system.utils.UtilClass; 
import system.utils.UtilClass.MESSAGES; 
import view.ViewController; 
 
public class MainPresenter extends Presenter { 
 
 private ViewController viewController; 
 private MainForm form; 
 
 public MainPresenter(ViewController viewController, MainForm form) { 
  this.viewController = viewController; 
  this.form = form; 
  this.registerItselfInForm(); 
 } 
 
 @Override 
 protected void registerItselfInForm() { 
  this.form.registerPresenter(this); 
 } 
 
 @Override 



  

 public void fillIn() {} 
 
 @Override 
 public void fillOut() {} 
 
 public void setFormEnabled(boolean enabled) { 
  this.form.setMainFormEnabled(enabled); 
 } 
 
 public void selectProjectView() { 
  this.form.selectProjectView(); 
 } 
 public void selectCompetenceQuestionsView() { 
  this.form.selectCompetenceQuestionsView(); 
 } 
 public void selectTermsView() { 
  this.form.selectTermsView(); 
 } 
 
 public void allowViewChanges(boolean allowed) { 
  this.form.allowViewChanges(allowed); 
 } 
  
 public void setAppTitle(final String appTitle) { 
  this.form.setAppTitle(appTitle); 
 } 
 
 public void startNewFile(final String fileName, final String 
fileAddress) { 
  this.viewController.startNewFile(fileName, fileAddress); 
 } 
 
 public void openFile(final String fileName, final String fileAddress) { 
  try { 
   this.viewController.openFile(fileName, fileAddress); 
  } catch (Exception e) { 
   this.form.showMessage(MESSAGES.FAIL_ON_OPEN_PROJECT); 
  } 
 } 
 
 public void persistProject() { 
  final Boolean retorno = this.viewController.persistProject(); 
  if (retorno == null) { 
  
 this.form.showMessage(UtilClass.MESSAGES.NO_PROJECT_TO_PERSIST); 
  } else if (retorno) { 
  
 this.form.showMessage(UtilClass.MESSAGES.PROJECT_PERSISTED); 
  } else { 
  
 this.form.showMessage(UtilClass.MESSAGES.FAIL_ON_PROJECT_PERSISTENCE); 
  } 
 } 
} 
 

? Sub-pacote “project”: 

? Interface ProjectForm.java: 
package view.project; 
 
import java.util.Date; 
import java.util.List; 
 
import system.mvp.PassiveView; 
 
public interface ProjectForm extends PassiveView { 
  
 String getProjectName(); 
  
 String getProjectAutor(); 
  
 String getProjectPurpose(); 
  
 String getProjectScope(); 
  
 String getProjectFormalityLevel(); 



  

  
 List&lt;String&gt; getProjectUsersDescriptionsList(); 
  
 List&lt;String&gt; getProjectUsesScenariosList(); 
  
 void setProjectName(String value); 
  
 void setProjectCreateDate(Date value); 
  
 void setProjectAutor(String value); 
  
 void setProjectPurpose(String value); 
  
 void setProjectScope(String value); 
  
 void setProjectFormalityLevel(String value); 
  
 void setProjectUsersDescriptionsList(List&lt;String&gt; value); 
  
 void setProjectUsesScenariosList(List&lt;String&gt; value); 
  
 void setEmptyMode(); 
  
 void setViewMode(); 
  
 void setEditMode(); 
  
} 
 

? Classe ProjectFormImpl.java: 
package view.project; 
 
import system.mvp.Presenter; 
import view.ViewController; 
import beans.ProjectBean; 
 
public class ProjectPresenter extends Presenter { 
 
 private ViewController viewController; 
 private ProjectForm form; 
  
 private ProjectBean bean; 
 
 public ProjectPresenter(final ViewController viewController, final 
ProjectForm form) { 
  this.viewController = viewController; 
  this.form = form; 
  this.registerItselfInForm(); 
 } 
 
 @Override 
 protected void registerItselfInForm() { 
  this.form.registerPresenter(this); 
 } 
  
 public void loadBean(ProjectBean bean) { 
  this.bean = bean; 
  this.loadValues(); 
 } 
  
 public void loadValues() { 
  if (this.bean != null) { 
   this.bean.clearChanges(); 
   this.fillIn(); 
   this.setFormViewMode(); 
  } else { 
   this.fillEmpty(); 
  } 
 } 
  
 public boolean hasChanges() { 
  this.fillOut(); 
  return this.bean.hasChanges(); 
 } 
  
 private void fillEmpty() { 
  this.form.setProjectName(null); 
  this.form.setProjectCreateDate(null); 



  

  this.form.setProjectAutor(null); 
  this.form.setProjectPurpose(null); 
  this.form.setProjectScope(null); 
  this.form.setProjectFormalityLevel(null); 
  this.setFormEmptyMode(); 
 } 
 
 @Override 
 public void fillIn() { 
  this.form.setProjectName(this.bean.getName()); 
  this.form.setProjectCreateDate(this.bean.getCreateDate()); 
  this.form.setProjectAutor(this.bean.getAutor()); 
  this.form.setProjectPurpose(this.bean.getPurpose()); 
  this.form.setProjectScope(this.bean.getScope()); 
 
 this.form.setProjectFormalityLevel(this.bean.getFormalityLevel()); 
  this.fillInUsersDescriptionsList(); 
  this.fillInUsesScenariosList(); 
 } 
 
 @Override 
 public void fillOut() { 
  this.bean.setName(this.form.getProjectName()); 
  this.bean.setAutor(this.form.getProjectAutor()); 
  this.bean.setPurpose(this.form.getProjectPurpose()); 
  this.bean.setScope(this.form.getProjectScope()); 
 
 this.bean.setFormalityLevel(this.form.getProjectFormalityLevel()); 
  this.fillOutUsersDescriptionsList(); 
  this.fillOutUsesScenariosList(); 
 } 
  
 private void fillInUsersDescriptionsList() { 
 
 this.form.setProjectUsersDescriptionsList(this.bean.getUsersDescription
sList()); 
 } 
 private void fillOutUsersDescriptionsList() { 
 
 this.bean.setUsersDescriptionList(this.form.getProjectUsersDescriptions
List()); 
 } 
  
 private void fillInUsesScenariosList() { 
 
 this.form.setProjectUsesScenariosList(this.bean.getUsesScenariosList())
; 
 } 
 private void fillOutUsesScenariosList() { 
 
 this.bean.setUsesScenariosList(this.form.getProjectUsesScenariosList())
; 
 } 
  
 public void doEditAction() { 
  this.setFormEditMode(); 
 } 
  
 public void doSaveAction() { 
  if (this.hasChanges()) { 
   this.viewController.saveProjectBean(this.bean); 
  } else { 
   this.setFormViewMode(); 
  } 
 } 
 
 public void doCancelAction() { 
  this.loadValues(); 
 } 
  
 private void setFormEmptyMode() { 
  this.form.setEmptyMode(); 
  this.viewController.setMainFormEnabled(true); 
 } 
 private void setFormViewMode() { 
  this.form.setViewMode(); 
  this.viewController.setMainFormEnabled(true); 
 } 
 private void setFormEditMode() { 
  this.form.setEditMode(); 



  

  this.viewController.setMainFormEnabled(false); 
 } 
} 
 

? Sub-pacote “questions”: 

? Interface CompetenceQuestionsForm.java: 
package view.questions; 
 
import java.util.List; 
import java.util.Map; 
 
import system.mvp.PassiveView; 
 
public interface CompetenceQuestionsForm extends PassiveView { 
  
 public enum FORM_FIELDS { 
  // LISTING FIELDS: 
  CATEGORY_LIST, 
  CQ_LIST, 
  // CATEGORY DETAILS FIELDS: 
  CATEGORY_NAME, 
  CATEGORY_DESCRIPTION, 
  //CQ DETAILS FIELDS: 
  CQ_QUESTION, 
  CQ_ANSWER 
 } 
  
 void setCategoriesList(Map&lt;Integer, String&gt; categories); 
  
 void setCompetenceQuestionsList( 
   Map&lt;Integer, String&gt; questionsMap, 
   Map&lt;Integer, String&gt; answersMap); 
  
 void setModalMode(boolean modalEnabled); 
  
 void showDetailToAddCategory(); 
 void showDetailToEditCategory(Integer idCode, String name, String 
description); 
 void showDetailToRemoveCategory(List&lt;Integer&gt; selectedCategories, 
boolean categoriesHaveCQs); 
  
 void showDetailToAddCompetenceQuestion(); 
 void showDetailToEditCompetenceQuestion( 
   Integer idCode, String question, String answer); 
 void showDetailToRemoveCompetenceQuestion(List&lt;Integer&gt; 
competenceQuestionIDsList); 
 void showDetailToMoveCompetenceQuestions(Integer sourceCategoryID, 
List&lt;Integer&gt; selectedIDs, 
   Map&lt;String, Integer&gt; destinationOptionsMap); 
} 
 

? Classe CompetenceQuestionsFormImpl.java: 
package view.questions; 
 
import java.util.ArrayList; 
import java.util.LinkedHashMap; 
import java.util.List; 
import java.util.Map; 
 
import system.mvp.Presenter; 
import system.utils.UtilClass; 
import system.utils.UtilClass.ValidationErrors; 
import view.ViewController; 
import view.questions.CompetenceQuestionsForm.FORM_FIELDS; 
import beans.CompetenceQuestionsBean; 
import beans.CompetenceQuestionsBean.OneCategory; 
import beans.CompetenceQuestionsBean.OneCompetenceQuestion; 
import data.CQ; 
import data.Category; 
 
public class CompetenceQuestionsPresenter extends Presenter { 
 
 private ViewController viewController; 



  

 private CompetenceQuestionsForm form; 
  
 private CompetenceQuestionsBean bean; 
 
 public CompetenceQuestionsPresenter(final ViewController 
viewController, final CompetenceQuestionsForm form) { 
  this.viewController = viewController; 
  this.form = form; 
  this.registerItselfInForm(); 
 } 
 
 @Override 
 protected void registerItselfInForm() { 
  this.form.registerPresenter(this); 
 } 
  
 @Override 
 public void fillIn() { 
  if (bean == null) { 
   this.bean = 
this.viewController.getCompetenceQuestionsBean(); 
  } 
  this.loadCategories(); 
  this.loadSelectedCategoryItems(UtilClass.NO_SELECTED_CATEGORY); 
 } 
 
 @Override 
 public void fillOut() { 
  this.bean = null; 
  this.loadCategories(); 
  this.loadSelectedCategoryItems(UtilClass.NO_SELECTED_CATEGORY); 
 } 
  
 /*------------------------------------- 
  * Método envolvidos com as Categorias: 
  -------------------------------------*/ 
 private void loadCategories() { 
  Map&lt;Integer, String&gt; categoriesMap = new LinkedHashMap&lt;Integer, 
String&gt;(0); 
  if (this.bean != null) { 
   categoriesMap = 
this.prepareCategoriesMap(this.bean.getCategoriesMap()); 
  } 
  this.form.setCategoriesList(categoriesMap); 
 } 
  
 public void doAddCategory() { 
  this.form.showDetailToAddCategory(); 
 } 
 public void doEditCategory(final Integer categoryID) { 
  if (categoryID != null &amp;amp;&amp;amp; categoryID &gt; 0) { 
   this.viewController.loadOneCategory(this.bean, 
categoryID); 
   final OneCategory oneCategory = 
this.bean.getOneCategory(); 
   if (oneCategory != null) { 
   
 this.form.showDetailToEditCategory(oneCategory.getIdCode(), 
      oneCategory.getName(), 
oneCategory.getDescription()); 
   } 
  } 
 } 
 public void doRemoveCategory(final List&lt;Integer&gt; categoryIDsList) { 
  final boolean categoriesHaveCQs = 
this.viewController.hasCQs(categoryIDsList); 
  this.form.showDetailToRemoveCategory(categoryIDsList, 
categoriesHaveCQs); 
 } 
  
 public void addCategory(final String categoryName, String 
categoryDescription) { 
  this.viewController.addCategory(this.bean, categoryName, 
categoryDescription); 
  this.fillIn(); 
 } 
  
 public void editCategory(final int categoryID, 
   final String categoryName, final String 
categoryDescription) { 



  

  this.viewController.editCategory(categoryID, categoryName, 
categoryDescription); 
  this.fillIn(); 
 } 
  
 public void removeCategories(final List&lt;Integer&gt; categoryIDsList) { 
  this.viewController.removeCategories(this.bean, 
categoryIDsList); 
  this.fillIn(); 
 } 
  
 /*---------------------------------------------------- 
  * Métodos envolvidos com as Perguntas de Competência: 
  ----------------------------------------------------*/ 
 public void doAddCQ() { 
  this.form.showDetailToAddCompetenceQuestion(); 
 } 
 public void doEditCQ(final Integer competenceQuestionID) { 
  if (competenceQuestionID != null &amp;amp;&amp;amp; competenceQuestionID &gt; 0) { 
   this.viewController.loadOneCQ(this.bean, 
competenceQuestionID); 
   final OneCompetenceQuestion oneCQ = 
this.bean.getOneCompetenceQuestion(); 
   if (oneCQ != null) { 
    this.form.showDetailToEditCompetenceQuestion( 
      oneCQ.getIdCode(), 
oneCQ.getQuestion(), oneCQ.getAnswer()); 
   } 
  } 
 } 
 public void doRemoveCQ(final List&lt;Integer&gt; competenceQuestionIDsList) { 
 
 this.form.showDetailToRemoveCompetenceQuestion(competenceQuestionIDsLis
t); 
 } 
  
 public void doMoveCQ(Integer sourceCategoryID, List&lt;Integer&gt; 
selectedIDs) { 
  this.form.showDetailToMoveCompetenceQuestions(sourceCategoryID, 
selectedIDs, 
   
 this.bean.getAvailableCategoriesToMove(sourceCategoryID));   
 } 
  
 public void addCompetenceQuestion(final Integer categoryID, 
   final String question, final String answer) { 
  this.viewController.addCompetenceQuestion(this.bean, categoryID, 
question, answer); 
 
 this.loadCompetenceQuestions(this.bean.getCompetenceQuestionsMap()); 
 } 
  
 public void editCompetenceQuestion(final Integer competenceQuestionID, 
   final String question, final String answer) { 
  this.viewController.editCompetenceQuestion(competenceQuestionID, 
question, answer); 
 
 this.loadCompetenceQuestions(this.bean.getCompetenceQuestionsMap()); 
 } 
  
 public void removeCompetenceQuestions(final Integer categoryID, 
   final List&lt;Integer&gt; competenceQuestionIDsList) { 
  this.viewController.removeCompetenceQuestions(this.bean, 
categoryID, competenceQuestionIDsList); 
 
 this.loadCompetenceQuestions(this.bean.getCompetenceQuestionsMap()); 
 } 
  
 public void moveCompetenceQuestions(final Integer sourceCategoryID, 
   final Integer targetCategoryID, final List&lt;Integer&gt; 
cqIDsList) { 
  this.viewController.moveCompetenceQuestions(this.bean, 
sourceCategoryID, targetCategoryID, cqIDsList); 
 
 this.loadCompetenceQuestions(this.bean.getCompetenceQuestionsMap()); 
 } 
  
 /*---------------------------------------------------------------------
-------- 



  

  * Métodos envolvidos tanto com Categorias quanto com Perguntas de 
Competência: 
  ----------------------------------------------------------------------
-------*/ 
 public void loadSelectedCategoryItems(final int categoryID) { 
  final Map&lt;Integer, CQ&gt; mapOfCQ; 
  switch (categoryID) { 
  case UtilClass.NO_SELECTED_CATEGORY: 
   mapOfCQ = null; 
   break; 
  case UtilClass.ALL_CATEGORIES_ID: 
   this.viewController.loadAllCQs(this.bean); 
   mapOfCQ = this.bean.getCompetenceQuestionsMap(); 
   break; 
  default: 
   this.viewController.loadCQsByCategory(this.bean, 
categoryID); 
   mapOfCQ = this.bean.getCompetenceQuestionsMap(); 
   break; 
  } 
  this.loadCompetenceQuestions(mapOfCQ); 
 } 
  
 private void loadCompetenceQuestions(final Map&lt;Integer, CQ&gt; mapOfCQ) { 
  CQsViewObject cqsViewObject = null; 
  if (mapOfCQ != null) { 
   cqsViewObject = this.prepareCQsMaps(mapOfCQ); 
  } 
  Map&lt;Integer, String&gt; questionsMap = null; 
  Map&lt;Integer, String&gt; answersMap = null; 
  if (cqsViewObject != null) { 
   questionsMap = cqsViewObject.getMapOfQuestionString(); 
   answersMap = cqsViewObject.getMapOfAnswerString(); 
  } 
  this.form.setCompetenceQuestionsList(questionsMap, answersMap); 
 } 
  
 /*----------------------- 
  * Métodos preparatórios: 
  -----------------------*/ 
 private Map&lt;Integer, String&gt; prepareCategoriesMap(final Map&lt;Integer, 
Category&gt; mapOfCategory) { 
  final int length = (mapOfCategory != null ? mapOfCategory.size() 
: 0); 
  Map&lt;Integer, String&gt; mapOfString = new LinkedHashMap&lt;Integer, 
String&gt;(length); 
  if (length &gt; 0) { 
   mapOfString.put(UtilClass.ALL_CATEGORIES_ID, 
UtilClass.ALL_CATEGORIES_LABEL); 
   final List&lt;Category&gt; categories = new 
ArrayList&lt;Category&gt;(mapOfCategory.values()); 
   for (Category category : categories) { 
    mapOfString.put(category.getIdCode(), 
category.getName()); 
   } 
  } 
  return mapOfString; 
 } 
  
 private CQsViewObject prepareCQsMaps(final Map&lt;Integer, CQ&gt; mapOfCQ) { 
  final int length = (mapOfCQ != null ? mapOfCQ.size() : 0); 
  Map&lt;Integer, String&gt; mapOfQuestionString = new 
LinkedHashMap&lt;Integer, String&gt;(length); 
  Map&lt;Integer, String&gt; mapOfAnswerString = new 
LinkedHashMap&lt;Integer, String&gt;(0); 
   
  if (length &gt; 0) { 
   final List&lt;CQ&gt; cqList = new 
ArrayList&lt;CQ&gt;(mapOfCQ.values()); 
   for (CQ cq : cqList) { 
    final Integer key = cq.getIdCode(); 
    mapOfQuestionString.put(key, 
cq.getQuestion().getSentence()); 
    final String answer = 
cq.getAnswer().getSentence(); 
    if (!UtilClass.isNullOrEmpty(answer)) { 
     mapOfAnswerString.put(key, answer); 
    } 
   } 
  } 



  

  return new CQsViewObject(mapOfQuestionString, 
mapOfAnswerString); 
 } 
  
 /** 
  * Objeto interno para retorno, a partir do método preparatório 
  * dos mapeamentos das perguntas e respostas ao método de envio ao 
form. 
  */ 
 private class CQsViewObject { 
   
  private final Map&lt;Integer, String&gt; mapOfQuestionString; 
  private final Map&lt;Integer, String&gt; mapOfAnswerString; 
   
  public CQsViewObject(final Map&lt;Integer, String&gt; 
mapOfQuestionString, 
    final Map&lt;Integer, String&gt; mapOfAnswerString) { 
   this.mapOfQuestionString = mapOfQuestionString; 
   this.mapOfAnswerString = mapOfAnswerString; 
  } 
 
  public Map&lt;Integer, String&gt; getMapOfQuestionString() { 
   return mapOfQuestionString; 
  } 
 
  public Map&lt;Integer, String&gt; getMapOfAnswerString() { 
   return mapOfAnswerString; 
  } 
   
 } 
  
 public void setModalMode(boolean modalEnabled) { 
  this.viewController.setMainFormEnabled(!modalEnabled); 
  this.form.setModalMode(modalEnabled); 
 } 
 
 public Map&lt;FORM_FIELDS, List&lt;ValidationErrors&gt;&gt; validateCategoryDetail( 
   final Integer idCode, final String name, final String 
description) { 
  Map&lt;FORM_FIELDS, List&lt;ValidationErrors&gt;&gt; errors = 
   new LinkedHashMap&lt;FORM_FIELDS, 
List&lt;ValidationErrors&gt;&gt;(0); 
   
  if (name == null || name.trim().isEmpty()) { 
   errors.put(FORM_FIELDS.CATEGORY_NAME, 
    
 UtilClass.getOneItemList(ValidationErrors.NULL_FIELD)); 
  } else if (this.bean.existCategoryName(idCode, name)) { 
   errors.put(FORM_FIELDS.CATEGORY_NAME, 
    
 UtilClass.getOneItemList(ValidationErrors.EXISTED_VALUE)); 
  } 
  return errors; 
 } 
 
 public Map&lt;FORM_FIELDS, List&lt;ValidationErrors&gt;&gt; validateCQDetail( 
   final Integer idCode, final String question, final 
String answer) { 
  Map&lt;FORM_FIELDS, List&lt;ValidationErrors&gt;&gt; errors = 
   new LinkedHashMap&lt;FORM_FIELDS, 
List&lt;ValidationErrors&gt;&gt;(0); 
   
  if (question == null || question.trim().isEmpty()) { 
   errors.put(FORM_FIELDS.CQ_QUESTION, 
    
 UtilClass.getOneItemList(ValidationErrors.NULL_FIELD)); 
  } 
  return errors; 
 } 
} 
 

? Sub-pacote “terms”: 

? Interface TermsForm.java: 
package view.terms; 
 



  

import java.util.List; 
import java.util.Map; 
import java.util.Set; 
 
import system.mvp.PassiveView; 
import system.utils.UtilClass.MESSAGES; 
 
public interface TermsForm extends PassiveView { 
  
 public enum OrderByOptions { 
  ALPHABET("Alphabet"), 
  FREQUENCY("Frequency"), 
  POSITION("Position"); 
   
  private final String label; 
   
  private OrderByOptions(final String label) { 
   this.label = label; 
  } 
 
  public String getLabel() { 
   return label; 
  } 
   
  public static OrderByOptions getOptionByOrdinal(final int 
ordinal) { 
   if (ALPHABET.ordinal() == ordinal) { 
    return ALPHABET; 
   } else if (FREQUENCY.ordinal() == ordinal) { 
    return FREQUENCY; 
   } else { 
    return POSITION; 
   } 
  } 
 } 
  
 OrderByOptions getOrderByOption(); 
 
 List&lt;String&gt; getNotOrderedTerms(); 
  
 List&lt;String&gt; getOrderedTerms(); 
  
 void setModalMode(boolean modalEnabled); 
 
 void setExtractedTermsList(Map&lt;String, String&gt; extractedTermsMap); 
 
 void setChosenTermsList(Map&lt;String, String&gt; chosenTermsMap); 
 
 void setTermsPersistenceNeed(boolean needed); 
 
 void showDetailToExtractTerms(Map&lt;String, Integer&gt; 
availableCategoriesToExtract); 
 
 void showDetailToRemoveTerms(List&lt;String&gt; termsList); 
  
 void showDetailToOrderTerms(List&lt;String&gt; orderedTerms, List&lt;String&gt; 
notOrderedTerms); 
  
 void showException(MESSAGES exceptionEnum); 
 
 void finishOrderTerms(); 
  
 void showDetailToCombineTerms(List&lt;String&gt; termsList, 
   Set&lt;Integer&gt; commonQuestions, Set&lt;Integer&gt; 
commonAnswers); 
 
 void finishCombineTerms(MESSAGES message); 
 
} 
 

? Classe TermsFormImpl.java: 
package view.terms; 
 
import java.text.MessageFormat; 
import java.util.ArrayList; 
import java.util.Collection; 
import java.util.LinkedHashMap; 
import java.util.LinkedHashSet; 



  

import java.util.List; 
import java.util.Map; 
import java.util.Set; 
 
import system.mvp.Presenter; 
import system.utils.UtilClass; 
import system.utils.UtilClass.MESSAGES; 
import system.utils.UtilClass.ValidationErrors; 
import view.ViewController; 
import view.terms.TermsForm.OrderByOptions; 
import beans.TermsBean; 
import beans.TermsBean.MappedTerm; 
 
public class TermsPresenter extends Presenter { 
 
 private ViewController viewController; 
 private TermsForm form; 
  
 private TermsBean bean; 
 
 public TermsPresenter(final ViewController viewController, final 
TermsForm form) { 
  this.viewController = viewController; 
  this.form = form; 
  this.registerItselfInForm(); 
 } 
 
 @Override 
 protected void registerItselfInForm() { 
  this.form.registerPresenter(this); 
 } 
 
 @Override 
 public void fillIn() { 
  if (this.bean == null) { 
   this.bean = this.viewController.getTermsBean(); 
  } 
  this.loadChosenTerms(); 
  this.loadExtractedTerms(); 
  this.defineTermsPersistenceNeed(); 
 } 
 
 @Override 
 public void fillOut() { 
  this.bean = null; 
  this.loadChosenTerms(); 
  this.loadExtractedTerms(); 
 } 
  
 private void loadExtractedTerms() { 
  Map&lt;String, String&gt; extractedTermsMap = new 
LinkedHashMap&lt;String, String&gt;(0); 
  if (this.bean != null) { 
   extractedTermsMap = this.prepareTermsMap( 
    
 this.bean.valuesOfExtractedTermsMap(this.form.getOrderByOption())); 
  } 
  this.form.setExtractedTermsList(extractedTermsMap); 
 } 
 
 private void loadChosenTerms() { 
  Map&lt;String, String&gt; chosenTermsMap = new LinkedHashMap&lt;String, 
String&gt;(0); 
  if (this.bean != null) { 
   chosenTermsMap = this.prepareTermsMap( 
    
 this.bean.valuesOfChosenTermsMap(this.form.getOrderByOption())); 
  } 
  this.form.setChosenTermsList(chosenTermsMap); 
 } 
  
 private Map&lt;String, String&gt; prepareTermsMap(final 
Collection&lt;MappedTerm&gt; valuesOfMap) { 
  final int length = (valuesOfMap != null ? valuesOfMap.size() : 
0); 
  Map&lt;String, String&gt; mapStringToString = new 
LinkedHashMap&lt;String, String&gt;(length); 
  if (length &gt; 0) { 
   for (MappedTerm mappedTerm : valuesOfMap) { 



  

    final StringBuilder strBuilder = new 
StringBuilder( 
      mappedTerm.getTerm() + 
UtilClass.TERMS_INIT_DETAILS_TAG); 
    final Integer idCode = mappedTerm.getIdCode(); 
    if (idCode != null) { 
     strBuilder.append( 
      
 MessageFormat.format(UtilClass.TERMS_IDCODE_TAG, idCode)); 
    } 
    if (mappedTerm.getOriginQuestions().size() &gt; 0) { 
     strBuilder.append( 
      
 MessageFormat.format(UtilClass.TERMS_ORIGIN_QUESTIONS_TAG,  
      
 mappedTerm.getOriginQuestions().toString())); 
    } 
    if (mappedTerm.getOriginAnswers().size() &gt; 0) { 
     strBuilder.append( 
      
 MessageFormat.format(UtilClass.TERMS_ORIGIN_ANSWERS_TAG, 
      
 mappedTerm.getOriginAnswers().toString())); 
    } 
    final Integer order = 
mappedTerm.getOrderPosition(); 
    if (order != null) { 
     strBuilder.append( 
      
 MessageFormat.format(UtilClass.TERMS_ORDER_TAG, order)); 
    } 
    mapStringToString.put(mappedTerm.getTerm(), 
strBuilder.toString()); 
   } 
  } 
  return mapStringToString; 
 } 
  
 private TermsOrderListsObject prepareTermsMapToOrder() { 
  final Collection&lt;MappedTerm&gt; valuesOfMap = 
this.bean.valuesOfChosenTermsMap(OrderByOptions.POSITION); 
  final int length = (valuesOfMap != null ? valuesOfMap.size() : 
0); 
  List&lt;String&gt; orderedTerms = null; 
  List&lt;String&gt; notOrderedTerms = null; 
  if (length &gt; 0) { 
   orderedTerms = new ArrayList&lt;String&gt;(0); 
   notOrderedTerms = new ArrayList&lt;String&gt;(0); 
   for (MappedTerm mappedTerm : valuesOfMap) { 
    final Integer position = 
mappedTerm.getOrderPosition(); 
    final String term = 
UtilClass.formatTermsMapKey(mappedTerm.getTerm()); 
    if (position != null) { 
     orderedTerms.add(term); 
    } else { 
     notOrderedTerms.add(term); 
    } 
   } 
  } 
  return new TermsOrderListsObject(orderedTerms, notOrderedTerms); 
 } 
 
 private void defineTermsPersistenceNeed() { 
  final boolean needed; 
  if (this.bean != null) { 
   needed = !this.bean.isChosenEqualsInitMap(); 
  } else { 
   needed = false; 
  } 
  this.form.setTermsPersistenceNeed(needed); 
 } 
  
 private class TermsOrderListsObject { 
  private final List&lt;String&gt; orderedTerms; 
  private final List&lt;String&gt; notOrderedTerms; 
   
  public TermsOrderListsObject(final List&lt;String&gt; orderedTerms, 
    final List&lt;String&gt; notOrderedTerms) { 
   this.orderedTerms = orderedTerms; 



  

   this.notOrderedTerms = notOrderedTerms; 
  } 
 
  public List&lt;String&gt; getOrderedTerms() { 
   return orderedTerms; 
  } 
 
  public List&lt;String&gt; getNotOrderedTerms() { 
   return notOrderedTerms; 
  } 
 } 
  
 /*--------------------------- 
  * Buttons Incomming Methods: 
  ---------------------------*/ 
 public void doExtractTerms() { 
 
 this.form.showDetailToExtractTerms(this.bean.getAvailableCategoriesToEx
tract()); 
 } 
  
 public void doRemoveTerm(final List&lt;String&gt; termsList) { 
  this.form.showDetailToRemoveTerms(termsList); 
 } 
  
 public void doOrderTerms() { 
  List&lt;String&gt; orderedTerms = null; 
  List&lt;String&gt; notOrderedTerms = null; 
  if (this.bean != null) { 
   final TermsOrderListsObject tolo = 
    this.prepareTermsMapToOrder(); 
   orderedTerms = tolo.getOrderedTerms(); 
   notOrderedTerms = tolo.getNotOrderedTerms(); 
  } 
  this.form.showDetailToOrderTerms(orderedTerms, notOrderedTerms); 
 } 
  
 public void doConfirmOrderedTerms() { 
  final Map&lt;String, MappedTerm&gt; chosenTermsMap = 
this.bean.getChosenTermsMap(); 
   
  final List&lt;String&gt; notOrderedTermsList = 
this.form.getNotOrderedTerms(); 
  if (notOrderedTermsList != null &amp;amp;&amp;amp; notOrderedTermsList.size() &gt; 
0) { 
   for (int i=0; i &amp;lt;notOrderedTermsList.size(); i++) { 
    final String term = 
UtilClass.formatTermsMapKey(notOrderedTermsList.get(i)); 
    chosenTermsMap.get(term).setOrderPosition(null); 
   } 
  } 
 
  final List&lt;String&gt; orderedTermsList = 
this.form.getOrderedTerms(); 
  if (orderedTermsList != null &amp;amp;&amp;amp; orderedTermsList.size() &gt; 0) { 
   for (int i=0; i &amp;lt;orderedTermsList.size(); i++) { 
    final String term = 
UtilClass.formatTermsMapKey(orderedTermsList.get(i)); 
    chosenTermsMap.get(term).setOrderPosition(i+1); 
   } 
  } 
   
  this.loadChosenTerms(); 
  this.form.finishOrderTerms(); 
 } 
  
 public void doCombineTerms(final List&lt;String&gt; termsList) { 
  if (termsList != null &amp;amp;&amp;amp; termsList.size() &gt; 0) { 
   final Map&lt;String, MappedTerm&gt; extractedTermsMap = 
this.bean.getExtractedTermsMap(); 
   final Map&lt;Integer, Integer&gt; mapQuestions = new 
LinkedHashMap&lt;Integer, Integer&gt;(0); 
   final Map&lt;Integer, Integer&gt; mapAnswers = new 
LinkedHashMap&lt;Integer, Integer&gt;(0); 
    
   for (String strTerm : termsList) { 
    final String term = 
UtilClass.formatTermsMapKey(strTerm); 
    final MappedTerm mappedTerm = 
extractedTermsMap.get(term); 



  

    this.appendOrigins(mapQuestions, 
mappedTerm.getOriginQuestions()); 
    this.appendOrigins(mapAnswers, 
mappedTerm.getOriginAnswers()); 
   } 
    
   final int commonNeededQuant = termsList.size(); 
   final Set&lt;Integer&gt; commonQuestions = 
this.compareOrigins(mapQuestions, commonNeededQuant); 
   final Set&lt;Integer&gt; commonAnswers = 
this.compareOrigins(mapAnswers, commonNeededQuant); 
    
   if (commonQuestions.size() &gt; 0 || commonAnswers.size() &gt; 
0) { 
    this.form.showDetailToCombineTerms(termsList, 
commonQuestions, commonAnswers); 
   } else { 
   
 this.form.showException(MESSAGES.NO_COMMON_ORIGINS); 
   } 
  } 
 } 
 
 private void appendOrigins(final Map&lt;Integer, Integer&gt; mapOrigins, 
   final Set&lt;Integer&gt; originSet) { 
  if (mapOrigins != null &amp;amp;&amp;amp; originSet != null) { 
   for (Integer origin : originSet) { 
    if (mapOrigins.containsKey(origin)) { 
     int quant = mapOrigins.get(origin); 
     mapOrigins.put(origin, ++quant); 
    } else { 
     mapOrigins.put(origin, 1); 
    } 
   } 
  } 
 } 
  
 private Set&lt;Integer&gt; compareOrigins(final Map&lt;Integer, Integer&gt; 
mapOrigins, 
   final int commonNeededQuant) { 
  final Set&lt;Integer&gt; commonOrigins = new 
LinkedHashSet&lt;Integer&gt;(0); 
  for (Integer origin : mapOrigins.keySet()) { 
   if (commonNeededQuant == mapOrigins.get(origin)) { 
    commonOrigins.add(origin); 
   } 
  } 
  return commonOrigins; 
 } 
  
 public void setModalMode(boolean modalEnabled) { 
  this.viewController.setMainFormEnabled(!modalEnabled); 
  this.form.setModalMode(modalEnabled); 
  if (!modalEnabled) { 
   this.defineTermsPersistenceNeed(); 
  } 
 } 
  
 public void changeListsOrdenation() { 
  this.loadExtractedTerms(); 
  this.loadChosenTerms(); 
 } 
  
 public void extractTerms(final Integer categoryID) { 
  try { 
   this.viewController.extractTerms(this.bean, categoryID); 
   this.loadExtractedTerms(); 
  } catch (Exception e) { 
  
 this.form.showException(UtilClass.MESSAGES.EXTRACT_TERMS_EXCEPTION); 
   e.printStackTrace();  
  } 
 } 
 
 public void addExtractedTerms(final List&lt;String&gt; termsList) { 
  this.bean.moveTermsToChosenMap(termsList); 
  this.loadExtractedTerms(); 
  this.loadChosenTerms(); 
  this.defineTermsPersistenceNeed(); 
 } 



  

  
 public void addCombinedTerms(final List&lt;String&gt; combinedTermsList, 
   final Set&lt;Integer&gt; commonQuestions, final Set&lt;Integer&gt; 
commonAnswers) { 
  MESSAGES message = null; 
  try { 
   this.bean.addCombinedTermsToChosenMap( 
     combinedTermsList, commonQuestions, 
commonAnswers); 
   this.loadChosenTerms(); 
   this.defineTermsPersistenceNeed(); 
  } catch (Exception ex) { 
   if 
(ValidationErrors.EXISTED_VALUE.toString().equals(ex.getMessage())) { 
    message = MESSAGES.TERM_ALLREADY_EXIST; 
   } else { 
    message = MESSAGES.COMBINE_TERMS_EXCEPTION; 
   } 
  } finally { 
   this.form.finishCombineTerms(message); 
  } 
 } 
 
 public void removeChosenTerms(final List&lt;String&gt; termsList) { 
  final List&lt;Integer&gt; persistedTermIDs = 
   this.bean.removeNotPersistedChosenTerms(termsList); 
  if (persistedTermIDs.size() &gt; 0) { 
   this.viewController.removePersistedTerms(this.bean, 
persistedTermIDs); 
  } 
  this.loadExtractedTerms(); 
  this.loadChosenTerms(); 
  this.defineTermsPersistenceNeed(); 
 } 
 
 public void persistTerms() { 
  this.viewController.persistTerms(this.bean); 
  this.loadChosenTerms(); 
  this.defineTermsPersistenceNeed(); 
 } 
} 
 

? Projeto “View-CQPlugin” — projeto de camada visual 

para a aplicação proposta. 
 

? Pacote “gui”: 

? Classe CompetenceQuestionsFormImpl.java: 
package gui; 
 
import java.awt.Dimension; 
import java.awt.FlowLayout; 
import java.awt.GridBagConstraints; 
import java.awt.GridBagLayout; 
import java.awt.Insets; 
import java.util.ArrayList; 
import java.util.LinkedHashMap; 
import java.util.List; 
import java.util.Map; 
import java.util.Vector; 
 
import javax.swing.JButton; 
import javax.swing.JDesktopPane; 
import javax.swing.JInternalFrame; 
import javax.swing.JLabel; 
import javax.swing.JList; 
import javax.swing.JOptionPane; 
import javax.swing.JPanel; 
import javax.swing.JScrollPane; 
import javax.swing.JSplitPane; 
import javax.swing.JTextArea; 
import javax.swing.JTextField; 



  

import javax.swing.WindowConstants; 
 
import system.mvp.Presenter; 
import system.utils.UtilClass; 
import system.utils.UtilClass.ValidationErrors; 
import view.questions.CompetenceQuestionsForm; 
import view.questions.CompetenceQuestionsPresenter; 
 
public class CompetenceQuestionsFormImpl extends JDesktopPane implements 
  CompetenceQuestionsForm { 
 
 private static final long serialVersionUID = 1L; 
  
 private static final String NEW_CATEGORY_TITLE = "New Category"; 
 private static final String EDIT_CATEGORY_TITLE = "Edit Category"; 
  
 private static final String NEW_CQ_TITLE = "New Competence Question"; 
 private static final String EDIT_CQ_TITLE = "Edit Competence Question"; 
  
 private static final String REMOVE_CATEGORY_MAIN_TEXT = 
  "You really want to remove the selected category(ies)?"; 
 private static final String REMOVE_CATEGORY_PROCEDURE_TEXT_LINE_1 = 
  "If there are competence questions in this(ese) category(ies),"; 
 private static final String REMOVE_CATEGORY_PROCEDURE_TEXT_LINE_2 = 
  "they will be moved to the default category."; 
  
 private CategoryParams filledInCategoryParams = null; 
 private List&lt;Integer&gt; selectedCategoriesToRemove = null; 
 private CQParams filledInCQParams = null; 
  
 private CompetenceQuestionsPresenter presenter; 
 private JSplitPane jSplitPane = null; 
 private JPanel panelCategories = null; 
 private JPanel panelCQs = null; 
 private JLabel captionCategoriesPanel = null; 
 private JButton buttonAddCategory = null; 
 private JButton buttonEditCategory = null; 
 private JButton buttonRemoveCategory = null; 
 private JScrollPane scrollPaneCategories = null; 
 private JLabel captionCQsPanel = null; 
 private JButton buttonAddCQ = null; 
 private JButton buttonEditCQ = null; 
 private JButton buttonRemoveCQ = null; 
 private JScrollPane scrollPaneCQs = null; 
 private JListCategories jListCategories = null; 
 private JListCQs jListCQs = null; 
 private JInternalFrame jInternalFrameCategoryDetail = null; 
 private JPanel jContentPaneCategoryDetail = null; 
 private JLabel captionCategDetailName = null; 
 private JTextField fieldCategDetailName = null; 
 private JLabel captionCategDetailDescription = null; 
 private JScrollPane scrollPaneCategDetailDescription = null; 
 private JTextArea fieldCategDetailDescription = null; 
 private JPanel bottomBarCategDetail = null; 
 private JButton buttonCategDetailConfirm = null; 
 private JButton buttonCategDetailCancel = null; 
 private JLabel infoRequiredCategDetail = null; 
 private JInternalFrame jInternalFrameRemoveCategory = null; 
 private JPanel jContentPaneRemoveCategory = null; 
 private JPanel bottomBarRemoveCateg = null; 
 private JButton buttonRemoveCategConfirm = null; 
 private JButton buttonRemoveCategCancel = null; 
 private JLabel labelRemoveCategProcedureLine1 = null; 
 private JLabel labelRemoveCategMainLine = null; 
 private JLabel labelRemoveCategProcedureLine2 = null; 
 private JInternalFrame jInternalFrameCQDetail = null; 
 private JPanel jContentPaneCQDetail = null; 
 private JLabel captionCQDetailQuestion = null; 
 private JTextField fieldCQDetailQuestion = null; 
 private JLabel captionCQDetailAnswer = null; 
 private JTextField fieldCQDetailAnswer = null; 
 private JPanel bottomBarCQDetail = null; 
 private JButton buttonCQDetailConfirm = null; 
 private JButton buttonCQDetailCancel = null; 
 private JLabel infoRequiredCQDetail = null; 
 private JButton buttonMoveCQ = null; 
 
 public CompetenceQuestionsFormImpl() { 
  super(); 
  initialize(); 



  

 } 
 
 private void initialize() { 
  GridBagConstraints gridBagConstraints = new 
GridBagConstraints(); 
  gridBagConstraints.fill = GridBagConstraints.BOTH; 
  gridBagConstraints.gridy = 0; 
  gridBagConstraints.weightx = 1.0; 
  gridBagConstraints.weighty = 1.0; 
  gridBagConstraints.gridx = 0; 
  this.setSize(500, 300); 
  this.setLayout(new GridBagLayout()); 
  this.add(getJSplitPane(), gridBagConstraints); 
 } 
  
 private void showInfoMessage(final String message) { 
  JOptionPane.showMessageDialog(this, message); 
 } 
  
 /*------------------- 
  * Overrided Methods: 
  -------------------*/ 
 @Override 
 public void setVisible(final boolean flag) { 
  super.setVisible(flag); 
  if (this.presenter != null) { 
   if (flag) { 
    this.presenter.fillIn(); 
   } else { 
    this.presenter.fillOut(); 
   } 
  } 
 } 
  
 /*------------------- 
  * Interface Methods: 
  -------------------*/ 
 @Override 
 public&amp;lt;T extends Presenter&gt; void registerPresenter(T presenter) { 
  this.presenter = (CompetenceQuestionsPresenter)presenter; 
 } 
 
 @Override 
 public void setCategoriesList(Map&lt;Integer, String&gt; categories) { 
  this.jListCategories.setData(categories); 
 } 
 
 @Override 
 public void setCompetenceQuestionsList( 
   Map&lt;Integer, String&gt; questionsMap, 
   Map&lt;Integer, String&gt; answersMap) { 
  this.jListCQs.setData(questionsMap, answersMap); 
 } 
  
 @Override 
 public void setModalMode(boolean modalEnabled) { 
  final boolean enabled = !modalEnabled; 
   
  this.jSplitPane.setEnabled(enabled); 
   
  this.jListCategories.setEnabled(enabled); 
  this.buttonAddCategory.setEnabled(enabled); 
  this.buttonEditCategory.setEnabled(enabled); 
  this.buttonRemoveCategory.setEnabled(enabled); 
   
  this.jListCQs.setEnabled(enabled); 
  this.buttonAddCQ.setEnabled(enabled); 
  this.buttonEditCQ.setEnabled(enabled); 
  this.buttonRemoveCQ.setEnabled(enabled); 
 } 
  
 @Override 
 public void showDetailToAddCategory() { 
  this.showCategoryDetail(true, null); 
 } 
  
 @Override 
 public void showDetailToEditCategory(final Integer idCode, 
   final String name, final String description) { 



  

  this.showCategoryDetail(false, new CategoryParams(idCode, name, 
description)); 
 } 
  
 @Override 
 public void showDetailToRemoveCategory(final List&lt;Integer&gt; 
selectedCategories, 
   final boolean categoriesHaveCQs) { 
  this.selectedCategoriesToRemove = selectedCategories; 
  this.showRemoveCategory(categoriesHaveCQs); 
 } 
  
 @Override 
 public void showDetailToAddCompetenceQuestion() { 
  this.showCQDetail(true, null); 
 } 
 
 @Override 
 public void showDetailToEditCompetenceQuestion(final Integer idCode, 
   final String question, final String answer) { 
  this.showCQDetail(false, new CQParams(idCode, question, 
answer)); 
 } 
  
 @Override 
 public void showDetailToRemoveCompetenceQuestion(final List&lt;Integer&gt; 
competenceQuestionIDsList) { 
  final String title = "Removing competence question..."; 
  final String message = 
   "Are you sure you want to remove the selected 
questions?\n" + 
    "If there are answers to them, these will be 
removed too."; 
  final int choice = JOptionPane.showConfirmDialog( 
    CompetenceQuestionsFormImpl.this, 
    message, title, JOptionPane.OK_CANCEL_OPTION); 
  if (choice == JOptionPane.OK_OPTION) { 
   final Integer categoryID = 
jListCategories.getSelectedDataID(); 
   this.presenter.removeCompetenceQuestions(categoryID, 
competenceQuestionIDsList); 
  } 
 } 
  
 @Override 
 public void showDetailToMoveCompetenceQuestions(final Integer 
sourceCategoryID, final List&lt;Integer&gt; selectedIDs, 
   final Map&lt;String, Integer&gt; destinationOptionsMap) { 
  if (destinationOptionsMap != null &amp;amp;&amp;amp; 
destinationOptionsMap.size() &gt; 0) { 
   String[] destinations = 
destinationOptionsMap.keySet().toArray(new String[]{}); 
   final String choice = 
this.showMoveCQsDialog(destinations); 
   if (choice != null &amp;amp;&amp;amp; !choice.isEmpty()) { 
    final Integer targetCategoryID = 
destinationOptionsMap.get(choice); 
   
 presenter.moveCompetenceQuestions(sourceCategoryID, targetCategoryID, 
selectedIDs); 
   } 
  } else { 
   this.showInfoMessage( 
     "There aren't categories available to 
move\n" + 
     "the selected competence questions."); 
  } 
 } 
  
 /*--------------------------------- 
  * Components manipulation methods: 
  ---------------------------------*/ 
 private void showCategoryDetail(final boolean newCategory, final 
CategoryParams params) { 
  if (this.jInternalFrameCategoryDetail == null) { 
   this.add(this.getJInternalFrameCategoryDetail(), null); 
  } 
  this.jInternalFrameCategoryDetail.setTitle( 
    newCategory ? NEW_CATEGORY_TITLE : 
EDIT_CATEGORY_TITLE); 



  

  this.fillInCategoryDetail(params); 
  this.jInternalFrameCategoryDetail.show(); 
 } 
  
 private void fillInCategoryDetail(final CategoryParams params) { 
  if (this.jInternalFrameCategoryDetail != null) { 
   String name = null; 
   String description = null; 
   if (params != null) { 
    name = params.getName(); 
    description = params.getDescription(); 
   } 
   this.fieldCategDetailName.setText(name); 
   this.fieldCategDetailDescription.setText(description); 
    
   this.filledInCategoryParams = params; 
  } 
 } 
  
 private CategoryParams fillOutCategoryDetail() { 
  if (this.jInternalFrameCategoryDetail != null) { 
   final String name = this.fieldCategDetailName.getText(); 
   final String description = 
this.fieldCategDetailDescription.getText(); 
   final Integer idCode = (this.filledInCategoryParams != 
null ? 
     this.filledInCategoryParams.getIdCode() : 
null); 
   return new CategoryParams(idCode, name, description); 
  } 
  return null; 
 } 
  
 private void showRemoveCategory(final boolean categoriesHaveCQs) { 
  if (this.jInternalFrameRemoveCategory == null) { 
   this.add(this.getJInternalFrameRemoveCategory(), null); 
  } 
  final String mainLabel = REMOVE_CATEGORY_MAIN_TEXT; 
  final String procedureLine1 = 
REMOVE_CATEGORY_PROCEDURE_TEXT_LINE_1; 
  final String procedureLine2 = 
REMOVE_CATEGORY_PROCEDURE_TEXT_LINE_2; 
  this.labelRemoveCategMainLine.setText(mainLabel); 
  this.labelRemoveCategProcedureLine1.setText(procedureLine1); 
  this.labelRemoveCategProcedureLine2.setText(procedureLine2); 
  this.jInternalFrameRemoveCategory.show(); 
 } 
  
 private void showCQDetail(final boolean newCQ, final CQParams params) { 
  if (this.jInternalFrameCQDetail == null) { 
   this.add(this.getJInternalFrameCQDetail(), null); 
  } 
  this.jInternalFrameCQDetail.setTitle( 
    newCQ ? NEW_CQ_TITLE : EDIT_CQ_TITLE); 
  this.fillInCQDetail(params); 
  this.jInternalFrameCQDetail.show(); 
 } 
  
 private void fillInCQDetail(final CQParams params) { 
  if (this.jInternalFrameCQDetail != null) { 
   String question = null; 
   String answer = null; 
   if (params != null) { 
    question = params.getQuestion(); 
    answer = params.getAnswer(); 
   } 
   this.fieldCQDetailQuestion.setText(question); 
   this.fieldCQDetailAnswer.setText(answer); 
    
   this.filledInCQParams = params; 
  } 
 } 
  
 private CQParams fillOutCQDetail() { 
  if (this.jInternalFrameCQDetail != null) { 
   final String question = 
this.fieldCQDetailQuestion.getText(); 
   final String answer = 
this.fieldCQDetailAnswer.getText(); 
   final Integer idCode = (this.filledInCQParams != null ? 



  

     this.filledInCQParams.getIdCode() : 
null); 
   return new CQParams(idCode, question, answer); 
  } 
  return null; 
 } 
  
 private String showMoveCQsDialog(final String[] destinations) { 
  final String title = "Moving competence questions..."; 
  final String message = 
   "Select the category in which to move\n" + 
    "the selected competence questions."; 
  final String choice = 
   (String)JOptionPane.showInputDialog(this, message, 
title, 
     JOptionPane.OK_CANCEL_OPTION, null, 
destinations, destinations[0]); 
  return choice; 
 } 
 
 /*--------------------------- 
  * Data Manipulation Methods: 
  ---------------------------*/ 
 private void applyCategoryDetailErrorsMap( 
   Map&lt;FORM_FIELDS, List&lt;ValidationErrors&gt;&gt; 
fieldsErrorsMap, 
   List&lt;String&gt; messageList) { 
  if (fieldsErrorsMap.containsKey(FORM_FIELDS.CATEGORY_NAME)) { 
   List&lt;ValidationErrors&gt; errorList = 
fieldsErrorsMap.get(FORM_FIELDS.CATEGORY_NAME); 
   for (ValidationErrors error : errorList) { 
    switch (error) { 
    case NULL_FIELD: 
     messageList.add("Inform the name of the 
category."); 
     break; 
    case EXISTED_VALUE: 
     messageList.add("The given name already 
exists."); 
     break; 
    } 
   } 
  } 
 } 
  
 private void applyCQDetailErrorsMap( 
   Map&lt;FORM_FIELDS, List&lt;ValidationErrors&gt;&gt; 
fieldsErrorsMap, 
   List&lt;String&gt; messageList) { 
  if (fieldsErrorsMap.containsKey(FORM_FIELDS.CQ_QUESTION)) { 
   List&lt;ValidationErrors&gt; errorList = 
fieldsErrorsMap.get(FORM_FIELDS.CQ_QUESTION); 
   for (ValidationErrors error : errorList) { 
    switch (error) { 
    case NULL_FIELD: 
     messageList.add("You must inform the 
question sentence of the competence question."); 
     break; 
    } 
   } 
  } 
 } 
  
 /** 
  * Cerifica se há apenas uma categoria selecionada 
  * e se esta é valida (não pode ser o item "&lt;All Categories&gt;") 
  * @return {@linkplain boolean} Retorna&amp;lt;code&gt;true&lt;/code&gt; 
  *     se apenas uma categoria válida estiver 
selecionada. 
  */ 
 private boolean hasSelectedOneValidCategory() { 
  if (this.jListCategories != null &amp;amp;&amp;amp; 
this.jListCategories.isEnabled()) { 
   final List&lt;Integer&gt; selectedIDs = 
this.jListCategories.getSelectedDataIDsList(); 
   final int quantSelectedIDs = selectedIDs.size(); 
   if (quantSelectedIDs == 1) { 
    if (UtilClass.ALL_CATEGORIES_ID != 
selectedIDs.get(0)) { 
     return true; 



  

    } 
   } 
  } 
  return false; 
 } 
  
 private JSplitPane getJSplitPane() { 
  if (jSplitPane == null) { 
   jSplitPane = new JSplitPane(); 
   jSplitPane.setLeftComponent(getPanelCategories()); 
   jSplitPane.setRightComponent(getPanelCQs()); 
  } 
  return jSplitPane; 
 } 
 
 private JPanel getPanelCategories() { 
  if (panelCategories == null) { 
   GridBagConstraints gridBagConstraints5 = new 
GridBagConstraints(); 
   gridBagConstraints5.fill = GridBagConstraints.BOTH; 
   gridBagConstraints5.gridy = 2; 
   gridBagConstraints5.weightx = 1.0; 
   gridBagConstraints5.weighty = 1.0; 
   gridBagConstraints5.gridwidth = 3; 
   gridBagConstraints5.insets = new Insets(2, 2, 2, 2); 
   gridBagConstraints5.gridx = 0; 
   GridBagConstraints gridBagConstraints4 = new 
GridBagConstraints(); 
   gridBagConstraints4.gridx = 2; 
   gridBagConstraints4.insets = new Insets(1, 1, 1, 1); 
   gridBagConstraints4.anchor = 
GridBagConstraints.NORTHWEST; 
   gridBagConstraints4.gridy = 1; 
   GridBagConstraints gridBagConstraints3 = new 
GridBagConstraints(); 
   gridBagConstraints3.gridx = 1; 
   gridBagConstraints3.insets = new Insets(1, 1, 1, 1); 
   gridBagConstraints3.anchor = 
GridBagConstraints.NORTHWEST; 
   gridBagConstraints3.gridy = 1; 
   GridBagConstraints gridBagConstraints2 = new 
GridBagConstraints(); 
   gridBagConstraints2.gridx = 0; 
   gridBagConstraints2.anchor = 
GridBagConstraints.NORTHWEST; 
   gridBagConstraints2.insets = new Insets(1, 1, 1, 1); 
   gridBagConstraints2.gridy = 1; 
   GridBagConstraints gridBagConstraints1 = new 
GridBagConstraints(); 
   gridBagConstraints1.anchor = 
GridBagConstraints.NORTHWEST; 
   gridBagConstraints1.insets = new Insets(2, 2, 2, 2); 
   gridBagConstraints1.gridwidth = 3; 
   gridBagConstraints1.fill = 
GridBagConstraints.HORIZONTAL; 
   captionCategoriesPanel = new JLabel(); 
   captionCategoriesPanel.setText("Categories:"); 
   panelCategories = new JPanel(); 
   panelCategories.setLayout(new GridBagLayout()); 
   panelCategories.add(captionCategoriesPanel, 
gridBagConstraints1); 
   panelCategories.add(getButtonAddCategory(), 
gridBagConstraints2); 
   panelCategories.add(getButtonEditCategory(), 
gridBagConstraints3); 
   panelCategories.add(getButtonRemoveCategory(), 
gridBagConstraints4); 
   panelCategories.add(getScrollPaneCategories(), 
gridBagConstraints5); 
  } 
  return panelCategories; 
 } 
 
 private JPanel getPanelCQs() { 
  if (panelCQs == null) { 
   GridBagConstraints gridBagConstraints27 = new 
GridBagConstraints(); 
   gridBagConstraints27.gridx = 3; 
   gridBagConstraints27.anchor = 
GridBagConstraints.NORTHWEST; 



  

   gridBagConstraints27.insets = new Insets(1, 1, 1, 1); 
   gridBagConstraints27.gridy = 1; 
   GridBagConstraints gridBagConstraints10 = new 
GridBagConstraints(); 
   gridBagConstraints10.fill = GridBagConstraints.BOTH; 
   gridBagConstraints10.gridy = 2; 
   gridBagConstraints10.weightx = 1.0; 
   gridBagConstraints10.weighty = 1.0; 
   gridBagConstraints10.gridwidth = 4; 
   gridBagConstraints10.anchor = GridBagConstraints.CENTER; 
   gridBagConstraints10.insets = new Insets(2, 2, 2, 2); 
   gridBagConstraints10.gridx = 0; 
   GridBagConstraints gridBagConstraints9 = new 
GridBagConstraints(); 
   gridBagConstraints9.gridx = 2; 
   gridBagConstraints9.anchor = 
GridBagConstraints.NORTHWEST; 
   gridBagConstraints9.insets = new Insets(1, 1, 1, 1); 
   gridBagConstraints9.gridy = 1; 
   GridBagConstraints gridBagConstraints8 = new 
GridBagConstraints(); 
   gridBagConstraints8.gridx = 1; 
   gridBagConstraints8.anchor = 
GridBagConstraints.NORTHWEST; 
   gridBagConstraints8.insets = new Insets(1, 1, 1, 1); 
   gridBagConstraints8.gridy = 1; 
   GridBagConstraints gridBagConstraints7 = new 
GridBagConstraints(); 
   gridBagConstraints7.gridx = 0; 
   gridBagConstraints7.anchor = 
GridBagConstraints.NORTHWEST; 
   gridBagConstraints7.insets = new Insets(1, 1, 1, 1); 
   gridBagConstraints7.gridy = 1; 
   GridBagConstraints gridBagConstraints6 = new 
GridBagConstraints(); 
   gridBagConstraints6.gridx = 0; 
   gridBagConstraints6.anchor = 
GridBagConstraints.NORTHWEST; 
   gridBagConstraints6.gridwidth = 4; 
   gridBagConstraints6.fill = 
GridBagConstraints.HORIZONTAL; 
   gridBagConstraints6.insets = new Insets(2, 2, 2, 2); 
   gridBagConstraints6.gridy = 0; 
   captionCQsPanel = new JLabel(); 
   captionCQsPanel.setText("Competence Questions:"); 
   panelCQs = new JPanel(); 
   panelCQs.setLayout(new GridBagLayout()); 
   panelCQs.add(captionCQsPanel, gridBagConstraints6); 
   panelCQs.add(getButtonAddCQ(), gridBagConstraints7); 
   panelCQs.add(getButtonEditCQ(), gridBagConstraints8); 
   panelCQs.add(getButtonRemoveCQ(), gridBagConstraints9); 
   panelCQs.add(getButtonMoveCQ(), gridBagConstraints27); 
   panelCQs.add(getScrollPaneCQs(), gridBagConstraints10); 
  } 
  return panelCQs; 
 } 
 
 private JButton getButtonAddCategory() { 
  if (buttonAddCategory == null) { 
   buttonAddCategory = new JButton(); 
   buttonAddCategory.setText("Add"); 
   buttonAddCategory.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     if (presenter != null) { 
      presenter.doAddCategory(); 
     } 
    } 
   }); 
  } 
  return buttonAddCategory; 
 } 
 
 private JButton getButtonEditCategory() { 
  if (buttonEditCategory == null) { 
   buttonEditCategory = new JButton(); 
   buttonEditCategory.setText("Edit"); 
   buttonEditCategory.addActionListener(new 
java.awt.event.ActionListener() { 



  

    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     if (presenter != null) { 
      final Integer categoryID = 
jListCategories.getSelectedDataID(); 
      if (categoryID != null &amp;amp;&amp;amp; 
categoryID &gt; 0) { 
      
 presenter.doEditCategory(categoryID); 
      } else { 
       final String message = 
        "Select a category 
to edit.\n" + 
        "The item&amp;lt;all 
categories&gt; is not a category, \n" + 
        "is a compilation 
from all one, can't be edited."; 
       showInfoMessage(message); 
      } 
     } 
    } 
   }); 
  } 
  return buttonEditCategory; 
 } 
 
 private JButton getButtonRemoveCategory() { 
  if (buttonRemoveCategory == null) { 
   buttonRemoveCategory = new JButton(); 
   buttonRemoveCategory.setText("Remove"); 
   buttonRemoveCategory.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     if (presenter != null) { 
      final List&lt;Integer&gt; 
categoryIDsList = jListCategories.getSelectedDataIDsList(); 
       
      final List&lt;String&gt; messageList = 
new ArrayList&lt;String&gt;(0); 
      for (Integer categoryID : 
categoryIDsList) { 
       if (categoryID == 
UtilClass.DEFAULT_CATEGORY_ID) { 
        messageList.add( 
          "The 
default category (the one with ID: " + 
         
 UtilClass.DEFAULT_CATEGORY_ID + 
          ") 
was selected, but it can't be removed.\n"); 
       
 categoryIDsList.remove(categoryID); 
        break; 
       } 
      } 
      if (categoryIDsList != null &amp;amp;&amp;amp; 
categoryIDsList.size() &gt; 0) { 
      
 presenter.doRemoveCategory(categoryIDsList); 
      } else { 
       messageList.add("Select a 
category " + 
         "(except the 
default (with ID: " + 
        
 UtilClass.DEFAULT_CATEGORY_ID + 
         ") to be 
removed."); 
      } 
      if (messageList.size() &gt; 0) { 
       final StringBuilder 
msgBuilder = new StringBuilder(); 
       for (String message : 
messageList) { 
        if 
(msgBuilder.length() &gt; 0) { 
        
 msgBuilder.append("\n"); 
        } 



  

       
 msgBuilder.append(message); 
       } 
      
 showInfoMessage(msgBuilder.toString()); 
      } 
     } 
    } 
   }); 
  } 
  return buttonRemoveCategory; 
 } 
 
 private JScrollPane getScrollPaneCategories() { 
  if (scrollPaneCategories == null) { 
   scrollPaneCategories = new JScrollPane(); 
  
 scrollPaneCategories.setViewportView(getJListCategories()); 
  } 
  return scrollPaneCategories; 
 } 
 
 private JButton getButtonAddCQ() { 
  if (buttonAddCQ == null) { 
   buttonAddCQ = new JButton(); 
   buttonAddCQ.setText("Add"); 
   buttonAddCQ.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     if (presenter != null) { 
      if (hasSelectedOneValidCategory()) 
{ 
       presenter.doAddCQ(); 
      } else { 
       final String message = 
        "You must select a 
category to add a competence question.\n" + 
        "(Attention: The 
item \""+ UtilClass.ALL_CATEGORIES_LABEL +"\" isn't a category)"; 
       showInfoMessage(message); 
      } 
     } 
    } 
   }); 
  } 
  return buttonAddCQ; 
 } 
 
 private JButton getButtonEditCQ() { 
  if (buttonEditCQ == null) { 
   buttonEditCQ = new JButton(); 
   buttonEditCQ.setText("Edit"); 
   buttonEditCQ.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     if (presenter != null) { 
      final List&lt;Integer&gt; selectedIDs = 
jListCQs.getSelectedDataIDsList(); 
      final int length = 
selectedIDs.size(); 
      if (length == 0) { 
       showInfoMessage("Select one 
competence question to edit."); 
      } else if (length &gt; 1) { 
       showInfoMessage("Only one 
competence question can be edited at time."); 
      } else { 
      
 presenter.doEditCQ(selectedIDs.get(0)); 
      } 
     } 
    } 
   }); 
  } 
  return buttonEditCQ; 
 } 
 
 private JButton getButtonRemoveCQ() { 



  

  if (buttonRemoveCQ == null) { 
   buttonRemoveCQ = new JButton(); 
   buttonRemoveCQ.setText("Remove"); 
   buttonRemoveCQ.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     if (presenter != null) { 
      final List&lt;Integer&gt; selectedIDs = 
jListCQs.getSelectedDataIDsList(); 
      if (selectedIDs.size() == 0) { 
       showInfoMessage("Select at 
least one Competence Question to remove."); 
      } else { 
      
 presenter.doRemoveCQ(selectedIDs); 
      } 
     } 
    } 
   }); 
  } 
  return buttonRemoveCQ; 
 } 
 
 private JScrollPane getScrollPaneCQs() { 
  if (scrollPaneCQs == null) { 
   scrollPaneCQs = new JScrollPane(); 
   scrollPaneCQs.setViewportView(getJListCQs()); 
  } 
  return scrollPaneCQs; 
 } 
 
 private JListCategories getJListCategories() { 
  if (jListCategories == null) { 
   jListCategories = new JListCategories(); 
   jListCategories.addMouseListener(new 
java.awt.event.MouseAdapter() { 
    public void 
mouseClicked(java.awt.event.MouseEvent e) { 
     if (jListCategories.isEnabled()) { 
      final List&lt;Integer&gt; selectedIDs = 
jListCategories.getSelectedDataIDsList(); 
      if (selectedIDs.size() == 1) { 
      
 presenter.loadSelectedCategoryItems(selectedIDs.get(0)); 
      } else { 
      
 presenter.loadSelectedCategoryItems(UtilClass.NO_SELECTED_CATEGORY); 
      } 
     } 
    } 
   }); 
  } 
  return jListCategories; 
 } 
 
 private JListCQs getJListCQs() { 
  if (jListCQs == null) { 
   jListCQs = new JListCQs(); 
  } 
  return jListCQs; 
 } 
  
 /** 
  * Especialização do componente JList para a exibição das categorias. 
  * Recebe e trabalha com um mapeamento de dados. 
  */ 
 private class JListCategories extends JList { 
   
  private static final long serialVersionUID = 1L; 
   
  private Map&lt;Integer, ?&gt; mapIndexToDataID; 
   
  public JListCategories() { 
   super(); 
  } 
   
  /** 
   * @deprecated usar setData(Map&lt;K, V&gt; categoriesMap) 
   */ 



  

  @Override 
  public void setListData(Object[] listData) { 
   super.setListData(listData); 
  } 
   
  /** 
   * @deprecated usar setData(Map&lt;K, V&gt; categoriesMap) 
   */ 
  @Override 
  public void setListData(Vector&lt;?&gt; listData) { 
   super.setListData(listData); 
  } 
   
  @SuppressWarnings("unchecked") 
  public&amp;lt;K extends Object, V extends Object&gt; void setData(Map&lt;K, 
V&gt; categoriesMap) { 
   final int length = ( categoriesMap != null ? 
categoriesMap.size() : 0 ); 
   Map&lt;Integer, K&gt; mapIndexToDataID = new 
LinkedHashMap&lt;Integer, K&gt;(length); 
   final Vector&lt;String&gt; listData = new 
Vector&lt;String&gt;(length); 
    
   if (length &gt; 0) { 
    final K[] keys = 
(K[])categoriesMap.keySet().toArray(); 
    for (int i=0; i &amp;lt;length; i++) { 
     final K dataID = keys[i];  
     listData.add( dataID + 
UtilClass.CATEGORY_PREFIX + 
       categoriesMap.get(dataID) 
); 
     mapIndexToDataID.put(listData.size()-1, 
dataID); 
    } 
    this.mapIndexToDataID = mapIndexToDataID; 
   } 
    
   super.setListData(listData); 
  } 
   
  @SuppressWarnings("unchecked") 
  public&amp;lt;K extends Object&gt; K getSelectedDataID() { 
   if (this.mapIndexToDataID != null &amp;amp;&amp;amp; 
this.mapIndexToDataID.size() &gt; 0) { 
    final int selectedIndex = 
super.getSelectedIndex(); 
    if (selectedIndex &gt;= 0) { 
     return 
(K)this.mapIndexToDataID.get(selectedIndex); 
    } 
   } 
   return null; 
  } 
   
  @SuppressWarnings("unchecked") 
  public&amp;lt;K extends Object&gt; List&lt;K&gt; getSelectedDataIDsList() { 
   final int[] indices = super.getSelectedIndices(); 
   final int length = indices.length; 
   final List&lt;K&gt; dataIDsList = new ArrayList&lt;K&gt;(length); 
   for (int i=0; i &amp;lt;length; i++) { 
   
 dataIDsList.add((K)this.mapIndexToDataID.get(indices[i])); 
   } 
   return dataIDsList; 
  } 
 } 
  
 /** 
  * Especialização do componente JList para a exibição 
  * das perguntas de competência e suas respostas. 
  * Recebe e trabalha com um duplo mapeamento de dados. 
  */ 
 private class JListCQs extends JList { 
   
  private static final long serialVersionUID = 1L; 
   
  private Map&lt;Integer, ?&gt; mapIndexToQuestionID; 
  private Map&lt;Integer, ?&gt; mapIndexToAnswerID; 
   



  

  public JListCQs() { 
   super(); 
  } 
   
  /** 
   * @deprecated usar setData(Map&lt;K, V&gt; questionsMap, Map&lt;K, V&gt; 
answersMap) 
   */ 
  @Override 
  public void setListData(Object[] listData) { 
   super.setListData(listData); 
  } 
   
  /** 
   * @deprecated usar setData(Map&lt;K, V&gt; questionsMap, Map&lt;K, V&gt; 
answersMap) 
   */ 
  @Override 
  public void setListData(Vector&lt;?&gt; listData) { 
   super.setListData(listData); 
  } 
   
  @SuppressWarnings("unchecked") 
  public&amp;lt;K extends Object, V extends Object&gt; void setData( 
    Map&lt;K, V&gt; questionsMap, Map&lt;K, V&gt; answersMap) { 
   final int lengthQuestions = (questionsMap != null ? 
questionsMap.size() : 0); 
   final int lengthAnswers = (answersMap != null ? 
answersMap.size() : 0); 
    
   Map&lt;Integer, K&gt; mapIndexToQuestionID = new 
LinkedHashMap&lt;Integer, K&gt;(lengthQuestions); 
   Map&lt;Integer, K&gt; mapIndexToAnswerID = new 
LinkedHashMap&lt;Integer, K&gt;(lengthAnswers); 
   final Vector&lt;String&gt; listData = new 
Vector&lt;String&gt;(lengthQuestions); 
    
   if (lengthQuestions &gt; 0) { 
    final boolean hasAnswers = (lengthAnswers &gt; 0); 
    final K[] keys = 
(K[])questionsMap.keySet().toArray(); 
    for (int i=0; i &amp;lt;lengthQuestions; i++) { 
     final K dataID = keys[i]; 
      
     listData.add( dataID + 
UtilClass.QUESTION_PREFIX + 
       questionsMap.get(dataID) ); 
     mapIndexToQuestionID.put(listData.size()-
1, dataID); 
      
     if (hasAnswers &amp;amp;&amp;amp; 
answersMap.containsKey(dataID)) { 
      listData.add( dataID + 
UtilClass.ANSWER_PREFIX + 
       
 answersMap.get(dataID) ); 
     
 mapIndexToAnswerID.put(listData.size()-1, dataID); 
     } 
    } 
    this.mapIndexToQuestionID = mapIndexToQuestionID; 
    this.mapIndexToAnswerID = mapIndexToAnswerID; 
   } 
    
   super.setListData(listData); 
  } 
   
  @SuppressWarnings("unchecked") 
  public&amp;lt;K extends Object&gt; K getSelectedDataID() { 
   final int selectedIndex = super.getSelectedIndex(); 
   K selectedDataID = null; 
    
   if (selectedIndex &gt;= 0) { 
    if (this.mapIndexToQuestionID != null &amp;amp;&amp;amp; 
     
 this.mapIndexToQuestionID.containsKey(selectedIndex)) { 
     selectedDataID = 
(K)this.mapIndexToQuestionID.get(selectedIndex); 
    } 
    if (selectedDataID == null &amp;amp;&amp;amp; 



  

      this.mapIndexToAnswerID != null &amp;amp;&amp;amp; 
     
 this.mapIndexToAnswerID.containsKey(selectedIndex)) { 
     selectedDataID = 
(K)this.mapIndexToAnswerID.get(selectedIndex); 
    } 
   } 
    
   return selectedDataID; 
  } 
   
  @SuppressWarnings("unchecked") 
  public&amp;lt;K extends Object&gt; List&lt;K&gt; getSelectedDataIDsList() { 
   final int[] indices = super.getSelectedIndices(); 
   final int length = indices.length; 
   final List&lt;K&gt; dataIDsList = new ArrayList&lt;K&gt;(length); 
   for (int i=0; i &amp;lt;length; i++) { 
    final K questionID = 
(K)this.mapIndexToQuestionID.get(indices[i]); 
    if (questionID != null) { 
     this.setInOneList(dataIDsList, 
questionID); 
    } else { 
     final K answerID = 
(K)this.mapIndexToAnswerID.get(indices[i]); 
     if (answerID != null) { 
      this.setInOneList(dataIDsList, 
answerID); 
     } 
    } 
   } 
   return dataIDsList; 
  } 
   
  private&amp;lt;K extends Object&gt; void setInOneList( 
    final List&lt;K&gt; listToSet, final K element) { 
   if (listToSet != null &amp;amp;&amp;amp; element != null) { 
    if ( ! listToSet.contains(element)) { 
     listToSet.add(element); 
    } 
   } 
  } 
 } 
  
 private static class CategoryParams { 
  private final Integer idCode; 
  private final String name; 
  private final String description; 
   
  public CategoryParams(final Integer idCode, final String name, 
final String description) { 
   this.idCode = idCode; 
   this.name = name; 
   this.description = description; 
  } 
 
  public Integer getIdCode() { 
   return idCode; 
  } 
 
  public String getName() { 
   return name; 
  } 
 
  public String getDescription() { 
   return description; 
  } 
 } 
  
 private static class CQParams { 
  private final Integer idCode; 
  private final String question; 
  private final String answer; 
   
  public CQParams(final Integer idCode, final String question, 
final String answer) { 
   this.idCode = idCode; 
   this.question = question; 
   this.answer = answer; 
  } 



  

 
  public Integer getIdCode() { 
   return idCode; 
  } 
 
  public String getQuestion() { 
   return question; 
  } 
 
  public String getAnswer() { 
   return answer; 
  } 
 } 
 
 private JInternalFrame getJInternalFrameCategoryDetail() { 
  if (jInternalFrameCategoryDetail == null) { 
   jInternalFrameCategoryDetail = new JInternalFrame(); 
   jInternalFrameCategoryDetail.setTitle("Category 
Detail"); 
  
 jInternalFrameCategoryDetail.setDefaultCloseOperation(WindowConstants.H
IDE_ON_CLOSE); 
   jInternalFrameCategoryDetail.setClosable(false); 
  
 jInternalFrameCategoryDetail.setContentPane(getJContentPaneCategoryDeta
il()); 
   final Dimension size = new Dimension(300, 200); 
   this.jInternalFrameCategoryDetail.setMinimumSize(size); 
   this.jInternalFrameCategoryDetail.setSize(size); 
   jInternalFrameCategoryDetail 
     .addComponentListener(new 
java.awt.event.ComponentAdapter() {    
    public void 
componentShown(java.awt.event.ComponentEvent e) {     
     if (presenter != null) { 
      presenter.setModalMode(true); 
     } 
    } 
    public void 
componentHidden(java.awt.event.ComponentEvent e) { 
     if (presenter != null) { 
      presenter.setModalMode(false); 
     } 
    } 
     }); 
  } 
  return jInternalFrameCategoryDetail; 
 } 
 
 private JPanel getJContentPaneCategoryDetail() { 
  if (jContentPaneCategoryDetail == null) { 
   GridBagConstraints gridBagConstraints17 = new 
GridBagConstraints(); 
   gridBagConstraints17.gridx = 0; 
   gridBagConstraints17.anchor = 
GridBagConstraints.SOUTHWEST; 
   gridBagConstraints17.fill = 
GridBagConstraints.HORIZONTAL; 
   gridBagConstraints17.insets = new Insets(0, 4, 2, 4); 
   gridBagConstraints17.gridy = 5; 
   infoRequiredCategDetail = new JLabel(); 
   infoRequiredCategDetail.setText("Fields with (*) are 
required."); 
   GridBagConstraints gridBagConstraints15 = new 
GridBagConstraints(); 
   gridBagConstraints15.gridx = 0; 
   gridBagConstraints15.anchor = 
GridBagConstraints.SOUTHWEST; 
   gridBagConstraints15.insets = new Insets(2, 4, 0, 4); 
   gridBagConstraints15.fill = 
GridBagConstraints.HORIZONTAL; 
   gridBagConstraints15.gridwidth = 1; 
   gridBagConstraints15.gridy = 4; 
   GridBagConstraints gridBagConstraints14 = new 
GridBagConstraints(); 
   gridBagConstraints14.fill = GridBagConstraints.BOTH; 
   gridBagConstraints14.gridy = 3; 
   gridBagConstraints14.weightx = 1.0; 
   gridBagConstraints14.weighty = 1.0; 



  

   gridBagConstraints14.anchor = 
GridBagConstraints.NORTHWEST; 
   gridBagConstraints14.insets = new Insets(0, 4, 2, 4); 
   gridBagConstraints14.gridwidth = 1; 
   gridBagConstraints14.gridx = 0; 
   GridBagConstraints gridBagConstraints13 = new 
GridBagConstraints(); 
   gridBagConstraints13.gridx = 0; 
   gridBagConstraints13.anchor = 
GridBagConstraints.NORTHWEST; 
   gridBagConstraints13.fill = 
GridBagConstraints.HORIZONTAL; 
   gridBagConstraints13.insets = new Insets(2, 4, 0, 4); 
   gridBagConstraints13.gridwidth = 1; 
   gridBagConstraints13.gridy = 2; 
   captionCategDetailDescription = new JLabel(); 
   captionCategDetailDescription.setText("Description:"); 
   GridBagConstraints gridBagConstraints12 = new 
GridBagConstraints(); 
   gridBagConstraints12.fill = GridBagConstraints.BOTH; 
   gridBagConstraints12.gridy = 1; 
   gridBagConstraints12.weightx = 1.0; 
   gridBagConstraints12.anchor = 
GridBagConstraints.NORTHWEST; 
   gridBagConstraints12.insets = new Insets(0, 4, 2, 4); 
   gridBagConstraints12.gridwidth = 1; 
   gridBagConstraints12.gridx = 0; 
   GridBagConstraints gridBagConstraints11 = new 
GridBagConstraints(); 
   gridBagConstraints11.gridx = 0; 
   gridBagConstraints11.anchor = 
GridBagConstraints.NORTHWEST; 
   gridBagConstraints11.insets = new Insets(4, 4, 0, 4); 
   gridBagConstraints11.fill = 
GridBagConstraints.HORIZONTAL; 
   gridBagConstraints11.gridy = 0; 
   captionCategDetailName = new JLabel(); 
   captionCategDetailName.setText("Name: (*)"); 
   jContentPaneCategoryDetail = new JPanel(); 
   jContentPaneCategoryDetail.setLayout(new 
GridBagLayout()); 
   jContentPaneCategoryDetail.setPreferredSize(new 
Dimension(300, 200)); 
   jContentPaneCategoryDetail.add(captionCategDetailName, 
gridBagConstraints11); 
  
 jContentPaneCategoryDetail.add(getFieldCategDetailName(), 
gridBagConstraints12); 
  
 jContentPaneCategoryDetail.add(captionCategDetailDescription, 
gridBagConstraints13); 
  
 jContentPaneCategoryDetail.add(getScrollPaneCategDetailDescription(), 
gridBagConstraints14); 
  
 jContentPaneCategoryDetail.add(getBottomBarCategDetail(), 
gridBagConstraints15); 
   jContentPaneCategoryDetail.add(infoRequiredCategDetail, 
gridBagConstraints17); 
    
  } 
  return jContentPaneCategoryDetail; 
 } 
 
 private JTextField getFieldCategDetailName() { 
  if (fieldCategDetailName == null) { 
   fieldCategDetailName = new JTextField(); 
   fieldCategDetailName.setText("Name"); 
  } 
  return fieldCategDetailName; 
 } 
 
 private JScrollPane getScrollPaneCategDetailDescription() { 
  if (scrollPaneCategDetailDescription == null) { 
   scrollPaneCategDetailDescription = new JScrollPane(); 
  
 scrollPaneCategDetailDescription.setViewportView(getFieldCategDetailDes
cription()); 
  } 
  return scrollPaneCategDetailDescription; 



  

 } 
 
 private JTextArea getFieldCategDetailDescription() { 
  if (fieldCategDetailDescription == null) { 
   fieldCategDetailDescription = new JTextArea(); 
   fieldCategDetailDescription.setText("Description"); 
  } 
  return fieldCategDetailDescription; 
 } 
 
 private JPanel getBottomBarCategDetail() { 
  if (bottomBarCategDetail == null) { 
   bottomBarCategDetail = new JPanel(); 
   bottomBarCategDetail.setLayout(new FlowLayout()); 
   bottomBarCategDetail.add(getButtonCategDetailConfirm(), 
null); 
   bottomBarCategDetail.add(getButtonCategDetailCancel(), 
null); 
  } 
  return bottomBarCategDetail; 
 } 
 
 private JButton getButtonCategDetailConfirm() { 
  if (buttonCategDetailConfirm == null) { 
   buttonCategDetailConfirm = new JButton(); 
   buttonCategDetailConfirm.setText("Confirm"); 
   buttonCategDetailConfirm.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     final CategoryParams filledOutParams = 
fillOutCategoryDetail(); 
     if (filledOutParams != null) { 
      Map&lt;FORM_FIELDS, 
List&lt;ValidationErrors&gt;&gt; errors = presenter.validateCategoryDetail( 
       
 filledOutParams.getIdCode(), filledOutParams.getName(), 
       
 filledOutParams.getDescription()); 
      if (errors.isEmpty()) { 
       if 
(filledOutParams.getIdCode() == null) { 
       
 presenter.addCategory( 
         
 filledOutParams.getName(), filledOutParams.getDescription()); 
       } else { 
       
 presenter.editCategory(filledOutParams.getIdCode(), 
         
 filledOutParams.getName(), filledOutParams.getDescription()); 
       } 
      
 jInternalFrameCategoryDetail.doDefaultCloseAction(); 
      } else { 
       List&lt;String&gt; messageList = 
new ArrayList&lt;String&gt;(0); 
      
 applyCategoryDetailErrorsMap(errors, messageList); 
       final StringBuilder 
msgBuilder = new StringBuilder(); 
       for (String message : 
messageList) { 
        if 
(msgBuilder.length() &gt; 0) { 
        
 msgBuilder.append("\n"); 
        } 
       
 msgBuilder.append(message); 
       } 
      
 JOptionPane.showMessageDialog(jInternalFrameCategoryDetail, 
        
 msgBuilder.toString(), 
         "Validation 
Errors", 
        
 JOptionPane.INFORMATION_MESSAGE); 
      } 



  

     } 
    } 
   }); 
  } 
  return buttonCategDetailConfirm; 
 } 
 
 private JButton getButtonCategDetailCancel() { 
  if (buttonCategDetailCancel == null) { 
   buttonCategDetailCancel = new JButton(); 
   buttonCategDetailCancel.setText("Cancel"); 
   buttonCategDetailCancel.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
    
 jInternalFrameCategoryDetail.doDefaultCloseAction(); 
    } 
   }); 
  } 
  return buttonCategDetailCancel; 
 } 
 
 private JInternalFrame getJInternalFrameRemoveCategory() { 
  if (jInternalFrameRemoveCategory == null) { 
   jInternalFrameRemoveCategory = new JInternalFrame(); 
  
 jInternalFrameRemoveCategory.setDefaultCloseOperation(WindowConstants.H
IDE_ON_CLOSE); 
   jInternalFrameRemoveCategory.setTitle("Remove 
Category"); 
   final Dimension size = new Dimension(360, 150); 
   this.jInternalFrameRemoveCategory.setMinimumSize(size); 
   this.jInternalFrameRemoveCategory.setSize(size); 
  
 jInternalFrameRemoveCategory.setContentPane(getJContentPaneRemoveCatego
ry()); 
   jInternalFrameRemoveCategory 
     .addComponentListener(new 
java.awt.event.ComponentAdapter() {    
    public void 
componentShown(java.awt.event.ComponentEvent e) {     
     if (presenter != null) { 
      presenter.setModalMode(true); 
     } 
    } 
    public void 
componentHidden(java.awt.event.ComponentEvent e) { 
     if (presenter != null) { 
      presenter.setModalMode(false); 
     } 
    } 
     }); 
  } 
  return jInternalFrameRemoveCategory; 
 } 
 
 private JPanel getJContentPaneRemoveCategory() { 
  if (jContentPaneRemoveCategory == null) { 
   GridBagConstraints gridBagConstraints20 = new 
GridBagConstraints(); 
   gridBagConstraints20.gridx = 0; 
   gridBagConstraints20.insets = new Insets(2, 4, 4, 4); 
   gridBagConstraints20.anchor = GridBagConstraints.NORTH; 
   gridBagConstraints20.gridy = 2; 
   labelRemoveCategProcedureLine2 = new JLabel(); 
   labelRemoveCategProcedureLine2.setText("Procedure Line 
2"); 
   GridBagConstraints gridBagConstraints19 = new 
GridBagConstraints(); 
   gridBagConstraints19.insets = new Insets(4, 4, 2, 3); 
   gridBagConstraints19.anchor = GridBagConstraints.NORTH; 
   labelRemoveCategMainLine = new JLabel(); 
   labelRemoveCategMainLine.setText("Main Line"); 
   GridBagConstraints gridBagConstraints16 = new 
GridBagConstraints(); 
   gridBagConstraints16.gridx = 0; 
   gridBagConstraints16.anchor = GridBagConstraints.NORTH; 
   gridBagConstraints16.insets = new Insets(2, 4, 2, 4); 
   gridBagConstraints16.fill = GridBagConstraints.NONE; 



  

   gridBagConstraints16.gridy = 1; 
   labelRemoveCategProcedureLine1 = new JLabel(); 
   labelRemoveCategProcedureLine1.setText("Procedure Line 
1"); 
   GridBagConstraints gridBagConstraints18 = new 
GridBagConstraints(); 
   gridBagConstraints18.gridy = 3; 
   gridBagConstraints18.insets = new Insets(8, 4, 4, 4); 
   gridBagConstraints18.fill = 
GridBagConstraints.HORIZONTAL; 
   gridBagConstraints18.anchor = GridBagConstraints.SOUTH; 
   jContentPaneRemoveCategory = new JPanel(); 
   jContentPaneRemoveCategory.setLayout(new 
GridBagLayout()); 
   jContentPaneRemoveCategory.add(labelRemoveCategMainLine, 
gridBagConstraints19); 
  
 jContentPaneRemoveCategory.add(labelRemoveCategProcedureLine1, 
gridBagConstraints16); 
  
 jContentPaneRemoveCategory.add(labelRemoveCategProcedureLine2, 
gridBagConstraints20); 
  
 jContentPaneRemoveCategory.add(getBottomBarRemoveCateg(), 
gridBagConstraints18); 
  } 
  return jContentPaneRemoveCategory; 
 } 
 
 private JPanel getBottomBarRemoveCateg() { 
  if (bottomBarRemoveCateg == null) { 
   bottomBarRemoveCateg = new JPanel(); 
   bottomBarRemoveCateg.setLayout(new FlowLayout()); 
   bottomBarRemoveCateg.add(getButtonRemoveCategConfirm(), 
null); 
   bottomBarRemoveCateg.add(getButtonRemoveCategCancel(), 
null); 
  } 
  return bottomBarRemoveCateg; 
 } 
 
 private JButton getButtonRemoveCategConfirm() { 
  if (buttonRemoveCategConfirm == null) { 
   buttonRemoveCategConfirm = new JButton(); 
   buttonRemoveCategConfirm.setText("Remove"); 
   buttonRemoveCategConfirm.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     if (presenter != null) { 
     
 presenter.removeCategories(selectedCategoriesToRemove); 
     } 
    
 jInternalFrameRemoveCategory.doDefaultCloseAction(); 
    } 
   }); 
  } 
  return buttonRemoveCategConfirm; 
 } 
 
 private JButton getButtonRemoveCategCancel() { 
  if (buttonRemoveCategCancel == null) { 
   buttonRemoveCategCancel = new JButton(); 
   buttonRemoveCategCancel.setText("Cancel"); 
   buttonRemoveCategCancel.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
    
 jInternalFrameRemoveCategory.doDefaultCloseAction(); 
    } 
   }); 
  } 
  return buttonRemoveCategCancel; 
 } 
 
 private JInternalFrame getJInternalFrameCQDetail() { 
  if (jInternalFrameCQDetail == null) { 
   jInternalFrameCQDetail = new JInternalFrame(); 



  

   final Dimension size = new Dimension(400, 180); 
   jInternalFrameCQDetail.setMinimumSize(size); 
   jInternalFrameCQDetail.setSize(size); 
   jInternalFrameCQDetail.setPreferredSize(size); 
   jInternalFrameCQDetail.setTitle("CQ Detail"); 
  
 jInternalFrameCQDetail.setDefaultCloseOperation(WindowConstants.HIDE_ON
_CLOSE); 
  
 jInternalFrameCQDetail.setContentPane(getJContentPaneCQDetail()); 
   jInternalFrameCQDetail 
     .addComponentListener(new 
java.awt.event.ComponentAdapter() {    
    public void 
componentShown(java.awt.event.ComponentEvent e) {     
     if (presenter != null) { 
      presenter.setModalMode(true); 
     } 
    } 
    public void 
componentHidden(java.awt.event.ComponentEvent e) { 
     if (presenter != null) { 
      presenter.setModalMode(false); 
     } 
    } 
     }); 
  } 
  return jInternalFrameCQDetail; 
 } 
 
 private JPanel getJContentPaneCQDetail() { 
  if (jContentPaneCQDetail == null) { 
   GridBagConstraints gridBagConstraints26 = new 
GridBagConstraints(); 
   gridBagConstraints26.gridx = 0; 
   gridBagConstraints26.anchor = 
GridBagConstraints.SOUTHWEST; 
   gridBagConstraints26.fill = 
GridBagConstraints.HORIZONTAL; 
   gridBagConstraints26.insets = new Insets(0, 4, 2, 4); 
   gridBagConstraints26.gridy = 5; 
   infoRequiredCQDetail = new JLabel(); 
   infoRequiredCQDetail.setText("Fields with (*) are 
required."); 
   GridBagConstraints gridBagConstraints25 = new 
GridBagConstraints(); 
   gridBagConstraints25.gridx = 0; 
   gridBagConstraints25.anchor = 
GridBagConstraints.SOUTHWEST; 
   gridBagConstraints25.fill = 
GridBagConstraints.HORIZONTAL; 
   gridBagConstraints25.insets = new Insets(2, 4, 0, 4); 
   gridBagConstraints25.gridy = 4; 
   GridBagConstraints gridBagConstraints24 = new 
GridBagConstraints(); 
   gridBagConstraints24.fill = 
GridBagConstraints.HORIZONTAL; 
   gridBagConstraints24.gridy = 3; 
   gridBagConstraints24.weightx = 1.0; 
   gridBagConstraints24.anchor = 
GridBagConstraints.NORTHWEST; 
   gridBagConstraints24.insets = new Insets(0, 4, 2, 4); 
   gridBagConstraints24.gridx = 0; 
   GridBagConstraints gridBagConstraints23 = new 
GridBagConstraints(); 
   gridBagConstraints23.gridx = 0; 
   gridBagConstraints23.anchor = 
GridBagConstraints.NORTHWEST; 
   gridBagConstraints23.insets = new Insets(2, 4, 0, 4); 
   gridBagConstraints23.fill = 
GridBagConstraints.HORIZONTAL; 
   gridBagConstraints23.gridy = 2; 
   captionCQDetailAnswer = new JLabel(); 
   captionCQDetailAnswer.setText("Answer sentence:"); 
   GridBagConstraints gridBagConstraints22 = new 
GridBagConstraints(); 
   gridBagConstraints22.fill = 
GridBagConstraints.HORIZONTAL; 
   gridBagConstraints22.gridy = 1; 
   gridBagConstraints22.weightx = 1.0; 



  

   gridBagConstraints22.anchor = 
GridBagConstraints.NORTHWEST; 
   gridBagConstraints22.insets = new Insets(0, 4, 2, 4); 
   gridBagConstraints22.gridx = 0; 
   GridBagConstraints gridBagConstraints21 = new 
GridBagConstraints(); 
   gridBagConstraints21.gridx = 0; 
   gridBagConstraints21.anchor = 
GridBagConstraints.NORTHWEST; 
   gridBagConstraints21.insets = new Insets(4, 4, 0, 4); 
   gridBagConstraints21.fill = 
GridBagConstraints.HORIZONTAL; 
   gridBagConstraints21.gridy = 0; 
   captionCQDetailQuestion = new JLabel(); 
   captionCQDetailQuestion.setText("Question sentence: 
(*)"); 
   jContentPaneCQDetail = new JPanel(); 
   jContentPaneCQDetail.setLayout(new GridBagLayout()); 
   jContentPaneCQDetail.add(captionCQDetailQuestion, 
gridBagConstraints21); 
   jContentPaneCQDetail.add(getFieldCQDetailQuestion(), 
gridBagConstraints22); 
   jContentPaneCQDetail.add(captionCQDetailAnswer, 
gridBagConstraints23); 
   jContentPaneCQDetail.add(getFieldCQDetailAnswer(), 
gridBagConstraints24); 
   jContentPaneCQDetail.add(getBottomBarCQDetail(), 
gridBagConstraints25); 
   jContentPaneCQDetail.add(infoRequiredCQDetail, 
gridBagConstraints26); 
  } 
  return jContentPaneCQDetail; 
 } 
 
 private JTextField getFieldCQDetailQuestion() { 
  if (fieldCQDetailQuestion == null) { 
   fieldCQDetailQuestion = new JTextField(); 
   fieldCQDetailQuestion.setText("Question"); 
  } 
  return fieldCQDetailQuestion; 
 } 
 
 private JTextField getFieldCQDetailAnswer() { 
  if (fieldCQDetailAnswer == null) { 
   fieldCQDetailAnswer = new JTextField(); 
   fieldCQDetailAnswer.setText("Answer"); 
  } 
  return fieldCQDetailAnswer; 
 } 
 
 private JPanel getBottomBarCQDetail() { 
  if (bottomBarCQDetail == null) { 
   bottomBarCQDetail = new JPanel(); 
   bottomBarCQDetail.setLayout(new FlowLayout()); 
   bottomBarCQDetail.add(getButtonCQDetailConfirm(), null); 
   bottomBarCQDetail.add(getButtonCQDetailCancel(), null); 
  } 
  return bottomBarCQDetail; 
 } 
 
 private JButton getButtonCQDetailConfirm() { 
  if (buttonCQDetailConfirm == null) { 
   buttonCQDetailConfirm = new JButton(); 
   buttonCQDetailConfirm.setText("Confirm"); 
   buttonCQDetailConfirm.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     final CQParams filledOutParams = 
fillOutCQDetail(); 
     if (filledOutParams != null) { 
      Map&lt;FORM_FIELDS, 
List&lt;ValidationErrors&gt;&gt; errors = presenter.validateCQDetail( 
       
 filledOutParams.getIdCode(), filledOutParams.getQuestion(), 
       
 filledOutParams.getAnswer()); 
      if (errors.isEmpty()) { 
       if 
(filledOutParams.getIdCode() == null) { 



  

        final Integer 
categoryID = jListCategories.getSelectedDataID(); 
       
 presenter.addCompetenceQuestion(categoryID, 
         
 filledOutParams.getQuestion(), filledOutParams.getAnswer()); 
       } else { 
       
 presenter.editCompetenceQuestion(filledOutParams.getIdCode(), 
         
 filledOutParams.getQuestion(), filledOutParams.getAnswer()); 
       } 
      
 jInternalFrameCQDetail.doDefaultCloseAction(); 
      } else { 
       List&lt;String&gt; messageList = 
new ArrayList&lt;String&gt;(0); 
      
 applyCQDetailErrorsMap(errors, messageList); 
       final StringBuilder 
msgBuilder = new StringBuilder(); 
       for (String message : 
messageList) { 
        if 
(msgBuilder.length() &gt; 0) { 
        
 msgBuilder.append("\n"); 
        } 
       
 msgBuilder.append(message); 
       } 
      
 JOptionPane.showMessageDialog(jInternalFrameCategoryDetail, 
        
 msgBuilder.toString(), 
         "Validation 
Errors", 
        
 JOptionPane.INFORMATION_MESSAGE); 
      } 
     } 
    } 
   }); 
  } 
  return buttonCQDetailConfirm; 
 } 
 
 private JButton getButtonCQDetailCancel() { 
  if (buttonCQDetailCancel == null) { 
   buttonCQDetailCancel = new JButton(); 
   buttonCQDetailCancel.setText("Cancel"); 
   buttonCQDetailCancel.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
    
 jInternalFrameCQDetail.doDefaultCloseAction(); 
    } 
   }); 
  } 
  return buttonCQDetailCancel; 
 } 
 
 private JButton getButtonMoveCQ() { 
  if (buttonMoveCQ == null) { 
   buttonMoveCQ = new JButton(); 
   buttonMoveCQ.setText("Move..."); 
   buttonMoveCQ.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     if (presenter != null) { 
      if (hasSelectedOneValidCategory()) 
{ 
       final List&lt;Integer&gt; 
selectedIDs = jListCQs.getSelectedDataIDsList(); 
       if (selectedIDs.size() == 
0) { 
       
 showInfoMessage("Select at least one competence question to move."); 



  

       } else { 
        final Integer 
categoryID = jListCategories.getSelectedDataID(); 
       
 presenter.doMoveCQ(categoryID, selectedIDs); 
       } 
      } else { 
       final String message = 
        "You must select a 
category to move competence questions.\n" + 
        "(Attention: The 
item \""+ UtilClass.ALL_CATEGORIES_LABEL +"\" isn't a category)"; 
       showInfoMessage(message); 
      } 
     } 
    } 
   }); 
  } 
  return buttonMoveCQ; 
 } 
} 
 

? Classe MainFormImpl.java: 
package gui; 
 
import java.awt.CardLayout; 
import java.awt.Toolkit; 
import java.io.File; 
 
import javax.swing.JFileChooser; 
import javax.swing.JFrame; 
import javax.swing.JMenu; 
import javax.swing.JMenuBar; 
import javax.swing.JMenuItem; 
import javax.swing.JOptionPane; 
import javax.swing.JPanel; 
import javax.swing.JTabbedPane; 
 
import system.mvp.Presenter; 
import system.utils.UtilClass; 
import system.utils.UtilClass.MESSAGES; 
import view.main.MainForm; 
import view.main.MainPresenter; 
 
public class MainFormImpl extends JFrame implements MainForm { 
  
 private static final long serialVersionUID = 1L; 
  
 private static final String NEW_PROJECT_DIALOG_TITLE = "New"; 
  
 private enum Modules { 
  PROJECT_FORM(ProjectFormImpl.class.getName(), "Project"), 
 
 COMPETENCE_QUESTIONS_FORM(CompetenceQuestionsFormImpl.class.getName(), 
    "Competence questions"), 
  TERMS_FORM(TermsFormImpl.class.getName(), "Terms"); 
   
  private final String moduleName; 
  private final String tabTitle; 
   
  private Modules(final String moduleName, final String tabTitle) 
{ 
   this.moduleName = moduleName; 
   this.tabTitle = tabTitle; 
  } 
   
  public String getModuleName() { 
   return moduleName; 
  } 
   
  public String getTabTitle() { 
   return tabTitle; 
  } 
 } 
  
 private MainPresenter presenter; 
  
 private ProjectFormImpl projectFormImpl; 



  

 private CompetenceQuestionsFormImpl cqFormImpl; 
 private TermsFormImpl termsFormImpl; 
  
 private JFileChooser fileDialog; 
  
 private JPanel jContentPane = null; 
 private JTabbedPane tabBar = null; 
 
 private JMenuBar appMenuBar = null; 
 
 private JMenu menuFile = null; 
 
 private JMenuItem menuItemNew = null; 
 
 private JMenuItem menuItemOpen = null; 
 
 private JMenuItem menuItemPersist = null; 
 
 public MainFormImpl() { 
  super(); 
  this.projectFormImpl = new ProjectFormImpl(); 
  this.cqFormImpl = new CompetenceQuestionsFormImpl(); 
  this.termsFormImpl = new TermsFormImpl(); 
  initialize(); 
 } 
 
 private void initialize() { 
  JFrame.setDefaultLookAndFeelDecorated(true); 
  this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 
  this.setJMenuBar(getAppMenuBar()); 
  this.setContentPane(getJContentPane()); 
  this.setVisible(true); 
  final int width = UtilClass.APP_WIDTH; 
  final int heigth = UtilClass.APP_HEIGTH; 
  this.setSize(width, heigth); 
  { 
   Toolkit toolkit = Toolkit.getDefaultToolkit(); 
   final int sysWidth  = toolkit.getScreenSize().width; 
   final int sysHeight = toolkit.getScreenSize().height; 
   final int locWidth = (sysWidth/2 - width/2); 
   final int locHeigth = (sysHeight/2 - heigth/2); 
   this.setLocation( 
     (locWidth &gt; 0 ? locWidth : 100), 
     (locHeigth &gt; 0 ? locHeigth : 100)); 
  } 
  this.setTitle("CQPlugin"); 
 
 this.projectFormImpl.setSplitPaneDividerLocation(this.getWidth()/2); 
 } 
  
 private void showInforMessage(final String message) { 
  JOptionPane.showMessageDialog(this, message); 
 } 
 
 private JPanel getJContentPane() { 
  if (jContentPane == null) { 
   jContentPane = new JPanel(); 
   jContentPane.setLayout(new CardLayout()); 
   jContentPane.add(getTabBar(), getTabBar().getName()); 
  } 
  return jContentPane; 
 } 
  
 public ProjectFormImpl getProjectFormImpl() { 
  return projectFormImpl; 
 } 
 
 public CompetenceQuestionsFormImpl getCompetenceQuestionsFormImpl() { 
  return cqFormImpl; 
 } 
 
 public TermsFormImpl getTermsFormImpl() { 
  return termsFormImpl; 
 } 
  
 /*---------------------- 
  * Manipulation Methods: 
  ----------------------*/ 
 private void slotOnMenuFileNewCommand() { 
  if (this.fileDialog == null) { 



  

   fileDialog = new JFileChooser(); 
  } 
   
  final int resposta = fileDialog.showDialog(this, 
NEW_PROJECT_DIALOG_TITLE); 
  if (resposta == JFileChooser.APPROVE_OPTION) { 
   File newFile = this.fileDialog.getSelectedFile(); 
   if (newFile != null) { 
    String fileName = newFile.getName();; 
    String fileAddress = newFile.getAbsolutePath(); 
    if (UtilClass.validateFileName(fileName)) { 
     this.presenter.startNewFile(fileName, 
fileAddress); 
    } else { 
     this.showInforMessage("The new file must 
have the \""+UtilClass.APP_FILE_EXT+"\" extension."); 
    } 
   } else { 
    this.showInforMessage("You must type or selected 
a new file to begin."); 
   } 
  } 
 } 
 
 private void slotOnMenuFileOpenCommand() { 
  if (this.fileDialog == null) { 
   fileDialog = new JFileChooser(); 
  } 
   
  final int resposta = fileDialog.showOpenDialog(this); 
  if (resposta == JFileChooser.APPROVE_OPTION) { 
   File newFile = this.fileDialog.getSelectedFile(); 
   if (newFile != null) { 
    String fileName = newFile.getName();; 
    String fileAddress = newFile.getAbsolutePath(); 
    if (UtilClass.validateFileName(fileName)) { 
     this.presenter.openFile(fileName, 
fileAddress); 
    } else { 
     this.showInforMessage("The file must have 
the \""+UtilClass.APP_FILE_EXT+"\" extension."); 
    } 
   } else { 
    this.showInforMessage("You must type or selected 
a file to open."); 
   } 
  } 
 } 
 
 /*------------------- 
  * Interface Methods: 
  -------------------*/ 
 @Override 
 public&amp;lt;T extends Presenter&gt; void registerPresenter(T presenter) { 
  this.presenter = (MainPresenter)presenter; 
 } 
 
 @Override 
 public void close() { 
  super.dispose(); 
 } 
  
 @Override 
 public void setAppTitle(String appTitle) { 
  this.setTitle(appTitle); 
 } 
  
 @Override 
 public void setMainFormEnabled(boolean enabled) { 
  this.menuFile.setEnabled(enabled); 
  this.allowViewChanges(enabled); 
 } 
  
 @Override 
 public void allowViewChanges(boolean allowed) { 
  this.tabBar.setEnabled(allowed); 
 } 
  
 @Override 
 public void selectProjectView() { 



  

  this.tabBar.setSelectedIndex(Modules.PROJECT_FORM.ordinal()); 
 } 
  
 @Override 
 public void selectCompetenceQuestionsView() { 
 
 this.tabBar.setSelectedIndex(Modules.COMPETENCE_QUESTIONS_FORM.ordinal(
)); 
 } 
  
 @Override 
 public void selectTermsView() { 
  this.tabBar.setSelectedIndex(Modules.TERMS_FORM.ordinal()); 
 } 
  
 @Override 
 public void showMessage(MESSAGES message) { 
  final String viewMessage; 
  switch (message) { 
  case FAIL_ON_OPEN_PROJECT: { 
   viewMessage = 
    "There was a problem on open the project.\n" + 
    "Check the XML file structure!"; 
   break; 
  } 
  case NO_PROJECT_TO_PERSIST: { 
   viewMessage = "There is no open project to persist."; 
   break; 
  } 
  case FAIL_ON_PROJECT_PERSISTENCE: { 
   viewMessage = "There was a problem on the persistence of 
the project."; 
   break; 
  } 
  case PROJECT_PERSISTED: { 
   viewMessage = "The project was persisted successfully."; 
   break; 
  } 
  default: { 
   viewMessage = null; 
   break; 
  } 
  } 
   
  if (viewMessage != null) { 
   this.showInforMessage(viewMessage); 
  } 
 } 
  
 private JTabbedPane getTabBar() { 
  if (tabBar == null) { 
   tabBar = new JTabbedPane(); 
   tabBar.setName("tabBar"); 
    
   tabBar.addTab(Modules.PROJECT_FORM.getTabTitle(), 
getProjectFormImpl()); 
  
 tabBar.addTab(Modules.COMPETENCE_QUESTIONS_FORM.getTabTitle(), 
getCompetenceQuestionsFormImpl()); 
   tabBar.addTab(Modules.TERMS_FORM.getTabTitle(), 
getTermsFormImpl()); 
  } 
  return tabBar; 
 } 
 
 private JMenuBar getAppMenuBar() { 
  if (appMenuBar == null) { 
   appMenuBar = new JMenuBar(); 
   appMenuBar.add(getMenuFile()); 
  } 
  return appMenuBar; 
 } 
 
 private JMenu getMenuFile() { 
  if (menuFile == null) { 
   menuFile = new JMenu(); 
   menuFile.setText("File"); 
   menuFile.add(getMenuItemNew()); 
   menuFile.add(getMenuItemOpen()); 
   menuFile.add(getMenuItemPersist()); 



  

  } 
  return menuFile; 
 } 
 
 private JMenuItem getMenuItemNew() { 
  if (menuItemNew == null) { 
   menuItemNew = new JMenuItem(); 
   menuItemNew.setText("New..."); 
   menuItemNew.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     if (presenter != null) { 
     
 MainFormImpl.this.slotOnMenuFileNewCommand(); 
     } 
    } 
   }); 
  } 
  return menuItemNew; 
 } 
 
 private JMenuItem getMenuItemOpen() { 
  if (menuItemOpen == null) { 
   menuItemOpen = new JMenuItem(); 
   menuItemOpen.setText("Open..."); 
   menuItemOpen.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     if (presenter != null) { 
     
 MainFormImpl.this.slotOnMenuFileOpenCommand(); 
     } 
    } 
   }); 
  } 
  return menuItemOpen; 
 } 
 
 private JMenuItem getMenuItemPersist() { 
  if (menuItemPersist == null) { 
   menuItemPersist = new JMenuItem(); 
   menuItemPersist.setText("Persist project..."); 
   menuItemPersist.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     if (presenter != null) { 
      presenter.persistProject(); 
     } 
    } 
   }); 
  } 
  return menuItemPersist; 
 } 
} 
 

? Classe TermFormImpl.java: 
package gui; 
 
import java.awt.Dimension; 
import java.awt.FlowLayout; 
import java.awt.GridBagConstraints; 
import java.awt.GridBagLayout; 
import java.awt.Insets; 
import java.util.ArrayList; 
import java.util.LinkedHashMap; 
import java.util.List; 
import java.util.Map; 
import java.util.Set; 
import java.util.Vector; 
 
import javax.swing.JButton; 
import javax.swing.JComboBox; 
import javax.swing.JDesktopPane; 
import javax.swing.JInternalFrame; 
import javax.swing.JLabel; 



  

import javax.swing.JList; 
import javax.swing.JOptionPane; 
import javax.swing.JPanel; 
import javax.swing.JScrollPane; 
import javax.swing.JSplitPane; 
import javax.swing.JTabbedPane; 
import javax.swing.SwingConstants; 
import javax.swing.WindowConstants; 
 
import system.mvp.Presenter; 
import system.utils.UtilClass; 
import system.utils.UtilClass.MESSAGES; 
import view.terms.TermsForm; 
import view.terms.TermsPresenter; 
 
public class TermsFormImpl extends JDesktopPane implements TermsForm { 
 
 private static final long serialVersionUID = 1L; 
  
 private List&lt;String&gt; orderedTerms = null; 
 private List&lt;String&gt; notOrderedTerms = null; 
  
 private List&lt;String&gt; combineTermsList = null; 
 private Set&lt;Integer&gt; commonQuestions = null; 
 private Set&lt;Integer&gt; commonAnswers = null; 
  
 private TermsPresenter presenter; 
 
 private JPanel panelExtractCommands = null; 
 private JButton buttonExtractTerms = null; 
 private JScrollPane scrollPaneExtractedTerms = null; 
 private JPanel panelMiddleButtons = null; 
 private JButton buttonAddTerm = null; 
 private JScrollPane scrollPaneChosenTerms = null; 
 private JPanel panelPersistCommands = null; 
 private JButton buttonPersistTerms = null; 
 private JButton buttonCombineTerms = null; 
 private JButton buttonOrderTerms = null; 
 private JButton buttonRemoveTerm = null; 
 private JListTerms jListExtractedTerms = null; 
 private JListTerms jListChosenTerms = null; 
 private JTabbedPane tabbedPaneExtractedTerms = null; 
 private JTabbedPane tabbedPaneChosenTerms = null; 
 private JPanel panelOrderBy = null; 
 private JLabel captionOrderBy = null; 
 private JComboBox comboBoxOrderBy = null; 
 private JInternalFrame jInternalFrameOrderTerms = null; 
 private JPanel jContentPaneOrderTerms = null; 
 private JSplitPane jSplitPaneOrderTerms = null; 
 private JScrollPane scrollPaneNotOrderedTerms = null; 
 private JScrollPane scrollPaneOrderedTerms = null; 
 private JList jListNotOrderedTerms = null; 
 private JList jListOrderedTerms = null; 
 private JLabel captionNotOrderedTerms = null; 
 private JLabel captionOrderedTerms = null; 
 private JPanel panelNotOrderedTerms = null; 
 private JPanel panelOrderedTerms = null; 
 private JPanel bottomBarOrderTerms = null; 
 private JButton buttonOrderTermsConfirm = null; 
 private JButton buttonOrderTermsCancel = null; 
 private JButton buttonAddToOrderedTerms = null; 
 private JButton buttonRemoveToNotOrderedTerms = null; 
 private JButton buttonOrderUp = null; 
 private JButton buttonOrderDown = null; 
 private JInternalFrame jInternalFrameCombineTerms = null; 
 private JPanel jContentPaneCombineTerms = null; 
 private JScrollPane scrollPaneCombineTerms = null; 
 private JList jListCombineTerms = null; 
 private JPanel bottomBarCombineTerms = null; 
 private JButton buttonCombineTermsConfirm = null; 
 private JButton buttonCombineTermsCancel = null; 
 private JPanel panelButtonsCombineTerms = null; 
 private JButton buttonCombineTermsUp = null; 
 private JButton buttonCombineTermsDown = null; 
 private JButton buttonCombineTermsAdd = null; 
 
 public TermsFormImpl() { 
  super(); 
  initialize(); 
 } 



  

 
 private void initialize() { 
  GridBagConstraints gridBagConstraints2 = new 
GridBagConstraints(); 
  gridBagConstraints2.gridx = 3; 
  gridBagConstraints2.fill = GridBagConstraints.BOTH; 
  gridBagConstraints2.gridy = 0; 
  GridBagConstraints gridBagConstraints31 = new 
GridBagConstraints(); 
  gridBagConstraints31.fill = GridBagConstraints.BOTH; 
  gridBagConstraints31.gridy = 1; 
  gridBagConstraints31.weightx = 1.0; 
  gridBagConstraints31.weighty = 1.0; 
  gridBagConstraints31.anchor = GridBagConstraints.EAST; 
  gridBagConstraints31.insets = new Insets(0, 2, 2, 2); 
  gridBagConstraints31.gridwidth = 1; 
  gridBagConstraints31.gridx = 5; 
  GridBagConstraints gridBagConstraints22 = new 
GridBagConstraints(); 
  gridBagConstraints22.fill = GridBagConstraints.BOTH; 
  gridBagConstraints22.gridy = 1; 
  gridBagConstraints22.weightx = 1.0; 
  gridBagConstraints22.weighty = 1.0; 
  gridBagConstraints22.gridwidth = 1; 
  gridBagConstraints22.insets = new Insets(0, 2, 2, 2); 
  gridBagConstraints22.anchor = GridBagConstraints.WEST; 
  gridBagConstraints22.gridx = 0; 
  GridBagConstraints gridBagConstraints21 = new 
GridBagConstraints(); 
  gridBagConstraints21.gridx = 5; 
  gridBagConstraints21.anchor = GridBagConstraints.NORTHWEST; 
  gridBagConstraints21.insets = new Insets(2, 2, 0, 2); 
  gridBagConstraints21.fill = GridBagConstraints.HORIZONTAL; 
  gridBagConstraints21.gridy = 0; 
  GridBagConstraints gridBagConstraints3 = new 
GridBagConstraints(); 
  gridBagConstraints3.gridx = 3; 
  gridBagConstraints3.insets = new Insets(2, 2, 2, 2); 
  gridBagConstraints3.fill = GridBagConstraints.VERTICAL; 
  gridBagConstraints3.ipadx = 0; 
  gridBagConstraints3.ipady = 0; 
  gridBagConstraints3.gridy = 1; 
  GridBagConstraints gridBagConstraints = new 
GridBagConstraints(); 
  gridBagConstraints.gridx = 0; 
  gridBagConstraints.fill = GridBagConstraints.HORIZONTAL; 
  gridBagConstraints.insets = new Insets(2, 2, 0, 2); 
  gridBagConstraints.anchor = GridBagConstraints.NORTHWEST; 
  gridBagConstraints.gridy = 0; 
  this.setSize(600, 300); 
  this.setLayout(new GridBagLayout()); 
  this.add(getPanelExtractCommands(), gridBagConstraints); 
  this.add(getTabbedPaneExtractedTerms(), gridBagConstraints22); 
  this.add(getPanelMiddleButtons(), gridBagConstraints3); 
  this.add(getPanelPersistCommands(), gridBagConstraints21); 
  this.add(getTabbedPaneChosenTerms(), gridBagConstraints31); 
  this.add(getPanelOrderBy(), gridBagConstraints2); 
 } 
  
 private void showInfoMessage(final String message) { 
  JOptionPane.showMessageDialog(this, message); 
 } 
  
 /*------------------- 
  * Overrided Methods: 
  -------------------*/ 
 @Override 
 public void setVisible(boolean flag) { 
  super.setVisible(flag); 
  if (this.presenter != null) { 
   if (flag) { 
    this.presenter.fillIn(); 
   } else { 
    this.presenter.fillOut(); 
   } 
  } 
 } 
  
 /*------------------- 
  * Interface Methods: 



  

  -------------------*/ 
 @Override 
 public OrderByOptions getOrderByOption() { 
  final int orderChoise = this.getOrderChoise(); 
  if (orderChoise &gt;= 0) { 
   return OrderByOptions.getOptionByOrdinal(orderChoise); 
  } 
  return null; 
 } 
  
 @Override 
 public List&lt;String&gt; getNotOrderedTerms() { 
  return this.notOrderedTerms; 
 } 
  
 @Override 
 public List&lt;String&gt; getOrderedTerms() { 
  return this.orderedTerms; 
 } 
  
 @Override 
 public void setModalMode(boolean modalEnabled) { 
  final boolean visible = !modalEnabled; 
   
  this.panelOrderBy.setVisible(visible); 
  this.panelExtractCommands.setVisible(visible); 
  this.panelPersistCommands.setVisible(visible); 
  this.panelMiddleButtons.setVisible(visible);   
  this.tabbedPaneExtractedTerms.setVisible(visible); 
  this.tabbedPaneChosenTerms.setVisible(visible); 
 } 
  
 @Override 
 public void showException(MESSAGES exceptionEnum) { 
  String message = null; 
  switch (exceptionEnum) { 
   case EXTRACT_TERMS_EXCEPTION: { 
    message = "Houve um problema durante a extração 
dos termos!"; 
    break; 
   } 
   case NO_COMMON_ORIGINS: { 
    message = "Os termos precisam ter perguntas de 
competência (ou respostas) em comum para serem combinados."; 
    break; 
   } 
  } 
  if (message != null &amp;amp;&amp;amp; !message.isEmpty()) { 
   this.showInfoMessage(message); 
  } 
 } 
 
 @Override 
 public&amp;lt;T extends Presenter&gt; void registerPresenter(T presenter) { 
  this.presenter = (TermsPresenter)presenter; 
 } 
  
 @Override 
 public void setExtractedTermsList(final Map&lt;String, String&gt; 
extractedTermsMap) { 
  this.jListExtractedTerms.setData(extractedTermsMap); 
 } 
  
 @Override 
 public void setChosenTermsList(Map&lt;String, String&gt; chosenTermsMap) { 
  this.jListChosenTerms.setData(chosenTermsMap); 
 } 
  
 @Override 
 public void setTermsPersistenceNeed(final boolean needed) { 
  this.buttonPersistTerms.setEnabled(needed); 
 } 
  
 @Override 
 public void showDetailToExtractTerms( 
   final Map&lt;String, Integer&gt; availableCategoriesToExtract) 
{ 
  if (availableCategoriesToExtract != null &amp;amp;&amp;amp; 
    availableCategoriesToExtract.size() &gt; 0) { 
   final String choice = this.showExtractTermsDialog( 



  

    
 availableCategoriesToExtract.keySet().toArray(new String[]{})); 
   if (choice != null &amp;amp;&amp;amp; !choice.isEmpty()) { 
    final Integer categoryID = 
availableCategoriesToExtract.get(choice); 
    presenter.extractTerms(categoryID); 
   } 
  } else { 
   this.showInfoMessage( 
     "There aren't competence questions 
available\n" + 
     "for the extraction of terms."); 
  } 
 } 
  
 @Override 
 public void showDetailToRemoveTerms(final List&lt;String&gt; termsList) { 
  final String title = "Removing chosen term..."; 
  final String message = "You really want to remove the selected 
chosen term(s)?"; 
  final int choice = JOptionPane.showConfirmDialog(this, message, 
title, JOptionPane.OK_CANCEL_OPTION); 
  if (choice == JOptionPane.OK_OPTION) { 
   presenter.removeChosenTerms(termsList); 
  } 
 } 
  
 @Override 
 public void showDetailToOrderTerms(final List&lt;String&gt; orderedTerms, 
   final List&lt;String&gt; notOrderedTerms) { 
  if (orderedTerms != null &amp;amp;&amp;amp; notOrderedTerms != null &amp;amp;&amp;amp; 
    (orderedTerms.size() &gt; 0 || 
notOrderedTerms.size() &gt; 0)) { 
   this.showOrderTermsDetail(orderedTerms, 
notOrderedTerms); 
  } else { 
   this.showInfoMessage("No terms available to order."); 
  } 
 } 
  
 @Override 
 public void finishOrderTerms() { 
  if (this.jInternalFrameOrderTerms != null) { 
   this.jInternalFrameOrderTerms.doDefaultCloseAction(); 
  } 
 } 
  
 @Override 
 public void showDetailToCombineTerms(final List&lt;String&gt; termsList, 
   final Set&lt;Integer&gt; commonQuestions, final Set&lt;Integer&gt; 
commonAnswers) { 
  this.combineTermsList = termsList; 
  this.commonQuestions = commonQuestions; 
  this.commonAnswers = commonAnswers; 
  if (this.jInternalFrameCombineTerms == null) { 
   this.add(this.getJInternalFrameCombineTerms(), null); 
  } 
  this.jInternalFrameCombineTerms.show(); 
  this.refreshCombineTermsList(); 
 } 
  
 @Override 
 public void finishCombineTerms(final MESSAGES message) { 
  if (jInternalFrameCombineTerms != null) { 
   jInternalFrameCombineTerms.doDefaultCloseAction(); 
  } 
  if (message == null) { 
   this.jListExtractedTerms.setSelectedIndices(new int[0]); 
  } else { 
   switch (message) { 
    case TERM_ALLREADY_EXIST: 
     this.showInfoMessage("O termo resultante 
da combinação já existe nos termos escolhidos."); 
     break; 
    case COMBINE_TERMS_EXCEPTION: 
     this.showInfoMessage("Houve um problema 
durante a combinação dos termos!"); 
     break; 
   } 
  } 



  

 } 
 
 /*------------------------ 
  * Inner Details Methods: 
  ------------------------*/ 
 private String showExtractTermsDialog(final String[] selectionValues) { 
  final String title = "Terms extraction..."; 
  final String message = 
   "Select a category to perform the extraction\n" + 
   "of the terms of their competence questions."; 
  return (String)JOptionPane.showInputDialog( 
    this, message, title, 
JOptionPane.OK_CANCEL_OPTION, null, 
    selectionValues, selectionValues[0]); 
 } 
  
 private void showOrderTermsDetail(final List&lt;String&gt; orderedTerms, 
   final List&lt;String&gt; notOrderedTerms) { 
  this.orderedTerms = orderedTerms; 
  this.notOrderedTerms = notOrderedTerms; 
  if (this.jInternalFrameOrderTerms == null) { 
   this.add(this.getJInternalFrameOrderTerms(), null); 
  } 
  this.jInternalFrameOrderTerms.show(); 
  this.refreshNotOrderedListData(); 
  this.refreshOrderedListData(); 
 } 
  
 /*---------------------- 
  * Manipulation Methods: 
  ----------------------*/ 
 private void refreshOrderedListData() { 
  this.jListOrderedTerms.setListData(new 
Vector&lt;String&gt;(this.orderedTerms)); 
 } 
  
 private void refreshNotOrderedListData() { 
  this.jListNotOrderedTerms.setListData(new 
Vector&lt;String&gt;(this.notOrderedTerms)); 
 } 
  
 private void addToOrderedTermsList(final int[] selectedIndices) { 
  final List&lt;String&gt; auxList = new 
ArrayList&lt;String&gt;(selectedIndices.length); 
  for (int index : selectedIndices) { 
   auxList.add(this.notOrderedTerms.get(index)); 
  } 
  this.orderedTerms.addAll(auxList); 
  this.notOrderedTerms.removeAll(auxList); 
  this.refreshNotOrderedListData(); 
  this.refreshOrderedListData(); 
 } 
  
 private void removeToNotOrderedList(final int[] selectedIndices) { 
  final List&lt;String&gt; auxList = new 
ArrayList&lt;String&gt;(selectedIndices.length); 
  for (int index : selectedIndices) { 
   auxList.add(this.orderedTerms.get(index)); 
  } 
  this.notOrderedTerms.addAll(auxList); 
  this.orderedTerms.removeAll(auxList); 
  this.refreshNotOrderedListData(); 
  this.refreshOrderedListData(); 
 } 
  
 private void setOrderUp(final int index) { 
  if (index &gt; 0) { 
   final String movedTerm = this.orderedTerms.get(index); 
   final int newPosition = index-1; 
   final int length = this.orderedTerms.size(); 
   final List&lt;String&gt; auxList = new 
ArrayList&lt;String&gt;(length); 
   for (int i=0; i &amp;lt;length; i++) { 
    if (i == newPosition) { 
     auxList.add(movedTerm); 
     auxList.add(this.orderedTerms.get(i)); 
    } else if (i != index) { 
     auxList.add(this.orderedTerms.get(i)); 
    } 
   } 



  

   this.orderedTerms = auxList; 
   this.refreshOrderedListData(); 
   this.jListOrderedTerms.setSelectedIndex(newPosition); 
  } 
 } 
  
 private void setOrderDown(final int index) { 
  final int length = this.orderedTerms.size(); 
  if (index &amp;lt;(length-1)) { 
   final String movedTerm = this.orderedTerms.get(index); 
   final int newPosition = index+1; 
   final List&lt;String&gt; auxList = new 
ArrayList&lt;String&gt;(length); 
   for (int i=0; i &amp;lt;length; i++) { 
    if (i == newPosition) { 
     auxList.add(this.orderedTerms.get(i)); 
     auxList.add(movedTerm); 
    } else if (i != index) { 
     auxList.add(this.orderedTerms.get(i)); 
    } 
   } 
   this.orderedTerms = auxList; 
   this.refreshOrderedListData(); 
   this.jListOrderedTerms.setSelectedIndex(newPosition); 
  } 
 } 
  
 private void refreshCombineTermsList() { 
  this.jListCombineTerms.setListData(new 
Vector&lt;String&gt;(this.combineTermsList)); 
 } 
  
 private void setCombineOrderUp(final int index) { 
  if (index &gt; 0) { 
   final String movedTerm = 
this.combineTermsList.get(index); 
   final int newPosition = index-1; 
   final int length = this.combineTermsList.size(); 
   final List&lt;String&gt; auxList = new 
ArrayList&lt;String&gt;(length); 
   for (int i=0; i &amp;lt;length; i++) { 
    if (i == newPosition) { 
     auxList.add(movedTerm); 
    
 auxList.add(this.combineTermsList.get(i)); 
    } else if (i != index) { 
    
 auxList.add(this.combineTermsList.get(i)); 
    } 
   } 
   this.combineTermsList = auxList; 
   this.refreshCombineTermsList(); 
   this.jListCombineTerms.setSelectedIndex(newPosition); 
  } 
 } 
  
 private void setCombineOrderDown(final int index) { 
  final int length = this.combineTermsList.size(); 
  if (index &amp;lt;(length-1)) { 
   final String movedTerm = 
this.combineTermsList.get(index); 
   final int newPosition = index+1; 
   final List&lt;String&gt; auxList = new 
ArrayList&lt;String&gt;(length); 
   for (int i=0; i &amp;lt;length; i++) { 
    if (i == newPosition) { 
    
 auxList.add(this.combineTermsList.get(i)); 
     auxList.add(movedTerm); 
    } else if (i != index) { 
    
 auxList.add(this.combineTermsList.get(i)); 
    } 
   } 
   this.combineTermsList = auxList; 
   this.refreshCombineTermsList(); 
   this.jListCombineTerms.setSelectedIndex(newPosition); 
  } 
 } 
  



  

 private void addPrepositionToCombineTerms() { 
  final String title = "Adding a preposition to combine terms..."; 
  final String message = "Informe a preposição que deseja 
inserir:"; 
  final String preposition = JOptionPane.showInputDialog(this, 
message, title, JOptionPane.OK_CANCEL_OPTION); 
   
  if (preposition != null &amp;amp;&amp;amp; !preposition.trim().isEmpty()) { 
   final int length = this.combineTermsList.size(); 
   final List&lt;String&gt; auxList = new 
ArrayList&lt;String&gt;(length+1); 
   final String addedTerm = 
UtilClass.formatTermsMapKey(preposition.trim()); 
   auxList.add(addedTerm); 
   for (int i=0; i &amp;lt;length; i++) { 
    auxList.add(this.combineTermsList.get(i)); 
   } 
   this.combineTermsList = auxList; 
   this.refreshCombineTermsList(); 
   this.jListCombineTerms.setSelectedIndex(0); 
  } 
 } 
  
 /*--------------- 
  * Inner Classes: 
  ---------------*/ 
 private class JListTerms extends JList { 
 
  private static final long serialVersionUID = 1L; 
   
  private Map&lt;Integer, String&gt; mapIndexToDataID; 
   
  public JListTerms() { 
   super(); 
  } 
   
  /** 
   * @deprecated usar setData(Map&lt;String, String&gt; termsMap) 
   */ 
  @Override 
  public void setListData(Object[] listData) { 
   super.setListData(listData); 
  } 
   
  /** 
   * @deprecated usar setData(Map&lt;String, String&gt; termsMap) 
   */ 
  @Override 
  public void setListData(Vector&lt;?&gt; listData) { 
   super.setListData(listData); 
  } 
   
  public void setData(final Map&lt;String, String&gt; termsMap) { 
   final int length = (termsMap != null ? termsMap.size() : 
0); 
   this.mapIndexToDataID = new LinkedHashMap&lt;Integer, 
String&gt;(length); 
   final Vector&lt;String&gt; listData = new 
Vector&lt;String&gt;(length); 
    
   if (length &gt; 0) { 
    final Set&lt;String&gt; keySet = termsMap.keySet(); 
    for (String dataID : keySet) { 
     listData.add(termsMap.get(dataID)); 
    
 this.mapIndexToDataID.put(listData.size()-1, dataID); 
    } 
   } 
    
   super.setListData(listData); 
  } 
   
  public String getSelectedDataID() { 
   if (this.mapIndexToDataID != null &amp;amp;&amp;amp; 
this.mapIndexToDataID.size() &gt; 0) { 
    final int selectedIndex = 
super.getSelectedIndex(); 
    if (selectedIndex &gt;= 0) { 
     return 
this.mapIndexToDataID.get(selectedIndex); 



  

    } 
   } 
   return null; 
  } 
   
  public List&lt;String&gt; getSelectedDataIDsList() { 
   final int[] selectedIndices = 
super.getSelectedIndices(); 
   final int length = selectedIndices.length; 
   final List&lt;String&gt; selectedIDs = new 
ArrayList&lt;String&gt;(length); 
   for (int i=0; i &amp;lt;length; i++) { 
   
 selectedIDs.add(this.mapIndexToDataID.get(selectedIndices[i])); 
   } 
   return selectedIDs; 
  } 
   
 } 
  
 private JPanel getPanelExtractCommands() { 
  if (panelExtractCommands == null) { 
   FlowLayout flowLayout = new FlowLayout(); 
   flowLayout.setAlignment(java.awt.FlowLayout.LEFT); 
   panelExtractCommands = new JPanel(); 
   panelExtractCommands.setLayout(flowLayout); 
   panelExtractCommands.add(getButtonExtractTerms(), null); 
  } 
  return panelExtractCommands; 
 } 
 
 private JButton getButtonExtractTerms() { 
  if (buttonExtractTerms == null) { 
   buttonExtractTerms = new JButton(); 
   buttonExtractTerms.setText("Extract..."); 
  
 buttonExtractTerms.setVerticalAlignment(SwingConstants.BOTTOM); 
   buttonExtractTerms.setToolTipText("Extract terms from 
the competence questions."); 
   buttonExtractTerms.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     if (presenter != null) { 
      presenter.doExtractTerms(); 
     } 
    } 
   }); 
  } 
  return buttonExtractTerms; 
 } 
 
 private JScrollPane getScrollPaneExtractedTerms() { 
  if (scrollPaneExtractedTerms == null) { 
   scrollPaneExtractedTerms = new JScrollPane(); 
  
 scrollPaneExtractedTerms.setViewportView(getJListExtractedTerms()); 
  } 
  return scrollPaneExtractedTerms; 
 } 
 
 private JPanel getPanelMiddleButtons() { 
  if (panelMiddleButtons == null) { 
   GridBagConstraints gridBagConstraints1 = new 
GridBagConstraints(); 
   gridBagConstraints1.gridx = 0; 
   gridBagConstraints1.fill = 
GridBagConstraints.HORIZONTAL; 
   gridBagConstraints1.insets = new Insets(2, 2, 2, 2); 
   gridBagConstraints1.gridy = 1; 
   GridBagConstraints gridBagConstraints4 = new 
GridBagConstraints(); 
   gridBagConstraints4.gridx = 0; 
   gridBagConstraints4.insets = new Insets(2, 2, 2, 2); 
   gridBagConstraints4.fill = 
GridBagConstraints.HORIZONTAL; 
   gridBagConstraints4.gridy = 0; 
   panelMiddleButtons = new JPanel(); 
   panelMiddleButtons.setLayout(new GridBagLayout()); 



  

   panelMiddleButtons.add(getButtonAddTerm(), 
gridBagConstraints4); 
   panelMiddleButtons.add(getButtonCombineTerms(), 
gridBagConstraints1); 
  } 
  return panelMiddleButtons; 
 } 
 
 private JButton getButtonAddTerm() { 
  if (buttonAddTerm == null) { 
   buttonAddTerm = new JButton(); 
   buttonAddTerm.setText("Add »"); 
   buttonAddTerm.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     if (presenter != null) { 
      final List&lt;String&gt; selectedIDs = 
jListExtractedTerms.getSelectedDataIDsList(); 
      if (selectedIDs.size() == 0) { 
       showInfoMessage("Select, at 
least, one extracted term to add."); 
      } else { 
      
 presenter.addExtractedTerms(selectedIDs); 
      } 
     } 
    } 
   }); 
  } 
  return buttonAddTerm; 
 } 
 
 private JScrollPane getScrollPaneChosenTerms() { 
  if (scrollPaneChosenTerms == null) { 
   scrollPaneChosenTerms = new JScrollPane(); 
  
 scrollPaneChosenTerms.setViewportView(getJListSelectedTerms()); 
  } 
  return scrollPaneChosenTerms; 
 } 
 
 private JPanel getPanelPersistCommands() { 
  if (panelPersistCommands == null) { 
   FlowLayout flowLayout1 = new FlowLayout(); 
   flowLayout1.setAlignment(java.awt.FlowLayout.RIGHT); 
   panelPersistCommands = new JPanel(); 
   panelPersistCommands.setLayout(flowLayout1); 
   panelPersistCommands.add(getButtonRemoveTerm(), null); 
   panelPersistCommands.add(getButtonOrderTerms(), null); 
   panelPersistCommands.add(getButtonPersistTerms(), null); 
  } 
  return panelPersistCommands; 
 } 
 
 private JButton getButtonPersistTerms() { 
  if (buttonPersistTerms == null) { 
   buttonPersistTerms = new JButton(); 
   buttonPersistTerms.setText("Persist"); 
  
 buttonPersistTerms.setVerticalAlignment(SwingConstants.BOTTOM); 
   buttonPersistTerms.setToolTipText("Persist the chosen 
terms."); 
   buttonPersistTerms.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     if (presenter != null) { 
      presenter.persistTerms(); 
     } 
    } 
   }); 
  } 
  return buttonPersistTerms; 
 } 
 
 private JButton getButtonCombineTerms() { 
  if (buttonCombineTerms == null) { 
   buttonCombineTerms = new JButton(); 
   buttonCombineTerms.setText("Combine"); 



  

  
 buttonCombineTerms.setVerticalAlignment(SwingConstants.BOTTOM); 
   buttonCombineTerms.setToolTipText("Combine some 
extracted terms to generate a single one to add."); 
   buttonCombineTerms.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     if (presenter != null) { 
      final List&lt;String&gt; selectedIDs = 
jListExtractedTerms.getSelectedDataIDsList(); 
      final int length = 
selectedIDs.size(); 
      if (length &gt;= 2) { 
      
 presenter.doCombineTerms(selectedIDs); 
      } else { 
       showInfoMessage("Selecione 
ao menos 2 termos para combinar."); 
      } 
     } 
    } 
   }); 
  } 
  return buttonCombineTerms; 
 } 
 
 private JButton getButtonOrderTerms() { 
  if (buttonOrderTerms == null) { 
   buttonOrderTerms = new JButton(); 
   buttonOrderTerms.setText("Order..."); 
  
 buttonOrderTerms.setVerticalAlignment(SwingConstants.BOTTOM); 
   buttonOrderTerms.setToolTipText("Order the chosen 
terms."); 
   buttonOrderTerms.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     if (presenter != null) { 
      presenter.doOrderTerms(); 
     } 
    } 
   }); 
  } 
  return buttonOrderTerms; 
 } 
 
 private JButton getButtonRemoveTerm() { 
  if (buttonRemoveTerm == null) { 
   buttonRemoveTerm = new JButton(); 
   buttonRemoveTerm.setText("Remove"); 
  
 buttonRemoveTerm.setVerticalAlignment(SwingConstants.BOTTOM); 
   buttonRemoveTerm.setToolTipText("Remove the selected 
chosen terms."); 
   buttonRemoveTerm.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     if (presenter != null) { 
      final List&lt;String&gt; selectedIDs = 
jListChosenTerms.getSelectedDataIDsList(); 
      if (selectedIDs.size() == 0) { 
       showInfoMessage("Select, at 
least, one chosen term to remove."); 
      } else { 
      
 presenter.doRemoveTerm(selectedIDs); 
      } 
     } 
    } 
   }); 
  } 
  return buttonRemoveTerm; 
 } 
 
 private JListTerms getJListExtractedTerms() { 
  if (jListExtractedTerms == null) { 
   jListExtractedTerms = new JListTerms(); 



  

  } 
  return jListExtractedTerms; 
 } 
 
 private JListTerms getJListSelectedTerms() { 
  if (jListChosenTerms == null) { 
   jListChosenTerms = new JListTerms(); 
  } 
  return jListChosenTerms; 
 } 
 
 private JTabbedPane getTabbedPaneExtractedTerms() { 
  if (tabbedPaneExtractedTerms == null) { 
   tabbedPaneExtractedTerms = new JTabbedPane(); 
   tabbedPaneExtractedTerms.addTab("Extracted Terms", null, 
getScrollPaneExtractedTerms(), null); 
  } 
  return tabbedPaneExtractedTerms; 
 } 
 
 private JTabbedPane getTabbedPaneChosenTerms() { 
  if (tabbedPaneChosenTerms == null) { 
   tabbedPaneChosenTerms = new JTabbedPane(); 
   tabbedPaneChosenTerms.addTab("Chosen Terms", null, 
getScrollPaneChosenTerms(), null); 
  } 
  return tabbedPaneChosenTerms; 
 } 
 
 private JPanel getPanelOrderBy() { 
  if (panelOrderBy == null) { 
   GridBagConstraints gridBagConstraints6 = new 
GridBagConstraints(); 
   gridBagConstraints6.fill = 
GridBagConstraints.HORIZONTAL; 
   gridBagConstraints6.gridy = 1; 
   gridBagConstraints6.weightx = 1.0; 
   gridBagConstraints6.insets = new Insets(0, 0, 0, 0); 
   gridBagConstraints6.gridx = 0; 
   GridBagConstraints gridBagConstraints5 = new 
GridBagConstraints(); 
   gridBagConstraints5.gridx = 0; 
   gridBagConstraints5.insets = new Insets(1, 1, 0, 1); 
   gridBagConstraints5.fill = 
GridBagConstraints.HORIZONTAL; 
   gridBagConstraints5.gridy = 0; 
   captionOrderBy = new JLabel(); 
   captionOrderBy.setText("Order by:"); 
   panelOrderBy = new JPanel(); 
   panelOrderBy.setLayout(new GridBagLayout()); 
   panelOrderBy.setVisible(true); 
   panelOrderBy.add(captionOrderBy, gridBagConstraints5); 
   panelOrderBy.add(getComboBoxOrderBy(), 
gridBagConstraints6); 
  } 
  return panelOrderBy; 
 } 
 
 private JComboBox getComboBoxOrderBy() { 
  if (comboBoxOrderBy == null) { 
   comboBoxOrderBy = new JComboBox(); 
   this.loadOrderByItems(); 
   comboBoxOrderBy.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     if (presenter != null) { 
      presenter.changeListsOrdenation(); 
     } 
    } 
   }); 
  } 
  return comboBoxOrderBy; 
 } 
 
 private void loadOrderByItems() { 
  final int length = TermsForm.OrderByOptions.values().length; 
  for (int i=0; i &amp;lt;length; i++) { 
   this.comboBoxOrderBy.addItem( 



  

    
 TermsForm.OrderByOptions.getOptionByOrdinal(i).getLabel()); 
  } 
 } 
  
 private int getOrderChoise() { 
  if (this.comboBoxOrderBy != null) { 
   return this.comboBoxOrderBy.getSelectedIndex(); 
  } 
  return -1; 
 } 
 
 private JInternalFrame getJInternalFrameOrderTerms() { 
  if (jInternalFrameOrderTerms == null) { 
   jInternalFrameOrderTerms = new JInternalFrame(); 
  
 jInternalFrameOrderTerms.setDefaultCloseOperation(WindowConstants.HIDE_
ON_CLOSE); 
   final Dimension size = new Dimension(400, 300); 
   jInternalFrameOrderTerms.setSize(size); 
   jInternalFrameOrderTerms.setMinimumSize(size); 
   jInternalFrameOrderTerms.setTitle("Order chosen terms"); 
  
 jInternalFrameOrderTerms.setContentPane(getJContentPaneOrderTerms()); 
   jInternalFrameOrderTerms 
     .addComponentListener(new 
java.awt.event.ComponentAdapter() {    
    public void 
componentShown(java.awt.event.ComponentEvent e) {     
     if (presenter != null) { 
      presenter.setModalMode(true); 
     } 
    } 
    public void 
componentHidden(java.awt.event.ComponentEvent e) { 
     orderedTerms = null; 
     notOrderedTerms = null; 
     if (presenter != null) { 
      presenter.setModalMode(false); 
     } 
    } 
     }); 
  } 
  return jInternalFrameOrderTerms; 
 } 
 
 private JPanel getJContentPaneOrderTerms() { 
  if (jContentPaneOrderTerms == null) { 
   GridBagConstraints gridBagConstraints12 = new 
GridBagConstraints(); 
   gridBagConstraints12.insets = new Insets(0, 2, 2, 2); 
   gridBagConstraints12.gridx = 0; 
   gridBagConstraints12.gridy = 1; 
   gridBagConstraints12.fill = 
GridBagConstraints.HORIZONTAL; 
   captionOrderedTerms = new JLabel(); 
   captionOrderedTerms.setText("Ordered Terms:"); 
   captionNotOrderedTerms = new JLabel(); 
   captionNotOrderedTerms.setText("Not Ordered Terms:"); 
   GridBagConstraints gridBagConstraints7 = new 
GridBagConstraints(); 
   gridBagConstraints7.fill = GridBagConstraints.BOTH; 
   gridBagConstraints7.gridy = 0; 
   gridBagConstraints7.weightx = 1.0; 
   gridBagConstraints7.weighty = 1.0; 
   gridBagConstraints7.gridwidth = 1; 
   gridBagConstraints7.insets = new Insets(2, 2, 2, 2); 
   gridBagConstraints7.gridx = 0; 
   jContentPaneOrderTerms = new JPanel(); 
   jContentPaneOrderTerms.setLayout(new GridBagLayout()); 
   jContentPaneOrderTerms.add(getJSplitPaneOrderTerms(), 
gridBagConstraints7); 
   jContentPaneOrderTerms.add(getBottomBarOrderTerms(), 
gridBagConstraints12); 
  } 
  return jContentPaneOrderTerms; 
 } 
 
 private JSplitPane getJSplitPaneOrderTerms() { 
  if (jSplitPaneOrderTerms == null) { 



  

   jSplitPaneOrderTerms = new JSplitPane(); 
   final int location = 
jInternalFrameOrderTerms.getWidth()/2; 
   jSplitPaneOrderTerms.setDividerLocation(location); 
  
 jSplitPaneOrderTerms.setRightComponent(getPanelOrderedTerms()); 
  
 jSplitPaneOrderTerms.setLeftComponent(getPanelNotOrderedTerms()); 
  } 
  return jSplitPaneOrderTerms; 
 } 
 
 private JScrollPane getScrollPaneNotOrderedTerms() { 
  if (scrollPaneNotOrderedTerms == null) { 
   scrollPaneNotOrderedTerms = new JScrollPane(); 
  
 scrollPaneNotOrderedTerms.setViewportView(getJListNotOrderedTerms()); 
  } 
  return scrollPaneNotOrderedTerms; 
 } 
 
 private JScrollPane getScrollPaneOrderedTerms() { 
  if (scrollPaneOrderedTerms == null) { 
   scrollPaneOrderedTerms = new JScrollPane(); 
  
 scrollPaneOrderedTerms.setViewportView(getJListOrderedTerms()); 
  } 
  return scrollPaneOrderedTerms; 
 } 
 
 private JList getJListNotOrderedTerms() { 
  if (jListNotOrderedTerms == null) { 
   jListNotOrderedTerms = new JList(); 
  } 
  return jListNotOrderedTerms; 
 } 
 
 private JList getJListOrderedTerms() { 
  if (jListOrderedTerms == null) { 
   jListOrderedTerms = new JList(); 
  } 
  return jListOrderedTerms; 
 } 
 
 private JPanel getPanelNotOrderedTerms() { 
  if (panelNotOrderedTerms == null) { 
   GridBagConstraints gridBagConstraints13 = new 
GridBagConstraints(); 
   gridBagConstraints13.gridx = 0; 
   gridBagConstraints13.anchor = 
GridBagConstraints.NORTHEAST; 
   gridBagConstraints13.insets = new Insets(2, 2, 2, 2); 
   gridBagConstraints13.gridy = 0; 
   GridBagConstraints gridBagConstraints8 = new 
GridBagConstraints(); 
   gridBagConstraints8.gridx = -1; 
   gridBagConstraints8.anchor = GridBagConstraints.WEST; 
   gridBagConstraints8.insets = new Insets(2, 2, 0, 2); 
   gridBagConstraints8.fill = 
GridBagConstraints.HORIZONTAL; 
   gridBagConstraints8.gridy = 1; 
   GridBagConstraints gridBagConstraints10 = new 
GridBagConstraints(); 
   gridBagConstraints10.fill = GridBagConstraints.BOTH; 
   gridBagConstraints10.weighty = 1.0; 
   gridBagConstraints10.gridheight = 1; 
   gridBagConstraints10.gridx = 0; 
   gridBagConstraints10.gridy = 2; 
   gridBagConstraints10.weightx = 1.0; 
   panelNotOrderedTerms = new JPanel(); 
   panelNotOrderedTerms.setLayout(new GridBagLayout()); 
   panelNotOrderedTerms.add(getButtonAddToOrderedTerms(), 
gridBagConstraints13); 
   panelNotOrderedTerms.add(captionNotOrderedTerms, 
gridBagConstraints8); 
   panelNotOrderedTerms.add(getScrollPaneNotOrderedTerms(), 
gridBagConstraints10); 
  } 
  return panelNotOrderedTerms; 
 } 



  

 
 private JPanel getPanelOrderedTerms() { 
  if (panelOrderedTerms == null) { 
   GridBagConstraints gridBagConstraints16 = new 
GridBagConstraints(); 
   gridBagConstraints16.gridx = 2; 
   gridBagConstraints16.anchor = 
GridBagConstraints.NORTHWEST; 
   gridBagConstraints16.insets = new Insets(2, 2, 2, 2); 
   gridBagConstraints16.gridy = 0; 
   GridBagConstraints gridBagConstraints15 = new 
GridBagConstraints(); 
   gridBagConstraints15.gridx = 1; 
   gridBagConstraints15.anchor = 
GridBagConstraints.NORTHWEST; 
   gridBagConstraints15.insets = new Insets(2, 2, 2, 2); 
   gridBagConstraints15.gridy = 0; 
   GridBagConstraints gridBagConstraints14 = new 
GridBagConstraints(); 
   gridBagConstraints14.gridx = 0; 
   gridBagConstraints14.anchor = 
GridBagConstraints.NORTHWEST; 
   gridBagConstraints14.insets = new Insets(2, 2, 2, 2); 
   gridBagConstraints14.fill = GridBagConstraints.NONE; 
   gridBagConstraints14.gridy = 0; 
   GridBagConstraints gridBagConstraints9 = new 
GridBagConstraints(); 
   gridBagConstraints9.gridx = 0; 
   gridBagConstraints9.fill = 
GridBagConstraints.HORIZONTAL; 
   gridBagConstraints9.insets = new Insets(2, 2, 0, 2); 
   gridBagConstraints9.anchor = GridBagConstraints.WEST; 
   gridBagConstraints9.gridwidth = 3; 
   gridBagConstraints9.gridy = 1; 
   GridBagConstraints gridBagConstraints11 = new 
GridBagConstraints(); 
   gridBagConstraints11.fill = GridBagConstraints.BOTH; 
   gridBagConstraints11.weighty = 1.0; 
   gridBagConstraints11.gridheight = 1; 
   gridBagConstraints11.gridx = 0; 
   gridBagConstraints11.gridy = 2; 
   gridBagConstraints11.gridwidth = 3; 
   gridBagConstraints11.weightx = 1.0; 
   panelOrderedTerms = new JPanel(); 
   panelOrderedTerms.setLayout(new GridBagLayout()); 
   panelOrderedTerms.add(captionOrderedTerms, 
gridBagConstraints9); 
   panelOrderedTerms.add(getScrollPaneOrderedTerms(), 
gridBagConstraints11); 
  
 panelOrderedTerms.add(getButtonRemoveToNotOrderedTerms(), 
gridBagConstraints14); 
   panelOrderedTerms.add(getButtonOrderUp(), 
gridBagConstraints15); 
   panelOrderedTerms.add(getButtonOrderDown(), 
gridBagConstraints16); 
  } 
  return panelOrderedTerms; 
 } 
 
 private JPanel getBottomBarOrderTerms() { 
  if (bottomBarOrderTerms == null) { 
   bottomBarOrderTerms = new JPanel(); 
   bottomBarOrderTerms.setLayout(new FlowLayout()); 
   bottomBarOrderTerms.add(getButtonOrderTermsConfirm(), 
null); 
   bottomBarOrderTerms.add(getButtonOrderTermsCancel(), 
null); 
  } 
  return bottomBarOrderTerms; 
 } 
 
 private JButton getButtonOrderTermsConfirm() { 
  if (buttonOrderTermsConfirm == null) { 
   buttonOrderTermsConfirm = new JButton(); 
   buttonOrderTermsConfirm.setText("Confirm"); 
   buttonOrderTermsConfirm.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 



  

     if (presenter != null) { 
      presenter.doConfirmOrderedTerms(); 
     } 
    } 
   }); 
  } 
  return buttonOrderTermsConfirm; 
 } 
 
 private JButton getButtonOrderTermsCancel() { 
  if (buttonOrderTermsCancel == null) { 
   buttonOrderTermsCancel = new JButton(); 
   buttonOrderTermsCancel.setText("Cancel"); 
   buttonOrderTermsCancel.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
    
 jInternalFrameOrderTerms.doDefaultCloseAction(); 
    } 
   }); 
  } 
  return buttonOrderTermsCancel; 
 } 
 
 private JButton getButtonAddToOrderedTerms() { 
  if (buttonAddToOrderedTerms == null) { 
   buttonAddToOrderedTerms = new JButton(); 
   buttonAddToOrderedTerms.setText("&gt;&gt;"); 
   buttonAddToOrderedTerms.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     if (notOrderedTerms != null &amp;amp;&amp;amp; 
notOrderedTerms.size() &gt; 0) { 
      final int[] selectedIndices = 
jListNotOrderedTerms.getSelectedIndices(); 
      final int length = 
selectedIndices.length; 
      if (length == 0) { 
       showInfoMessage("Selecione 
ao menos um termo para adicionar."); 
      } else { 
      
 TermsFormImpl.this.addToOrderedTermsList(selectedIndices); 
      }    
   
     } 
    } 
   }); 
  } 
  return buttonAddToOrderedTerms; 
 } 
 
 private JButton getButtonRemoveToNotOrderedTerms() { 
  if (buttonRemoveToNotOrderedTerms == null) { 
   buttonRemoveToNotOrderedTerms = new JButton(); 
   buttonRemoveToNotOrderedTerms.setText("&lt;&lt;"); 
   buttonRemoveToNotOrderedTerms 
     .addActionListener(new 
java.awt.event.ActionListener() { 
      public void 
actionPerformed(java.awt.event.ActionEvent e) { 
       if (orderedTerms != null &amp;amp;&amp;amp; 
orderedTerms.size() &gt; 0) { 
        final int[] 
selectedIndices = jListOrderedTerms.getSelectedIndices(); 
        final int length = 
selectedIndices.length; 
        if (length == 0) { 
        
 showInfoMessage("Selecione ao menos um termo ordenado para remover da 
listagem ordenada"); 
        } else { 
        
 TermsFormImpl.this.removeToNotOrderedList(selectedIndices); 
        } 
       } 
      } 
     }); 



  

  } 
  return buttonRemoveToNotOrderedTerms; 
 } 
 
 private JButton getButtonOrderUp() { 
  if (buttonOrderUp == null) { 
   buttonOrderUp = new JButton(); 
   buttonOrderUp.setText("UP"); 
   buttonOrderUp.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     if (orderedTerms != null &amp;amp;&amp;amp; 
orderedTerms.size() &gt; 1) { 
      final int[] selectedIndices = 
jListOrderedTerms.getSelectedIndices(); 
      final int length = 
selectedIndices.length; 
      if (length == 1) { 
      
 TermsFormImpl.this.setOrderUp(selectedIndices[0]); 
      } else if (length == 0) { 
       showInfoMessage("Selecione 
um termo para indicar a ordem."); 
      } else { 
       showInfoMessage("Apenas um 
termo pode ser selecionado para se indicar a ordem."); 
      } 
     } 
    } 
   }); 
  } 
  return buttonOrderUp; 
 } 
 
 private JButton getButtonOrderDown() { 
  if (buttonOrderDown == null) { 
   buttonOrderDown = new JButton(); 
   buttonOrderDown.setText("DOWN"); 
   buttonOrderDown.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     if (orderedTerms != null &amp;amp;&amp;amp; 
orderedTerms.size() &gt; 1) { 
      final int[] selectedIndices = 
jListOrderedTerms.getSelectedIndices(); 
      final int length = 
selectedIndices.length; 
      if (length == 1) { 
      
 TermsFormImpl.this.setOrderDown(selectedIndices[0]); 
      } else if (length == 0) { 
       showInfoMessage("Selecione 
um termo para indicar a ordem."); 
      } else { 
       showInfoMessage("Apenas um 
termo pode ser selecionado para se indicar a ordem."); 
      } 
     } 
    } 
   }); 
  } 
  return buttonOrderDown; 
 } 
 
 private JInternalFrame getJInternalFrameCombineTerms() { 
  if (jInternalFrameCombineTerms == null) { 
   jInternalFrameCombineTerms = new JInternalFrame(); 
   final Dimension size = new Dimension(250, 300); 
   jInternalFrameCombineTerms.setMinimumSize(size); 
   jInternalFrameCombineTerms.setSize(size); 
  
 jInternalFrameCombineTerms.setDefaultCloseOperation(WindowConstants.HID
E_ON_CLOSE); 
  
 jInternalFrameCombineTerms.setContentPane(getJContentPaneCombineTerms()
); 
   jInternalFrameCombineTerms 



  

     .addComponentListener(new 
java.awt.event.ComponentAdapter() {    
      public void 
componentShown(java.awt.event.ComponentEvent e) {     
       if (presenter != null) { 
       
 presenter.setModalMode(true); 
       } 
      } 
      public void 
componentHidden(java.awt.event.ComponentEvent e) { 
       commonQuestions = null; 
       commonAnswers = null; 
       if (presenter != null) { 
       
 presenter.setModalMode(false); 
       } 
      } 
     }); 
  } 
  return jInternalFrameCombineTerms; 
 } 
 
 private JPanel getJContentPaneCombineTerms() { 
  if (jContentPaneCombineTerms == null) { 
   GridBagConstraints gridBagConstraints19 = new 
GridBagConstraints(); 
   gridBagConstraints19.gridx = 0; 
   gridBagConstraints19.fill = GridBagConstraints.BOTH; 
   gridBagConstraints19.anchor = GridBagConstraints.NORTH; 
   gridBagConstraints19.insets = new Insets(2, 2, 0, 2); 
   gridBagConstraints19.gridy = 0; 
   GridBagConstraints gridBagConstraints18 = new 
GridBagConstraints(); 
   gridBagConstraints18.gridx = 0; 
   gridBagConstraints18.anchor = GridBagConstraints.SOUTH; 
   gridBagConstraints18.fill = 
GridBagConstraints.HORIZONTAL; 
   gridBagConstraints18.insets = new Insets(0, 2, 2, 2); 
   gridBagConstraints18.gridy = 2; 
   GridBagConstraints gridBagConstraints17 = new 
GridBagConstraints(); 
   gridBagConstraints17.fill = GridBagConstraints.BOTH; 
   gridBagConstraints17.gridy = 1; 
   gridBagConstraints17.weightx = 1.0; 
   gridBagConstraints17.weighty = 1.0; 
   gridBagConstraints17.insets = new Insets(6, 6, 6, 6); 
   gridBagConstraints17.gridx = 0; 
   jContentPaneCombineTerms = new JPanel(); 
   jContentPaneCombineTerms.setLayout(new GridBagLayout()); 
  
 jContentPaneCombineTerms.add(getPanelButtonsCombineTerms(), 
gridBagConstraints19); 
  
 jContentPaneCombineTerms.add(getScrollPaneCombineTerms(), 
gridBagConstraints17); 
   jContentPaneCombineTerms.add(getBottomBarCombineTerms(), 
gridBagConstraints18); 
  } 
  return jContentPaneCombineTerms; 
 } 
 
 private JScrollPane getScrollPaneCombineTerms() { 
  if (scrollPaneCombineTerms == null) { 
   scrollPaneCombineTerms = new JScrollPane(); 
  
 scrollPaneCombineTerms.setViewportView(getJListCombineTerms()); 
  } 
  return scrollPaneCombineTerms; 
 } 
 
 private JList getJListCombineTerms() { 
  if (jListCombineTerms == null) { 
   jListCombineTerms = new JList(); 
  } 
  return jListCombineTerms; 
 } 
 
 private JPanel getBottomBarCombineTerms() { 
  if (bottomBarCombineTerms == null) { 



  

   bottomBarCombineTerms = new JPanel(); 
   bottomBarCombineTerms.setLayout(new FlowLayout()); 
  
 bottomBarCombineTerms.add(getButtonCombineTermsConfirm(), null); 
   bottomBarCombineTerms.add(getButtonCombineTermsCancel(), 
null); 
  } 
  return bottomBarCombineTerms; 
 } 
 
 private JButton getButtonCombineTermsConfirm() { 
  if (buttonCombineTermsConfirm == null) { 
   buttonCombineTermsConfirm = new JButton(); 
   buttonCombineTermsConfirm.setText("Confirm"); 
   buttonCombineTermsConfirm 
     .addActionListener(new 
java.awt.event.ActionListener() { 
      public void 
actionPerformed(java.awt.event.ActionEvent e) { 
       if (presenter != null) { 
       
 presenter.addCombinedTerms( 
         
 combineTermsList, commonQuestions, commonAnswers); 
       } 
      } 
     }); 
  } 
  return buttonCombineTermsConfirm; 
 } 
 
 private JButton getButtonCombineTermsCancel() { 
  if (buttonCombineTermsCancel == null) { 
   buttonCombineTermsCancel = new JButton(); 
   buttonCombineTermsCancel.setText("Cancel"); 
   buttonCombineTermsCancel.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
    
 jInternalFrameCombineTerms.doDefaultCloseAction(); 
    } 
   }); 
  } 
  return buttonCombineTermsCancel; 
 } 
 
 private JPanel getPanelButtonsCombineTerms() { 
  if (panelButtonsCombineTerms == null) { 
   panelButtonsCombineTerms = new JPanel(); 
   panelButtonsCombineTerms.setLayout(new FlowLayout()); 
   panelButtonsCombineTerms.add(getButtonCombineTermsUp(), 
null); 
  
 panelButtonsCombineTerms.add(getButtonCombineTermsDown(), null); 
   panelButtonsCombineTerms.add(getButtonCombineTermsAdd(), 
null); 
  } 
  return panelButtonsCombineTerms; 
 } 
 
 private JButton getButtonCombineTermsUp() { 
  if (buttonCombineTermsUp == null) { 
   buttonCombineTermsUp = new JButton(); 
   buttonCombineTermsUp.setText("UP"); 
   buttonCombineTermsUp.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     final int[] selectedIndices = 
jListCombineTerms.getSelectedIndices(); 
     final int length = 
selectedIndices.length; 
     if (length == 1) { 
     
 TermsFormImpl.this.setCombineOrderUp(selectedIndices[0]); 
     } else if (length == 0) { 
      showInfoMessage("Selecione um 
termo para indicar a ordem de combinação."); 
     } else { 



  

      showInfoMessage("Apenas um termo 
pode ser selecionado para se indicar a ordem de combinação."); 
     } 
    } 
   }); 
  } 
  return buttonCombineTermsUp; 
 } 
 
 private JButton getButtonCombineTermsDown() { 
  if (buttonCombineTermsDown == null) { 
   buttonCombineTermsDown = new JButton(); 
   buttonCombineTermsDown.setText("DOWN"); 
   buttonCombineTermsDown.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     final int[] selectedIndices = 
jListCombineTerms.getSelectedIndices(); 
     final int length = 
selectedIndices.length; 
     if (length == 1) { 
     
 TermsFormImpl.this.setCombineOrderDown(selectedIndices[0]); 
     } else if (length == 0) { 
      showInfoMessage("Selecione um 
termo para indicar a ordem de combinação."); 
     } else { 
      showInfoMessage("Apenas um termo 
pode ser selecionado para se indicar a ordem de combinação."); 
     } 
    } 
   }); 
  } 
  return buttonCombineTermsDown; 
 } 
 
 private JButton getButtonCombineTermsAdd() { 
  if (buttonCombineTermsAdd == null) { 
   buttonCombineTermsAdd = new JButton(); 
   buttonCombineTermsAdd.setText("Add*"); 
   _above_ 
   buttonCombineTermsAdd.setToolTipText( 
     "Adiciona uma preposição entre os 
termos."); 
   buttonCombineTermsAdd.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
    
 TermsFormImpl.this.addPrepositionToCombineTerms();  
    } 
   }); 
  } 
  return buttonCombineTermsAdd; 
 } 
} 
 

? Classe ProjectFormImpl.java: 
package gui; 
 
import java.awt.CardLayout; 
import java.awt.Component; 
import java.awt.FlowLayout; 
import java.awt.Font; 
import java.awt.GridBagConstraints; 
import java.awt.GridBagLayout; 
import java.awt.Insets; 
import java.util.ArrayList; 
import java.util.Date; 
import java.util.Iterator; 
import java.util.List; 
import java.util.Vector; 
 
import javax.swing.JButton; 
import javax.swing.JLabel; 
import javax.swing.JList; 
import javax.swing.JOptionPane; 



  

import javax.swing.JPanel; 
import javax.swing.JScrollPane; 
import javax.swing.JSplitPane; 
import javax.swing.JTextArea; 
import javax.swing.JTextField; 
 
import system.mvp.Presenter; 
import system.utils.UtilClass; 
import view.project.ProjectForm; 
import view.project.ProjectPresenter; 
 
public class ProjectFormImpl extends JPanel implements ProjectForm { 
 
 private static final long serialVersionUID = 1L; 
  
 private enum BottomBarMode { 
  EMPTY_MODE(), 
  VIEW_MODE(), 
  EDIT_TEMPLATE(); 
 } 
  
 private List&lt;String&gt; listUsersDescriptions = new ArrayList&lt;String&gt;(0); 
 private List&lt;String&gt; listUsesScenarios = new ArrayList&lt;String&gt;(0); 
  
 private ProjectPresenter presenter; 
 
 private CardLayout bottomBarLayoutMgr; 
 
 private JLabel captionName = null; 
 private JLabel captionCreateDate = null; 
 private JTextField fieldName = null; 
 private JLabel fieldCreateDate = null; 
 private JLabel captionAutor = null; 
 private JTextField fieldAutor = null; 
 private JLabel captionPurpose = null; 
 private JScrollPane scrollPanePurpose = null; 
 private JTextArea fieldPurpose = null; 
 private JPanel bottomBar = null; 
 private JButton buttonSave = null; 
 private JButton buttonCancel = null; 
 private JPanel templateEditButton = null; 
 private JPanel templateSaveCancelButton = null; 
 private JButton buttonEdit = null; 
 private JLabel captionScope = null; 
 private JScrollPane scrollPaneScope = null; 
 private JTextArea fieldScope = null; 
 private JLabel captionFormalityLevel = null; 
 private JScrollPane scrollPaneFormalityLevel = null; 
 private JTextArea fieldFormalityLevel = null; 
 private JLabel captionUsersDescriptions = null; 
 private JButton buttonAddUserDescription = null; 
 private JScrollPane scrollPaneUsersDescriptions = null; 
 private JLabel captionUsesScenarios = null; 
 private JButton buttonAddUseScenario = null; 
 private JScrollPane scrollPaneUsesScenarios = null; 
 private JList jListUsersDescriptions = null; 
 private JList jListUsesScenarios = null; 
 private JPanel panelButtonsUsersDescriptions = null; 
 private JButton buttonEditUserDescription = null; 
 private JButton buttonRemoveUserDescription = null; 
 private JPanel panelButtonsUsesScenarios = null; 
 private JButton buttonEditUseScenario = null; 
 private JButton buttonRemoveUseScenario = null; 
 private JSplitPane splitPaneDescriptions = null; 
 private JPanel leftPanel = null; 
 private JPanel rightPanel = null; 
 
 public ProjectFormImpl() { 
  super(); 
  initialize(); 
 } 
  
 private void initialize() { 
  GridBagConstraints gridBagConstraints32 = new 
GridBagConstraints(); 
  gridBagConstraints32.fill = GridBagConstraints.BOTH; 
  gridBagConstraints32.gridy = 10; 
  gridBagConstraints32.weightx = 1.0; 
  gridBagConstraints32.weighty = 1.0; 
  gridBagConstraints32.gridwidth = 4; 



  

  gridBagConstraints32.insets = new Insets(2, 2, 2, 2); 
  gridBagConstraints32.gridx = 0; 
  captionUsesScenarios = new JLabel(); 
  captionUsesScenarios.setText("Uses Scenarios:"); 
  GridBagConstraints gridBagConstraints7 = new 
GridBagConstraints(); 
  gridBagConstraints7.gridx = 1; 
  gridBagConstraints7.gridy = 12; 
  captionUsersDescriptions = new JLabel(); 
  captionUsersDescriptions.setText("Users Descriptions:"); 
  GridBagConstraints gridBagConstraints13 = new 
GridBagConstraints(); 
  gridBagConstraints13.gridx = 0; 
  gridBagConstraints13.anchor = GridBagConstraints.NORTHWEST; 
  gridBagConstraints13.fill = GridBagConstraints.BOTH; 
  gridBagConstraints13.gridwidth = 2; 
  gridBagConstraints13.insets = new Insets(2, 2, 2, 2); 
  gridBagConstraints13.gridy = 11; 
  GridBagConstraints gridBagConstraints5 = new 
GridBagConstraints(); 
  gridBagConstraints5.fill = GridBagConstraints.BOTH; 
  gridBagConstraints5.gridy = 9; 
  gridBagConstraints5.weightx = 1.0; 
  gridBagConstraints5.weighty = 1.0; 
  gridBagConstraints5.anchor = GridBagConstraints.NORTHWEST; 
  gridBagConstraints5.insets = new Insets(0, 2, 2, 2); 
  gridBagConstraints5.gridwidth = 4; 
  gridBagConstraints5.gridx = 0; 
  GridBagConstraints gridBagConstraints41 = new 
GridBagConstraints(); 
  gridBagConstraints41.gridx = 0; 
  gridBagConstraints41.anchor = GridBagConstraints.NORTHWEST; 
  gridBagConstraints41.insets = new Insets(2, 2, 0, 2); 
  gridBagConstraints41.fill = GridBagConstraints.HORIZONTAL; 
  gridBagConstraints41.gridwidth = 4; 
  gridBagConstraints41.gridy = 8; 
  captionFormalityLevel = new JLabel(); 
  captionFormalityLevel.setText("Formality Level:"); 
  GridBagConstraints gridBagConstraints31 = new 
GridBagConstraints(); 
  gridBagConstraints31.fill = GridBagConstraints.BOTH; 
  gridBagConstraints31.gridy = 7; 
  gridBagConstraints31.weightx = 1.0; 
  gridBagConstraints31.weighty = 1.0; 
  gridBagConstraints31.anchor = GridBagConstraints.NORTHWEST; 
  gridBagConstraints31.insets = new Insets(0, 2, 2, 2); 
  gridBagConstraints31.gridwidth = 4; 
  gridBagConstraints31.gridx = 0; 
  GridBagConstraints gridBagConstraints11 = new 
GridBagConstraints(); 
  gridBagConstraints11.gridx = 0; 
  gridBagConstraints11.anchor = GridBagConstraints.NORTHWEST; 
  gridBagConstraints11.insets = new Insets(2, 2, 0, 2); 
  gridBagConstraints11.fill = GridBagConstraints.HORIZONTAL; 
  gridBagConstraints11.gridwidth = 4; 
  gridBagConstraints11.gridy = 6; 
  captionScope = new JLabel(); 
  captionScope.setText("Project scope:"); 
  GridBagConstraints gridBagConstraints12 = new 
GridBagConstraints(); 
  gridBagConstraints12.gridx = 0; 
  gridBagConstraints12.fill = GridBagConstraints.HORIZONTAL; 
  gridBagConstraints12.anchor = GridBagConstraints.SOUTHWEST; 
  gridBagConstraints12.insets = new Insets(2, 2, 2, 2); 
  gridBagConstraints12.gridwidth = 4; 
  gridBagConstraints12.gridy = 17; 
  GridBagConstraints gbcScrollPaneDescription = new 
GridBagConstraints(); 
  gbcScrollPaneDescription.fill = GridBagConstraints.BOTH; 
  gbcScrollPaneDescription.gridy = 5; 
  gbcScrollPaneDescription.weightx = 1.0; 
  gbcScrollPaneDescription.weighty = 1.0; 
  gbcScrollPaneDescription.gridwidth = 4; 
  gbcScrollPaneDescription.anchor = GridBagConstraints.NORTHWEST; 
  gbcScrollPaneDescription.insets = new Insets(0, 2, 2, 2); 
  gbcScrollPaneDescription.gridx = 0; 
  GridBagConstraints gbcCaptionDescription = new 
GridBagConstraints(); 
  gbcCaptionDescription.gridx = 0; 
  gbcCaptionDescription.anchor = GridBagConstraints.NORTHWEST; 



  

  gbcCaptionDescription.insets = new Insets(2, 2, 0, 2); 
  gbcCaptionDescription.fill = GridBagConstraints.HORIZONTAL; 
  gbcCaptionDescription.gridwidth = 4; 
  gbcCaptionDescription.gridy = 4; 
  captionPurpose = new JLabel(); 
  captionPurpose.setText("Project purpose:"); 
  GridBagConstraints gridBagConstraints6 = new 
GridBagConstraints(); 
  gridBagConstraints6.fill = GridBagConstraints.BOTH; 
  gridBagConstraints6.gridy = 3; 
  gridBagConstraints6.weightx = 1.0; 
  gridBagConstraints6.anchor = GridBagConstraints.NORTHWEST; 
  gridBagConstraints6.gridwidth = 4; 
  gridBagConstraints6.insets = new Insets(0, 2, 2, 2); 
  gridBagConstraints6.gridx = 0; 
  GridBagConstraints gridBagConstraints4 = new 
GridBagConstraints(); 
  gridBagConstraints4.gridx = 0; 
  gridBagConstraints4.gridwidth = 4; 
  gridBagConstraints4.anchor = GridBagConstraints.NORTHWEST; 
  gridBagConstraints4.fill = GridBagConstraints.HORIZONTAL; 
  gridBagConstraints4.insets = new Insets(2, 2, 0, 2); 
  gridBagConstraints4.gridy = 2; 
  captionAutor = new JLabel(); 
  captionAutor.setText("Autor:"); 
  GridBagConstraints gridBagConstraints3 = new 
GridBagConstraints(); 
  gridBagConstraints3.gridx = 3; 
  gridBagConstraints3.anchor = GridBagConstraints.NORTHWEST; 
  gridBagConstraints3.insets = new Insets(2, 2, 2, 2); 
  gridBagConstraints3.gridy = 1; 
  fieldCreateDate = new JLabel(); 
  fieldCreateDate.setText("01/01/09"); 
  GridBagConstraints gridBagConstraints2 = new 
GridBagConstraints(); 
  gridBagConstraints2.fill = GridBagConstraints.HORIZONTAL; 
  gridBagConstraints2.gridy = 1; 
  gridBagConstraints2.weightx = 1.0; 
  gridBagConstraints2.anchor = GridBagConstraints.NORTHWEST; 
  gridBagConstraints2.gridwidth = 3; 
  gridBagConstraints2.insets = new Insets(0, 2, 2, 2); 
  gridBagConstraints2.gridx = 0; 
  GridBagConstraints gridBagConstraints1 = new 
GridBagConstraints(); 
  gridBagConstraints1.gridx = 3; 
  gridBagConstraints1.anchor = GridBagConstraints.NORTHWEST; 
  gridBagConstraints1.ipadx = 1; 
  gridBagConstraints1.insets = new Insets(2, 2, 0, 2); 
  gridBagConstraints1.gridy = 0; 
  captionCreateDate = new JLabel(); 
  captionCreateDate.setText("Create date:"); 
  GridBagConstraints gridBagConstraints = new 
GridBagConstraints(); 
  gridBagConstraints.gridx = 0; 
  gridBagConstraints.anchor = GridBagConstraints.NORTHWEST; 
  gridBagConstraints.gridwidth = 3; 
  gridBagConstraints.fill = GridBagConstraints.HORIZONTAL; 
  gridBagConstraints.insets = new Insets(2, 2, 0, 2); 
  gridBagConstraints.gridy = 0; 
  captionName = new JLabel(); 
  captionName.setText("Project name:"); 
  this.setLayout(new GridBagLayout()); 
  this.setSize(500, 400); 
  this.add(captionName, gridBagConstraints); 
  this.add(captionCreateDate, gridBagConstraints1); 
  this.add(getFieldName(), gridBagConstraints2); 
  this.add(fieldCreateDate, gridBagConstraints3); 
  this.add(captionAutor, gridBagConstraints4); 
  this.add(getFieldAutor(), gridBagConstraints6); 
  this.add(captionPurpose, gbcCaptionDescription); 
  this.add(getScrollPanePurpose(), gbcScrollPaneDescription); 
  this.add(captionScope, gridBagConstraints11); 
  this.add(getScrollPaneScope(), gridBagConstraints31); 
  this.add(captionFormalityLevel, gridBagConstraints41); 
  this.add(getScrollPaneFormalityLevel(), gridBagConstraints5); 
  this.add(getSplitPaneDescriptions(), gridBagConstraints32); 
  this.add(getBottomBar(), gridBagConstraints12); 
   
 } 
  



  

 /*---------------------- 
  * Manipulation Methods: 
  ----------------------*/ 
 private void showInfoMessage(final String message) { 
  JOptionPane.showMessageDialog(this, message); 
 } 
  
 private void setFormMode(final BottomBarMode mode) { 
  switch (mode) { 
  case EMPTY_MODE: { 
   this.setFormEnabled(false); 
   this.bottomBarLayoutMgr.show(this.bottomBar, 
getTemplateEditButton().getName()); 
   break; 
  } 
  default: { 
   this.setFormEnabled(true); 
   switch (mode) { 
   case VIEW_MODE: { 
    this.setFieldsEditable(false); 
    this.bottomBarLayoutMgr.show(this.bottomBar, 
getTemplateEditButton().getName()); 
    break; 
   } 
   case EDIT_TEMPLATE: { 
    this.setFieldsEditable(true); 
    this.bottomBarLayoutMgr.show(this.bottomBar, 
getTemplateSaveCancelButton().getName()); 
    break; 
   } 
   default: { 
    JOptionPane.showMessageDialog(this, "setFormMode: 
Modo não tratado."); 
   } 
   } 
  } 
  } 
 } 
  
 private void setFormEnabled(final boolean enabled) { 
  this.fieldName.setEnabled(enabled); 
  this.fieldAutor.setEnabled(enabled); 
  this.fieldPurpose.setEnabled(enabled); 
  this.fieldScope.setEnabled(enabled); 
  this.fieldFormalityLevel.setEnabled(enabled); 
  this.setMoreInfoPanelEnabled(enabled); 
  this.setBottomBarEnabled(enabled); 
 } 
  
 private void setMoreInfoPanelEnabled(final boolean enabled) { 
  this.buttonAddUserDescription.setEnabled(enabled); 
  this.buttonEditUserDescription.setEnabled(enabled); 
  this.buttonRemoveUserDescription.setEnabled(enabled); 
  this.jListUsersDescriptions.setEnabled(enabled); 
   
  this.buttonAddUseScenario.setEnabled(enabled); 
  this.buttonEditUseScenario.setEnabled(enabled); 
  this.buttonRemoveUseScenario.setEnabled(enabled); 
  this.jListUsesScenarios.setEnabled(enabled); 
 } 
  
 private void setBottomBarEnabled(final boolean enabled) { 
  List&lt;Component[]&gt; componentsGroups = new 
ArrayList&lt;Component[]&gt;(); 
  componentsGroups.add(this.templateEditButton.getComponents()); 
 
 componentsGroups.add(this.templateSaveCancelButton.getComponents()); 
   
  for (Iterator&lt;Component[]&gt; it = componentsGroups.iterator(); 
it.hasNext();) { 
   Component[] components = it.next(); 
   if (components != null) { 
    for (int i=0; i &amp;lt;components.length; i++) { 
     components[i].setEnabled(enabled); 
    } 
   } 
  } 
 } 
  
 private void setFieldsEditable(final boolean flag) { 



  

  this.fieldName.setEditable(flag); 
  this.fieldAutor.setEditable(flag); 
  this.fieldPurpose.setEditable(flag); 
  this.fieldScope.setEditable(flag); 
  this.fieldFormalityLevel.setEditable(flag); 
  this.setMoreInfoPanelEnabled(flag); 
 } 
  
 /*------------------- 
  * Interface Methods: 
  -------------------*/ 
 @Override 
 public&amp;lt;T extends Presenter&gt; void registerPresenter(T presenter) { 
  this.presenter = (ProjectPresenter)presenter; 
 } 
  
 @Override 
 public String getProjectName() { 
  return this.fieldName.getText(); 
 } 
 
 @Override 
 public String getProjectAutor() { 
  return this.fieldAutor.getText(); 
 } 
 
 @Override 
 public String getProjectPurpose() { 
  return this.fieldPurpose.getText(); 
 } 
  
 @Override 
 public String getProjectScope() { 
  return this.fieldScope.getText(); 
 } 
  
 @Override 
 public String getProjectFormalityLevel() { 
  return this.fieldFormalityLevel.getText(); 
 } 
  
 @Override 
 public List&lt;String&gt; getProjectUsersDescriptionsList() { 
 
  if (this.listUsersDescriptions != null) { 
   final int length = this.listUsersDescriptions.size(); 
   for (int i=0; i &amp;lt;length; i++) { 
   
 System.out.println(this.listUsersDescriptions.get(i)); 
   } 
  } else { 
   System.out.println("user descriptions is null"); 
  } 
  return new ArrayList&lt;String&gt;(this.listUsersDescriptions); 
 } 
  
 @Override 
 public List&lt;String&gt; getProjectUsesScenariosList() { 
  return new ArrayList&lt;String&gt;(this.listUsesScenarios); 
 } 
  
 @Override 
 public void setProjectName(String value) { 
  this.fieldName.setText(value); 
 } 
  
 @Override 
 public void setProjectAutor(final String value) { 
  this.fieldAutor.setText(value); 
 } 
  
 @Override 
 public void setProjectPurpose(final String value) { 
  this.fieldPurpose.setText(value); 
 } 
  
 @Override 
 public void setProjectScope(final String value) { 
  this.fieldScope.setText(value); 
 } 



  

  
 @Override 
 public void setProjectFormalityLevel(final String value) { 
  this.fieldFormalityLevel.setText(value); 
 } 
  
 @Override 
 public void setProjectUsersDescriptionsList(List&lt;String&gt; value) { 
  if (value != null) { 
   this.listUsersDescriptions = new 
ArrayList&lt;String&gt;(value); 
  } else { 
   this.listUsersDescriptions.clear(); 
  } 
 
 this.setComponentUsersDescriptionsList(this.listUsersDescriptions); 
 } 
 private void setComponentUsersDescriptionsList(final List&lt;String&gt; 
listData) { 
 
 this.jListUsersDescriptions.setListData(this.getListData(listData, 
true)); 
 } 
  
 @Override 
 public void setProjectUsesScenariosList(List&lt;String&gt; value) { 
  if (value != null) { 
   this.listUsesScenarios = new ArrayList&lt;String&gt;(value); 
  } else { 
   this.listUsesScenarios.clear(); 
  } 
  this.setComponentUsesScenariosList(this.listUsesScenarios); 
 } 
 private void setComponentUsesScenariosList(final List&lt;String&gt; listData) 
{ 
  this.jListUsesScenarios.setListData(this.getListData(listData, 
false)); 
 } 
  
 private Vector&lt;String&gt; getListData(final List&lt;String&gt; originalListData, 
   final boolean isUserDescriptions) { 
  final int length = originalListData.size(); 
  final String prefix = ( isUserDescriptions ? "User " : "Scenario 
" ); 
  Vector&lt;String&gt; componentListData = new Vector&lt;String&gt;(length); 
  for (int i=0; i &amp;lt;length; i++) { 
   componentListData.add(prefix + (i+1) + ": " + 
originalListData.get(i)); 
  } 
  return componentListData; 
 } 
  
 private List&lt;String&gt; getRemoveList(final int[] removeIndices, 
   final List&lt;String&gt; originalList) { 
  final List&lt;String&gt; removeList = new ArrayList&lt;String&gt;(0); 
  final int length = removeIndices.length; 
  for (int i=0; i &amp;lt;length; i++) { 
   removeList.add(originalList.get(removeIndices[i])); 
  } 
  return removeList; 
 } 
  
 private void doRemoveUsersDescriptions(final int[] selectedUsers) { 
  this.listUsersDescriptions.removeAll( 
    this.getRemoveList(selectedUsers, 
this.listUsersDescriptions)); 
 
 this.setComponentUsersDescriptionsList(this.listUsersDescriptions); 
 } 
  
 private void doRemoveUsesScenarios(final int[] selectedScenarios) { 
  this.listUsesScenarios.removeAll( 
    this.getRemoveList(selectedScenarios, 
this.listUsesScenarios)); 
  this.setComponentUsesScenariosList(this.listUsesScenarios); 
 } 
 
 @Override 
 public void setProjectCreateDate(final Date value) { 
  if (value != null) { 



  

   this.fieldCreateDate.setText(value.toString());  
  } else { 
  
 this.fieldCreateDate.setText(UtilClass.NO_CREATE_DATE_LABEL); 
  } 
 } 
 
 @Override 
 public void setEmptyMode() { 
  this.setFormMode(BottomBarMode.EMPTY_MODE); 
 } 
  
 @Override 
 public void setViewMode() { 
  this.setFormMode(BottomBarMode.VIEW_MODE); 
 } 
  
 @Override 
 public void setEditMode() { 
  this.setFormMode(BottomBarMode.EDIT_TEMPLATE); 
 } 
  
 /*----------------------- 
  * Show Dialoges Methods: 
  -----------------------*/ 
 private String doShowInputDialog(final String title, final String 
message, final String initValue) { 
  return (String)JOptionPane.showInputDialog(this, message, title, 
JOptionPane.OK_CANCEL_OPTION, null, null, initValue); 
 } 
  
 private int doShowConfirmDialog(final String title, final String 
message) { 
  return JOptionPane.showConfirmDialog(this, message, title, 
JOptionPane.OK_CANCEL_OPTION); 
 } 
  
 private void showAddUserDescriptionDialog(final int userIndex) { 
  final String inputString = this.doShowInputDialog("Add user 
description", 
    "Write the description of the User "+ (userIndex 
+ 1) +":", null); 
  if (inputString != null &amp;amp;&amp;amp; !inputString.trim().isEmpty()) { 
   this.listUsersDescriptions.add(inputString); 
  
 this.setComponentUsersDescriptionsList(this.listUsersDescriptions); 
  } 
 } 
  
 private void showEditUserDescriptionDialog(final int userIndex) { 
  final String inputString = this.doShowInputDialog("Edit user 
description", 
    "Edit the description of the User "+ (userIndex + 
1) +":", 
    this.listUsersDescriptions.get(userIndex)); 
  if (inputString != null &amp;amp;&amp;amp; !inputString.trim().isEmpty()) { 
   this.listUsersDescriptions.set(userIndex, inputString); 
  
 this.setComponentUsersDescriptionsList(this.listUsersDescriptions); 
  } else { 
   final int choice = this.doShowConfirmDialog(null, 
     "You want to remove this description?"); 
   if (choice == JOptionPane.OK_OPTION) { 
    this.doRemoveUsersDescriptions(new 
int[]{userIndex}); 
   } 
  } 
 } 
  
 private void showRemoveUserDescriptionDialog(final int[] selectedUsers) 
{ 
  final int choice = this.doShowConfirmDialog("Removing users 
descriptions", 
    "You really want to remove the selected 
description(s)?"); 
  if (choice == JOptionPane.OK_OPTION) { 
   this.doRemoveUsersDescriptions(selectedUsers); 
  } 
 } 
  



  

 private void showAddUseScenarioDialog(final int scenarioIndex) { 
  final String inputString = this.doShowInputDialog("Add use 
scenario", 
    "Write the description of the Scenario "+ 
(scenarioIndex + 1) +":", null); 
  if (inputString != null &amp;amp;&amp;amp; !inputString.trim().isEmpty()) { 
   this.listUsesScenarios.add(inputString); 
  
 this.setComponentUsesScenariosList(this.listUsesScenarios); 
  } 
 } 
  
 private void showEditUseScenarioDialog(final int scenarioIndex) { 
  final String inputString = this.doShowInputDialog("Edit use 
scenario", 
    "Edit the description of the Use Scenario "+ 
(scenarioIndex + 1) +":", 
    this.listUsesScenarios.get(scenarioIndex)); 
  if (inputString != null &amp;amp;&amp;amp; !inputString.trim().isEmpty()) { 
   this.listUsesScenarios.set(scenarioIndex, inputString); 
  
 this.setComponentUsesScenariosList(this.listUsesScenarios); 
  } else { 
   final int choice = this.doShowConfirmDialog(null, 
     "You want to remove this description?"); 
   if (choice == JOptionPane.OK_OPTION) { 
    this.doRemoveUsesScenarios(new 
int[]{scenarioIndex}); 
   } 
  } 
 } 
  
 private void showRemoveUseScenarioDialog(final int[] selectedScenarios) 
{ 
  final int choice = this.doShowConfirmDialog("Removing uses 
scenarios", 
    "You really want to remove the selected 
scenario(s)?"); 
  if (choice == JOptionPane.OK_OPTION) { 
   this.doRemoveUsesScenarios(selectedScenarios); 
  } 
 } 
  
 private JTextField getFieldName() { 
  if (fieldName == null) { 
   fieldName = new JTextField(); 
   fieldName.setText("Name"); 
  } 
  return fieldName; 
 } 
 
 private JTextField getFieldAutor() { 
  if (fieldAutor == null) { 
   fieldAutor = new JTextField(); 
   fieldAutor.setText("Autor"); 
  } 
  return fieldAutor; 
 } 
 
 private JScrollPane getScrollPanePurpose() { 
  if (scrollPanePurpose == null) { 
   scrollPanePurpose = new JScrollPane(); 
   scrollPanePurpose.setViewportView(getFieldPurpose()); 
  } 
  return scrollPanePurpose; 
 } 
 
 private JTextArea getFieldPurpose() { 
  if (fieldPurpose == null) { 
   fieldPurpose = new JTextArea(); 
   fieldPurpose.setText("Description"); 
  } 
  return fieldPurpose; 
 } 
 
 private JPanel getBottomBar() { 
  if (bottomBar == null) { 
   bottomBar = new JPanel(); 
   this.bottomBarLayoutMgr = new CardLayout(); 
   bottomBar.setLayout(this.bottomBarLayoutMgr); 



  

   bottomBar.add(getTemplateEditButton(), 
getTemplateEditButton().getName()); 
   bottomBar.add(getTemplateSaveCancelButton(), 
getTemplateSaveCancelButton().getName()); 
  } 
  return bottomBar; 
 } 
 
 private JButton getButtonSave() { 
  if (buttonSave == null) { 
   buttonSave = new JButton(); 
   buttonSave.setText("Save"); 
   buttonSave.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     presenter.doSaveAction(); 
    } 
   }); 
  } 
  return buttonSave; 
 } 
 
 private JButton getButtonCancel() { 
  if (buttonCancel == null) { 
   buttonCancel = new JButton(); 
   buttonCancel.setText("Cancel"); 
   buttonCancel.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     presenter.doCancelAction(); 
    } 
   }); 
  } 
  return buttonCancel; 
 } 
 
 private JPanel getTemplateEditButton() { 
  if (templateEditButton == null) { 
   templateEditButton = new JPanel(); 
   templateEditButton.setLayout(new FlowLayout()); 
   templateEditButton.setName("jEditButtonPanel"); 
   templateEditButton.add(getButtonEdit(), null); 
  } 
  return templateEditButton; 
 } 
 
 private JPanel getTemplateSaveCancelButton() { 
  if (templateSaveCancelButton == null) { 
   templateSaveCancelButton = new JPanel(); 
   templateSaveCancelButton.setLayout(new FlowLayout()); 
  
 templateSaveCancelButton.setName("jSaveCancelButtonPanel"); 
   templateSaveCancelButton.add(getButtonSave(), null); 
   templateSaveCancelButton.add(getButtonCancel(), null); 
  } 
  return templateSaveCancelButton; 
 } 
 
 private JButton getButtonEdit() { 
  if (buttonEdit == null) { 
   buttonEdit = new JButton(); 
   buttonEdit.setText("Edit"); 
   buttonEdit.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     presenter.doEditAction(); 
    } 
   }); 
  } 
  return buttonEdit; 
 } 
 
 private JScrollPane getScrollPaneScope() { 
  if (scrollPaneScope == null) { 
   scrollPaneScope = new JScrollPane(); 
   scrollPaneScope.setViewportView(getFieldScope()); 
  } 



  

  return scrollPaneScope; 
 } 
 
 private JTextArea getFieldScope() { 
  if (fieldScope == null) { 
   fieldScope = new JTextArea(); 
   fieldScope.setText("Scope"); 
  } 
  return fieldScope; 
 } 
 
 private JScrollPane getScrollPaneFormalityLevel() { 
  if (scrollPaneFormalityLevel == null) { 
   scrollPaneFormalityLevel = new JScrollPane(); 
  
 scrollPaneFormalityLevel.setViewportView(getFieldFormalityLevel()); 
  } 
  return scrollPaneFormalityLevel; 
 } 
 
 private JTextArea getFieldFormalityLevel() { 
  if (fieldFormalityLevel == null) { 
   fieldFormalityLevel = new JTextArea(); 
   fieldFormalityLevel.setText("Formality Level"); 
  } 
  return fieldFormalityLevel; 
 } 
 
 private JButton getButtonAddUserDescription() { 
  if (buttonAddUserDescription == null) { 
   buttonAddUserDescription = new JButton(); 
   buttonAddUserDescription.setText("Add"); 
   buttonAddUserDescription.setFont(new Font("Dialog", 
Font.BOLD, 10)); 
   buttonAddUserDescription.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     final int userIndex = 
listUsersDescriptions.size(); 
     showAddUserDescriptionDialog(userIndex); 
    } 
   }); 
  } 
  return buttonAddUserDescription; 
 } 
 
 private JScrollPane getScrollPaneUsersDescriptions() { 
  if (scrollPaneUsersDescriptions == null) { 
   scrollPaneUsersDescriptions = new JScrollPane(); 
  
 scrollPaneUsersDescriptions.setViewportView(getJListUsersDescriptions()
); 
  
 scrollPaneUsersDescriptions.setViewportView(getJListUsersDescriptions()
); 
  } 
  return scrollPaneUsersDescriptions; 
 } 
 
 private JButton getButtonAddUseScenario() { 
  if (buttonAddUseScenario == null) { 
   buttonAddUseScenario = new JButton(); 
   buttonAddUseScenario.setText("Add"); 
   buttonAddUseScenario.setFont(new Font("Dialog", 
Font.BOLD, 10)); 
   buttonAddUseScenario.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     final int scenarioIndex = 
listUsesScenarios.size(); 
     showAddUseScenarioDialog(scenarioIndex); 
    } 
   }); 
  } 
  return buttonAddUseScenario; 
 } 
 
 private JScrollPane getScrollPaneUsesScenarios() { 



  

  if (scrollPaneUsesScenarios == null) { 
   scrollPaneUsesScenarios = new JScrollPane(); 
  
 scrollPaneUsesScenarios.setViewportView(getJListUsesScenarios()); 
  } 
  return scrollPaneUsesScenarios; 
 } 
 
 private JList getJListUsersDescriptions() { 
  if (jListUsersDescriptions == null) { 
   jListUsersDescriptions = new JList(); 
  } 
  return jListUsersDescriptions; 
 } 
 
 private JList getJListUsesScenarios() { 
  if (jListUsesScenarios == null) { 
   jListUsesScenarios = new JList(); 
  } 
  return jListUsesScenarios; 
 } 
 
 private JPanel getPanelButtonsUsersDescriptions() { 
  if (panelButtonsUsersDescriptions == null) { 
   FlowLayout flowLayout = new FlowLayout(); 
   flowLayout.setAlignment(java.awt.FlowLayout.LEFT); 
   panelButtonsUsersDescriptions = new JPanel(); 
   panelButtonsUsersDescriptions.setLayout(flowLayout); 
  
 panelButtonsUsersDescriptions.add(getButtonAddUserDescription(), null); 
  
 panelButtonsUsersDescriptions.add(getButtonEditUserDescription(), 
null); 
  
 panelButtonsUsersDescriptions.add(getButtonRemoveUserDescription(), 
null); 
  } 
  return panelButtonsUsersDescriptions; 
 } 
 
 private JButton getButtonEditUserDescription() { 
  if (buttonEditUserDescription == null) { 
   buttonEditUserDescription = new JButton(); 
   buttonEditUserDescription.setText("Edit"); 
   buttonEditUserDescription.setFont(new Font("Dialog", 
Font.BOLD, 10)); 
   buttonEditUserDescription 
     .addActionListener(new 
java.awt.event.ActionListener() { 
      public void 
actionPerformed(java.awt.event.ActionEvent e) { 
       final int[] selectedIndices 
= jListUsersDescriptions.getSelectedIndices(); 
       if (selectedIndices.length 
== 0) { 
       
 showInfoMessage("Select one User Description to edit."); 
       } else if 
(selectedIndices.length &gt; 1) { 
       
 showInfoMessage("Only one User Description can be edited at time."); 
       } else { 
       
 showEditUserDescriptionDialog(selectedIndices[0]); 
       } 
      } 
     }); 
  } 
  return buttonEditUserDescription; 
 } 
 
 private JButton getButtonRemoveUserDescription() { 
  if (buttonRemoveUserDescription == null) { 
   buttonRemoveUserDescription = new JButton(); 
   buttonRemoveUserDescription.setText("Remove"); 
   buttonRemoveUserDescription.setFont(new Font("Dialog", 
Font.BOLD, 10)); 
   buttonRemoveUserDescription 
     .addActionListener(new 
java.awt.event.ActionListener() { 



  

      public void 
actionPerformed(java.awt.event.ActionEvent e) { 
       final int[] selectedIndices 
= jListUsersDescriptions.getSelectedIndices(); 
       if (selectedIndices.length 
== 0) { 
       
 showInfoMessage("Select at least one User Description to remove."); 
       } else { 
       
 showRemoveUserDescriptionDialog(selectedIndices); 
       } 
      } 
     }); 
  } 
  return buttonRemoveUserDescription; 
 } 
 
 private JPanel getPanelButtonsUsesScenarios() { 
  if (panelButtonsUsesScenarios == null) { 
   FlowLayout flowLayout1 = new FlowLayout(); 
   flowLayout1.setAlignment(java.awt.FlowLayout.LEFT); 
   panelButtonsUsesScenarios = new JPanel(); 
   panelButtonsUsesScenarios.setLayout(flowLayout1); 
   panelButtonsUsesScenarios.add(getButtonAddUseScenario(), 
null); 
  
 panelButtonsUsesScenarios.add(getButtonEditUseScenario(), null); 
  
 panelButtonsUsesScenarios.add(getButtonRemoveUseScenario(), null); 
  } 
  return panelButtonsUsesScenarios; 
 } 
 
 private JButton getButtonEditUseScenario() { 
  if (buttonEditUseScenario == null) { 
   buttonEditUseScenario = new JButton(); 
   buttonEditUseScenario.setText("Edit"); 
   buttonEditUseScenario.setFont(new Font("Dialog", 
Font.BOLD, 10)); 
   buttonEditUseScenario.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     final int[] selectedIndices = 
jListUsesScenarios.getSelectedIndices(); 
     if (selectedIndices.length == 0) { 
      showInfoMessage("Select one Use 
Scenario to edit."); 
     } else if (selectedIndices.length &gt; 1) { 
      showInfoMessage("Only one Use 
Scenario can be edited at time."); 
     } else { 
     
 showEditUseScenarioDialog(selectedIndices[0]); 
     } 
    } 
   }); 
  } 
  return buttonEditUseScenario; 
 } 
 
 private JButton getButtonRemoveUseScenario() { 
  if (buttonRemoveUseScenario == null) { 
   buttonRemoveUseScenario = new JButton(); 
   buttonRemoveUseScenario.setText("Remove"); 
   buttonRemoveUseScenario.setFont(new Font("Dialog", 
Font.BOLD, 10)); 
   buttonRemoveUseScenario.addActionListener(new 
java.awt.event.ActionListener() { 
    public void 
actionPerformed(java.awt.event.ActionEvent e) { 
     final int[] selectedIndices = 
jListUsesScenarios.getSelectedIndices(); 
     if (selectedIndices.length == 0) { 
      showInfoMessage("Select at least 
one Use Scenario to remove."); 
     } else { 
     
 showRemoveUseScenarioDialog(selectedIndices); 



  

     } 
    } 
   }); 
  } 
  return buttonRemoveUseScenario; 
 } 
 
 private JSplitPane getSplitPaneDescriptions() { 
  if (splitPaneDescriptions == null) { 
   splitPaneDescriptions = new JSplitPane(); 
   final int divider = this.getWidth()/2; 
   splitPaneDescriptions.setDividerLocation(divider); 
   splitPaneDescriptions.setLeftComponent(getLeftPanel()); 
  
 splitPaneDescriptions.setRightComponent(getRightPanel()); 
  } 
  return splitPaneDescriptions; 
 } 
  
 public void setSplitPaneDividerLocation(final int location) { 
  this.splitPaneDescriptions.setDividerLocation(location); 
 } 
 
 private JPanel getLeftPanel() { 
  if (leftPanel == null) { 
   GridBagConstraints gridBagConstraints17 = new 
GridBagConstraints(); 
   gridBagConstraints17.fill = GridBagConstraints.BOTH; 
   gridBagConstraints17.weighty = 1.0; 
   gridBagConstraints17.gridx = 0; 
   gridBagConstraints17.gridy = 2; 
   gridBagConstraints17.gridwidth = 2; 
   gridBagConstraints17.weightx = 1.0; 
   GridBagConstraints gridBagConstraints15 = new 
GridBagConstraints(); 
   gridBagConstraints15.anchor = 
GridBagConstraints.NORTHWEST; 
   gridBagConstraints15.insets = new Insets(0, 2, 2, 2); 
   gridBagConstraints15.gridwidth = 2; 
   gridBagConstraints15.gridx = -1; 
   gridBagConstraints15.gridy = -1; 
   gridBagConstraints15.weightx = 1.0; 
   gridBagConstraints15.weighty = 1.0; 
   gridBagConstraints15.fill = GridBagConstraints.BOTH; 
   GridBagConstraints gridBagConstraints10 = new 
GridBagConstraints(); 
   gridBagConstraints10.anchor = GridBagConstraints.WEST; 
   gridBagConstraints10.gridwidth = 1; 
   gridBagConstraints10.gridx = 0; 
   gridBagConstraints10.gridy = 1; 
   gridBagConstraints10.fill = 
GridBagConstraints.HORIZONTAL; 
   GridBagConstraints gridBagConstraints9 = new 
GridBagConstraints(); 
   gridBagConstraints9.anchor = 
GridBagConstraints.SOUTHWEST; 
   gridBagConstraints9.insets = new Insets(2, 2, 0, 2); 
   gridBagConstraints9.gridwidth = 2; 
   gridBagConstraints9.gridx = -1; 
   gridBagConstraints9.gridy = -1; 
   gridBagConstraints9.fill = 
GridBagConstraints.HORIZONTAL; 
   leftPanel = new JPanel(); 
   leftPanel.setLayout(new GridBagLayout()); 
   leftPanel.add(captionUsersDescriptions, 
gridBagConstraints9); 
   leftPanel.add(getPanelButtonsUsersDescriptions(), 
gridBagConstraints10); 
   leftPanel.add(getScrollPaneUsersDescriptions(), 
gridBagConstraints17); 
  } 
  return leftPanel; 
 } 
 
 private JPanel getRightPanel() { 
  if (rightPanel == null) { 
   GridBagConstraints gridBagConstraints14 = new 
GridBagConstraints(); 
   gridBagConstraints14.anchor = 
GridBagConstraints.NORTHWEST; 



  

   gridBagConstraints14.insets = new Insets(0, 2, 2, 2); 
   gridBagConstraints14.gridwidth = 2; 
   gridBagConstraints14.gridx = 0; 
   gridBagConstraints14.gridy = 2; 
   gridBagConstraints14.weightx = 1.0; 
   gridBagConstraints14.weighty = 1.0; 
   gridBagConstraints14.fill = GridBagConstraints.BOTH; 
   GridBagConstraints gridBagConstraints16 = new 
GridBagConstraints(); 
   gridBagConstraints16.anchor = GridBagConstraints.WEST; 
   gridBagConstraints16.gridx = 0; 
   gridBagConstraints16.gridy = 1; 
   gridBagConstraints16.fill = 
GridBagConstraints.HORIZONTAL; 
   GridBagConstraints gridBagConstraints8 = new 
GridBagConstraints(); 
   gridBagConstraints8.anchor = 
GridBagConstraints.SOUTHWEST; 
   gridBagConstraints8.insets = new Insets(2, 2, 0, 2); 
   gridBagConstraints8.gridwidth = 2; 
   gridBagConstraints8.gridx = 0; 
   gridBagConstraints8.gridy = 0; 
   gridBagConstraints8.fill = 
GridBagConstraints.HORIZONTAL; 
   rightPanel = new JPanel(); 
   rightPanel.setLayout(new GridBagLayout()); 
   rightPanel.add(captionUsesScenarios, 
gridBagConstraints8); 
   rightPanel.add(getPanelButtonsUsesScenarios(), 
gridBagConstraints16); 
   rightPanel.add(getScrollPaneUsesScenarios(), 
gridBagConstraints14); 
  } 
  return rightPanel; 
 } 
} 
 

? Pacote “root”: 

? Classe Starter.java: 
package root; 
 
import gui.MainFormImpl; 
 
import javax.swing.SwingUtilities; 
 
import system.Environment; 
 
public class Starter { 
 
 public static void main(String[] args) { 
  SwingUtilities.invokeLater(new Runnable() { 
   public void run() { 
    MainFormImpl mainForm = new MainFormImpl(); 
     
    Environment.start(mainForm, 
mainForm.getProjectFormImpl(), 
     
 mainForm.getCompetenceQuestionsFormImpl(), 
mainForm.getTermsFormImpl()); 
   } 
  }); 
 } 
} 
 

 



  

ANEXO B — ARTIGO 

Desenvolvimento de aplicação para a etapa de 
especificação da metodologia de desenvolvimento de 

ontologias em rede NeOn. 

Cleiton E. J. Duarte1, José L. Todesco1, Fernando A. O. Gauthier1 

1Departamento de Informática e Estatística – INE 
Universidade Federal de Santa Catarina – UFSC 

Caixa Postal 476 – 88.040-900 – Florianópolis – SC – Brasil 

cleitone@inf.ufrgs.br, tite@inf.ufrgs.br, gauthier@inf.ufrgs. 

Abstract. This article is intended to summarize the course paper on 

"Application development for the methodology specification stage 

for development of networked ontologies NeOn". On this paper the 

objectives were to know and present the NeOn methodology, 

focusing its specification stage, then moving to the establishment of a 

system that would support this activity. Structurally, the article 

describes the most important concepts concerned in this study 

(ontologies, ontology engineering, etc.) and in the specification stage 

of the NeOn, and then passing to the modeling of the application 

requirements, closing up with conclusions about the development. 

Resumo. Este artigo tem por propósito apresentar de forma sucinta 

o trabalho de conclusão de curso sobre “Desenvolvimento de 

aplicação para a etapa de especificação da metodologia de 

desenvolvimento de ontologias em rede NeOn”. Nesse trabalho os 

objetivos foram conhecer e apresentar a metodologia NeOn, com 

foco na sua etapa de especificação, passando na seqüencia à 

elaboração de um sistema que desse suporte a esta atividade. 

Estruturalmente o artigo descreve os conceitos mais importantes do 

escopo de trabalho (ontologias, engenharia de ontologias, etc.) e da 

etapa de especificação do NeOn, passando então a modelagem dos 

requisitos da aplicação e finalizando com conclusões sobre o 

referido desenvolvimento. 

1. Introdução 

O aumento gradativo do uso das ontologias tem exigido cada vez mais 
ferramentas que automatizem o processo de construção destas. Nesse sentido, 
surgiu na Europa o projeto NeOn. Este projeto propôs uma metodologia que 
prevê o desenvolvimento de ontologias em rede, visando o reuso e a 
reengenharia de ontologias já existentes para elaboração de novas. Para 
suportar esta metodologia, foi concebido o NeOn Toolkit, um plataforma que 



  

integra várias ferramentas específicas para atender a diferentes atividades 
relacionadas a metodologia NeOn. 

 Observando a falta de uma ferramenta que suportasse a etapa de 
especificação dessa metodologia este trabalho propõe o “Desenvolvimento de 
uma aplicação para a etapa de especificação da metodologia de 
desenvolvimento de ontologias em rede NeOn”. 

 Como objetivo específico do trabalho está o desenvolvimento de uma 
aplicação que suporte a etapa de especificação da metodologia de 
desenvolvimento de ontologias em rede NeOn. Já os objetivos específicos 
implícitos são: 

Conhecer o projeto NeOn, seus objetivos e estrutura. 

Conhecer a metodologia de desenvolvimento de ontologias em rede do NeOn. 

Elaborar uma estrutura de classes que realize o suporte à etapa de 
especificação de ontologias da metodologia NeOn. 

Desenvolver uma aplicação com base na estrutura de classes elaborada. 

2. Engenharia de ontologias 

A Engenharia de Ontologias é a disciplina responsável por administrar e se 
preocupar com as atividades, processos, ciclos de vida, métodos e 
metodologias envolvidos no desenvolvimento de ontologias, bem como nas 
ferramentas e linguagens envolvidos na construção dessas ontologias 
(GÓMEZ-PÉREZ et al., 2004). 

 A terminologia envolvida na Engenharia de Ontologias foi baseada na 
Engenharia de Software, advindo daí a semelhança nas atividades envolvidas 
no desenvolvimento de ontologias com as de desenvolvimento de software 
(PINTO; MARTINS, 2004). 

 A seguir, as principais atividades presentes no desenvolvimento de 
ontologias: 

? Especificação: etapa onde são identificados propósito e escopo da ontologia 
a ser desenvolvida. Podem ser aplicadas as perguntas “Por que a ontologia é 
construída?” e “Quais são as intenções de uso e usuários da ontologia?”, pois 
as respostas destas serão as definições, respectivamente, do propósito e do 
escopo. 

? Conceitualização: é onde se define um modelo conceitual da ontologia, que 
represente os conceitos do domínio abordado e as relações entre estes. A 
definição se baseia nas informações colhidas na atividade anterior 
(especificação). 

? Formalização: nesta atividade o modelo conceitual anteriormente definido 
é formalizado, aplicando-se restrições e axiomas aos conceitos já 
estabelecidos. Dessa forma é feita a restrição das interpretações desses termos 
e feita a organização hierárquica dos mesmos (através de relações estruturais 



  

como “é-um” ou “parte-de”).? Implementação: a ontologia é implementada 
através de uma linguagem de representação do conhecimento, que deve ser 
escolhida adequadamente para cada caso. 

? Manutenção: como no desenvolvimento de softwares, é onde são feitas 
correções e atualizações na ontologia, algumas vezes provocados por novos 
requisitos que surgem, ou são visualizados, durante o desenvolvimento. 

 A seguir o capítulo aborda alguns conceitos e processos envolvidos na 
Engenharia de Ontologias, discorrendo rapidamente a respeito do conceito 
ontologia e sobre algumas metodologias existentes para desenvolvimento de 
ontologias. 

2.1. Ontologia 

O conceito de ontologia variou de definição desde seu surgimento na Filosofia 
até as sua aplicação atual no âmbito da Ciência da Computação e Engenharia 
do Conhecimento (KIRYAKOV, 2006). Em sua origem o conceito era de uma 
disciplina dedicada ao estudo da natureza e da existência dos elementos. Já na 
Ciência da Computação, trata da representação do conhecimento, a 
organização e estruturação dos conhecimentos sobre um determinado domínio. 

 A definição inicialmente utilizada na Ciência da Computação veio, 
segundo Kiryakov (2006), por Gruber (1993) que define o conceito de 
ontologia como “uma especificação explícita de uma conceitualização”. Outro 
autor, Borst (1997) atribuiu mais detalhes a definição, sendo que para ele 
“ontologia é uma especificação formal e explícita de uma conceitualização 
compartilhada”. 

 Atualmente há a definição dada por Devedzic (2002), que interpreta 
ontologia como um sistema de conceitos e das relações existentes entre esses 
conceitos, sendo os conceitos definidos e interpretados declarativamente. O 
sistema modelaria um determinado domínio definindo o vocabulário de termos 
do mesmo e as restrições das combinações possíveis entre esses termos. 

2.2. Metodologias para construção de ontologias 

Dentre as metodologias existentes para desenvolvimento de ontologias duas 
serão consideradas para apresentação neste artigo: a METHONTOLOGY e a 
metodologia NeOn.  

 A METHONTOLOGY nasceu em um grupo de pesquisa em 
Engenharia de Ontologias da Universidade Politécnica de Madri, e tem forte 
embasamento nas metodologias de Engenharia de Software e Engenharia do 
Conhecimento (GOMÉZ-PÉREZ et al., 2004). Nessa metodologia, o ciclo de 
vida de uma ontologia é baseado em protótipos — a cada etapa do processo de 
desenvolvimento (especificação, conceitualização e demais) é gerado um 
protótipo da ontologia até aquele ponto. As atividades dessa metodologia têm 
foco na gerência, desenvolvimento e suporte ao ciclo de vida, tendo esta 
característica forte ligação com a Engenharia de Software. 



  

 A metodologia NeOn — acrônimo para Networked Ontologies — 
trabalha com a idéia de desenvolvimento colaborativo de ontologias, 
permitindo o reuso de ontologias para construção de novas, promovendo isso 
através de ontologias distribuídas em rede, em diferentes locais e 
compartilhadas via web (SUÁREZ-FIGUEROA et al., 2007). Assim não seria 
mais necessário construir uma ontologia totalmente do zero, ou então replicar 
elementos de uma ontologia já existente para criar uma nova, bastaria 
compartilhar a já existente e estendê-la para gerar a nova criação. Para tal, a 
metodologia trabalha de acordo com o cenário de construção de uma ontologia 
em rede que se apresenta para o caso (construção com reuso, com 
reengenharia da ontologia, com extensão, etc.) aplicando atividades 
específicas às já conhecidas etapas da Engenharia de Ontologias. 

3. A fase de especificação de ontologias 

Na Engenharia de Ontologias a etapa de especificação visa identificar o 
propósito e escopo da ontologia a ser desenvolvida, respondendo 
respectivamente as perguntas “Por que a ontologia é construída?” e “Quais são 
as intenções de uso e usuários da ontologia?” (PINTO; MARTINS, 2004) e 
também definir quais tipos de usuários, cenários de usos e nível de 
formalização que a ontologia irá suportar e os requisitos que a mesma deve 
atender (SUÁREZ-FIGUEROA, 2008). A partir dessas definições a etapa foi 
analisada através da comparação entre duas visões, a descrita na metodologia 
NeOn e a que foi empregada na ferramenta para construção de ontologias 
OntoKEM. 

3.1. Como é visto no NeOn 

Para a metodologia NeOn foi proposta a técnica de perguntas de competência 
(GRÜNINGER; FOX, 1995) para o levantamento dos requisitos da ontologia. 
Através das perguntas de competência é que se levantará “o que” a ontologia 
deve responder — ao final serão essas perguntas que a mesma deverá 
responder. Os termos extraídos dessas perguntas é que passarão, na etapa 
seguinte da metodologia, a formar os conceitos e relações entre conceitos da 
ontologia. 

 Como documento de resultado da etapa de especificação a metodologia 
NeOn propõe o OSRD (“Ontology Requirements Specification Document” ou 
“Documento de Especificação de Requisitos da Ontologia”), um modelo 
padrão que apresenta os requisitos da ontologia, sendo eles (SUÁREZ-
FIGUEROA, 2008): 

? Propósito (“Ontology purpose”): aqui é onde são detalhados os objetivos, 
as finalidades ao qual a ontologia se propõe. 

? Escopo (“Ontology scope”): identifica qual será a abrangência e a 
granularidade da ontologia, até que profundidade a ontologia abordará o 
domínio representado. 



  

? Nível de Formalismo (“Level of Formality”): indica qual o grau de 
formalização que se pretende adotar na implementação da ontologia. Um 
exemplo de descrição de Nível de Formalismo seria: “A ontologia será 
implementada na linguagem OWL”. 

? Usuários desejados (“Intended Users”): o objetivo neste item é criar as 
descrições dos perfis de usuários desejados para essa ontologia. Através dessas 
descrições é possível, após a elaboração da ontologia, desenvolver aplicações 
melhor focadas nos perfis mais desejados, por exemplo. 

? Usos (Cenários) desejados (“Intended Uses”): este item detalhar os 
cenários de uso que a ontologia deverá prover suporte ao estar concluída. 
Estes cenários podem ser descritos através de linguagem natural ou até mesmo 
através de diagramas UML, como diagramas casos de uso. Também facilita o 
desenvolvimento de aplicações mais focadas. 

? Grupos de Perguntas de Competência (“Groups of Competence 
Questions”): é onde são inseridas as perguntas de competências elaboradas, 
bem como as suas respectivas respostas. As perguntas devem ser 
categorizadas conforme a necessidade e também deve ser atribuída a 
prioridade de cada uma. 

 A partir desses grupos, e de suas perguntas de competência, é que 
serão extraídos os termos e objetos para a ontologia. No projeto NeOn a 
proposta é que essa extração seja automática: é feita uma busca nas perguntas 
e extraídos os termos, que então são exibidos ao usuário desenvolvedor que, 
por sua vez, pode selecionar quais são relevantes. 

? Termos (“Terms”): representam os termos extraídos das perguntas, sendo 
estes normalmente conceitos ou relações entre conceitos da ontologia. Sempre 
apresentam a freqüência com a qual aparecem na listagem total de perguntas 
de competência e podem também receber ordenação de prioridade. 

? Objetos (“Objects”): representam os objetos extraídos das perguntas, sendo 
estes objetos normalmente instâncias da ontologia. Possuem as mesmas 
características de freqüência e prioridade dos termos. 

3.2. Como foi visto no ontoKEM 

Na ferramenta ontoKEM, desenvolvida sob as metodologias On-to-
Knowledge e METHONTOLOGY, pode-se notar algumas distinções em 
relação a proposta da metodologia NeOn, mas que possuem uma certa 
semelhança de objetivo. No ontoKEM (RAUTEMBERG et al., 2008) a etapa 
de especificação é dividida em dois módulos: o de “Projeto” e o de “Perguntas 
de Competência”. 

 No de “Projeto” é especificado, além do nome da ontologia, a 
descrição da mesma — além da descrição da versão na qual se encontra a 
mesma. Em relação ao NeOn esse campo de “descrição” seria um equivalente 
aos campos descritivos de “propósito” e “escopo” unificados. Na mesma 
“descrição” poderiam ser incluídos os campos “nível de formalismo” e até 



  

“usuários desejados” e “usos (cenários) desejados” do NeOn, que não 
possuem correspondentes diretos no ontoKEM. O problema seria o de que 
todas essas informações seriam repassadas juntas e na forma de texto livre. 

 Tanto no ontoKEM quanto no NeOn é proposta a técnica de perguntas 
de competência para o levantamento de requisitos, cabendo a gerência disto ao 
módulo de “Perguntas de competência”. Ali, além dos cadastrados da 
perguntas, é feito o cadastro dos termos para cada uma das perguntas. A 
extração destes, porém, é feita manualmente pelo usuário desenvolvedor da 
ontologia — ao contrário da proposta de extração automática do NeOn. Após 
o término do cadastro das perguntas e termos é possível fazer uma 
visualização e seleção dos termos, permitindo assim exportar os relevantes 
para a próxima etapa do desenvolvimento da ontologia. 

3.3. Considerações 

Em relação aos procedimentos da etapa de especificação adotados nas duas 
soluções, podemos fazer algumas comparações. 

 A divisão proposta pelo NeOn para os requisitos mais descritivos da 
ontologia — propósitos, escopo, nível de formalismo — permite uma 
definição mais clara de cada um por parte de quem especifica a ontologia. 
Apenas um campo descritivo pode permitir uma maior liberdade, mas com 
isso o desenvolvedor pode acabar esquecendo alguma dessas informações, 
deixando a especificação mais pobre. 

 A listagem de usuários desejados e dos cenários de uso da ontologia, 
propostas estas do NeOn, permitem uma definição mais clara dos objetivos e 
aplicações da ontologia, facilitando até o desenvolvimento posterior de 
aplicações sobre a ontologia — podendo estas serem focadas sobre 
determinados usuários ou cenários de usos. 

 O uso de perguntas de competência é bem semelhante em ambos, 
sendo que no NeOn também são requeridas as respostas respectivas a cada 
questão. A extração dos termos é que faz a grande diferença nesta parte — 
manual no ontoKEM e automática através de técnicas de extração 
terminológicas (SUÁREZ-FIGUEROA, 2008) no NeOn. A extração 
automática, com possibilidade de posterior seleção dos mais relevantes, 
facilita bastante o levantamento dos termos da ontologia, não havendo a 
necessidade de um usuário ficar analisando cada pergunta e/ou resposta de 
competência para verificar quais os termos que podem existir. 

 O modelo proposto pela metodologia NeOn parece interessante e 
eficaz como modelo de especificação de ontologias. Observado isso, o 
documento OSRD e seus itens serviram de base para o desenvolvimento da 
aplicação para suporte da etapa de especificação da metodologia NeOn. 



  

4. Aplicação para a fase de especificação 

Em Suárez-Figueroa (2008), ao final das explicações a respeito da etapa de 
especificação da metodologia NeOn, há uma sugestão de implementação. 
Sugere-se o desenvolvimento de uma aplicação acoplável — um plugin — 
para a plataforma de desenvolvimento de ontologias em rede NeOn Toolkit, 
sendo que esta aplicação deve seguir os processos e atividades propostas na 
etapa de especificação da metodologia NeOn. 

 No trabalho proposto o foco não foi no desenvolvimento somente de 
um plugin para o NeOn Toolkit, mas sim em uma aplicação para especificação 
de ontologias baseada na metodologia NeOn e que permitisse liberdade de 
acoplamento, tanto na parte visual quando na parte de saídas resultantes — 
documentos que podem ser gerados ou formas de persistência dos dados. Para 
isso houve a aplicação adaptada do padrão de projeto conhecido por MVP. 

 Tendo como ponto de partida o processo descrito na etapa de 
especificação da metodologia NeOn, foram levantados três casos de uso para a 
aplicação: 

? Criar o Projeto: nesse processo são informados os requisitos gerais da 
especificação — o nome do projeto de especificação (nome da ontologia), 
autores, propósito da ontologia, escopo, nível de formalismo, usuários 
desejados e cenários de uso da ontologia. Ao abstrair esse processo também 
foi definida a forma de persistência dos dados armazenados, que seria feita em 
um arquivo XML, melhor detalhado posteriormente na sessão 4.3. Ao criar o 
projeto já é gerada uma versão inicial do arquivo XML, guardando os 
requisitos gerais cadastrados. 

? Criação de categorias e perguntas de competência: é o processo onde são 
criadas as perguntas de competência e as categorias que as armazenam. Por 
padrão, ao criar o projeto já é criada uma categoria intitulada “default” (o 
nome pode ser alterado) para receber as perguntas. Mais categorias podem ser 
criadas conforme a necessidade. As perguntas podem ter uma sentença (sendo 
esta apenas a pergunta em si) ou então duas sentenças (a pergunta e a sua 
resposta). Cada pergunta pode ser classificada a apenas uma categoria, 
podendo haver mudança posterior à classificação inicial. 

? Identificação dos termos das perguntas de competência: este processo é 
mais automatizado pela própria aplicação. Nele é realizada a extração 
automática dos termos das perguntas de competência (tanto das perguntas em 
si quanto das respostas quando estas existirem). A extração é feita a partir de 
todo o conjunto de perguntas ou do conjunto de perguntas de uma categoria 
específica. O conjunto dos termos encontrados são exibidos ao usuário 
desenvolvedor para que este possa selecionar quais termos são relevantes para 
o projeto. Há a possibilidade também de realizar a combinação entre termos 
durante a seleção, a fim de criar um termo composto que a extração 
automática não capturou nas sentenças. 



  

 Para a persistência dos dados levantados pela aplicação, no processo de 
especificação de ontologia, optou-se pelo uso do XML. A estrutura deste 
segue uma abstração dos itens presentes no documento OSRD proposto na 
etapa de especificação do NeOn. Poderia ter sido utilizado a persistência em 
um banco de dados ou em outro tipo de repositório de dados, mas o uso do 
XML permite à aplicação uma maior comunicação com outros tipos de 
sistemas, ferramentas ou aplicações, bastando às aplicações-clientes o 
conhecimento sobre a estrutura XML e a possibilidade de fazer leitura de 
arquivos desse tipo. 

 Com base nas modelagens acima descritas foi elaborada uma aplicação 
que atendesse à mesmas e prestasse o suporte esperado a etapa de 
especificação da metodologia NeOn. 

5. Conclusão 

Em relação à metodologia NeOn, mais exatamente sobre a etapa de 
especificação de ontologias, o ponto que mais se destaca é a tentativa de 
aproximar o processo de desenvolvimento de ontologias à maturidade hoje 
observada na Engenharia de Software, como inclusive é citado em Suárez-
Figueroa (2008). 

 O documento OSRD proposto na etapa de especificação da 
metodologia traz um padrão exato das informações relevantes à etapa durante 
o desenvolvimento da ontologia, organizando as informações para que estas 
sirvam de subsídio para as etapas seguintes do processo de desenvolvimento. 

 Com a aplicação há a possibilidade de automatizar o desenvolvimento 
desse documento além de permitir uma comunicação facilitada com outras 
aplicações durante o processo, responsáveis por outras etapas do mesmo, 
sendo isto possível a partir de um arquivo XML cuja estrutura seja de 
conhecimento comum, possibilitando a implementação da correta forma de 
leitura e interpretação do mesmo. 

References 

BORST, W. N. “Construction of Engineering Ontologies.” Tese, University of 
Tweenty – Centre for Telematica and Information Technology, Enschede, 
Nederland, 1997. 

DEVEDZIC, V. “Understanding Ontological Engineering. Communications of 
the ACM”, v. 45, n. 4, p. 136-144, 2002. 

GÓMEZ-PÉREZ, A; et al. “Ontologic Engineering: with examples from the 
areas of knowledge management, e-commerce and the semantic web.” 
Springer-Verlag, 2004. 

GRUBER, T. “A translation approach  to portable ontology specification. 
Knowledge Acquisition”, v. 5, n. 2, p. 199-220, 1993.  



  

GRUNINGER, M.; FOX, M. S. “Methodology for the design and evaluation 
of ontologies.” In Skuce D (ed) IJCAI95 Workshop on Basic Ontological 
Issues in Knowledge Sharing, pp 6.1–6.10.,1995. 

KIRYAKOV, A. “Ontologies for Knowledge Management.” In: DAVIES, J.; 
et al. (eds). Semantic Web Technologies: trends and research in ontology-
based systems, p. 115-138, 2006. 

PINTO, H. S.; MARTINS, J. P. “Ontologies: how can they be built? 
Knowledge and Information Systems”, v. 6, n. 4, p. 441-464, 2004. 

RAUTENBERG, S.; et al. “ontoKEM: uma ferramenta para construção e 
documentação de ontologias.” In: Seminário de Pesquisa  em Ontologia no 
Brasil, Niterói, Brasil, Agosto, 2008. Anais do 1º Seminário de Pesquisa em 
Ontologia no Brasil, 2008. 

SUÁREZ-FIGUEROA, M. C.; et al., “D5.3.1 NeOn Development Process and 
Ontology Life Cycle. NeOn: Lifecycle Support for Networked Ontologies”, 
Integrated Project (IST-2005-027595), NeOn-Project.org, 2007. 

SUÁREZ-FIGUEROA, M. C., “D5.4.1. NeOn Methodology for Building 
Contextualized Ontology Networks. NeOn: Lifecycle Support for 
Networked Ontologies”, Integrated Project (IST-2005-027595), NeOn-
Project.org, 2008. 

 


</field>
	</doc>
</add>