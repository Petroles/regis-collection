<?xml version="1.0" encoding="utf-8"?>
<add>
	<doc>
		<field name="docid">BR-TU.22021</field>
		<field name="filename">5884_dissertacao.pdf</field>
		<field name="filetype">PDF</field>
		<field name="text">
Programação por restrições e

escalonamento baseado em restrições:

Um estudo de caso na programação de

recursos para o desenvolvimento de

poços de petróleo

Thiago Serra Azevedo Silva

Dissertação apresentada
ao

Instituto de Matemática e Estatística
da

Universidade de São Paulo
para

obtenção do título
de

Mestre em Ciências

Programa: Ciência da Computação

Orientador: Profa. Dra. Yoshiko Wakabayashi

São Paulo, julho de 2012



Programação por restrições e escalonamento baseado em restrições:
Um estudo de caso na programação de recursos para o

desenvolvimento de poços de petróleo

Esta dissertação contém as correções e alterações

sugeridas pela Comissão Julgadora durante a defesa

realizada por Thiago Serra Azevedo Silva em 23/05/2012.

O original encontra-se disponível no Instituto de

Matemática e Estatística da Universidade de São Paulo.

Comissão Julgadora:

• Profa. Dra. Yoshiko Wakabayashi (orientadora) ? IME-USP

• Prof. Dr. Walter Figueiredo Mascarenhas ? IME-USP

• Prof. Dr. Arnaldo Vieira Moura ? IC-UNICAMP



Resumo

SERRA, T. Programação por restrições e escalonamento baseado em restrições: Um

estudo de caso na programação de recursos para o desenvolvimento de poços de pe-

tróleo.. 2012. 151 f. Dissertação (Mestrado) - Instituto de Matemática e Estatística, Universidade

de São Paulo, São Paulo, 2012.

O objetivo dessa dissertação é apresentar um problema de otimização do uso de recursos críticos

no desenvolvimento de poços de petróleo marítimos e a técnica empregada para a abordagem pro-

posta ao problema. A revisão da técnica de Programação por Restrições é feita analisando aspectos

relevantes de modelagem, propagação, busca e paradigmas de programação. A especialização da

técnica para problemas de escalonamento, o Escalonamento Baseado em Restrições, é descrita com

ênfase nos paradigmas descritivos e nos mecanismos de propagação de restrições. Como subsídio

ao uso da técnica em outros problemas, a linguagem comercial de modelagem OPL é apresentada

no Apêndice. O objetivo da abordagem ao problema é obter um escalonador para maximizar a

produção de óleo obtida no curto prazo. O escalonador proposto baseia-se na declaração de um mo-

delo empregando variáveis de intervalo. Um algoritmo e um modelo de Programação Linear Inteira

abordando relaxações do problema são apresentados para que se obtenha um limitante superior

ao valor de produção ótimo. Para o cenário real no qual a análise experimental foi feita, foram

obtidas soluções a menos de 16% do ótimo após uma hora de execução; e os testes em instâncias

de tamanhos variados evidenciaram a robustez do escalonador. Direções para trabalhos futuros são

apresentadas ponderando os resultados obtidos.

Palavras-chave: Programação por Restrições, Escalonamento Baseado em Restrições, Desenvol-

vimento de Poços de Petróleo Marítimos.

i



ii



Abstract

SERRA, T. Constraint programming and constraint-based scheduling: A case study in

the scheduling of resources for developing o?shore oil wells.. 2012. 151 f. Dissertation

(M.Sc.) - Instituto de Matemática e Estatística, Universidade de São Paulo, São Paulo, 2012.

The aim of this work is to present a problem of optimizing the use of critical resources to develop

o?shore oil wells and the technique used to approach the problem. The review of the Constraint

Programming technique is made by analyzing relevant aspects of modeling, propagation, search

and programming paradigms. The specialization of the technique to scheduling problems, known as

Constraint-Based Scheduling, is described with emphasis on descriptive paradigms and constraint

propagation mechanisms. In order to support the use of the technique to tackle other problems, the

commercial modeling language OPL is presented in the appendix. The aim of the approach to the

problem is to obtain a scheduler that maximizes the short-term production of oil. The scheduler

presented relies on the description of a model using interval variables. An algorithm and an Integer

Linear Programming model approaching relaxations of the problem are presented in order to obtain

an upper bound for the optimal production value. For the real scenario upon which the experimental

analysis was done, there were found solutions within 16% of the optimal after one hour of execution;

and the tests on instances of varied sizes gave evidence of the robustness of the scheduler. Directions

for future work are presented based on the results achieved.

Keywords: Constraint Programming, Constraint-Based Scheduling, O?shore Oil Well Develop-

ments.

iii



iv



Prefácio

Essa dissertação se divide entre a abordagem a um problema prático oriundo da Petrobras

e uma introdução teórica à técnica empregada, sendo dado bastante destaque a essa última. E

por que tanta ênfase à técnica? Comparativamente, a programação por restrições não goza de

muito reconhecimento no Brasil. Sua importância se deve à facilidade com que possibilita abordar

problemas combinatórios e de escalonamento tratados frequentemente no meio acadêmico e na

indústria. Dessa forma, ainda que o problema estudado seja bastante interessante e pouco trivial,

elaborar material atualizado e em português sobre a técnica pode ser muito mais importante do

que simplesmente reproduzir o conteúdo dos artigos elaborados acerca do problema. Por tal razão,

decidi dar igual importância à técnica e ao problema, além de repetir algumas de?nições em mais

de uma parte do trabalho para possibilitar ao leitor a uma leitura sequencial.

Pelo hábito e con?ança à técnica, sei que me arrisco a ser omisso ou mesmo tendencioso. Dada

a multidisciplinaridade do campo da pesquisa operacional, é muito comum que cada praticante se

concentre em algumas técnicas e acabe por ver qualquer problema apenas sob a ótica das mesmas. No

meu caso, a marcha foi inversa e acabei por me especializar no assunto em razão dos resultados que

obtive no projeto aqui descrito. Entretanto, nem sempre fui bem-sucedido em passar essa mensagem

adiante e utilizar os argumentos corretos para justi?car seu emprego. O material que apresento

na primeira parte dessa dissertação re?ete o desenvolvimento do meu discurso a esse respeito,

procurando encorajar ao máximo a aplicação da técnica em situações com maior potencial para

sucesso. Além disso, a terminologia reconhecida em inglês para os principais conceitos é informada

para que o leitor possa procurar por outras referências com maior facilidade. Como adendo a essa

parte teórica, a linguagem de modelagem comercial OPL é introduzida no apêndice como forma de

subsídio à utilização efetiva da técnica.

Não obstante o foco dado à programação por restrições, o problema abordado tem uma apli-

cação importante e é tratado em um grau de detalhe maior se comparado à literatura existente.

A programação de recursos ditos críticos ao desenvolvimento de novos poços de petróleo é crucial

devido à escassez e ao alto custo desses recursos, que são o gargalo do processo. Levando-se em conta

o cenário recente de descobertas relativamente abundantes na camada do pré-sal e as limitações

econômicas envolvidas, qualquer melhoria no desempenho operacional tem uma relação direta com

a antecipação da produção nesses novos reservatórios e com a consequente redução dos investimen-

tos necessários, ou com o aumento do escopo de tais investimentos. Além disso, o detalhamento

dado ao problema serve tanto como registro documental sobre o processo sob o ponto de vista do

problema de otimização decorrente como também constitui um estudo de caso interessante pela

variedade de interdependências entre as atividades a serem programadas. A abordagem proposta

atém-se ao paradigma declarativo, de forma que sua relevância se dá pela forma com que captura

a estrutura do problema para que seja resolvido por ferramentas que se encontram no estado da

v



vi

arte. Dessa forma, além de validar a técnica com uma aplicação signi?cativa, o desenvolvimento do

estudo de caso também ?gura como uma contribuição paralela àquela da apresentação teórica.

Minha participação nesse projeto da Petrobras concentrou-se no desenvolvimento de um novo

módulo resolvedor para o sistema ORCA (Otimização dos Recursos Críticos nas Atividades), que

consiste no estudo de caso apresentado. A existência do sistema na Petrobras precede em muito

minha colaboração, sendo importante ressaltar o empenho pioneiro de Ricardo Accioly e Fernando

Marcellino, de Romulo Albuquerque no desenvolvimento de um resolvedor para versões intermediá-

rias, de Gilberto Nishioka na retomada do projeto e nos detalhamentos posteriores, além de muitos

outros colaboradores da força de trabalho da Petrobras, e de alunos e professores da Unicamp que

se envolveram de alguma forma ao longo desses anos. Espero manter esse elo pré-existente, fazendo

com que a publicação dessa dissertação auxilie em desenvolvimentos posteriores ou em projetos

similares, além de encorajar o emprego da técnica em outros nichos com potencial de sucesso.



Agradecimentos

Em primeiro lugar, à minha família pelo papel fundamental para que esse trabalho se concre-

tizasse. À minha companheira Sabrina pela presença e carinho ao longo desses anos juntos, além

do apoio quando precisei me dedicar aos estudos e do capricho dos modelos que fez para minhas

apresentações. À minha mãe Ana Maria pelo sacrifício, cuidado e amor com que criou seus ?lhos

e possibilitou que pudéssemos buscar nossos sonhos. À minha irmã Ana Caroline pela companhia

nos bons e maus momentos desde muito cedo na vida. À minha sogra Maria Inês pelos conselhos da

experiência e toda a co-orientação informal ajudando nos meus escritos e apresentações. Por ?m,

à memória de meu pai Joaquim Benedito e de meus quatro avós, que a seu tempo contribuíram

direta e indiretamente para essa realização.

Não poderia também esquecer o apoio de vários professores e pro?ssionais diversos no âmbito

acadêmico. À minha orientadora Yoshiko Wakabayashi por ter aceitado o desa?o de me orientar

em um tema diferente de sua linha de pesquisa, bem como pelo nível de suas aulas e atenção ao

desempenho dos alunos. Ao professor Arnaldo Vieira Moura, meu orientador de iniciação cientí?ca

na Unicamp, por ter possibilitado meu primeiro contato com a Petrobras. Ao professor Carlos

Eduardo Ferreira que, em conjunto com a Yoshiko e o Arnaldo, contribuiu com sugestões valiosas

em minha banca de quali?cação. Aos professores Arnaldo, Cid Carvalho de Souza, Cláudio Leonardo

Lucchesi, Rodolfo Jardim Azevedo e Miguel Mira da Silva pelas cartas de recomendação para minha

admissão no mestrado. Decerto que a lista de professores que ?zeram diferença é muito maior que a

apresentada e gostaria de representá-los simbolicamente por meio da professora Edileuza, da minha

quarta série do primário, por remar contra a maré e se preocupar com seus alunos no contexto de

um ensino público de níveis básico e médio bastante de?citário. Por ?m, ao corpo de funcionários

do IME e da USP por possibilitar a execução de meu trabalho.

Cabem também agradecimentos para que o projeto ocorresse com sucesso na Petrobras. Ao

Fernando Marcellino por ter con?ado a mim a responsabilidade de desenvolver um novo módulo

resolvedor. A toda a equipe do ORCA e à estrutura subjacente, com especial atenção a Gilberto

Nishioka, Antônio de Oliveira e à gerência da TIC em São Paulo. A meus colegas e ex-colegas

de trabalho pelos eventuais apoios, revisões de rascunhos e sugestões, incluindo Edson Nishida,

Tony Lopes, Daniel Ferber, Felipe Sodré, Henrique Goulart e Gustavo Pacianotto. Aos colegas e

professores da Universidade Petrobras, que acompanharam o momento de escrita desse trabalho.

Por último, mas não menos importante, gostaria de lembrar algumas pessoas de contextos

diversos. A meus colegas de Unicamp Alan Godoy, Tiago Tavares e André Ciré, que acompanharam

bem de perto o desenrolar desse mestrado e colaboraram como puderam para seu sucesso por meio

da revisão de rascunhos e trocas de idéias. A outros amigos de longa data como a Amanda, o

Leandro, o Lucas e o Gustavo em Santo André; a Aline, o Pedro e o Hugo em Lisboa; e meus

colegas de EC03, CACo e Maratona na Unicamp. À Ivonete pelo zelo com que cuidou de nossa casa

vii



viii

e possibilitou que eu e a Sabrina pudéssemos coordenar estudo e trabalho. E a todos os demais que,

entendendo minha fraqueza de memória e o curto espaço disponível, saibam o quanto representam

para essa realização por terem cruzado comigo pela vida.



?Sabemos bem que toda a obra tem que ser imperfeita, e que a menos segura das nossas contem-

plações estéticas será a de aquilo que escrevemos. Mas imperfeito é tudo, nem há poente tão belo

que o não pudesse ser mais, ou brisa leve que nos dê sono que não pudesse dar-nos um sono mais

calmo ainda. E assim, contempladores iguais das montanhas e das estátuas, gozando os dias como

os livros, sonhando tudo, sobretudo, para o converter na nossa íntima substância, faremos também

descrições e análises, que, uma vez feitas, passarão a ser coisas alheias, que podemos gozar como

se viessem na tarde.?

Bernardo Soares (heterônimo de Fernando Pessoa), Livro do Desassossego

ix



x



Sumário

Lista de Abreviaturas xv

Lista de Figuras xvii

Lista de Tabelas xix

I INTRODUÇÃO 1

1 Introdução 3

1.1 Referências e Notas de Apoio à Leitura . . . . . . . . . . . . . . . . . . . . . . . . . . 3

1.2 A Indústria de Petróleo e a Programação de Recursos Críticos . . . . . . . . . . . . . 5

1.3 Problemas de Escalonamento e a Programação por Restrições . . . . . . . . . . . . . 8

1.4 Organização do Restante do Trabalho . . . . . . . . . . . . . . . . . . . . . . . . . . 10

II DESCRIÇÃO DA TÉCNICA 11

2 Programação por Restrições 13

2.1 Modelagem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

2.1.1 Aplicabilidade em Função da Modelagem . . . . . . . . . . . . . . . . . . . . 15

2.1.2 Boas Práticas em Modelagem . . . . . . . . . . . . . . . . . . . . . . . . . . . 18

2.2 Propagação de Restrições . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19

2.2.1 Técnicas de Consistência Binária . . . . . . . . . . . . . . . . . . . . . . . . . 20

2.2.2 Técnicas de Consistência Generalizada . . . . . . . . . . . . . . . . . . . . . . 27

2.3 Busca . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

2.3.1 Busca por Recursão e Retrocesso . . . . . . . . . . . . . . . . . . . . . . . . . 30

2.3.2 Busca Local e Estocástica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36

2.4 Paradigmas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37

2.4.1 Ferramentas Comerciais . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38

2.4.2 Modelagem Abstrata . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39

3 Escalonamento Baseado em Restrições 41

3.1 Modelagem e Paradigmas Descritivos . . . . . . . . . . . . . . . . . . . . . . . . . . . 42

3.1.1 Caracterização por Atividades e Recursos . . . . . . . . . . . . . . . . . . . . 42

3.1.2 Caracterização por Variáveis de Intervalo . . . . . . . . . . . . . . . . . . . . 46

3.2 Elementos Complementares de Resolução . . . . . . . . . . . . . . . . . . . . . . . . 49

xi



xii SUMÁRIO

3.2.1 Propagação . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49

3.2.2 Busca . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55

III ESTUDO DE CASO 57

4 O Problema da Programação de Recursos Críticos e Sua Abordagem 59

4.1 Decisões e Entidades Relacionadas . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60

4.2 Critérios de Otimização . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60

4.3 Restrições do Problema . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61

4.3.1 Restrições Gerais dos Recursos . . . . . . . . . . . . . . . . . . . . . . . . . . 61

4.3.2 Restrições Gerais de Execução das Atividades . . . . . . . . . . . . . . . . . . 62

4.3.3 Restrições de Estoque dos Recursos . . . . . . . . . . . . . . . . . . . . . . . . 62

4.3.4 Restrições de Estoque das Atividades . . . . . . . . . . . . . . . . . . . . . . . 62

4.4 Modelagem por Variáveis de Intervalo . . . . . . . . . . . . . . . . . . . . . . . . . . 63

4.4.1 Associação entre Atividades e Recursos . . . . . . . . . . . . . . . . . . . . . 63

4.4.2 Associação entre Atividades e Localidades . . . . . . . . . . . . . . . . . . . . 67

4.4.3 Restrições de Estoque e Transporte de Linhas . . . . . . . . . . . . . . . . . . 68

4.4.4 Função Objetivo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70

4.5 Limitante Superior ao Ótimo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70

4.5.1 Algoritmo Guloso sobre Relaxação . . . . . . . . . . . . . . . . . . . . . . . . 71

4.5.2 Modelo de PLI sobre Relaxação . . . . . . . . . . . . . . . . . . . . . . . . . . 71

5 Análise Experimental do Escalonador 77

5.1 Dados Disponíveis e Ambiente de Testes . . . . . . . . . . . . . . . . . . . . . . . . . 77

5.2 Experimentos Realizados e Resultados . . . . . . . . . . . . . . . . . . . . . . . . . . 78

5.3 Discussão . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81

IV CONCLUSÃO 83

6 Conclusão 85

V APÊNDICE 87

A Programação por Restrições em OPL 89

A.1 A Linguagem OPL e o Resolvedor CP . . . . . . . . . . . . . . . . . . . . . . . . . . 89

A.2 Representação do Modelo e da Entrada de Dados . . . . . . . . . . . . . . . . . . . . 90

A.3 Elementos de Uso Geral da Linguagem . . . . . . . . . . . . . . . . . . . . . . . . . . 91

A.3.1 Escolha do Resolvedor do Modelo . . . . . . . . . . . . . . . . . . . . . . . . . 91

A.3.2 Comentários em Arquivos de Modelo e de Dados . . . . . . . . . . . . . . . . 92

A.3.3 Variáveis de Tipos Primitivos e Atribuições . . . . . . . . . . . . . . . . . . . 92

A.3.4 Estruturas de Dados Básicas: Vetores e Domínios . . . . . . . . . . . . . . . . 93

A.3.5 Atribuições Básicas a Elementos de Vetores . . . . . . . . . . . . . . . . . . . 94

A.3.6 Expressões Numéricas e Predicados . . . . . . . . . . . . . . . . . . . . . . . . 95



SUMÁRIO xiii

A.3.7 Operadores de Agregação e Funções Sobre Vetores . . . . . . . . . . . . . . . 96

A.3.8 Estruturas de Dados Avançadas: Tuplas e Conjuntos . . . . . . . . . . . . . . 98

A.4 Modelagem de Problemas Combinatórios . . . . . . . . . . . . . . . . . . . . . . . . . 99

A.4.1 Variáveis de Decisão de Tipos Primitivos . . . . . . . . . . . . . . . . . . . . . 100

A.4.2 Expressões de Decisão . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 100

A.4.3 Sobre a Impossibilidade de Usar Variáveis float em CP . . . . . . . . . . . . 102

A.4.4 Função Objetivo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102

A.4.5 Restrições Básicas Sobre Tipos Primitivos . . . . . . . . . . . . . . . . . . . . 103

A.4.6 Restrições Especializadas Sobre Tipos Primitivos . . . . . . . . . . . . . . . . 104

A.4.7 Execução do Resolvedor e Con?gurações Básicas do CP . . . . . . . . . . . . 105

A.4.8 Manipulação da Solução e Impressão dos Resultados no Pós-Processamento . 106

A.4.9 Um Exemplo de Problema Combinatório Modelado em OPL . . . . . . . . . . 106

A.5 Modelagem de Problemas de Escalonamento . . . . . . . . . . . . . . . . . . . . . . . 108

A.5.1 Problemas de Escalonamento e a Motivação ao Emprego de CP . . . . . . . . 108

A.5.2 Variáveis de Intervalo e Suas Propriedades . . . . . . . . . . . . . . . . . . . . 108

A.5.3 Restrições de Precedência . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110

A.5.4 Predicados Sobre Conjuntos de Intervalos . . . . . . . . . . . . . . . . . . . . 111

A.5.5 Sequências e Transições . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112

A.5.6 Modelagem de Recursos Limitados . . . . . . . . . . . . . . . . . . . . . . . . 113

A.5.7 Funções Cumulativas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114

A.5.8 Funções de Estado . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117

A.5.9 Um Exemplo de Problema de Escalonamento Modelado em OPL . . . . . . . 118

A.6 Considerações Finais e Agradecimentos . . . . . . . . . . . . . . . . . . . . . . . . . . 120

Referências Bibliográ?cas 121

Índice Remissivo 127



xiv SUMÁRIO



Lista de Abreviaturas

CBS Escalonamento Baseado em Restrições

(de Constraint-Based Scheduling)

CLP Programação Lógica por Restrições

(de Constraint Logic Programming)

CP Programação por Restrições

(de Constraint Programming)

CSOP Problema de Otimização da Satisfação de Restrições

(de Constraint Satisfaction Optimization Problem)

CSP Problema de Satisfação de Restrições

(de Constraint Satisfaction Problem)

EBR Escalonamento Baseado em Restrições

GRASP Procedimentos de Busca Gulosa, Aleatória e Adaptativa

(de Greedy Randomized Adaptive Search Procedures)

JSP Problema do Escalonamento de Chão-de-Fábrica

(de Job-Shop Scheduling Problem)

MA Meta-Aprendizagem

ML Meta-Aprendizagem

(de Meta-Learning)

OPL Linguagem de Programação de Otimização

(de Optimization Programming Language)

ORCA Otimização de Recursos Críticos nas Atividades

(sistema desenvolvido na Petrobras)

PEC Problema do Escalonamento de Chão-de-Fábrica

PI Programação Inteira

PLI Programação Linear Inteira

PM Programação Matemática

PLR Programação Lógica por Restrições

PR Programação por Restrições

POSR Problema de Otimização da Satisfação de Restrições

PSR Problema de Satisfação de Restrições

PTS Problema Temporal Simples

SAT Problema de Satisfabilidade

STP Problema Temporal Simples

(de Simple Temporal Problem)

xv



xvi LISTA DE ABREVIATURAS



Lista de Figuras

1.1 Sonda marítima Transocean Legend. . . . . . . . . . . . . . . . . . . . . . . . . . . . 6

1.2 Barco lançador de linhas Polar Queen. . . . . . . . . . . . . . . . . . . . . . . . . . . 6

4.1 Relação elementar entre intervalos associados a atividades e recursos. . . . . . . . . . 65

4.2 Restrição de domínios temporais e de alocação no desenvolvimento de poços. . . . . 66

4.3 Relação entre intervalos associados a atividades e suas respectivas localidades. . . . . 68

4.4 Representação das restrições de estoque do recurso por porto e na totalidade. . . . . 69

5.1 Melhoria da solução obtida em cada rodada do escalonador para a instância Q1. . . . 79

5.2 Melhoria da solução obtida em cada rodada do escalonador para a instância Q2. . . . 79

5.3 Melhoria da solução obtida em cada rodada do escalonador para a instância Q3. . . . 79

5.4 Melhoria da solução obtida em cada rodada do escalonador para a instância Q4. . . . 80

5.5 Melhoria da solução obtida em cada rodada do escalonador para a instância H1. . . 80

5.6 Melhoria da solução obtida em cada rodada do escalonador para a instância H2. . . 80

5.7 Melhoria da solução obtida em cada rodada do escalonador para a instância O. . . . 81

xvii



xviii LISTA DE FIGURAS



Lista de Tabelas

4.1 Variáveis de decisão do modelo PLI do problema relaxado. . . . . . . . . . . . . . . . 72

5.1 Principais características das instâncias testadas. . . . . . . . . . . . . . . . . . . . . 77

5.2 Principais resultados dos experimentos do escalonador. . . . . . . . . . . . . . . . . . 78

xix



xx LISTA DE TABELAS



Parte I

INTRODUÇÃO

1





Capítulo 1

Introdução

Problemas combinatórios ocorrem em diversas indústrias, mas nem sempre são percebidos como

oportunidades para automação, otimização e consequente redução de custos. Um tratamento for-

mal e analítico desses problemas tem como benefício um melhor aproveitamento de mão-de-obra

especializada e dos bens de capital envolvidos. Tal aproveitamento pode ser observado em termos

quantitativos de produção, nas métricas de qualidade de serviço, na observância a normas de segu-

rança, etc. Entretanto, é importante observar que o sucesso de uma abordagem prática depende da

habilidade com que o problema é analisado e do ferramental à disposição dos pro?ssionais envol-

vidos. Dessa forma, é possível entender que a contribuição de um trabalho acadêmico com foco na

aplicação se dê pelo legado para que projetos posteriores tenham maior chance de sucesso. Tendo

essa observação em mente, o caminho escolhido nessa dissertação foi o de integrar a abordagem de

um problema real à descrição da técnica empregada.

O problema estudado nessa dissertação relaciona-se ao desenvolvimento de novos poços maríti-

mos de produção de petróleo e à manutenção de outros pré-existentes, sendo abordado pela técnica

de programação por restrições. Cabe ressaltar que a técnica adotada para a abordagem não repre-

senta a única opção possível, mas é uma modalidade que goza de pouco reconhecimento a despeito

da relativa facilidade com que poderia ser aplicada a muitos problemas. De forma a tornar o assunto

abordado mais acessível, alguns conceitos fundamentais de áreas correlatas e referências que entrem

em maiores detalhes são apresentados na seção 1.1. Na sequência, as seções 1.2 e 1.3 contextua-

lizam o problema em foco na indústria em que se insere e em função do ferramental empregado,

respectivamente. O propósito do restante da dissertação é apresentar a técnica adotada, introdu-

zir uma ferramenta que viabilize seu uso e tratar o problema mencionado em maiores detalhes. A

organização adotada para os demais capítulos é apresentada na seção 1.4.

1.1 Referências e Notas de Apoio à Leitura

A apresentação da indústria petrolífera descrita neste capítulo re?ete o conhecimento adquirido

pelo autor com sua experiência na Petrobras, tanto por meio de treinamentos quanto pelo levanta-

mentos de requisitos. Como sugestão de referência para aprofundamento, veja Thomas (2004).

Como parte da discussão sobre abordagens para a resolução de problemas de otimização, são

mencionados ou presumidos alguns conhecimentos de otimização númerica, programação linear e

de programação linear inteira. Para uma introdução ao primeiro tópico e aos conceitos de conve-

xidade de funções que possibilitam o uso de algoritmos de gradiente para obter um ótimo global,

3



4 INTRODUÇÃO 1.1

veja Nocedal e Wright (2000). Para uma introdução ao segundo, veja Bazaraa et al. (1990). Para

uma introdução ao último e aos tipos de problemas que permitem uma resolução e?ciente com seu

uso, veja Wolsey (1998).

Por ?m, diversos conceitos de teoria da computação são mencionados no desenvolvimento teó-

rico acerca da técnica. Para maiores detalhes sobre linguagens formais, veja Sipser (2007). Para

uma introdução às classes de complexidade de algoritmos, veja Cormen et al. (2002). Para maiores

informações sobre teoria dos grafos, veja Bondy e Murty (2008). De forma a facilitar a consulta a

conceitos de maior relevância, um pequeno resumo de alguns deles é apresentado a seguir.

Classes de problemas.

• Problemas NP. A classe dos problemas NP contempla problemas decisórios cujas solu-
ções podem ser veri?cadas em tempo polinomial com relação ao tamanho da entrada. (Mais

formalmente, diz-se que tais soluções podem ser veri?cadas em tempo polinomial por uma

máquina de Turing não-determinística.)

• Problemas NP-Difíceis. Dizemos que um problema Q pertence à classe dos problemas
NP-Difíceis se todo problema em NP pode ser reduzido a Q em tempo polinomial.

• Problemas NP-Completos. Dizemos que um problema Q pertence à classe dos problemas
NP-Completos se Q pertence à classe NP, e além disso é NP-Difícil. Assim, se tivéssemos um

algoritmo polinomial para um problema NP-Completo, então poderíamos resolver em tempo

polinomial todos os problemas em NP.

Grafos. Um grafo G consiste em um par (V,E), onde V é um conjunto de elementos chamados

vértices e E é um conjunto elementos chamados arestas, sendo que cada aresta corresponde a um

par de vértices de V . Uma aresta correspondente a um par de vértices u,v ? V é denotada por uv,
e é dita incidente ao tal par. Quando uma aresta é duplamente incidente a um mesmo vértice, ela

é denominada laço; e quando duas arestas distintas correspondem a um mesmo par de vértices elas

são chamadas paralelas. Um grafo sem laços e sem arestas múltiplas é chamado simples.

• Orientação. Uma orientação de um grafo G = (V,E) é um grafo direcionado ? ou digrafo ?
D = (V,E?) tendo o mesmo conjunto de vértices mas arestas dirigidas, de forma que a cada

aresta uv ? E corresponde uma aresta ??uv ? E ou ??vu ? E, mas não ambas.

• Ordenação topológica. Uma ordenação topológica de um digrafo D = (V,E?) consiste em
uma ordenação linear de seus vértices tal que para cada aresta ??uv ? E?, o vértice u precede v
nesta ordem (linear).

• Árvore. Uma árvore é um grafo conexo e sem circuitos (ou equivalentemente, um grafo onde
há um único caminho entre cada par de vértices).

• Subgrafo. Diz-se que um grafo H = (V ?,E?) é subgrafo de G = (V,E) se V ? ? V e E? ? E.

• Subgrafo induzido. Dizemos que H = (V ?,E?) é um subgrafo induzido de G se E? corres-
ponde ao conjunto de todas as arestas de E incidentes exclusivamente a vértices de V ?. Neste

caso, H é induzido por um conjunto de vértices. (O conceito de subgrafos induzidos por um

conjunto de arestas não será usado aqui.)



1.2 A INDÚSTRIA DE PETRÓLEO E A PROGRAMAÇÃO DE RECURSOS CRÍTICOS 5

• Isomor?smo. Dois grafos G = (V,E) e H = (V ?,E?) são isomorfos se existe uma bijeção
f : V ? V ? tal que uv ? E ? f(u)f(v) ? E?.

• Grafo bipartido. Um grafo G = (V,E) é bipartido se existem conjuntos disjuntos V1 e V2
tais que V = V1 ?V2, e toda aresta em E é incidente a um vértice de V1 e a um vértice de V2.

• Emparelhamento máximo de um grafo bipartido. Um emparelhamento consiste em
um conjunto M ? E tal que nenhum par de arestas de M incide sobre um mesmo vértice.
Um emparelhamento M de G é máximo se não existe outro emparelhamento M ? de G tal que

|M ?| &gt; |M|.

• Corte. Um corte de um grafo G = (V,E) é o conjunto de todas as arestas incidentes a um
algum conjunto não-vazio W ? V e a seu complemento V \W .

1.2 A Indústria de Petróleo e a Programação de Recursos Críticos

A indústria petrolífera representa um cenário interessante a abordagens quantitativas para a

tomada de decisão devido aos altos custos envolvidos em várias etapas de sua cadeia produtiva.

Em primeira instância, uma parcela considerável dos processos desenvolvidos nessa indústria po-

dem ser divididos entre o que se convencionou chamar de upstream e downstream, respectivamente

responsáveis pela obtenção de óleo cru ? composto por gás natural, óleo, água e sedimentos, sendo

separados ?sicamente após a obtenção ? e pelo seu processamento para a obtenção de derivados ?

produtos resultantes de processos físicos e químicos realizados em uma re?naria. No caso especí-

?co do upstream, os processos podem ser subdivididos entre exploração1 e produção2, o primeiro

relacionado à prospecção de potenciais reservatórios e o segundo ao desenvolvimento e consequente

extração de matéria-prima dos reservatórios descobertos. Para a produção, destacam-se a etapa de

desenvolvimento dos poços de um reservatório, a produção de óleo e gás propriamente dita, inter-

venções periódicas de manutenção nos poços e o fechamento dos poços quando a produção cessa. O

foco desse trabalho se dará nas etapas de desenvolvimento e manutenção dos poços para produção,

com atenção às peculiaridades da extração marítima em águas profundas. Por águas profundas,

consideramos profundidades a partir de 300 metros por representarem o limite para a intervenção

humana direta e para a utilização de armaduras nos poços, o que possibilitaria aplicar técnicas

similares àquelas da extração terrestre.

A execução das atividades de desenvolvimento e manutenção da infraestrutura de produção

depende da alocação de recursos adequados às restrições operacionais. No caso de águas profundas,

os recursos de maior criticidade são sondas marítimas e barcos lançadores de linhas, exempli?cados

pela ?gura 1.1 de Yue (2008) e pela ?gura 1.2 de Acergy-Group (2010). Esses recursos têm um

custo signi?cativamente maior do que aquele veri?cado para equipamentos empregados em outras

modalidades de produção comercialmente viáveis atualmente. Apesar dos custos envolvidos em

desenvolvimentos marítimos serem muito maiores do que aqueles observados nas terrestres, eles

ainda são viáveis em razão do preço pago pelo barril atualmente. No entanto, existe uma exigência

mais elevada de produção para que exista uma compensação ?nanceira ao desenvolvimento de poços

nessas condições. Os recursos necessários a essas empreitas são tidos como críticos por serem pouco

1Denominada exploration em inglês.
2Denominada exploitation em inglês.



6 INTRODUÇÃO 1.2

numerosos e certas vezes alugados por períodos limitados de tempo, sendo necessário que transitem

entre diversas localidades de uma região de grandes dimensões. Além disso, devem obedecer a rotinas

constantes de manutenção que interrompem a capacidade de execução de alguns tipos de atividade

ou mesmo de qualquer atividade. Dessa forma, o uso adequado desses recursos pode representar um

ganho operacional signi?cativo.

Figura 1.1: Sonda marítima Transocean Legend.

Figura 1.2: Barco lançador de linhas Polar Queen.

A programação das atividades nos recursos contempla tanto a alocação a um recurso, i.e., como



1.2 A INDÚSTRIA DE PETRÓLEO E A PROGRAMAÇÃO DE RECURSOS CRÍTICOS 7

realizar cada atividade, quanto o escalonamento do recurso, i.e., quando realizá-las. Cada poço

começa a produzir ou tem uma retomada de sua produção tão logo suas atividades previstas sejam

concluídas. Por conseguinte, a programação deve ser feita de forma a antecipar o ganho resultante

no curto prazo para compensar os custos associados. Para o número de atividades e de restrições

de um cenário real desse problema, a programação manual das atividades passou a ser inviável por

tomar vários dias de trabalho de mão-de-obra especializada. Nessa situação, torna-se impraticável

reprogramar, em curto prazo, a escala completa de atividades devido à falta de um recurso ou ao

atraso na data de conclusão prevista para uma atividade. Por consequência, a otimização da escala é

muitas vezes desconsiderada numa abordagem manual. Portanto, a formalização e o desenvolvimento

de ferramentas capazes de resolver o problema de alocação e escalonamento de recursos é de grande

importância para um melhor desempenho da organização.

A primeira abordagem a este problema foi feita por Hasle et al. (1996) e motivou desenvolvi-

mentos posteriores para escopos e realidades distintas, como é o caso da brasileira. A abordagem

de Hasle et al. (1996) consistia em um protótipo para aplicação no desenvolvimento de poços no

Mar do Norte. Um sistema similar denominado ORCA foi desenvolvido pela Petrobras e descrito

em Accioly et al. (2002). A exemplo do precursor, esse sistema empregava a técnica de programação

por restrições. Apesar de contemplar requisitos necessários ao desenvolvimento de poços, o escopo

desse sistema restringiu-se às atividades de manutenção. A demanda por esse escopo restrito surgiu

devido à menor oferta relativa de recursos disponíveis para tal ?m, o que tornava imperativo o

melhor uso possível desses recursos. Uma abordagem alternativa empregando programação mate-

mática e busca tabu3 sobre uma simpli?cação do problema tratado pelo sistema da Petrobras foi

desenvolvida por do Nascimento (2002) a partir de um contato inicial entre a empresa e a Unicamp.

Essa autora provou que mesmo tal versão simpli?cada é NP-Difícil, sendo tão difícil quanto o Pro-

blema do Escalonamento de Chão-de-Fábrica (PEC)4, o que signi?ca que é pouco provável que

existam algoritmos e?cientes para o caso geral do problema tratado. Um detalhamento progressivo

dessa especi?cação original foi apresentado em trabalhos posteriores, cuja abordagem foi incorpo-

rada ao sistema original da empresa. Pereira et al. (2005) abordou a versão completa do problema

utilizando a meta-heurística GRASP5, tendo um resultado superior ao original para determinados

cenários. Um re?namento dessa abordagem é apresentada por Moura et al. (2008b), contemplando

a incorporação de restrições para o deslocamento de recursos entre localidades. O trabalho no sis-

tema ORCA foi retomado recentemente e teve seu foco principal alterado para o desenvolvimento

de poços. A abordagem descrita nessa dissertação contempla o que foi publicado recentemente

em Serra et al. (2010), Serra et al. (2011) e Serra et al. (2012), além de re?namentos adicionais

que constarão em publicação posterior sobre o trabalho desenvolvido. A retomada frequente no

desenvolvimento do ORCA se deve à constante identi?cação de novos gargalos que impossibilitem

a aplicação dos resultados sugeridos pelas soluções obtidas, o que é natural em situações desse tipo.

Convém observar que existem abordagens sobre problemas relacionados ao ciclo de vida dos

3 Meta-heurística denominada tabu search em inglês, proposta por Glover (1989), na qual as operações empregadas
mais recentemente para obter uma solução a partir de outra pré-existente são memorizadas para não serem repetidas
por um determinado número de passos ao longo da busca por uma solução de melhor qualidade.

4 Tradução livre adotada para o Job-Shop Scheduling Problem (JSP), que consiste no problema de minimar o
tempo de conclusão do escalonamento de um conjunto de sequências de tarefas, cada tarefa compatível com um
determinado recurso.

5Acrônimo em inglês para Greedy Randomized Adaptive Search Procedures, ou Procedimentos de Busca Gulosa,
Aleatória e Adaptativa, proposta por Feo e Resende (1989), na qual soluções são geradas por meio de uma construção
semi-gulosa que dá margem à aleatoriedade e de um aperfeiçoamento simples ao ?nal da constução



8 INTRODUÇÃO 1.3

reservatórios de petróleo, com relação às quais esse trabalho pode ser contextualizado. A programa-

ção de atividades de manutenção dos poços em produção representa um caso especial do problema

em estudo, abordada por Paiva (1997) e Aloise et al. (2006) no caso de poços terrestres. O plane-

jamento das atividades exploratórias é abordado por Glinz e Berumen (2009), sendo caracterizado

por um nível menor de detalhamento por representar um estágio preliminar com menor grau de

informação e maior incerteza acerca das características e do potencial dos poços a serem perfurados.

As decisões tomadas no planejamento da exploração possuem um caráter mais estratégico do que

operacional, estando associadas à aquisição de recursos para aumentar o retorno do investimento.

Por outro lado, as entidades na programação do desenvolvimento de poços possuem restrições rela-

tivas às características de cada poço, recurso ou atividade. Não obstante tal nível de detalhamento,

a programação do desenvolvimento aqui abordada tem ainda um caráter tático por possibilitar a

avaliação do ganho associado à aquisição de um novo recurso pela comparação das soluções com

e sem o seu emprego. Dessa forma, o problema em estudo tem um papel mais crítico devido à

sua proximidade ao nível operacional em um dos processos mais custosos na cadeia de valor da

companhia.

1.3 Problemas de Escalonamento e a Programação por Restrições

Problemas de escalonamento tratam da alocação de atividades a recursos e de sua programação

no tempo, sendo sujeitos a restrições técnicas que devem ser satisfeitas para que essas decisões sejam

válidas em cada situação possível. Conforme discutido anteriormente, é comum que esse tipo de pro-

blema envolva um detalhamento maior do que aquele encontrado em problemas de planejamento.

Em muitos casos, isso acaba levando a modelos matemáticos de representação que descrevem pro-

blemas computacionalmente difíceis. Por esse motivo, problemas de escalonamento nem sempre são

abordados com a ambição de que uma solução ótima seja encontrada. A obtenção de uma solução

factível já representa um grande avanço de acordo com o caso, como no problema de programação

de transportes por dutos tratado por Moura et al. (2008a). Em outras situações, é importante ter

uma sistemática de busca que facilite a obtenção de soluções cada vez melhores a um problema cuja

otimização seja a parte difícil, com a ?nalidade de tornar os resultados mais con?áveis. Represen-

tando um pouco de cada situação, o problema tratado nesse trabalho encerra uma oportunidade

interessante para a análise do ferramental disponível para a resolução de problemas de otimização

de ordem prática.

Na ausência de algoritmos especí?cos que abordem um problema de modo e?ciente, técnicas

generalistas como a Programação Matemática (PM) são utilizadas para uma abordagem sucinta.

De maneira bem simpli?cada, em PM um problema é descrito com a minimização ou maximização

de uma função sujeita a restrições impostas por outras funções sobre as mesmas variáveis de decisão.

Em alguns casos, entretanto, problemas de escalonamento representam um desa?o à aplicação de PM

devido a limitações de tempo e memória dos recursos computacionais. Tais empecilhos decorrem das

limitações sobre o tipo de variáveis e o tipo de restrições permitidos na formulação para o emprego

de certos algoritmos. O emprego de formulações com restrição de linearidade acaba exigindo a

integralidade das variáveis de decisão em certos casos e faz com que seu tamanho também cresça

consideravelmente com as dimensões do problema. Por tal razão, o tempo necessário para resolver

um problema numérico que seja tão somente convexo acaba por crescer muito rapidamente com



1.3 PROBLEMAS DE ESCALONAMENTO E A PROGRAMAÇÃO POR RESTRIÇÕES 9

tais dimensões. Disso resultam formulações maiores e, em certos casos, grandes demais para serem

resolvidas com os recursos computacionais disponíveis. Dessa forma, a despeito do desenvolvimento

observado e do consenso sobre a e?cácia da PM, nem todos os problemas podem ser abordados de

forma e?ciente com a mesma6.

A Programação por Restrições (PR) 7 representa uma alternativa à abordagem de problemas

combinatórios, inserindo-se no nicho não atendido completamente pela Programação Linear In-

teira (PLI) devido ao tamanho das formulações resultantes de tais abordagens. Em PR, a mode-

lagem é baseada em variáveis sobre domínios discretos e ?nitos com restrições arbitrárias, porém

especializadas. Dessa forma, a modelagem não está restrita a funções lineares ou mesmo convexas

como no caso das técnicas de PM; o que leva a algoritmos de busca diferentes daqueles de PM,

tanto mais generalistas quanto mais focados na factibilidade do que na otimalidade. Apesar disso,

a modelagem possui uma ligação mais estreita com as técnicas de resolução devido à existência de

restrições dedicadas à descrição de certas estruturas de problemas combinatórios. Isso permite que

o algoritmo de resolução possa trabalhar com maior facilidade no domínio do problema e inferir

reduções do espaço de busca mais e?cazes. No caso de problemas de escalonamento, não apenas as

restrições como as próprias variáveis de decisão empregadas são especí?cas ao domínio de aplica-

ção, constituindo o que se conhece por Escalonamento Baseado em Restrições (EBR)8 . Em razão

dessas peculiaridades de modelagem e da forma com que tais elementos são utilizados no processo

de resolução dos problemas, atribui-se à técnica uma natureza declarativa.

Convém notar que existem técnicas alternativas com um enfoque no paradigma imperativo de

programação, sendo tanto concorrentes quanto complementares à PR, dado que podem ser empre-

gadas como mecanismo de busca subjacente no segundo caso. Uma opção consiste no emprego de

algoritmos de aproximação, que geram soluções de modo e?ciente e com uma garantia teórica de

proximidade ao ótimo (Vazirani (2001)). No entanto, muitos desses algoritmos são propostos para

interesses mais teóricos do que práticos, o que faz com que nem sempre sejam considerados em

aplicações. Ainda pesa na opção por uma abordagem enumerativa como a PR em contraposição ao

emprego de um algoritmo determinístico a possibilidade de geração de múltiplas soluções. Outra

opção é a do uso de heurísticas que se valem da experiência prática de tomadores de decisão no

domínio de aplicação para que soluções com certa con?abilidade sejam obtidas de maneira e?ci-

ente. Entretanto, essa con?abilidade não é traduzida em uma medida de proximidade às soluções

ótimas e sim na evidência de que cada heurística se baseia em uma sucessão de decisões aparen-

temente razoáveis. Uma coletânea de resultados satisfatórios em casos diversos geralmente leva à

generalização desses procedimentos sob a forma de meta-heurísticas aplicáveis a uma gama de pro-

blemas combinatórios. Tais meta-heurísticas podem servir tanto à geração de soluções quanto à

obtenção de novas soluções a partir de outras pré-existentes, sendo respectivamente denominadas

construtivas e de busca local9. A argumentação em favor de alguns desses procedimentos generalis-

tas remete, em muitos casos, a paralelos nos campos da física e da biologia, como pode ser observado

6 Um leitor mais atento e experiente poderia objetar devido à existência de técnicas para a abordagem de problemas
de formulação explosiva, como a geração de colunas ou de planos de corte em programação linear inteira. Entretanto,
convém lembrar que o enfoque dado no presente trabalho é pela busca de uma abordagem mais acessível e que exija
menos experiência para ser replicada em outros problemas.

7Denominada Constraint Programming (CP) em inglês.
8 Denominado Constraint-Based Scheduling (CBS) em inglês.
9 Conforme pode ser constatado pela descrição em notas anteriores, a GRASP é construtiva e a Busca Tabu é de

busca local.



10 INTRODUÇÃO 1.4

em Aarts e Lenstra (1997). Battiti et al. (2008) faz uma ressalva ao foco excessivo dado a esse tipo

de argumento em trabalhos recentes em detrimento à compreensão do motivo pelo qual resultados

satisfatórios são obtidos e, por consequência, à adoção do mais adequado em cada caso. Por ?m,

é importante observar a compilação de estudos recentes por Hooker (2006) sobre a integração de

técnicas de forma a obter o melhor de cada uma delas, partindo de quais tipos de formulações são

resolvidos com maior facilidade por quais técnicas de otimização. Ainda que boa parte do que foi

mencionado neste parágrafo não seja retomada na dissertação, é importante que tais considerações

constem como referência aos leitores interessados em abordagens alternativas.

1.4 Organização do Restante do Trabalho

Além da introdução, esse trabalho possui outras três partes e um apêndice. Na segunda parte,

a técnica de programação por restrições é descrita no Capítulo 2 e sua extensão à abordagem de

problemas de escalonamento é apresentada no Capítulo 3. Na terceira parte, o estudo de caso é

dividido em duas etapas: a descrição do problema e a abordagem no Capítulo 4, e a análise dos

resultados obtidos no Capítulo 5. A quarta parte contempla as considerações ?nais sobre o trabalho

desenvolvido. No Apêndice A, uma possibilidade de ligação entre a técnica descrita na segunda

parte e a abordagem prática tratada na terceira parte é dada pela descrição de uma linguagem

algébrica comercial para o uso de PR.

Apesar da limitação imposta pela apresentação de uma única ferramenta para o uso prático da

técnica, é importante frisar a importância pedagógica e introdutória; à semelhança do que ocorre em

disciplinas de introdução à programação, em que apenas os elementos básicos de uma linguagem são

apresentados. Espera-se que a bagagem teórica e a noção de como é possível colocá-la em prática

dêem subsídios su?cientes para que leitores iniciantes no assunto possam tornar-se praticantes

independentes se assim o desejarem.



Parte II

DESCRIÇÃO DA TÉCNICA

11





Capítulo 2

Programação por Restrições

A Programação por Restrições (PR)1 é uma técnica declarativa para formular e resolver proble-

mas combinatórios por meio da identi?cação de estruturas que permitam uma representação sucinta

e facilmente explorável de cada problema. Devido à essa generalidade de propósito e à ?exibilidade

com que os problemas podem ser modelados, os mecanismos de resolução geralmente se baseiam em

técnicas do tipo ?tentativa-e-erro?. Não obstante, seu diferencial ? e foco ? se deve à exploração das

representações adotadas para os problemas, de forma a reduzir o esforço necessário para a resolução

dos mesmos. Dessa forma, a teoria subjacente à essa técnica possui tanto um foco especialista para

compreender como ela pode ser adequada a contextos de aplicação especí?cos com maior e?cácia

quanto outro generalista para inferir as limitações ao estabelecimento de uma abordagem e?ciente

de amplo espectro.

O propósito deste capítulo é analisar os aspectos teóricos gerais da PR para elucidar como

ela funciona e como tirar proveito dela, sendo foco do próximo capítulo a especialização desses

conceitos para o caso de problemas de escalonamento. Para tanto, convém compreender de antemão

o signi?cado do nome da técnica e os elementos fundamentais de sua constituição.

A PR é de?nida por Lustig e Puget (2001) como uma técnica de programação de computadores

dedicada à resolução de problemas combinatórios. Por meio dela, tais problemas são modelados

com restrições projetadas para captar a estrutura do problema mais facilmente sobre as variáveis

de decisão, sendo esta a razão para o nome e a vantagem subjacente à técnica. Dessa forma, o termo

?programação? não assume o signi?cado de um problema matemático2, mas sim de uma técnica de

codi?cação para gerar sistemas computacionais especialistas na resolução de um determinado tipo de

problema combinatório. Lustig e Puget (2001) enfatizam a existência de uma camada de modelagem

e outra de de?nição da estratégia para a realização da busca, o que é sintetizado simbolicamente

por Hentenryck (2010) como ?PR = Modelo + Busca? 3. Tal decomposição caracteriza a natureza

declarativa da técnica, que é devida à independência do modelo quanto à forma de busca. Devido

às sucessivas transformações do paradigma à aplicação da PR por usuários ?nais, Barták (1999)

observa uma ênfase crescente à modelagem em detrimento à busca, culminando no paralelo atribuído

1 Denominada Constraint Programming (CP) em inglês.
2 Como exemplo oposto, é destacada por Lustig e Puget (2001) a semântica desse termo para o caso da Programa-

ção Linear (PL): a alocação de recursos limitados visando otimizar um objetivo, ou seja, estabelecer a programação
mais adequada desses recursos. Para maiores detalhes, as preleções do Prêmio Nobel por Kantorovich (1975) e
Koopmans (1975) apresentam a interpretação econômica dos modelos resultantes, que conferem a semântica diferen-
ciada ao uso do termo ?programação?.

3No original em inglês, ?CP = Model + Search?.

13



14 PROGRAMAÇÃO POR RESTRIÇÕES 2.1

a Eugene Freuder pela máxima ?A Programação por Restrições representa uma das abordagens mais

próximas que a ciência da computação tem feito por ora ao Santo Graal da programação: o usuário

de?ne o problema, o computador resolve-o.4?. Entretanto, o binômio modelo-busca sobre sucessivos

paradigmas não descreve com precisão o funcionamento da PR por marginalizar a propagação

de restrições5, tida por referências como Barták (2001) como peça fundamental à viabilidade do

emprego dessa técnica. Como elemento do tripé, a propagação opera na redução ativa dos domínios

das variáveis de decisão por meio de inferências especializadas sobre as restrições em que tais

variáveis estão presentes. Em outras palavras: de?ne-se um nível desejado de consistência entre

as variáveis do modelo para que atribuições de valores não con?item, sendo a manutenção de tal

nível garantida por algoritmos de ?ltragem. Conforme observado por Bockmayr e Kasper (1998),

tal conceito guarda bastante similaridade com a geração de planos de corte para a resolução de

problemas de Programação Linear Inteira (PLI), uma vez que ambos os casos representam o emprego

de inferência para a geração de novas restrições sobre uma formulação. Em suma, a apresentação

da teoria geral sobre PR, que se segue, analisa separadamente modelagem, propagação, busca e

paradigmas de programação nas seções 2.1 a 2.4.

2.1 Modelagem

Formalmente, o objeto da Programação por Restrições é o Problema de Satisfação de Restri-

ções (PSR)6. O PSR consiste no problema de encontrar atribuições para um conjunto de n variáveis

de decisão levando em conta m restrições de relacionamento entre tais variáveis. Ele é caracterizado

na literatura pela tripla (X,D,R), sendo X o conjunto de variáveis de decisão xi para i = 1 . . .n,

D o conjunto de domínios Di para i = 1 . . .n, e R o conjunto de restrições rj para j = 1 . . .m.

Cada variável possui seu respectivo domínio discreto e ?nito de valores para atribuição, de forma

que (xi ? xi) ? (xi ? Di) para i = 1 . . .n. Cada restrição rj(x1,x2, . . . ,xn) é uma relação mate-
mática representando um subconjunto Sj do conjunto D1 ×D2 × . . .×Dn. Tais restrições podem
ser representadas tanto de modo enumerativo por meio da listagem de todas as tuplas que as satis-

fazem quanto de modo declarativo por meio de uma expressão que descreva a linguagem formada

pelas tuplas que satisfazem a restrição7. Uma restrição rj é dita satisfeita por (x1,x2, . . . ,xn) se,

e somente se, (x1,x2, . . . ,xn) ? Sj. A solução de um PSR consiste em uma atribuição a suas va-
riáveis, digamos (x1,x2, . . . ,xn), tal que (x1,x2, . . . ,xn) ? Sj, j = 1 . . .m, i.e., (x1,x2, . . . ,xn)
satisfaz todo o conjunto de restrições R. No caso de um problema de otimização, a de?nição do

PSR é estentida por Lustig e Puget (2001) e alguns outros autores como o Problema de Otimi-

zação da Satisfação de Restrições (POSR)8 para contemplar a existência de uma função objetivo

f : D1 ×D2 × . . .×Dn ?&amp;lt;que mapeie cada solução possível ou tentativa do PSR a um valor real,
a ser maximizado ou minimizado. Apesar do caráter meramente formal das de?nições apresentadas,

elas acabam por corresponder à estrutura com que os problemas são modelados em PR em razão

4 No original em inglês, citado por Barták (1999), ?Constraint Programming represents one of the closest appro-
aches computer science has yet made to the Holy Grail of programming: the user states the problem, the computer
solves it.".

5 Denominada constraint propagation em inglês.
6 Denominado Constraint Satisfaction Problem (CSP) em inglês.
7 Na literatura, restrições declarativas são descritas como expressões numéricas. Entretanto, uma expressão regular

também é conveniente ? e talvez mais apropriada em alguns casos ?, visto que representa qualquer combinação de
tuplas de um alfabeto. No caso da PR, o alfabeto seriam os domínios das variáveis de decisão.

8 Denominado Constraint Satisfaction Optimization Problem (CSOP) em inglês.



2.1 MODELAGEM 15

da generalidade com relação às restrições possíveis.

No entanto, convém ressaltar que a forma com que a otimização é considerada na PR não é de

todo consensual. Notadamente, o PSOR corresponde a uma concepção de otimização muito mais

arraigada à pesquisa operacional do que à inteligência arti?cial, campos esses com visões bastante

distintas sobre a técnica. Brailsford et al. (1999) compreende a otimização na PR como a forma pela

qual restrições fracas 9, cuja satisfação é desejável mas não necessária à viabilidade das soluções

do problema, procuram ser satisfeitas. Nessa linha, a otimização é interpretada como o processo de

busca de soluções que reduzam a violação das restrições fracas. Essa visão é partilhada por Dechter

(2003), sendo esse o ponto de maior crítica à sua obra na resenha feita por Barták (2008). Sem

embargo, dado o enfoque à abordagem de um problema de pesquisa operacional na próxima parte

da dissertação, optamos por enfatizar o PSOR como a forma com que consideramos a otimização

na PR.

2.1.1 Aplicabilidade em Função da Modelagem

A utilidade da técnica de PR decorre da abrangência de problemas que sua modelagem pode

contemplar e que, por conseguinte, sua busca pode ? em muitos casos ? solucionar. Uma vez que é

possível representar problemas pertinentes à classe NP-Completo por meio de PSRs, Dechter (2003)

observa que PSRs também são problemas NP-Completos. Por motivo similar, o PSOR pertence à

classe dos problemas NP-Difíceis, de forma que a expectativa sobre a PR nesse caso não é de que

soluções ótimas possam ser sempre encontradas em tempo polinomial para quaisquer instâncias.

Dessa feita, o esforço empreendido pela PR objetiva facilitar a resolução de nichos especí?cos em-

pregando o ferramental à sua disposição, i.e., modelos que facilitem a propagação e a busca. Ainda

que não seja uma percepção comum na literatura sobre PR, a prática da área corresponde à pedra

angular da Meta-Aprendizagem (MA)10 para o problema da seleção de algoritmos. Smith-Miles

(2008) apresenta o objeto de estudo da MA para a seleção de algoritmos como sendo a identi?cação

de parâmetros de problemas que justi?quem a diferença de desempenho de diversos algoritmos, de

forma a escolher o algoritmo mais apropriado a cada problema. Observações preliminares à elabo-

ração dessa dissertação foram tecidas a esse respeito em Serra e Wakabayashi (2010), ressaltando

que não é possível obter o melhor benefício possível da PR sem a compreensão do tipo de problemas

para os quais componentes especí?cos foram concebidos. Destarte, é importante avaliar se a forma

com que a propagação e a busca operam sobre o modelo repercutem em uma geração e?caz de

soluções. No caso de problemas de otimização, cabe ainda a avaliação da qualidade das soluções

obtidas com relação tanto ao que poderia ser obtido por outras técnicas cobrindo o mesmo nicho

quanto pelo ganho potencial representado por pequenas modi?cações sobre as soluções obtidas ?

o que evidenciaria falta de qualidade nas soluções geradas. Portanto, a adequação da sintaxe de

modelagem a um problema representa uma condição necessária mas não su?ciente para o sucesso

da abordagem de tal problema pela técnica.

No que diz respeito aos tipos de problema com modelagem facilitada em PR, consideramos

aqueles contendo apenas decisões discretas e para os quais, geralmente, a formulação utilizando

Programação Inteira (PI) não é uma opção devido à explosão no número de variáveis e/ou restri-

ções e à di?culdade para satisfazer as restrições de integralidade. Tal é o caso, por exemplo, de

9Denominadas soft constraints em inglês.
10Denominada Meta-Learning (ML) em inglês.



16 PROGRAMAÇÃO POR RESTRIÇÕES 2.1

muitos problemas de escalonamento: muitos deles são formulados com variáveis 0/1 em que cada

variável, digamos yijt, expressa um predicado como ?atividade i está sendo realizada com con?gu-

ração j no instante de tempo t?. No caso da PI, esse tipo de variável permite que o problema seja

modelado empregando apenas relações lineares no conjunto de restrições, de forma a se bene?ciar

dos algoritmos mais e?cientes de PI que poderiam possivelmente resolver o problema. Entretanto,

tal decomposição em variáveis binárias ? pelo produto cartesiano das dimensões do problema ?

cresce em tamanho muito rapidamente, especialmente se a dimensão temporal é aumentada. Por-

tanto, apesar do fato de cada variável de decisão em PR requerer muito mais memória de acordo

com o manual da IBM (2010), ela possui um valor semântico muito maior e pode representar tanta

informação quanto diversas variáveis binárias combinadas. Esse mesmo argumento pode ser aplicado

com relação ao conjunto de restrições. Dessa forma, o papel da PR acaba por ser complementar ao

de outras técnicas e, no que diz respeito à modelagem, sua aplicação é favorecida em domínios de

problemas nos quais representações mais compactas são possíveis ? não se olvidando a questão de

desempenho do modelo mencionada anteriormente.

Exemplo de Aplicação: Rotulação Graciosa de Grafos

Pelo per?l de problemas que a PR se propõe a resolver, a opção mais direta para exempli?car sua

aplicação seria por meio de modelos de problemas combinatórios clássicos para os quais foi observado

um desempenho razoável. Entretanto, isso não agregaria tanto quanto apontar um caso em que foi

percebida uma vantagem considerável em um nicho com menos abordagens bem-sucedidas. E esse

é o caso do problema da rotulação graciosa11 de grafos.

Diz-se que um grafo G = (V,E) com n = |V | vértices e m = |E| arestas possui uma rotulação
graciosa se é possível atribuir a cada um de seus vértices um rótulo único f : V ?{0, 1, 2 . . .m}, e
a cada uma de suas arestas um rótulo único g : E ?{1, 2 . . .m}, de modo que g(ij) = |f(i)?f(j)|
para cada aresta ij ? E, onde i,j ? V . O problema consiste em encontrar para um dado grafo uma
tal rotulação graciosa, se existente.

De acordo com Lustig e Puget (2001), mesmo para pequenas instâncias desse problema, não

se sabia se estas possuíam ou não uma rotulação graciosa até que a PR fosse aplicada. Como

forma de explicar o que signi?ca uma modelagem de PR na prática, a seguir é apresentado um

modelo adaptado de Lustig e Puget (2001) para esse problema na linguagem OPL. A adaptação foi

necessária devido às mudanças a que a linguagem foi submetida ao longo da última década. Para

facilitar a compreensão, as variáveis e domínios do modelo tiveram sua nomenclatura traduzida.

Ainda que não seja o escopo dessa parte do trabalho a descrição de uma linguagem de modelagem

para PR, o exemplo apresentado tem um papel importante por materializar a modelagem em PR e

por permitir uma explicação no nível necessário aos objetivos presentes. Para maiores informações

sobre a linguagem OPL, o leitor pode se referir ao Apêndice A.

11 Tradução livre da expressão graceful labeling em inglês.



2.1 MODELAGEM 17

1 int noVertices = . . . ;

2 range dVertices = 1 . . noVertices ;

3 tuple Aresta {

4 Vertices i ;

5 Vertices j ;

6 };

7 {Aresta} arestas = . . . ;

8 int noArestas = card ( arestas ) ;

9 range dRotulos = 0 . . noArestas ;

10 dvar int rotuloVertice [ dVertices ] in dRotulos ;

11 dvar int rotuloAresta [ arestas ] in dRotulos ;

12 subject to {

13 a l l D i f f e r e n t ( rotuloVertice ) ;

14 a l l D i f f e r e n t ( rotuloAresta ) ;

15 f o r a l l (a in arestas ) {

16 rotuloAresta [ a ] = abs ( rotuloVertice [ a . i ] ? rotuloVertice [ a . j ] ) ;
17 rotuloAresta [ a ] &gt; 0;

18 }

19 };

As primeiras nove linhas do modelo descrevem estruturas e entradas de dados. A declaração

explícita de domínio das rotulações na linha 9 serve como subsídio à declaração das variáveis de

decisão. As variáveis de decisão referem-se aos valores de rotulação dos vértices e arestas, conforme

declarado nas linhas 10 e 11. Como pode ser observado pela ausência de um critério de otimização

no código, trata-se de um problema estritamente de satisfabilidade. A restrição alldi?erent, repre-

sentada nas linhas 13 e 14 pelo nome allDifferent em OPL, de?ne que os valores atribuídos a

cada entrada do vetor de variáveis de decisão dado como argumento sejam únicos, de forma que

vértices distintos ou arestas distintas são tenham a mesma rotulação. Essa restrição está presente

em muitos modelos de problemas combinatórios e é descrita em maior detalhe na seção 2.2.2. Na

linha 15, é declarado um bloco de restrições indexado sobre cada aresta do grafo, garantindo na

linha 16 a diferença absoluta de rotulação dos vértices conforme exigido pelo problema. Na linha 17,

de?ne-se que a rotulação nula não seja dada a nenhuma aresta. Uma última observação importante

do modelo refere-se ao domínio das variáveis de decisão: em uma formulação de PI, por exemplo, não

seria possível expressar uma restrição como alldi?erent empregando o mesmo conjunto de variáveis

de decisão adotado.

Outros Exemplos de Aplicação: Problema das n Rainhas e Sudoku

Outros dois exemplos de problemas mais conhecidos e que ilustram a expressividade da técnica

são o problema das n rainhas e o sudoku. O primeiro deles, que consiste em posicionar n rainhas

em um tabuleiro de xadrez sem nenhum par possa se atacar, é apresentado na seção A.4.9 do

apêndice. O segundo, que consiste em preencher um quadro de 9x9 com os números 1 a 9 de tal

forma que os números não se repitam em nenhuma linha, coluna ou quadrante 3x3, possui uma

formulação bastante concisa por meio de restrições alldi?erent. Dessa forma, o modelo apresentado

a seguir pode ser utilizado para resolver problemas de sudoku, sendo que a inclusão de valores ?xos

a algumas posições é facilmente tratada pela inclusão de restrições adicionais ou pela declaração de

um domínio mais restrito na primeira linha do modelo:



18 PROGRAMAÇÃO POR RESTRIÇÕES 2.1

1 dvar int rotuloPosicao [ 1 . . 9 ] [ 1 . . 9 ] in 1 . . 9 ;

2 subject to {

3 f o r a l l ( i in 1 . . 9 ) {

4 a l l D i f f e r e n t ( rotuloPosicao [ i ] ) ;

5 a l l D i f f e r e n t ( a l l ( j in 1 . . 9 ) rotuloPosicao [ j ] [ i ] ) ;

6 }

7 f o r a l l ( i in 0 . . 2 , j in 0 . . 2 ) {

8 a l l D i f f e r e n t (

9 a l l ( i i in i ?3 + 1 . . i ?3+3, j j in j ?3 + 1 . . j ?3 +3)
10 rotuloPosicao [ i i ] [ j j ] ) ;

11 }

12 };

A restrição alldi?erent da linha 4 do modelo acima garante que o mesmo valor não seja usado

mais de uma vez na mesma linha do quadro. A linha 5 garante o mesmo para cada coluna do quadro.

Nas linha 8 a 10, isso é garantido para cada um dos 9 quadros 3x3 resultantes do particionamento

do quadro 9x9 em três partes horizontes e três partes verticais.

2.1.2 Boas Práticas em Modelagem

A despeito dessa natureza declarativa e da generalidade com relação às restrições possíveis, já foi

observado anteriormente que não se pode ignorar o impacto da modelagem sobre o desempenho do

sistema. Dito de outra forma, é importante notar que a diferentes modelos com a mesma ?nalidade

corresponderão desempenhos diversos.

Um caso bem comum desse fator diz respeito à existência de simetrias no modelo, tendo como

consequência um espaço de busca maior do que o necessário. Consideremos, por exemplo, a situa-

ção mencionada por Hentenryck et al. (2000) em que diferentes con?gurações de um tabuleiro de

xadrez diferem apenas por rotação: tais soluções seriam equivalentes para a resolução do problema

sendo abordado? Em caso positivo, pode-se partir para a identi?cação de simetrias a serem que-

bradas por meio do estabelecimento de restrições adicionais que reduzam o espaço de busca. Tal

redução deve ser feita sem prejuízo à corretude, por meio da preservação de ao menos uma solução

equivalente a cada solução do modelo original. Cabe a ressalva de que a quebra de simetria pode

trazer mais sobrecarga do que benefício. Isso pode ocorrer se o foco não for uma busca exaustiva e a

quebra representada pela novas restrições incidir sobre alguma parte do espaço de soluções que, de

outra forma, seria explorado antes e com maior proveito. Dessa forma, compete que a identi?cação

de simetrias seja observada na modelagem, mas a implementação de uma quebra deve atentar à

possibilidade de ganho em desempenho para a resolução do sistema.

Além da questão sobre as simetrias, certos problemas podem admitir diversos modelos que

representem o mesmo espaço de busca. A esse respeito, o manual da IBM (2010) enfatiza que o

estabelecimento de boas práticas para a modelagem usando PR ainda é uma área bastante cinzenta,

para a qual não existe uma consolidação similar à descrita para a PM em Williams (2005). De certa

forma, essa discussão não pode ser feita apenas no nível da modelagem, uma vez que a quali?cação do

desempenho do modelo depende de conceitos relativos à propagação e à busca. Como exemplo dessa

correlação, Brailsford et al. (1999) destaca a importância do emprego de restrições redundantes no

modelo para que a precisão do modelo não se deva às mesmas restrições que mantém o nível de

propagação, podendo estas serem mais simples do que aquelas. Assim sendo, cabe que esse assunto



2.2 PROPAGAÇÃO DE RESTRIÇÕES 19

seja sempre discutido em caráter transversal aos elementos de modelo, busca e propagação da PR.

2.2 Propagação de Restrições

A propagação de restrições consiste na geração de inferências sobre as restrições empregadas no

modelo como forma de reduzir o esforço necessário à realização da busca. Tais inferências consistem

na inspeção de quais valores das variáveis são incompatíveis entre si em função das restrições,

levando à remoção dos valores dos domínios das variáveis antes ou durante a busca. Essas reduções

são fundamentadas no princípio de que nenhuma solução ao problema possuirá os valores eliminados

atribuídos às suas respectivas variáveis. Se uma remoção é realizada antes da busca, isso signi?ca

que nunca será desfeita porque não é circunstancial. No caso de ser feita durante a busca, ela pode

ser re?exo de decisões tomadas ao longo da resolução. Nesse caso, ela pode ou não ser desfeita até o

término da busca, de acordo com a necessidade de reverter tais decisões para que não haja prejuízo

à completude do processo. O nível em que essa inspeção de compatibilidade entre as variáveis é

realizada impacta tanto na redução que pode ser obtida para os domínios quanto nos recursos

computacionais necessários para que tal redução seja atingida. Portanto, compete avaliar onde

reside a melhor relação de custo-benefício entre o esforço necessário e a redução de domínios obtida

para cada caso. De modo geral, a propagação permite que as soluções ao problema se tornem mais

evidentes e que as inconsistências remanescentes não prejudiquem tanto o desempenho da busca

para encontrá-las.

A propagação é realizada por técnicas de consistência dos mais variados tipos e níveis. Com

relação ao tipo, existem técnicas dedicadas a uma restrição especí?ca ou a uma classe delas, como a

classe de restrições que determinam a relação entre um determinado número de variáveis. Para cada

classe de restrições, são estabelecidos níveis de consistência em termos de certi?cados sobre quais

con?gurações inválidas são evitadas por meio das inferências de redução dos domínios, como quantos

valores podem ser atribuídos sem que ocorra um con?ito. Tais inferências podem ser produzidas

por diversos algoritmos possíveis, ditos algoritmos de ?ltragem. Em razão da existência de mais

de um nível para a propagação, torna-se evidente o fato que as reduções obtidas variam e, por

conseguinte, a eliminação de atribuições inconsistentes não é sempre completa. Na prática, Barták

(2001) observa que a consistência completa do modelo ? situação na qual a busca sobre o modelo

é feita sem que nenhuma decisão da busca tenha que ser revertida ou que o modelo é tido como

insatisfatível por algum domínio ter se tornado vazio ? não costuma ser uma opção viável devido

ao esforço necessário para atingi-la. A?nal, reduzir os domínios a tal ponto que a busca seja feita

em tempo linear no número de variáveis ? ou seja, em tempo ?xo por atribuição ? corresponderia

a delegar à propagação a resolução do problema NP-Completo em que consiste o PSR no caso

geral. Além disso, os níveis mais elementares costumam garantir a remoção da maior parte dos

valores inconsistentes, de forma que compensa mais explorar a combinação de outras técnicas com

algoritmos de consistência que não consumam muito tempo. Técnicas mais generalistas costumam

ser aplicadas a tipos mais simples e em níveis menores, ao passo que outras mais especializadas

são mais e?cazes na tarefa de redução de domínios restritas a alguns tipos de restrições. No que

se segue, as técnicas mais comuns de consistência são apresentadas das mais generalistas e simples

para as mais especializadas e elaboradas. Para maiores referências sobre a síntese feita da literatura

a respeito de propagação, veja Barták (2001, 1999); Dechter (2003).



20 PROGRAMAÇÃO POR RESTRIÇÕES 2.2

2.2.1 Técnicas de Consistência Binária

O tipo mais simples e comum de técnica de consistência estudado envolve pares de variáveis,

sendo conhecido como consistência binária. Ela é aplicada a restrições com uma ou duas variáveis,

respectivamente denominadas de restrições unárias e binárias. Nesse tipo de consistência, o modelo

pode ser analisado por meio de um grafo G = (V,E), sendo cada variável de decisão xi representada

por um vértice vi ? V , cada restrição binária rj(xi1,xi2 ) por uma aresta vi1vi2 ? E incidente aos
vértices vi1,vi2 ? V e cada restrição unária rj(xi) por um laço vivi ? E duplamente incidente
ao vértice vi ? V . Um vértice é dito consistente se nenhum valor do domínio de sua variável
correspondente está em desacordo com qualquer restrição unária. Por analogia, uma aresta é dita

consistente se para cada valor do domínio de uma de suas variáveis associadas existir um valor

correspondente no domínio da outra, de forma que a restrição possa ser satisfeita se tal valor for

atribuído à variável. Se todas as arestas estiverem consistentes, então o modelo é dito consistente

nesse nível. Cabe ressaltar que, historicamente, o nome dado a esse nível de consistência é o de

consistência de arco e ao anterior o de consistência de nó, sendo muito comum encontrar na literatura

uma nomenclatura sobre consistência binária trocando vértices por nós e arestas por arcos12. Por

?m, conforme veremos a seguir, níveis mais elevados ou incompletos e intermediários podem ser

estabelecidos para a consistência binária.

Antes de proceder ao detalhamento dos níveis e algoritmos de consistência binária, vejamos no

modelo apresentado a seguir como os conceitos descritos se aplicam a um caso simples.

1 using CP;

2 dvar int x in 1 . . 1 0 ;

3 dvar int y in 1 . . 1 0 ;

4 subject to {

5 x &gt; 5;

6 x &amp;lt;y ;

7 };

No modelo ilustrado, temos duas variáveis x e y no domínio dos inteiros entre 1 e 10, conforme

descrito nas linhas 2 e 3. Na linha 5, a primeira restrição força o valor de x a ser maior que 5. Dessa

forma, a propagação já poderia inferir que o domínio de x está reduzido, na prática, ao intervalo

entre 6 e 10. Na linha 6, a relação entre x e y permite reduzir ainda mais o domínio de x, visto que

ele não pode assumir o valor 10, ao passo que o domínio de y nas soluções se con?na ao intervalo

entre 7 e 10. Assim sendo, os domínios das variáveis x e y podem ser reduzidos de 10 possíveis

valores para 4 cada.

A consistência ao nível dos vértices é atingida com a primeira inferência sugerida sobre a restrição

da linha 5. No caso geral, ela pode ser atingida com uma única inspeção a cada restrição unária

do modelo. Por sua vez, a consistência ao nível das arestas é atingida gradativamente por uma

sucessão de aplicações que garantem a consistência individual de arestas. Conforme observado no

exemplo, uma aresta pode ser inspecionada mais de uma vez para que o nível de consistência global

seja atingido em razão dos efeitos colaterais das inspeções de arestas anteriores. Convém enfatizar

que esse processo é sempre ?nito, uma vez que novas inspeções a uma mesma aresta só ocorrem em

12 Apesar de ser uma prática aceita, essa nomenclatura não é reforçada nesse trabalho por não ser aquela empregada
em teoria dos grafos, sob o risco de prejudicar a explicação dos conceitos ao público de interesse, que não corresponde
àquele que já usa a técnica.



2.2 PROPAGAÇÃO DE RESTRIÇÕES 21

função de reduções prévias, sendo o número total de reduções limitado à soma dos tamanhos dos

domínios das variáveis do modelo.

Níveis de Consistência Binária

Conforme mencionado anteriormente, é possível arbitrar diversas séries de níveis de consistência.

Na consistência binária, o caso padrão é dado sequencialmente pelo número de variáveis para as

quais é possível realizar uma atribuição sem que um con?ito ocorra. Abaixo segue uma listagem

desde os casos mais simples, passando pelas generalizações até atingir a consistência completa do

modelo:

? Consistência em nível de vértice ou 1-consistência13 Diz-se que o vértice vi do grafo

do modelo associado à variável de decisão xi é consistente se qualquer valor xi do domínio Di
puder ser atribuído a xi sem que ocorra um con?ito com as restrições unárias do modelo, i.e.,

restrições envolvendo apenas xi. Sendo todos os vértices do grafo do modelo consistentes, o

modelo é dito consistente em nível de vértice.

? Consistência em nível de aresta ou 2-consistência14 Uma aresta vi1vi2 do grafo do

modelo, associada a uma restrição rj envolvendo as variáveis de decisão xi1 e xi2 do modelo, é

dita consistente se, para qualquer valor xi1 ? Di1, existir um valor xi2 ? Di2 tal que rj(xi1,xi2 )
seja satisfeita e vice-e-versa, i.e., invertendo as posições de xi1 e xi2 na condição. Quando todas

as arestas são consistentes, o modelo é dito consistente em nível de aresta.

? Consistência em nível de caminho ou 3-consistência15 Um caminho vi1vi2 . . .vik é

consistente se, para qualquer atribuição xi1 ? xi1 : xi1 ? Di1 e xik ? xik : xik ? Dik,
existirem valores xi2 ? Di2, . . ., xik?1 ? Dik?1 de forma que as arestas associadas às restrições
de cada par consecutivo de vértices do caminho esteja satisfeita. Conforme Barták (1999) e

Dechter (2003) ressaltam, se a consistência dos caminhos de tamanho 2 (duas arestas e k = 3)

for satisfeita para o grafo do modelo, então todos os caminhos são consistentes e o modelo é

consistente em nível de caminho.

? Consistência em k-ésimo nível ou k-consistência16 Dado um conjunto de valores para

atribuição a quaisquer k ? 1 variáveis de um modelo dentro de seus respectivos domínios ?
xi1 ? xi1 : xi1 ? Di1, xi2 ? xi2 : xi2 ? Di2, . . ., xik?1 ? xik?1 : xik?1 ? Dik?1 ? o modelo é
dito k-consistente se sempre houver um valor para atribuição no domínio de qualquer outra

k-ésima variável ? xik ? xik : xik ? Dik ? tal que nenhuma restrição do modelo seja violada
por tais atribuições. A k-consistência representa uma generalização dos níveis apresentados

acima.

? Consistência forte em k-ésimo nível ou k-consistência forte17 Um modelo é fortemente

k-consistente se ele for k?-consistente para qualquer k? ? k. Conforme enfatizado por Dechter
(2003), o fato de um modelo ser k?-consistente não implica que ele seja (k? ? 1)-consistente.

13Denominada node consistency ou 1-consistency em inglês.
14Denominada arc consistency ou 2-consistency em inglês.
15Denominada path consistency ou 3-consistency em inglês.
16Denominada k-consistency em inglês.
17 Denominada strong k-consistency em inglês.



22 PROGRAMAÇÃO POR RESTRIÇÕES 2.2

? Consistência completa do modelo ou n-consistência18 Um modelo é completamente

consistente se qualquer atribuição de valores dos domínios às variáveis de decisão ? xi1 ? xi1 :
xi1 ? Di1, xi2 ? xi2 : xi2 ? Di2, . . ., xin ? xin : xin ? Din ? satis?zer às restrições do modelo,
de forma que ? conforme observado anteriormente ? passa a ser possível obter uma solução

ao problema em tempo O(n). De acordo com Focacci et al. (2000), esse nível corresponde

naturalmente à n-ésima consistência, mas pode ser atingido se a k + 1-ésima consistência for

veri?cada em um grafo de modelo cujo vértice de maior grau19 tenha valor k. Sem embargo,

convém ressaltar que uma consistência completa não depende apenas da redução do domínio

das variáveis de decisão, mas também da redução dos domínios das restrições. Tais domínios

são representados como subconjuntos das tuplas das variáveis de decisão associadas a cada

restrição. Em última análise, a redução dos mesmos signi?ca mudar a própria semântica

da restrição nos modelos com consistência mais elevada. Isso se opera para n ? 3 no caso
binário, pois já na inspeção de caminhos entre pares de vértices é possível, por exemplo, que

as respectivas variáveis não tivessem nenhuma restrição mútua e suas combinações de valores

concorrentes tivessem que ser limitadas para garantir a consistência em nível de caminho.

Outras séries foram estudadas ? ainda que em menor grau ? a partir da extensão da série

acima, representando cada caso uma alternativa de generalização, diversidade ou compromisso com

relação ao paradigma estabelecido. Pela inclusão de parâmetros adicionais à de?nição dos níveis

de consistência, pode-se generalizar os níveis pré-estabelecidos. Alternativamente, a ponderação de

parâmetros diversos possibilita uma perspectiva mais ampla sobre os certi?cados de consistência

possíveis. Por ?m, o estabelecimento de níveis intermediários sobre a parametrização de maior

aceitação representa um maior nível de detalhamento acerca dos efeitos da propagação. Dentre

essas possibilidades, esta despertou maior atenção na literatura em razão de sua proximidade e

potencial de catalisação de resultados com relação à abordagem tradicional.

O estabelecimento de níveis intermediários parte de uma lógica muito similar àquela aplicada

na de?nição dos níveis originais. Uma vez que a veri?cação das restrições para garantir um nível

de consistência pode ter efeitos colaterais no que diz respeito à necessidade de uma nova iteração

para ?ltragem, passou-se a apurar o impacto dessas novas iterações para a redução dos domínios

e o esforço computacional que exigiam. A observação empírica de muitos autores a esse respeito é

de que a quantidade de valores inconsistentes que são removidos dos domínios é muito maior nas

primeiras veri?cações de propagação das restrições do modelo do que nas iterações subsequentes.

Dessa forma, o esforço na remoção de valores nas primeiras veri?cações tem maior compensação do

que aquele observado nas remoções seguintes. Em outros casos, foi observado que a forma com que o

modelo em estado consistente é utilizado na busca pode fazer com que certo esforço adicional tenha

sido em vão. Por conseguinte, a revisão exaustiva para a manutenção do nível de consistência em

um determinado nível passa a ser tão questionável quanto a manutenção de níveis de consistência

mais elevados.

A seguir estão listadas algumas das de?nições alternativas de níveis de propagação:

? Consistência direcional em nível de aresta20 A consistência direcional em nível de aresta

é de?nida exclusivamente sobre uma orientação do grafo do modelo, i.e., cada aresta tem sua

18Denominada full consistency ou n-consistency em inglês.
19 O grau de um vértice é dado pelo número de arestas incidentes ao mesmo no grafo.
20 Denominada directed arc consistency em inglês.



2.2 PROPAGAÇÃO DE RESTRIÇÕES 23

consistência veri?cada em apenas um sentido. Esse sentido é de?nido de acordo com uma

ordenação prévia dos vértices do grafo do modelo: uma aresta vi1vi2 é veri?cada de vi1 para

vi2 se a variável xi1 preceder xi2 na ordenação de?nida. Se as arestas forem percorridas de

acordo com a ordenação topológica dos vértices correspondente à ordenação das variáveis

de decisão, i.e., vi1vi2 sendo veri?cada antes de vi3vi4 se xi2 preceder xi4 na ordem, então

nenhuma aresta precisa ser inspecionada pela segunda vez. Esse nível de consistência é mais

fraco que a consistência ao nível da aresta, mas pode ser equivalente em alguns modelos, como

aqueles representados por árvores. Além disso, de acordo com Dechter (2003), o benefício da

propagação nesse nível é sempre equivalente ao da consistência ao nível da aresta em uma

busca que atribua valores às variáveis de acordo com a mesma ordenação das variáveis de

decisão usada para a manutenção de consistência.

? Consistência restrita em nível de caminho21 A consistência restrita em nível de caminho

encerra a consistência em nível de aresta acrescida de um caso especí?co da consistência em

nível de caminho. Esse caso é representado pela veri?cação da consistência de caminho a partir

de duas atribuições xi1 ? xi1 : xi1 ? Di1 e xik ? xik : xik ? Dik que devam obrigatoriamente
ocorrer em conjunto, i.e., (xi1 ? xi1 ) ? (xik ? xik ). O acréscimo da veri?cação desse caso à
consistência de aresta se justi?ca pelo seu potencial na redução dos domínios envolvidos sem

que todos os casos possíveis tenham que ser tratados.

? Consistência por limites22 A consistência por limites representa uma simpli?cação de

outros níveis de consistência pela veri?cação restrita aos valores mínimo e máximo de cada

domínio. O conceito de mínino e máximo não convém a domínios simbólicos ? i.e., em que

não existe uma ordem de?nida entre os elementos do conjunto ?, mas facilita a análise em

domínios numéricos, como uma faixa sequencial de números inteiros. Em alguns casos, a

veri?cação dos extremos do domínio basta para atingir um determinado nível de consistência.

Quando isso não é possível, sua aplicação pode decorrer da constatação de que a diferença de

redução resultante é pontual e é compensada pelo menor tempo de processamento resultante

da escolha.

? Consistência por conjunto unitário23 A consistência por conjunto unitário representa

uma restrição adicional que pode ser aplicada a outros níveis de consistência. Ela de?ne que

um determinado nível de consistência seja atingido para qualquer atribuição xi ? xi : xi ? Di
possível do modelo, i.e., o modelo possui tal nível de consistência para qualquer atribuição

adicional que seja feita.

? Consistência (i,j)24 A consistência (i,j) representa uma generalização da k-consistência:

enquanto nesta garante-se que a atribuição de valores a k?1 variáveis de decisão não impeça
a atribuição de valor a uma outra variável de decisão, naquela a garantia é de que a atribuição

de valores a i variáveis de decisão não impeça a atribuição de valores a outras j variáveis de

decisão. Dessa forma, a k-consistência é equivalente à consistência (k ? 1, 1).
21 Denominada path-restricted consistency em inglês.
22 Denominada bounds consistency em inglês.
23 Denominada singleton consistency em inglês.
24Denominada (i, j)-consistency em inglês.



24 PROGRAMAÇÃO POR RESTRIÇÕES 2.2

? Consistência inversa25 A consistência inversa representa uma especialização da consistência

(i,j) no sentido oposto ao da k-consistência: um modelo é inversamente k-consistente se tiver

consistência (1,k?1), i.e., a cada atribuição xi1 ? xi1 : xi1 ? Di1 deve corresponder ao menos
uma atribuição xi2 ? xi2 : xi2 ? Di2, . . ., xin ? xin : xin ? Din que não viole as restrições
do modelo, para quaisquer k variáveis de decisão.

Algoritmos de Filtragem para Consistência Binária

A garantia de um nível de consistência pode ser feita por diversos algoritmos, sendo possível

conceber muitos deles diretamente da de?nição. A presente seção ilustra os algoritmos dos níveis

gerais para os quais maior atenção foi dada. De forma a não tomar tanto espaço em um texto

introdutório, apenas a lógica por trás de tais algoritmos é descrita. Longe de se prestar como

uma apresentação exaustiva, a sucessão de tais algoritmos de ?ltragem ilustra como os métodos de

manutenção de consistência podem ser aperfeiçoados a partir de sua concepção original.

Para garantir a consistência em nível de vértice, um algoritmo que realize o mínimo esforço

necessário pode ser trivialmente concebido: uma inspeção sobre cada restrição unária basta para

atingir o nível. Assim sendo, o desenvolvimento descrito a seguir cobre os algoritmos de ?ltragem

para a consistência em nível de aresta e de caminho. Os algoritmos para níveis intermediários de

consistência representam modi?cações sobre aqueles para consistência precisa. Em última análise, o

problema de garantir a consistência completa de um modelo que descreve um problema combinatório

NP-Completo ? como o PSR no caso geral ? também será NP-Completo.

Algoritmos para consistência em nível de aresta Existe um padrão na literatura baseado na

nomenclatura dos algoritmos para consistência ao nível da aresta pelo pre?xo AC26 seguido de um

índice sequencial. Nessa linha, o algoritmo AC-1 representa o método mais intuitivo, consistindo na

repetição da revisão dos domínios das variáveis associadas aos vértices até que nenhuma alteração

ocorra. No algoritmo AC-2, apenas as revisões de domínio necessárias são repetidas: o domínio da

variável de um vértice só é revisado se ele for adjacente a qualquer vértice cuja variável tenha tido

o domínio reduzido desde sua última revisão. No AC-3, o processo de revisão é aperfeiçoado pela

operação por iteração em uma ?la de arestas: inserções ocorrem quando o domínio da variável de um

vértice incidente é alterado e remoções ocorrem quando essas arestas são revisadas. O ganho obtido

pelo uso da ?la se deve à prevenção de que arestas sejam revisadas mais de uma vez. O algoritmo

AC-4 itera sobre estruturas um pouco mais elaboradas, que evitam a revisão de domínios pela

iteração sobre as arestas: para cada aresta vi1vi2 do grafo do modelo, cada valor xi1 ? Di1 da variável
xi1 associada ao vértice vi1 possui um conjunto de valores de suporte V Sxi1i2 ? Di2, correspondendo
àqueles que não são incompatíveis com a atribuição xi1 ? xi1. Essa idéia foi simpli?cada no AC-6,
que armazena apenas um valor de suporte vsxi1i2 ? V Sxi1i2 para cada valor do domínio de Di1 e
procura um novo valor de suporte se o anterior passar a ser inválido, evitando a utilização proibitiva

de memória e tempo de seu antecessor. O AC-7 representa uma redução de esforço pela simples

constatação de que o suporte de valores é simétrico: se o valor xi1 ? Di1 suporta xi2 ? Di2, xi2 ? Di2
suporta xi1 ? Di1, i.e., (vsxi1i2 ? xi2 ) ? (vsxi2i1 ? xi1 ). Com relação à análise de complexidade
assintótica do tempo de execução no pior caso, sendo m o número de restrições, n o número de

25Denominada inverse consistency em inglês.
26Acrônimo em inglês para Arc Consistency.



2.2 PROPAGAÇÃO DE RESTRIÇÕES 25

vértices e k o tamanho do maior domínio considerado, AC-1 e AC-2 são O(mnk3), AC-3 é O(mk3)

e o limite inferior provado ao caso geral de O(mk2) é constatado para o AC-4 em diante.

Com relação ao algoritmo AC-5 descrito em Hentenryck et al. (1992), convém uma análise

mais apurada devido à forma com que esse algoritmo representa o conceito da especialização dos

mecanismos de resolução em função das restrições. O AC-5 não é completamente de?nido, sendo

possível parametrizá-lo por meio de implementações diferenciadas para dois métodos: um para

a veri?cação inicial de quais valores do domínio Di1 não são suportados por nenhum valor do

domínio Di2; outro para a veri?cação iterativa em ?la de quais valores do domínio Di1 não são

mais suportados se o valor xi2 for removido do domínio Di2. Uma implementação possível desses

métodos coincide com o AC-3, ao passo que outra coincide com o AC-4. No entanto, a vantagem desse

algoritmo se deve ao fato que ele possibilita que a consistência de classes especí?cas de restrições

sejam garantidas a uma complexidade de tempo inferior àquela do caso geral: restrições binárias

funcionais ? como xi1 + xi2 = k, sendo k uma constante ?, anti-funcionais ? como xi1 + xi2 6= k ?
e monotônicas ? como xi1 + xi2 &amp;lt;k ? em todo o domínio ou por partes podem ser propagadas em

tempo O(mk).

Algoritmos para consistência em nível de caminho Os algoritmos para consistência de

caminho foram desenvolvidos em paralelo aos de consistência de aresta, sendo costumeiramente

pre?xados como PC27. Dessa forma, podemos resumi-los revisando as idéias apresentadas anterior-

mente. O algoritmo PC-1 consiste na revisão de todos os caminhos até que não ocorra nenhuma

redução de domínio. No PC-2, a veri?cação é repetida apenas para os caminhos que possam ter

sido afetados por alguma revisão prévia. O algoritmo PC-3 representou a primeira proposta de

extensão das idéias do algoritmo AC-4 para a consistência em nível de caminho. Entretanto, ele foi

substituído pelo PC-4 por remover valores que poderiam pertencer a uma atribuição válida, caso

evitado pelas correções que diferem este algoritmo daquele. Por ?m, o algoritmo PC-5 represen-

tou para o PC-4 a mesma simpli?cação de implementação que o AC-6 representou para o AC-4,

reduzindo a quantidade de memória utilizada em estruturas de dados auxiliares.

Algoritmos para níveis intermediários de consistência Por ser efetuada em uma única pas-

sagem, não existem nuances de aperfeiçoamento para a execução do nível de consistência direcional

em nível de aresta, à semelhança do que observou-se para a consistência em nível de vértice. Por sua

vez, a consistência restrita ao nível do caminho foi concebida como uma especialização do algoritmo

AC-4, havendo veri?cação de consistência de caminhos entre as atribuições xi1 ? xi1 e xi2 ? xi2
apenas quando |V Sxi1i2| = 1, i.e., o conjunto de suporte de uma atribuição se restringir a uma
única atribuição à outra variável.

Considerações sobre os demais níveis de consistência De acordo com Barták (1999), apesar

de existirem algoritmos para k-consistência forte com k &gt; 2, seu custo computacional raramente

compensa pelo fato de que ainda não são capazes de isentar a busca de falhas potenciais. Com

relação aos níveis alternativos de consistência, Barták (2001) observa que a manutenção de i-uplas

para a manutenção da consistência (i,j) torna-se proibitiva para i ? 2. No caso da consistência
inversa, só há interesse para k = 3, uma vez que ela coincide com a consistência convencional em

27Acrônimo em inglês para Path Consistency.



26 PROGRAMAÇÃO POR RESTRIÇÕES 2.2

níveis menores e torna-se proibitiva para níveis maiores. Por ?m, a implementação de algoritmos

de ?ltragem para consistência por conjunto unitário geralmente consiste no acréscimo de um laço

superior que ?xa cada atribuição possível.

Binarização de Restrições

A hipótese de representar um PSR por meio de predicados com aridade máxima 2 ? i.e., via

restrições envolvendo até duas variáveis de decisão cada ? para que a propagação binária possa ser

empregada é bastante restritiva. Ainda que possível, ela pode levar a modelos demasiado extensos,

de forma que muitas simpli?cações não são possíveis senão por representação imprecisas. Dessa

limitação surge o impasse entre empregar uma representação simpli?cada, que possa se bene?ciar

da propagação binária; ou recorrer a uma gama mais ampla de representações, com potencial a uma

propagação mais e?caz no espaço de busca ao risco de um custo computacional de execução mais

elevado. Entretanto, a opção a ser feita não é exclusiva, pois o uso ativo de restrições redundantes

na modelagem ? mencionado na seção 2.1.2 ? condiz com o emprego de ambas as possibilidades:

restrições precisas que são complementadas por aproximações que possibilitem a propagação em

um nível mais elementar. Nessa seção, é explorada a possibilidade de simpli?car automaticamente a

representação por meio de decomposições binárias. Adiante, será discutida a hipótese de trabalhar

com representações mais elaboradas.

A decomposição em um modelo binário pode se dar por diversas formas. Ainda que algumas

delas levem a modelos imprecisos, é importante observar que, à semelhança do caso das restrições re-

dundantes, o objetivo de tais modelos não é substituir o modelo original na veri?cação da satisfação

das restrições, mas tão somente na operação da propagação. A seguir, constam três decomposições

identi?cadas por Barták (2001):

? Projeção A projeção consiste na aproximação de uma restrição por um conjunto de relações

binárias. Para cada par de variáveis envolvido na restrição original, delimita-se o domínio

possível para uma variável em função da outra no contexto da restrição. Formalmente, para

cada par de variáveis xi1 e xi2 de uma restrição rj(. . . ,xi1, . . . ,xi2, . . .), de?ne-se uma restrição

r?ji1i2 (xi1,xi2 ) satisfeita apenas por duplas (xi1,xi2 ) que possam concorrer em uma solução

? i.e., Sji1i2 = {(xi1,xi2 ) ? Di1 × Di2 : ? (x1, . . . ,xi1, . . . ,xi2, . . . ,xn) ? Sj, x1 ? D1, . . . ,
xi1?1 ? Di1?1, xi1+1 ? Di1+1, . . . , xi2?1 ? Di2?1, xi2+1 ? Di2+1, . . . , xn ? Dn}. Em alguns
casos, a projeção obtida é tão restritiva quanto a restrição original, mas em outros ela não

atinge o mesmo nível e representa uma relaxação do modelo.

? Codi?cação dual A codi?cação dual refere-se à dualização do modelo para representação

por meio de um grafo, feita pela inversão entre variáveis e restrições. Um vértice vj do grafo

representa a restrição rj do modelo original, tendo como domínio Sj ? i.e., todas as tuplas

de atribuições válidas para satisfazer a restrição. Por sua vez, cada aresta representa a in-

tersecção de variáveis de decisão entre restrições distintas ? i.e., os vértices relativos a duas

restrições distintas são incidentes a uma aresta em comum se tais restrições compartilharem

uma determinada variável de decisão. Dessa forma, a operação da propagação nesse conjunto

de arestas do grafo da dualização do modelo garante a unicidade do valor atribuído a uma

variável de decisão do modelo.



2.2 PROPAGAÇÃO DE RESTRIÇÕES 27

? Codi?cação por variáveis ocultas Na codi?cação por variáveis ocultas, tanto os domínios

das variáveis de decisão quanto os domínios das restrições são considerados. Assim sendo, o

grafo resultante possui n + m vértices, sendo o subgrafo induzido pelos n vértices associados

às variáveis de decisão isomorfo ao grafo do modelo e o subgrafo induzido pelos m vértices

restantes, associados às restrições, isomorfo ao grafo do modelo dual. Dessa forma, a inspeção

de consistência opera sobre ambos os tipos de domínio.

2.2.2 Técnicas de Consistência Generalizada

A generalização dos conceitos de consistência previamente explorados para o caso binário pode

decorrer de uma necessidade incondicional para que uma determinada abordagem seja viável ou

emergir como uma oportunidade de maior benefício em outros. Na primeira situação, tratam-se

de PSRs cujo modelo binário obtido não apresenta um nível de propagação adequado para reduzir

o esforço necessário à busca. Na segunda, o modelo corresponde ao que se esperaria de um caso

geral, mas oportunidades a uma propagação mais e?caz são identi?cadas. Em ambas as situações, o

problema se resume ao fato de a representação binária não ser capaz de atingir o nível de propagação

desejado.

Entretanto, cabe ressaltar que a generalização do conceito de consistência para a operação sobre

restrições arbitrárias por si só é proibitiva. Em termos de implementação, o caso geral implica na

operação sobre hipergrafos: hiper-arestas generalizando o conceito de arestas para um número arbi-

trário de vértices. Há um certo consenso na literatura de que essa via de abordagem não compensa o

esforço devido à di?culdade de implementação e à exigência de recursos computacionais decorrentes.

E é nesse ponto que entra em cena o conceito central à PR: empregar restrições adequadas para

propagar de modo e?ciente sobre a estrutura do problema e se bene?ciar de suas especi?cidades,

conforme tratado a seguir.

Restrições Globais

O conceito de restrição global28 representa tanto uma restrição especializada a um domínio de

aplicação quanto o algoritmo de ?ltragem subjacente que garante a manutenção do nível de con-

sistência. O termo ?global? atribuído a uma propagação especializada contrasta com as limitações

de extensão para que uma propagação generalizada não tome demasiado tempo, razão pela qual

esta envolve menos variáveis e é vista como ?local?. Dessa forma, a generalização de consistência

provida pela restrição global vem ao custo de especializar o algoritmo de ?ltragem àquele caso. Essa

abordagem especializada é compensada pela recorrência com que algumas dessas restrições acabam

por ser encontradas na formulação de problemas. Disso resulta o esforço de catalogar sistematica-

mente tais restrições por meio das propriedades estruturais que elas representam, conforme tratado

por Beldiceanu et al. (2007). Portanto, a propagação por meio de restrições globais representa um

esforço de especialização dos mecanismos de propagação, tendo em vista não apenas o benefício da

abordagem imediata como a de outros problemas com a mesma estrutura.

Como pode ser visto pela própria de?nição apresentada, o conceito de consistência e o algoritmo

de ?ltragem se misturam. Bessière e Hentenryck (2003) noticiam que um tutorial apresentado na

28Denominada global constraint em inglês.



28 PROGRAMAÇÃO POR RESTRIÇÕES 2.2

conferência CP29 de 2002 levantou um debate acalorado em decorrência de como pesquisadores

de áreas distintas concebem restrições globais sob óticas diferentes. Por esse motivo, esses autores

sugerem uma de?nição de níveis progressivos à globalidade de uma restrição:

? Algorítmico: a globalidade algorítmica corresponde à obtenção de um algoritmo de ?ltragem

mais e?ciente do que aquele correspondente ao caso geral para o nível de consistência atingido.

? Operacional: a globalidade operacional corresponde à capacidade de que mais valores sejam

removidos do que no caso em que a mesma restrição seja representada por um conjunto de

restrições locais.

? Semântico: a globalidade semântica corresponde à possibilidade de representar uma restrição

que um conjunto de restrições locais não é capaz de representar.

Exemplo de restrição global operacional: alldi?erent

A restrição alldi?erent representa uma estrutura comum a diversos problemas combinatórios,

como o da rotulação graciosa de grafos descrito na seção 2.1.1. Semanticamente,

alldi?erent(x1, . . . ,xn) corresponde ao conjunto de restrições binárias xi 6= xj ? i ? [1,n],j ?
[i + 1,n] ? i.e., de?ne que a atribuição de cada variável de decisão envolvida deve ter um valor

diferente das demais. O que confere o caráter de globalidade operacional a essa restrição é que, ao

contrário do conjunto de restrições binárias, ela possibilita que se detecte facilmente situações como

a do modelo a seguir:

1 using CP;

2 dvar int x [ 1 . . 3 ] in 1 . . 2 ;

3 subject to {

4 a l l D i f f e r e n t (x) ;

5 };

No modelo, três variáveis de decisão compartilham um domínio contendo dois valores. Pelo princípio

da casa dos pombos30, é evidente que qualquer atribuição de valores às variáveis incorrerá em

que ao menos duas variáveis compartilhem a atribuição de algum valor, de forma que o modelo

é insatisfatível ? i.e., não há como satisfazê-lo e ele não tem solução. No entanto, o modelo é

consistente em nível de aresta e o tratamento de casos como o apresentado exigiria o emprego de

um nível generalizado de consistência.

Régin (1994) observa que garantir a consistência generalizada da restrição alldi?erent com um

algoritmo de ?ltragem genérico demandaria a inspeção de todas as tuplas de atribuição possíveis

? i.e., Ak,n =
k!

(n?k)!, para n variáveis de decisão e k valores distintos nos domínios das variáveis.

Dessa feita, Régin (1994) propõe um algoritmo de ?ltragem baseado no conceito de emparelhamento

máximo de grafos bipartidos. Nesse algoritmo, utiliza-se um grafo bipartido no qual os vértices de

uma classe da partição estão associados às variáveis de decisão da restrição, os vértices da outra

29 A série de conferências anuais CP, acrônimo reduzido para International Conference on Principles and Practice of
Constraint Programming, ou Conferência Internacional sobre os Princípios e a Prática da Programação por Restrições,
representa a maior conferência mundial de PR. A 17a edição do evento ocorreu em Perúgia, na Itália, entre 12 e 16
de setembro de 2011.

30 O ?princípio da casa dos pombos? consiste em um jargão empregado para a constatação de que não é possível
que n elementos sejam particionados em m conjuntos, para n &gt; m, sem que ao menos um dos conjuntos tenha mais
do que um elemento.



2.3 BUSCA 29

classe aos valores distintos dos domínios dessas variáveis e as arestas representam as atribuições

possíveis entre a variável associada a um vértice da primeira classe e o valor associado a um vértice

da segunda. Portanto, a restrição só pode ser satisfeita por alguma atribuição de valores às variáveis

se o emparelhamento máximo tiver tantas arestas quantas forem as variáveis envolvidas, sendo que

uma atribuição só é permitida se pertencer a algum emparelhamento máximo do grafo. O algoritmo

proposto a partir das constatações anteriores vale-se de resultados da teoria dos grafos para atingir

a consistência desejada em tempo O(n2k2). Por essa razão, o estudo de Régin (1994) representa

um caso de particular interesse sobre como o tratamento de especi?cidades leva à obtenção de um

melhor desempenho na resolução de problemas usando PR.

2.3 Busca

Devido ao caráter declarativo da PR, a busca pode operar por meios bastante diversos. Conforme

observado anteriormente, os métodos mais empregados para a busca em PR são denominados, de

um modo geral, como ?tentativa-e-erro?. Isso se deve ao fato de que a propagação ? apesar de ser

um componente fundamental à técnica ? não é viável operando isoladamente, de forma que cabe à

busca lidar com certo grau de inconsistência do modelo. Como re?exo, o foco da busca em PR está

muito mais ligado à factibilidade do que à otimalidade, i.e., costuma-se priorizar que uma solução

seja encontrada em tempo hábil e não tanto que uma solução ótima seja obtida. No entanto, seria

errôneo reduzir o ferramental de busca aos algoritmos de recursão e retrocesso ? i.e., que atribuem

valores a variáveis de maneira ordenada e recuem em caso de con?ito -, ainda que boa parte das

abordagens para a busca em PR envolvam esse tipo de algoritmo. Dessa forma, compete elencar as

alternativas possíveis para então compará-las de acordo com os resultados descritos na literatura.

A forma com que a busca é feita em PR depende do objetivo de sua realização. A primeira

dimensão de análise diz respeito à completude: é necessário realizar uma busca exaustiva por todas

as soluções possíveis ou basta encontrar uma solução para encerrar a busca? A busca exaustiva,

também dita completa, pode ser realizada por algoritmos de recursão e retrocesso ou de programação

dinâmica 31. Entretanto, a análise de algoritmos de programação dinâmica possui uma importância

mais teórica do que prática devido à exigência de memória decorrente da aplicação no caso geral,

conforme pode ser visto em Dechter (2003). Para a busca por factibilidade, geralmente incompleta

por ?nalizar sem necessariamente exaurir o espaço de busca, tanto os algoritmos de recursão e

retrocesso quanto os de busca local ou estocástica podem ser empregados. A maior diferença entre

esses procedimentos consiste na sistemática de exploração e garantia de ?nalização daqueles, que

não necessariamente encontram equivalência nestes devido à forma intermitente e aleatória com que

exploram o espaço de busca. Em ambos os casos, artifícios podem ser empregados para orientar

a busca a uma conclusão antecipada, tanto para a factibilidade quanto para obter uma solução

razoável de acordo com a função objetivo que se quer otimizar. A ambivalência de emprego dos

algoritmos de recursão e retrocesso tanto na busca exaustiva quanto incompleta é creditada por

van Beek (2006) ao fato de operarem sobre uma única solução por vez, de forma que a busca não

precisa ser ?nalizada para que alguma solução seja obtida ? ao contrário do que ocorre no caso

da programação dinâmica. É por essa razão que o estudo de algoritmos de busca por recursão e

31A programação dinâmica é um método de resolução de problemas pela decomposição em problemas menores,
valendo-se do princípio da sub-estrutura ótima para que uma solução ótima ao problema seja obtida a partir da
solução ótima dos sub-problemas associados. Para uma introdução ao tema, veja Cormen et al. (2002).



30 PROGRAMAÇÃO POR RESTRIÇÕES 2.3

retrocesso para PSRs acaba por se confundir um pouco com o estudo da busca em PR. Entretanto,

é importante evitar uma associação indissolúvel entre ambos os conceitos para que o emprego da

técnica de PR não se torne demasiado restrito, conforme adverte Hooker (2007).

O restante da seção é dedicado à introdução dos principais elementos dos algoritmos de recursão

e retrocesso e a uma breve apresentação dos métodos de busca local e estocástica.

2.3.1 Busca por Recursão e Retrocesso

A busca por recursão e retrocesso32 consiste no processo de atribuir progressivamente valores

às variáveis que ainda não foram instanciadas. O algoritmo termina quando todas as possibilidades

de atribuição foram tentadas ou quando alguma solução é encontrada durante o processo e isso

bastar ao propósito da busca. O retrocesso se dá quando uma falha é detectada devido ao conjunto

de atribuições acumulado ter violado alguma restrição do modelo, quando então ao menos uma

das atribuições anteriores terá de ser desfeita e alterada. É possível que o retrocesso se transforme

em uma reação em cadeia caso todos os valores possíveis já tenham sido atribuídos à variável

anterior, levando a um novo retrocesso e assim por diante. Apesar de não ser necessário que seja

implementada como uma recursão, essa forma de busca se assemelha à recursão em dois aspectos:

? as atribuições anteriores são mantidas em uma estrutura de pilha para reversão das mesmas

no caso de retrocesso;

? o algoritmo consiste em uma recorrência sobre o passo da atribuição, de forma que a recursão

emerge como uma forma evidente de implementação.

Nessas linhas gerais, vários algoritmos foram propostos visando aperfeiçoar aspectos especí?cos da

estrutura de funcionamento descrita.

A despeito do algoritmo empregado, a extensão da busca por recursão e retrocesso para tratar

de PSORs em vez de PSRs pode ser feita de diversas formas que independem das especi?cidades

dos aperfeiçoamentos. Entretanto, a garantia de otimalidade em todos os casos depende de uma

busca exaustiva. A hipótese mais simples consiste em registrar e manter atualizada a indicação de

qual foi a solução com melhor valor de acordo com a função objetivo. Outra possibilidade consiste

em reiniciar a busca após cada solução encontrada, restringindo o espaço de busca às soluções que

sejam melhores do que a obtida. Nesse caso, o espaço de busca pode ser explorado pela busca no

intervalo entre o valor da solução obtida e algum limite evidente ao ótimo, o que pode operar de

três formas distintas segundo van Beek (2006):

? pela restrição de que a solução seja tão somente melhor do que a atual;

? pela restrição de que a solução não apenas seja melhor do que atual mas que sua diferença

com relação ao limite ao ótimo esteja em uma determinada faixa;

? pela bissecção do intervalo de busca, explorando primeiramente a metade mais próxima ao

limite ao ótimo e explorando a outra metade somente se a primeira de?nir um PSR inviável.

Dessas formas, Lustig e Puget (2001) observam que a última representa o de maior aceitação, sendo

denominada busca dicotômica.
32Denominada backtracking search em inglês.



2.3 BUSCA 31

A forma mais elementar de recursão e retrocesso consiste naquela com retorno à variável de atri-

buição imediatamente anterior no caso de con?ito, sendo conhecido como retrocesso cronológico33

ou BT34. A respeito desse algoritmo mais elementar, Barták (1999) elenca três problemas comuns

de desempenho decorrentes da ausência de ações preventivas ou reativas às falhas durante a busca:

? Degeneração da busca35: o processo iterativo de instanciação das variáveis falha repeti-

tivamente por um mesmo motivo, carecendo de uma estratégia de contenção da causa da

falha.

? Trabalho redundante: algumas variáveis possuem valores con?itantes entre si, de forma

que a memorização poderia evitar que fossem novamente atribuídos em conjunto durante o

restante da busca.

? Detecção tardia de con?ito: nenhum con?ito de atribuição de variáveis é previsto com

antecedência, sendo todos tratados à medida que ocorrem.

Além desses fatores, constatou-se que a adoção de uma estratégia de atribuição de valores mais

adequada a cada caso tem grande impacto no desempenho do processo de busca. Disso resultou a

proposição de um conjunto de aperfeiçoamentos na literatura, sendo que muitos deles podem ser

utilizados para a composição de algoritmos de recursão e retrocesso mais elaborados. A seguir, serão

mencionados alguns dos mais relevantes.

Estratégias de Rami?cação

O progresso da busca recursiva costuma ser descrito como uma árvore enraizada36 sobre a qual

estratégias podem ser estabelecidas para antecipar a conclusão da busca. Nessa representação, cada

decisão tomada durante a busca representa uma rami?cação da árvore. Da perspectiva do modelo

sendo resolvido, tais rami?cações correspondem a partições do espaço de busca. Em última análise,

o processo de resolução consiste na redução progressiva do espaço de busca pelo aumento da res-

tritividade sobre o modelo ao ponto de restar apenas uma ou nenhuma solução. Tais possibilidades

representam a distinção entre a satisfação do PSR e o retrocesso na busca, respectivamente. A res-

peito da forma com que esse processo de rami?cação pode ser promovido, existem tipos diferentes de

rami?cação e heurísticas para decidir como rami?car, conforme apresentado a seguir. Na sequência,

uma análise da importância dessas heurísticas e uma abordagem alternativa à busca por recursão

e retrocesso baseada nas mesmas é indicada.

Tipos de rami?cação. Três formas possíveis de rami?cação para a resolução de PSRs são

elencadas por van Beek (2006):

33Denominado chronological backtracking em inglês.
34Acrônimo em inglês surgido a partir do termo backtracking.
35Denominada thrashing em inglês.
36 Uma árvore enraizada consiste em uma árvore orientada em que apenas um vértice ? a raiz ? possui apenas

arestas de saída, de forma que existe um caminho direcionado entre a raiz e cada vértice da árvore por meio das
arestas orientadas, sendo os vértices ?nais em cada direção de rami?cação denominados de folhas. Um vértice no
?nal de um caminho é dito sucessor ou descendente dos outros vértices do mesmo caminho, que lhe são antecessores
ou antecedentes.



32 PROGRAMAÇÃO POR RESTRIÇÕES 2.3

? Pontos de decisão binária ou divisão em 237: representa a opção de atribuição de um

determinado valor a uma das variáveis de decisão, de forma que o nível seguinte possui dois

vértices: um em que esse valor é ?xado à variável e outro em que a atribuição desse valor não

é mais permitida à variável.

? Divisão de domínios38: não representa necessariamente a atribuição a uma variável, mas

antes a partição de seu domínio. Dessa forma, o conjunto de valores que podem ser atribuídos

à variável nos dois vértices do nível seguinte não possui intersecção entre si.

? Enumeração ou divisão em d39: representa a atribuição de cada valor possível a uma das

variáveis de decisão, de forma que cada vértice do nível seguinte representa o mesmo problema

com um valor distinto ?xado para tal variável.

Cabe ressaltar que as três modalidades representam uma sequência de generalizações que coincidem

para o caso de domínios binários, visto que a divisão em d coincide com a divisão em 2 e que a

divisão de um domínio binário invariavelmente induz a uma atribuição.

Heurísticas para rami?cação. A escolha da sequência de opções que serão realizadas ao longo

da busca representa a estratégia de rami?cação. Essa escolha pode ser baseada em decisões locais a

cada rami?cação ou ser estabelecida de antemão, sendo esse o ponto de distinção entre as ordenações

dinâmicas e estáticas das atribuições. Tais decisões são tomadas por meio de heurísticas sobre

as propriedades do modelo e partem de premissas sobre a consequência de cada escolha possível

mediante as condições observadas durante a busca. O objetivo mais comum a essas escolhas é de

que façam com que a busca seja feita com o menor esforço possível. A esse respeito, Refalo (2004)

destaca três princípios básicos que costumam orientar as rami?cações:

1. Sempre escolher para atribuição as variáveis com maior potencial à redução do espaço de

busca. Tal critério pode direcionar a escolha, por exemplo, para aquelas com menor tamanho

de domínio ou maior participação nas restrições do modelo. Na literatura, esse princípio

costuma ser identi?cado pela expressão ?falhar primeiro?40 devido ao fato de induzir à escolha

de variáveis com maior potencial à ocorrência de falhas prematuras durante a busca. Essa

opção objetiva evitar que a mesma falha ocorra com maior frequência, caso essa falha viesse

a ocorrer em níveis posteriores da busca.

2. Sempre escolher para atribuição os valores que maximizem as possibilidades de ocorrência de

outras atribuições, de forma que possuam uma maior probabilidade de presença nas soluções

ao problema. Como pode ser observado, o princípio de escolha de valores é antagônico ao de

escolha de variáveis.

3. Sempre privilegiar decisões mais próximas ao topo da árvore de busca, pois têm uma impor-

tância maior devido às consequências mais desastrosas que uma má decisão a esse ponto traria.

A razão desse princípio é consonante ao raciocínio apresentado para endossar o princípio de

?falhar primeiro?, mencionado anteriormente.

37Denominada binary choice points ou 2-way em inglês.
38Denominada domain splitting em inglês.
39Denominada enumeration ou d-way em inglês.
40Denominado fail-?rst principle em inglês.



2.3 BUSCA 33

Refalo (2004) observa que um desenvolvimento maior foi conferido inicialmente aos dois primeiros

princípios enunciados por meio de heurísticas para ordenar a preferência de escolha de variáveis e de

valores para atribuição, como pode ser observado na revisão de Brailsford et al. (1999). No entanto,

o terceiro princípio ganhou um reconhecimento maior ao longo da última década. Como exemplo

disso, Refalo (2004) explora o emprego de uma heurística que demanda maior processamento na

raiz da busca, Kautz et al. (2002) emprega estratégias dinâmicas de reinício da busca para alterar a

rami?cação próxima da raiz e em Arbelaez et al. (2009) é proposto um modelo preditivo de impacto

das heurísticas correlancionando diversas características do modelo.

É importante não esquecer o caráter tentativo de qualquer estratégia de rami?cação devido ao

fato de que o problema de formulação da estratégia ótima de rami?cação acaba por também ser NP-

Difícil. Isso pode ser constatado de forma simples no caso da abordagem a um PSR satisfatível: uma

estratégia perfeita de escolha de valores basta para que uma solução seja obtida sem que nenhum

retrocesso ocorra. No caso de um PSR insatisfatível, a incumbência para uma estratégia ótima

recai sobre a ordem de instanciação das variáveis, uma vez que tal escolha induz a uma exploração

exaustiva menos trabalhosa se os con?itos ocorrerem mais próximos à raiz da busca. É interessante

observar que o foco na literatura se concentra muito mais na ordenação das variáveis em razão da

importância atribuída à antecipação dos con?itos na árvore de busca. Como um contraponto a essa

ênfase, a seguir é apresentado um algoritmo alternativo de busca que se concentra exclusivamente na

ordenação dos valores. Apesar de não ser exatamente um algoritmo baseado em retrocesso, optou-

se por sua apresentação dentro da presente seção devido à similaridade entre ambos e à forma

alternativa com que explora estratégias de rami?cação.

Busca por discrepância limitada. A busca por discrepância limitada41 opera sobre instanci-

ações completas das variáveis de decisão até que seja obtida uma solução ao problema, i.e., até que

não haja nenhuma violação às restrições do PSR por parte das atribuições. Nesse algoritmo, parte-se

de uma instanciação das variáveis com o valor de maior prioridade a cada variável, correspondente

à rami?cação mais à esquerda42 na árvore de busca ? seja ela factível ou não. A cada iteração,

um número progressivo de valores é alterado a partir da instanciação original como forma de obter

uma solução ? i.e., o nível 0 consiste no conjunto de atribuições inicial, o nível 1 aos conjuntos de

atribuições que diferem em apenas uma variável do conjunto inicial e assim por diante. O intuito no

projeto desse algoritmo é de que o espaço de busca seja explorado apenas sob a orientação de um

conjunto referencial de valores de atribuição, assim evitando que uma má ordenação das variáveis

degenere a busca. De acordo com Baptiste et al. (2001), a premissa ao sucesso dessa abordagem é

de que as heurísticas empregadas falham em poucos pontos, a despeito de quais sejam esses pontos.

Dessa forma, o sucesso de uma busca desse tipo acaba por depender muito mais da forma com que

os valores são ordenados.

Técnicas Preventivas de Melhoria da Busca

O objetivo das técnicas preventivas43 é de manter um nível de consistência do modelo ao longo da

busca como forma de evitar a detecção tardia de con?ito em determinados casos. Essa manutenção

41Denominada Limited Discrepancy Search (LDS) em inglês.
42Por rami?cação mais à esquerda em uma árvore de busca, ilustra-se gra?camente o conceito do caminho obtido

pela escolher da primeira opção em cada nível da busca.
43Denominadas look ahead schemas em inglês.



34 PROGRAMAÇÃO POR RESTRIÇÕES 2.3

costuma ser feita por técnicas de consistência em nível de aresta, sendo as três modalidades mais

comuns as seguintes:

? Veri?cação adiantada ou FC44. Na veri?cação adiantada, a manutenção da consistência

em nível de aresta é feita sobre restrições binárias envolvendo uma variável instanciada e outra

não instanciada. A propagação resultante dessa manutenção ocorre a cada nova atribuição e

deve ser revertida se a atribuição for desfeita. Nessa modalidade, uma nova atribuição de valor

a uma variável será sempre válida devido aos domínios estarem consistentes no corte entre os

vértices das variáveis instanciadas e os vértices das variáveis não instanciadas. Dessa forma,

o retrocesso não opera devido ao con?ito imediato de uma atribuição à satisfação de uma

restrição, mas sim pelo esvaziamento do domínio de uma variável que ainda não foi instanciada

durante a propagação ? razão pela qual haveria um con?ito iminente para qualquer atribuição

à variável de domínio esvaziado. Segundo Barták (1999), foi constatado que o desempenho

decorrente da aplicação dessa técnica é superior ao do retrocesso cronológico.

? Antecipação parcial45. A antecipação parcial consiste em um desdobramento à manutenção

da consistência em nível de aresta não apenas para as arestas no corte tratado pela veri?cação

adiantada, mas também em uma orientação do restante das arestas entre vértices de variáveis

não instanciadas. Ela é dita parcial por operar apenas sobre uma orientação e não sobre todas

as arestas do grafo do modelo, de forma que representa a consistência direcional em nível de

aresta. Convém ressaltar que essa modalidade é elencada por Barták (1999) mas é ignorada por

van Beek (2006), que considera apenas os outros dois casos. Entretanto, conforme mencionado

anteriormente, Dechter (2003) aponta que a manutenção de consistência direcional ao nível

da aresta surte o mesmo efeito que a não-direcional no caso em que a orientação condiz com

a estratégia de rami?cação da busca. Dessa forma, a antecipação parcial pode substituir com

vantagem de desempenho a antecipação total em algumas situações, como no caso de uma

ordenação estática para rami?cação do restante do espaço de busca.

? Antecipação total, manutenção da consistência em nível de aresta ou MAC46.

Como o próprio nome alternativo anseia, a antecipação total consiste na manutenção da

consistência ao nível da aresta a todo o grafo do modelo, sem restrição de orientação ou

extensão. Barták (1999) observa que o esforço necessário à MAC pode tornar seu desempenho

pior que o da veri?cação antecipada ou do retrocesso cronológico em alguns casos. Por outro

lado, van Beek (2006) considera que a controvérsia a respeito da questão de desempenho nesse

caso foi superada por novos estudos empíricos e que a antecipação total representa uma opção

superior às demais no caso geral.

Técnicas Reativas de Melhoria da Busca

O objetivo das técnicas reativas47 é utilizar informações sobre con?itos que ocorreram durante

a busca para evitar sua repetição ou prover uma contingência mais adequada à sua ocorrência.

Sua necessidade se deve à impossibilidade de se atingir níveis completos de consistência, de forma

44Denominada Forward Checking (FC) em inglês.
45Denominada partial look ahead em inglês.
46Denominada (full) look ahead ou Maintaining Arc Consistency (MAC) em inglês.
47Denominadas look back schemas em inglês.



2.3 BUSCA 35

que a detecção tardia de con?ito não pode ser completamente erradicada. Assim sendo, o foco

dessas técnicas é evitar o trabalho redundante e, por consequência, a degeneração da busca. Entre-

tanto, convém sempre avaliar se o esforço exigido para a execução de procedimentos de veri?cação

adicionais não será maior do que o perda em desempenho cuja ocorrência se procura evitar.

A seguir, listamos algumas das técnicas reativas mais estudadas na literatura, conforme Dechter

(2003) e van Beek (2006):

? Aprendizado de restrições48. O aprendizado de restrições consiste na acumulação de no-

vas restrições ao modelo original em decorrência dos con?itos detectados durante a busca.

Cada nova restrição é obtida por meio da identi?cação de um conjunto de con?ito, que repre-

senta o conjunto de variáveis cujas atribuições justi?cam a violação de alguma restrição. Por

sua vez, as atribuições que conferem a violação de uma restrição a esse conjunto de con?ito

representam uma rejeição49, a partir da qual de?ne-se uma nova restrição que proíba exata-

mente esse conjunto de atribuições. Apesar de redundante por estar implícita no conjunto de

restrições original do modelo, essa nova restrição possibilita uma propagação mais e?ciente

por evidenciar um con?ito que já ocorreu anteriormente, de forma que interessa determinar

o menor conjunto de con?ito possível para que uma quantidade maior de con?itos futuros

seja evitada. O maior inconveniente a essa técnica ? e que faz com que não seja utilizada na

prática ? é que ela pode levar à inclusão de uma quantidade exagerada de restrições, de forma

que exige a de?nição de um critério à inclusão de novas restrições para privilegiar as mais

generalistas e outro critério à remoção de restrições para não continuar propagando aquelas

cujos con?itos evitados já não possam mais ocorrer.

? Retrocesso inteligente50. O retrocesso inteligente promove um retrocesso não-cronológico

? i.e., não necessariamente à última variável atribuída ? pela análise do conjunto de con?ito.

Dito de outra forma, ele salta variáveis da pilha cuja atribuição não tenha relação com a

impossibilidade de progresso da busca a partir daquele ponto. Sendo a alteração da atribuição

a alguma variável do conjunto de con?ito condição necessária ? mas não su?ciente ? para

que alguma solução seja obtida, um salto que ignore apenas variáveis ausentes do conjunto

não impede a completude da busca. Portanto, evita-se o trabalho redundante na busca pela

exaustão de possibilidades de atribuição que seriam exploradas sem serem capazes de evitar

a reincidência da falha observada. Uma sequência de algoritmos contemplando uma gama

cada vez mais ampla de saltos é descrita na literatura, dos quais dois têm maior destaque: o

algoritmo de retrocesso por salto51 ou de Gaschnig, que retrocede não cronologicamente apenas

de vértices da árvore de busca cujos descendentes sejam folhas ? i.e., nenhuma atribuição

ocorreu sem con?ito a partir daquele ponto; e o algoritmo de retrocesso baseado em con?ito52,

que pode retroceder a partir de outros vértices da árvore de busca devido ao acúmulo do

conjunto de con?ito dos sucessores dos quais retornou.

? Retrocesso dinâmico53. O retrocesso dinâmico consiste na permuta da ordem das variáveis

48Denominado backmarking em inglês.
49Denominada nogood em inglês.
50Denominado intelligent backtracking ou backjumping em inglês.
51Denominado BackJumping (BJ) em inglês.
52Denominado Con?ict-Based BackJumping (CBJ) em inglês.
53Denominado dynamic backtracking em inglês.



36 PROGRAMAÇÃO POR RESTRIÇÕES 2.3

da pilha de atribuições, de forma a aproximar a posição das atribuições de variáveis con?itan-

tes. Dessa forma, o retrocesso dinâmico representa uma alternativa ao retrocesso inteligente

por reduzir o trabalho redundante ao diminuir o número de atribuições a variáveis em or-

dem intermediária com relação às con?itantes. No entanto, a livre permuta das variáveis na

ordem de atribuição pode comprometer a sistemática da busca ? i.e., torná-la cíclica ou in-

completa. Portanto, esse subterfúgio tem maior utilidade no início da busca ou se incorporada

às estratégias de rami?cação.

2.3.2 Busca Local e Estocástica

A busca local e a busca estocástica procuram explorar o espaço de busca de forma não sistemá-

tica, podendo valer-se dos resultados intermediários para guiar o restante do processo de resolução.

No caso da busca estocástica, a justi?cativa a um processo não sistemático se dá pelo foco à explo-

ração de regiões com maior potencial em detrimento à completude. No entanto, é possível conferir

essa última característica a algumas das abordagens desse tipo. Como exemplo disso, temos as estra-

tégias de reinício como as descritas em Gomes et al. (1998) e Kautz et al. (2002), que interrompem

a busca para reiniciá-la com alterações às estratégias de rami?cação. Observa-se de Gomes et al.

(1998) que é possível manter a completude da busca empregando estratégias de reinício se o número

mínimo de retrocessos à interrupção da busca aumentar ao longo da resolução, de forma que em

algum momento a quantidade mínima ultrapasse o número de retrocessos necessários à realização

de uma busca completa. Entretanto, tal peculiaridade interessa menos como uma característica

desse tipo de abordagem à busca e mais como uma garantia de que o fracasso da estratégia de

reinício não prejudique a busca por sempre limitá-la apenas a algumas regiões. No caso da busca

local, a exploração do espaço de busca é limitada a aperfeiçoar resultados obtidos por outros meios

sob o argumento de que a completude não pode ser cogitada devido ao tamanho do espaço de

busca. Ela opera por meio de transformações de soluções obtidas anteriormente na resolução, seja

para minimizar a penalização decorrente de uma solução que não atenda a todas as restrições ou

para obter uma melhor aproximação à solução ótima a partir de soluções que já sejam factíveis.

Dessa forma, existe uma certa similaridade e intersecção entre ambas as modalidades, mas convém

analisá-las separadamente devido ao escopo diferenciado de ambas: na busca estocástica ainda é

possível operar sobre a mesma estrutura que a de recursão e retrocesso, enquanto que a busca local

opera sobre estruturas alternativas.

A estruturação da busca local costuma priorizar a obtenção de soluções a partir de outras pré-

existentes. Essa geração de soluções pode priorizar a qualidade ? seja por um melhor atendimento às

restrições ou uma melhor valoração da função objetivo ? ou a variabilidade ? como no caso em que

os critérios quantitativos de comparação das soluções não são tidos como su?cientes e certo grau de

liberdade é conferido à intervenção humana pela escolha dentre um conjunto de soluções distintas.

Por questão de foco ao tipo de abordagem realizado no estudo de caso do presente trabalho, serão

exempli?cadas a seguir apenas estruturas de priorização à qualidade. Dechter (2003) ilustra o caso

de melhor atendimento às restrições pelo emprego de métodos gulosos de busca local, de forma que a

resolução é decomposta entre uma atribuição completa de valores despreocupada com o atendimento

às restrições e a operação de reparos locais a tais atribuições como forma de reduzir a violação

decorrente. É possível observar certa similaridade entre essa estrutura e a busca por discrepância

limitada, com ressalva à ausência de sistematização para completude da busca nesse caso. Focando a



2.4 PARADIGMAS 37

otimalidade em vez da satisfabilidade, é estudada uma decomposição distinta em Laborie e Godard

(2007), dividida entre operadores que geram novas soluções por meio de modi?cações em soluções

factíveis e operadores que ajustam as soluções geradas para que satisfaçam às restrições no caso de

alguma violação ter sido causada. Duas referências são recomendadas para o aprofundamento na

aplicação de busca local em PR, tendo enfoques distintos: Dechter (2003) parte da PR para discutir

o emprego de busca local, ao passo que Hoos e Stützle (2005) partem da busca local estocástica

para discutir sua aplicação em PR.

2.4 Paradigmas

O desenvolvimento da PR ao longo dos anos ocorreu sob uma sucessão de paradigmas de sin-

taxe dos resolvedores cuja contextualização faz-se importante a uma melhor compreensão de como

a técnica foi sendo aperfeiçoada. O principal deles consiste na Programação Lógica por Restri-

ções (PLR)54. De acordo com Barták (1999); Ja?ar e Lassez (1987), a PR partiu da extensão de

linguagens lógicas55 como Prolog para uma resolução mais e?ciente de PSRs. A extensão des-

sas linguagens para a resolução de PSRs se deu principalmente pela inclusão de mecanismos de

inferência sobre as restrições, de forma a permitir cortes56 mais e?cazes durante a busca. No en-

tanto, elas conferiram aos programas resultantes um caráter distinto devido à manipulação explícita

dos predicados, remetendo ao paradigma de programação funcional57. Nesse contexto de impasse,

Ja?ar e Lassez (1987) propuseram a de?nição da classe de linguagens PLR como uma uni?cação

dos paradigmas declarativos funcional e lógico capaz de descrever as extensões sendo então promo-

vidas na literatura. A classe PLR representa linguagens direcionadas à resolução por inferência no

domínio de discurso dos problemas, em contraposição à tradução dos mesmos a uma estrutura uni-

?cada de inferência lógica, dessa forma conservando o caráter de programação declarativa. Por essa

razão, a PLR delineou uma estrutura prática ao desenvolvimento de mecanismos de propagação de

resolvedores de problemas combinatórios, provendo suporte ao emprego das técnicas pré-existentes

e facilitando a emergência de aperfeiçoamentos às mesmas.

No entanto, a PLR não bastou à PR devido à limitação do papel assumido pelo usuário ?nal

do resolvedor nessas linguagens. Isso porque a dinâmica estabelecida impedia que manipulações

especializadas a domínios mais restritos se viabilizassem. Essas manipulações foram facilitadas a

partir dos anos 1990 pelo emprego de linguagens imperativas como C++, nas quais a estrutura de

resolução é oferecida por meio de bibliotecas de código que podem ser especializadas na de?nição

de como se operam tanto a propagação quanto a busca. Entretanto, Lustig e Puget (2001) notam

que a PR ainda permanecia como uma técnica bastante restrita a essa época devido à exigência

de conhecimentos de programação de computadores para seu emprego. Nesse contexto, linguagens

de modelagem algébrica como as empregadas para programação matemática surgiram ao ?nal da

54 Denominada Constraint Logic Programming (CLP) em inglês.
55 No paradigma de programação lógica, programas são de?nidos como um conjunto de expressões sobre variáveis

ou termos constantes, designados predicados devido a seu resultado se resumir às condições de verdadeiro ou falso. O
objetivo da execução de um programa lógico consiste na veri?cação de que um predicado possa ser satisfeito mediante
uma atribuição de valores constantes a suas variáveis, sendo essa atribuição denominada uni?cação. Para maiores
detalhes, veja Scott (1999).

56 No contexto da programação lógica, um corte representa um ponto em que se assume a falha à satisfação de um
determinado predicado na hipótese de retrocesso durante a busca.

57 No paradigma de programação funcional, a declaração dos programas é essencialmente recursiva e desprovida
de atribuições explícitas, evidenciando a forma com que a resolução deve operar.



38 PROGRAMAÇÃO POR RESTRIÇÕES 2.4

década de 1990 e foram se transformando ao longo da década seguinte. Ainda que essas lingua-

gens já não correspondam à estrutura dos mecanismos de resolução subjacentes, existe uma relação

clara entre a expectativa de como o resolvedor será utilizado e a disposição da sintaxe de modela-

gem. Dessa forma, a compreensão da forma com que a PR tem se desenvolvido desde então passa

obrigatoriamente pela análise tanto das contribuições à PR na literatura que foram adotadas nos

resolvedores quanto da sintaxe com que os problemas passaram a ser modelados.

Como subsídio a uma introdução às tendências mais recentes observadas, a seção 2.4.1 serve

à analise de duas das ferramentas comerciais baseadas em PR mais empregadas, e a seção 2.4.2

aponta os esforços recentes voltados ao desenvolvimento de linguagens abstratas ? i.e., voltadas à

PR mas independentes de resolvedores.

2.4.1 Ferramentas Comerciais

Duas linguagens ? e seus respectivos resolvedores ? bastante empregadas atualmente por pra-

ticantes da PR são a OPL58 e a Comet. A análise que se segue de cada uma delas é baseada nos

manuais da IBM (2010) e Dynadec (2009), respectivas proprietárias das mesmas, além de outras

menções observadas sobre seus desenvolvimentos na literatura.

OPL

De acordo com Lustig e Puget (2001), a OPL foi uma das primeiras linguagens algébricas com

suporte à PR. Ela oferece uma sintaxe declarativa para expressões matemáticas e algumas restri-

ções especializadas a certos domínios de aplicação, como no caso de problemas de escalonamento.

Como pode ser observado pelos exemplos descritos em Hentenryck et al. (2000) e em Lustig e Puget

(2001), as versões iniciais permitiam a de?nição separada do modelo e da busca ? a última em ter-

mos de estratégias não necessariamente completas de rami?cação. No entanto, versões mais recentes

sofreram uma redução do escopo em que a busca pode ser de?nida. Em parte, é possível que isso

se deva ao argumento de Puget (2004) de que a simplicidade de uso era necessária à ampliação

do público-alvo da PR, defendida por ele como sendo ?qualquer engenheiro?. No mesmo evento,

Refalo (2004) apresentou uma técnica de rami?cação mais elaborada do que as heurísticas em uso

como alternativa à delegação de de?nição da busca ao usuário, alegando inspiração na programação

inteira. Um esforço similar foi observado com relação à aplicação em problemas de escalonamento

em todos as dimensões possíveis:

? novas abstrações de modelagem em Laborie e Rogerie (2008) e Laborie et al. (2009);

? exploração de níveis de propagação mais efetivos e de algoritmos de ?ltragem mais e?cientes

em Laborie (2003a), entre outros;

? algoritmos de busca dedicados a problemas de escalonamento em Godard e Laborie (2005) e

Laborie e Godard (2007).

Dessa forma, a sintaxe da OPL foi se transformando em direção à automatização dos mecanismos

de resolução em detrimento à manipulação da de?nição da busca. Isso fez com que a de?nição da

busca ?casse restrita à con?guração de parâmetros do conjunto de técnicas empregadas.

58Acrônimo em inglês para Optimization Programming Language, ou Linguagem de Programação para Otimização.



2.4 PARADIGMAS 39

Comet

De acordo com Hentenryck (2010), que foi um dos autores da OPL, a Comet teve sua primeira

versão apresentada três anos após a introdução da OPL. A intenção da linguagem era permitir uma

manipulação explícita de estratégias de busca local em PR. A princípio, sua estrutura era muito

parecida com aquele descrita anteriormente para a OPL em Hentenryck et al. (2000). No entanto, a

linguagem oferece muitos mecanismos de diferentes paradigmas de programação, tais como fechos59

e métodos acionados por eventos60 em forma propícia à de?nição de algoritmos de busca local. No

que diz respeito ao domínio de problemas de escalonamento, a estrutura de modelagem mantém

o emprego de abstrações tradicionais como atividades e recursos por meio de uma gama de pos-

sibilidades de restrições entre tais abstrações. No entanto, os algoritmos de resolução subjacentes

à modelagem não diferem tanto entre a Comet e a OPL. Assim sendo, a maior diferença nos em-

prego dessas linguagens e de seus respectivos mecanismos de resolução é que a de?nição da busca é

explícita na primeira e implícita na segunda. Entretanto, algumas publicações recentes tiverem seu

foco voltado à abstração da busca na Comet, como a proposta de um sintetizador de algoritmos

de busca baseado na estrutura do problema para a resolução de PSRs em Hentenryck e Michel

(2007) e de problemas de escalonamento especi?camente em Monette et al. (2009). A justi?cativa a

ambos os casos é atribuída a Gomes e Selman (2007), sendo similar àquela apresentada por Puget

(2004): a necessidade de ampliar a audiência sendo atendida pela abstração da busca. No caso de

Gomes e Selman (2007), alega-se a ausência do que se convencionou chamar de resolvedores ?caixa-

preta?, nos quais a modelagem independe de conhecimentos sobre como a busca opera ? algo que

deve ser tratado com cautela para obter o melhor desempenho possível, conforme defendido em

Serra e Wakabayashi (2010).

2.4.2 Modelagem Abstrata

Uma área de trabalho recente em PR diz respeito às linguagens de modelagem abstratas, por

meio das quais um determinado tipo de problema possa ser modelado a despeito do resolvedor que

será empregado. Esse tipo de linguagem surge com maior facilidade na programação matemática

devido à relativa uniformidade com que os problemas são modelados. No caso da PR, os obstáculos

são maiores devido à falta de padronização sobre como a modelagem deve ser feita. A MiniZinc,

originalmente proposta por Nethercote et al. (2007), representou a primeira empreita desse tipo.

Nela, os projetistas dos resolvedores são incumbidos de prover uma tradução de baixo nível entre as

estruturas de modelagem disponíveis de um lado e a sintaxe de seu resolvedor do outro. No entanto,

os autores reconhecem que há uma diferença considerável de desempenho contra a modelagem na

linguagem nativa do resolvedor, de forma que é necessário que seja dada uma atenção maior às

restrições globais e à de?nição da busca. Em meados de 2011, ocorreram testes controlados de

uma versão experimental da linguagem comercial de modelagem abstrata AIMMS capaz de utilizar

resolvedores de PR, conforme divulgado em van Hoeve et al. (2011), sendo possível que as versões

o?ciais da linguagem contemplem essa possibilidade nas próximas versões.

59Mecanismo de linguagens funcionais representando um corpo de código que pode ser manipulado e executado.
60Métodos de programação imperativa que podem ser acionados caso uma determinada condição monitorada

ocorra.



40 PROGRAMAÇÃO POR RESTRIÇÕES 2.4



Capítulo 3

Escalonamento Baseado em Restrições

O Escalonamento Baseado em Restrições (EBR)1 representa uma extensão da PR à aborda-

gem de problemas de escalonamento. Essa extensão consiste na especialização dos elementos de

modelagem, propagação e busca à resolução de problemas envolvendo a alocação temporal de ativi-

dades mediante as limitações dos recursos à disposição. Notadamente, o desenvolvimento observado

nessa linha de aplicação destacou-se das demais em PR e foi alavancado por pesquisa tanto na

academia quanto na indústria. O interesse acadêmico se deu pela integração e incentivo a frentes

bastante diversas de pesquisa em um ferramental de resolução uni?cado. Na indústria, identi?cou-se

a oportunidade de aplicação a problemas reais graças à forma compacta com que modelos de EBR

descrevem certos problemas e aos resultados observados. Dessa forma, o EBR representa um caso de

particular interesse da PR devido ao incentivo que representa à aplicação da técnica e ao benefício

advindo dessa aplicação no caso de problemas de escalonamento.

O propósito deste capítulo é analisar a especialização dos elementos constituintes da PR à

abordagem de problemas de escalonamento de diversos tipos. Para tanto, convém apresentar de

antemão as razões pelas quais a articulação entre esses elementos encontrou um campo mais fértil

nessa área do que em outras.

De acordo com Baptiste et al. (2006), o sucesso na abordagem de problemas de escalonamento

por meio da PR se deu pela aderência de técnicas pré-existentes à componentização de acordo com

o tripé modelo-propagação-busca, descrito no Capítulo 2. A modelagem por meio de variáveis e res-

trições especializadas possibilitou uma descrição natural e ?exível de problemas de escalonamento.

A propagação por meio de restrições globais aproveitou-se de uma sinergia entre a generalidade

de constituição dos problemas abordados na inteligência arti?cial e a e?ciência de algoritmos de

?ltragem especializados da pesquisa operacional. A descrição das heurísticas mais comuns de esca-

lonamento adequou-se à estrutura de árvore de busca empregada na PR. Além disso, a natureza

declarativa da modelagem possibilitou o emprego de métodos alternativos de busca, conforme men-

cionado na introdução do Capítulo 2 e exempli?cado na seção 2.3.2. Dessa forma, a EBR representou

antes uma compilação de ferramental disperso em uma organização propícia do que uma constitui-

ção completamente inédita e independente das abordagens alternativas à resolução de problemas

desse tipo.

A organização do restante do capítulo objetiva uma descrição do EBR por meio de suas especi?-

cidades com relação à PR. Portanto, a estrutura do capítulo é mais compacta mas bastante similar

1 Denominado Constraint-Based Scheduling (CBS) em inglês.

41



42 ESCALONAMENTO BASEADO EM RESTRIÇÕES 3.1

àquela empregada no capítulo anterior. A seção 3.1 trata dos paradigmas e da modelagem para a

de?nição dos problemas no EBR e a seção 3.2 da propagação e da busca para a resolução desses

problemas.

3.1 Modelagem e Paradigmas Descritivos

Apesar da modelagem dos problemas de escalonamento variar em função da tipologia de cada

problema, existem alguns elementos comuns a todos eles. Os PSRs especí?cos ao EBR se baseiam

nos conjuntos A = {a1, . . . ,an} de atividades e R = {r1, . . . ,rm} de recursos necessários às ati-
vidades. Sobre ambos os conjuntos, propriedades podem ser de?nidas como variáveis ou restrições

do problema. Essas propriedades podem dizer respeito à alocação temporal das atividades, à sua

demanda pela disponibilidade dos recursos, às restrições temporais entre atividades ou à limitação

da disponibilidade dos recursos ao longo do tempo. No caso de POSRs, a constituição da função

objetivo também é feita de variáveis de decisão advindas dessas propriedades. O que varia com as

diferentes tipologias de problema é a natureza, o valor ou a manipulação realizada das propriedades

que caracterizam os elementos dos conjuntos A e R, bem como sua inter-relação.

Convém, contudo, observar que a especialização da modelagem no EBR acaba por depender

do paradigma subjacente em um grau que impede uma análise separada desses elementos. Dessa

forma, o detalhamento da modelagem se dará pela descrição da forma clássica de representação

de EBRs em função da manipulação explícita de entidades representando atividades e recursos na

seção 3.1.1 e por uma caracterização alternativa através de variáveis de intervalo que representam

indiretamente os conceitos de atividade e recurso na seção 3.1.2. Além disso, é importante observar

que a notação adotada a seguir representa uma síntese dos conceitos por parte do autor e não guarda

correspondência exata com aquela encontrada na literatura. Entretanto, no caso da seção 3.1.2,

há uma grande correspondência ? ainda que não de todo precisa ? com a notação da linguagem

OPL devido ao fato da origem dessa modalidade estar associada ao próprio desenvolvimento da

linguagem.

3.1.1 Caracterização por Atividades e Recursos

A caracterização de PSRs do EBR por meio de relações explícitas entre as propriedades de

atividades e recursos permitiu que os mecanismos de resolução se especializassem com um benefício

tangível de desempenho. Ela é adotada por referências centrais na literatura como Baptiste et al.

(2001) e Baptiste et al. (2006). Além disso, é empregada de modo direto na abordagem a problemas

de escalonamento utilizando a linguagem Comet, de acordo com o manual da Dynadec (2009). E

ainda que não seja explicitamente adotada na linguagem OPL conforme o manual da IBM (2010),

as representações empregadas encerram correspondência su?ciente para que os mesmos mecanismos

de propagação sejam utilizados nesse caso. Dessa forma, a caracterização por atividades e recursos

persiste como dominante na literatura e a caracterização por variáveis de intervalo ? tratada na

seção 3.1.2 ? presta-se como uma representação mais generalista mas ainda capaz de se bene?ciar

dos desenvolvimentos voltados à estrutura descrita na presente seção.



3.1 MODELAGEM E PARADIGMAS DESCRITIVOS 43

Caracterização do Conjunto de Atividades

Visto que a modelagem dos recursos interessa somente à medida em que limitam a execução

das atividades, estas constituem o principal objeto de interesse no EBR. Cada atividade ai ? A
pode ter como propriedades a data de liberação2 dli a partir da qual pode ser executada, a data de

limite de conclusão3 dci em que deve ter sido concluída e o tempo de processamento a plena capa-

cidade tpi que determina o esforço necessário à sua realização. Quanto à tipologia das atividades,

é possível caracterizar um problema de escalonamento em níveis crescentes de generalização como

não-preemptivo, preemptivo ou elástico em função da natureza de suas atividades e de sua relação

com as propriedades descritas:

? Atividade não-preemptiva Uma atividade não-preemptiva ai deve ser realizada de maneira

ininterrupta a partir de seu início. Dessa forma, ela pode ser caracterizada pelo par de variáveis

discretas inicio(ai) e fim(ai) representando, respectivamente, os instantes de início e ?m de

ai tais que:

inicio(ai) ? dli (3.1)

fim(ai) ? dci (3.2)

fim(ai) ? inicio(ai) = tpi (3.3)

? Atividade preemptiva Uma atividade preemptiva ai pode ser realizada de maneira intermi-

tente. Dessa forma, é possível caracterizá-la pelo conjunto IF(ai) = {{inicioj(ai); fimj(ai)} :
j ? [1,rodadas(ai)]} representando os pares de início e ?m das rodadas necessárias à execução
de ai tal que:

inicioj(ai) &amp;lt;fimj(ai), j ? [1,rodadas(ai)] (3.4)

fimj?1(ai) ? inicioj(ai), j ? [1,rodadas(ai) ? 1] (3.5)

inicio1(ai) ? dli (3.6)

fimrodadas(ai)(ai) ? dci (3.7)

rodadas(ai)?
j=1

(fimj(ai) ? inicioj(ai)) = tpi (3.8)

? Atividade elástica Uma atividade elástica ai pode ser realizada a níveis variáveis de in-

tensidade, de forma que o tempo de execução difere do tempo de processamento em razão

dessa variabilidade. É possível caracterizá-la pelo conjunto IFP(ai) = {{inicioj(ai); fimj(ai);
produtividadej(ai)} : j ? [1,rodadas(ai)]} representando os trios de início, ?m e produtivi-
dade das rodadas necessárias à execução de ai. Ele difere da caracterização de IF(ai) apenas

2Denominada release date em inglês.
3Denominada deadline em inglês.



44 ESCALONAMENTO BASEADO EM RESTRIÇÕES 3.1

na última relação:

rodadas(ai)?
j=1

(fimj(ai) ? inicioj(ai)) ?produtividadej(ai) = tpi (3.9)

Convém observar que cada variável produtividadej(ai) representa uma fração no intervalo

real (0, 1], algo que pode parecer contraditório com a manipulação de domínios discretos e

?nitos em PSRs. Contudo, os valores atribuídos a cada uma dessas variáveis depende da forma

com que cada rodada expropria níveis discretos da capacidade dos recursos empregados em

sua execução ? conforme descrito adiante. Dessa forma, os níveis de produtividade de cada

rodada não variam arbitrariamente, mas em partições discretas da capacidade dos recursos

dos quais dependem. Em última análise, essas variáveis não representam decisões em si, mas

sim propriedades advindas das decisões discretas que determinam cada solução possível.

Além dessa tipologia de atividades, em alguns casos é necessário ponderar pela ocorrência ou não

de cada atividade ai tida como opcional por meio de uma variável booleana adicional ocorrencia(ai).

E tanto esta quanto as outras propriedades das atividades podem ser empregadas para a de?nição

de restrições entre entidades distintas. Portanto, o nível de generalização necessário a duas caracte-

rísticas das atividades do conjunto A leva a seis possibilidades de classi?cação para cada problema

de escalonamento ? interessando-nos classi?car cada um no nível mais especí?co possível para o

benefício de uma resolução mais e?ciente.

Caracterização do Conjunto de Recursos

Conforme observado anteriormente, a alocação de uma atividade a um recurso interessa à mo-

delagem na medida em que reduz a possibilidade de execução de outras atividades. Essa alocação

tanto pode ser de?nida a priori quanto decidida a partir de um conjunto de recursos disponíveis em

que cada um possa satisfazer à necessidade da atividade, sendo possível que uma atividade dependa

de diferentes recursos por diferentes critérios. As limitações dos recursos dizem respeito aos seus

estados e capacidades.

Estado dos recursos A cada recurso rj podem ser atribuídos diversos tipos de estado. Sendo ek
um desses tipos e Ek o conjunto de estados possíveis a esse tipo, é possível expressar a necessidade de

que uma atividade ai dependa do estado ek ? Ek atribuído ao tipo de estado ek do recurso rj durante
sua execução por meio da restrição ek(rj,ai) = ek. Por meio do estabelecimento dessa restrição,

evita-se que um mesmo recurso seja empregado simultaneamente por atividades que exijam estados

diferentes de um mesmo tipo ? o que torna seus períodos de execução mutuamente excludentes.

No caso em que mais de um recurso possa satisfazer a exigência de uma determinada atividade, a

restrição pode ser generalizada como sendo ek(Ri,ai) = ek para um conjunto Ri ? R de recursos
que possam satisfazer à demanda da atividade ai. Nesse caso, ao menos um recurso rj ? Ri deve
satisfazer a restrição ek(rj,ai) = ek para que a restrição ek(Ri,ai) = ek seja satisfeita. Além da

exclusividade temporal de diferentes estados limitarem o uso do um recurso, a transição entre

esses estados pode tomar tempo e incorrer em custos à solução. Para representar essa situação,

à declaração de um tipo de estado ek pode estar associada a uma função de tempo de transição

t : Ek×Ek ? N que mapeia cada transição possível entre estados do tipo ek. De forma similar e para



3.1 MODELAGEM E PARADIGMAS DESCRITIVOS 45

efeito na função objetivo, é possível de?nir uma função de custo de transição c : Ek ×Ek ? R. De
certa forma, no entanto, o mapeamento e a consequente restrição de estados possibilita um controle

no modelo que acaba por ser mais qualitativo do que quantitativo por não impedir a concorrência

de uma quantidade arbitrária de atividades com mesma con?guração de estados no recurso.

Capacidade dos recursos Para um controle quantitativo mais apurado da concorrência nos

recursos, a modelagem deve focar a capacidade em vez do estado dos mesmos. A respeito da capaci-

dade, os recursos podem ser de?nidos gradativamente como disjuntivos, cumulativos ou reservatórios

em razão do limite de concorrência de atividades:

? Recurso disjuntivo Um recurso disjuntivo pode ser usado por apenas uma atividade por vez.

Para um recurso rj e uma atividade ai, a restrição capacidade(rj) = 1 de?ne essa limitação

unitária de concorrência no recurso; e a restrição demanda(rj,ai) = 1 ou demanda(Ri,ai) = 1

que a atividade ai exige o emprego em caráter temporal exclusivo do recurso rj ou algum

recurso de Ri, respectivamente.

? Recurso cumulativo Um recurso cumulativo pode ter mais de uma atividade sendo realizada

ao mesmo tempo, sendo que diferentes atividades podem exigir diferentes níveis de capacidade

do recurso. Nesse caso, o controle de concorrência em um recurso rj é generalizado pela

restrição capacidade(rj) = kj para um valor de capacidade kj ? 1. O mesmo se opera no
caso da atividade: a restrição demanda(rj,ai) = kij de?ne um valor de capacidade kij ? 1
requerida à execução da atividade ai no recurso rj. Dessa forma, a concorrência de atividades

no recurso é limitada pelo nível de capacidade requerido pelas mesmas contra o nível máximo

possível ao recurso.

? Recurso reservatório Um recurso reservatório representa uma generalização do conceito de

capacidade pela manipulação de um montante que varia em função de eventos das atividades

associadas ao recurso. Em vez de uma capacidade ?xa do recurso rj e uma demanda simultânea

à execução de uma atividade ai, de?ne-se a capacidade como uma função capacidade(rj) : T ?
N sobre o domínio temporal T . Essa função varia a partir de um valor de capacidade inicial
capacidade0(rj) em decorrência de acréscimos ou decréscimos de unidades de capacidade pelas

restrições producao(rj, t) = ki e consumo(rj, t) = ki, respectivamente, para uma quantia

de ki unidades de variação e t = inicio(ai) ou t = fim(ai) para alguma atividade ai. A

partir dessa formalização, o valor de capacidade(rj) pode ser restrito a um determinado valor

em um dado instante ou em todo o seu domínio. Por exemplo, podemos de?nir a restrição

capacidade(rj) ? Mj para limitar superiormente a capacidade do recurso rj em Mj unidades
a todo instante.

Com relação à forma de execução, a contemplação de atividades elásticas pode levar ao uso de quan-

tidades fracionárias da capacidade dos recursos. Entretanto, essa possibilidade não será explorada

explicitamente devido ao propósito meramente introdutório do texto.

Limites à Caracterização por Atividades e Recursos

Uma das di?culdades do emprego dessa notação explícita envolvendo atividade e recursos de-

corre da combinação de possibilidades descritas anteriormente. Por exemplo, um recurso pode ter



46 ESCALONAMENTO BASEADO EM RESTRIÇÕES 3.1

uma relação de estado e capacidade com uma atividade, que por sua vez pode ou não ter sua

execução dividida em rodadas. Isso se torna bem claro no caso do manual da Dynadec (2009):

contemplar todas as combinações possíveis leva a uma listagem bastante extensa de possibilidades.

Em decorrência desse tipo de limitação que di?culta um emprego elegante dessas relações, a seguir

discutimos a representação por variáveis de intervalo.

3.1.2 Caracterização por Variáveis de Intervalo

A representação de modelos de EBR por variáveis de intervalo foi introduzida por

Laborie e Rogerie (2008) como uma alternativa de modelagem que privilegia a representação de

atividades opcionais, mesmo em problemas em que elas não ocorreriam explicitamente. Essa repre-

sentação parte do trabalho iniciado por Laborie (2003b), que estendeu problemas envolvendo apenas

a relação entre variáveis temporais tratada por Vilain et al. (1990) para a inclusão de peculiarida-

des de recursos nos modelos. Em muitos aspectos, o intervalo corresponde em suas propriedades à

noção previamente de?nida de atividade. Entretanto, ele difere na forma de manipulação ao ponto

de também poder caracterizar recursos em alguns casos. Isso se explica pelo estímulo ao emprego

corriqueiro de intervalos opcionais por ser possível representar explicitamente cada combinação de

alocação de uma atividade a um recurso por uma variável distinta, de forma que as especi?cidades

de cada combinação de alocação possam ser tratadas separadamente. E naqueles pontos em que

tal correspondência entre intervalos e atividades ou recursos não seja possível, elementos adicio-

nais foram propostos por Laborie et al. (2009) para complementação. O benefício alegado para essa

abordagem consiste na facilidade de modelar uma gama maior de problemas de escalonamento e

na consequente possibilidade de realizar uma propagação mais e?ciente sobre as restrições estabe-

lecidas. Dessa forma, a representação por variáveis intervalares se apresenta como uma alternativa

de modelagem tão desvencilhada quanto possível da caracterização convencional por atividades e

recursos sem, contudo, deixar de se bene?ciar dos mecanismos de resolução pré-existentes.

Propriedades das Variáveis de Intervalo

Para uma introdução aos pontos mais relevantes da formulação por variáveis de intervalo, con-

sideremos o conjunto V = {v1, . . . ,vn} de variáveis intervalares. Cada variável intervalar vi repre-
senta uma organização estruturada de decisões interdependentes. Algumas delas são de?nidas a

partir de propriedades análogas àquelas que caracterizam atividades, como inicio(vi), fim(vi) e

ocorrencia(vi); além da propriedade duracao(vi) = fim(vi) ? inicio(vi), explicitada como forma
de controlar diretamente o tempo de duração e intensi?car a propagação entre as variáveis consti-

tuintes do intervalo. Dessa forma, de?ne-se que uma variável de intervalo vi representa um evento

programado se o predicado ocorrencia(vi) for satisfeito, e sua extensão temporal é representada

pelo intervalo [inicio(vi),fim(vi)).

Restrições entre Variáveis de Intervalo

De acordo com Laborie e Rogerie (2008), as propriedades previamente elencadas já permitem

estabelecer uma estrutura de propagação local. Essa estrutura se dá tanto em termos de restrições

lógicas relativas à ocorrência quanto de restrições temporais envolvendo as propriedades de início ou

?m, ambas estabelecidas entre pares de variáveis intervalares distintas. No caso de restrições lógicas,



3.1 MODELAGEM E PARADIGMAS DESCRITIVOS 47

temos restrições como ocorrencia(vi1 ) ? ¬ocorrencia(vi2 ), que estabelecem relações diretas entre
os domínios booleanos de ocorrência das variáveis. No caso de restrições temporais, temos restrições

como fim(vi1 )+ki1i2 ? inicio(vi2 ), que estabelecem relações entre pares de propriedades de variáveis
distintas.

Para o caso de interdependências envolvendo uma quantidade arbitrária de variáveis intervalares,

algumas restrições globais podem ser empregadas para estabelecer uma hierarquia entre as decisões

do modelo. Para uma variável de intervalo vi e um conjunto de variáveis intervalares V
? ? V\{vi},

temos os seguintes exemplos:

? span4 A restrição span(vi,V
?) de?ne que a ocorrência de vi está condicionada à ocorrência

de ao menos uma variável v? ? V ?; e que o início e o ?m de vi coincidem, respectivamente,
com o menor e o maior valor de início e ?m de alguma variável do conjunto V ?. Dito de outra

forma, temos as seguintes relações:

ocorrencia(vi) ? (?v? ? V ? : ocorrencia(v?)) (3.10)

ocorrencia(vi) ? [(inicio(vi) ? inicio(v?) ?v? ? V ?) ? (?v? ? V ? : inicio(v?) = inicio(vi))]
(3.11)

ocorrencia(vi) ? [(fim(vi) ? fim(v?) ?v? ? V ?) ? (?v? ? V ? : fim(v?) = fim(vi))] (3.12)

? alternative A restrição alternative(vi,V
?) de?ne que apenas uma variável v? ? V ? pode

ocorrer e que seus valores coincidem com os de vi. Isso pode ser expresso compactamente pela

seguinte relação:

ocorrencia(vi) ? [?v? ? V ? : ocorrencia(v?)?(¬ocorrencia(v??) ?v?? ? V ?\{v?})?span(vi,{v?})]
(3.13)

Estruturas Complementares às Variáveis de Intervalo

O mapeamento de outras características dos recursos é feito por meio de elementos complemen-

tares de?nidos a partir de variáveis de intervalo. Entre esses elementos, encontram-se sequências,

funções cumulativas e funções de estado.

Sequência Uma sequência representa uma permutação de um conjunto de variáveis de intervalo.

De modo mais especí?co, seja s uma variável de sequência sobre um conjunto Vs de variáveis

intervalares, então seu domínio é de?nido como sendo todas as possíveis funções bijetoras ? : Vs ?
[1, |Vs|], cada uma estabelecendo um sequenciamento distinto das variáveis pertencentes a Vs. Em
primeira instância, sequências interessam à modelagem pela possibilidade de estabelecer a restrição

no-overlap(s), que impede a sobreposição de intervalos e força sua ocorrência na ordem de sequência

4Ao contrário de outras terminologias, a nomenclatura de restrições globais difundidas na literatura como alldif-
ferent, span, alternative, always-in, always-nostate e always-constant foi preservada em inglês ao longo do texto para
evitar a criação de termos desnecessários e que possam di?cultar a consulta à literatura.



48 ESCALONAMENTO BASEADO EM RESTRIÇÕES 3.2

das variáveis. Opcionalmente, a restrição pode ser estabelecida pela sintaxe no-overlap(s,t) para

uma função de tempo de transição t : Vs × Vs ? N que de?ne o tempo mínimo entre o ?m e o
início de intervalos consecutivos na sequência determinada. Formalmente, essa última de?nição da

restrição corresponde ao seguinte conjunto de relações:

fim(vi) + t(vi,vj) ? inicio(vj) ?vi,vj ? Vs : ?(vi) &amp;lt;?(vj) (3.14)

Dessa forma, sequências correspondem à representação de recursos disjuntivos na caracterização

por variáveis de intervalo.

Função cumulativa Uma função cumulativa representa uma quantia discreta que varia ao longo

do tempo em função de eventos relacionados às variáveis de intervalo. Dessa forma, com base em

um domínio temporal T , ela pode ser representada por uma função f : T ? N. A variação no
valor de f se dá em níveis discretos, i.e., por ?saltos? instantâneos decorrentes de acréscimos ou

decréscimos da quantia representada por meio de coe?cientes associados aos eventos de início e/ou

?m de determinadas variáveis intervalares. A natureza dessa variação pode ser de duas formas

elementares ? por degrau ou pulso:

? Função degrau O termo degrau(t,k) representa uma função com valor 0 no domínio (??, t)
e valor k no domínio [t, +?), sendo t = inicio(vi) ou t = fim(vi) para alguma variável de
intervalo vi.

? Função pulso O termo pulso(t1, t2,k) representa uma função com valor 0 no domínio

(??, t1), valor k no domínio [t1, t2) e valor 0 no domínio [t2, +?), sendo t1 = inicio(vi)
e t2 = fim(vi) para alguma variável de intervalo vi.

A partir desses termos, é possível de?nir funções cumulativas compostas como f =

degrau(inicio(v1), 1) ? degrau(fim(v2), 1). E sobre essas funções, é possível estabelecer restri-
ções gerais de valor, como f ? 0; ou restrições especí?cas ao domínio sobre um intervalo, como
always-in(f,v1, 0, 1), que restringe o valor da função f durante a ocorrência do intervalo v1 aos

valores no domínio [0, 1]. Ainda é possível que a variação dos termos elementares se dê por uma

variável inteira em vez de uma constante. Dessa forma, por meio de funções cumulativas é possível

representar desde recursos disjuntivos até recursos reservatórios.

Função de estado De maneira análoga à caracterização de estado para recursos na seção 3.1.1,

a função de estado representa um equivalente qualitativo das funções cumulativas. Dessa forma,

a de?nição da função de estado difere da função cumulativa por não explicitar uma composição.

No máximo, ela admite uma função de transição para estabelecer o tempo mínimo entre estados

consecutivos. Assim sendo, a variação dos estados é completamente determinada pela imposição de

restrições tanto da forma always-in como de outras similares: always-nostate(f,vi) para estabelecer

que a função f não está de?nida durante a ocorrência do intervalo de vi, always-constant(f,vi)

para estabelecer que a função f não varie de estado a despeito de qual ele seja durante o intervalo

de vi etc. A despeito do estado acabar por ser representado por uma quantidade, o que importa

na modelagem por funções de estado é que o domínio seja discreto e a representação por valores

inteiros atende a esse critério. Em suma, a função de estado acaba por exercer papel similar às

propriedades de estado do recurso.



3.2 ELEMENTOS COMPLEMENTARES DE RESOLUÇÃO 49

3.2 Elementos Complementares de Resolução

A resolução de problemas no EBR costuma apresentar algumas peculiaridades que o diferem

do que foi apresentado anteriormente para o caso geral da PR. Enquanto que a PR genérica tem

uma aplicação mais e?caz no caso de problemas com domínios reduzidos, o mesmo não pode ser

dito dos problemas do EBR em razão do tamanho dos domínios temporais geralmente envolvidos.

Naquele caso, a situação é propícia para que a propagação possa operar com impacto signi?cativo na

redução do espaço de busca e que a rami?cação por partição dos domínios seja e?caz em explorar as

possibilidades remanescentes. No presente caso, não se espera uma redução signi?cativa de domínios

temporais em razão de seu tamanho e da baixa restritividade. Por consequência, o esforço necessário

à garantia de que todas as reduções possíveis foram obtidas passa a ser questionável. Isso re?ete

em duas decisões de projeto importantes no caso do EBR:

? a rami?cação não se dá por partição de domínios temporais, mas pela ordenação relativa entre

as variáveis temporais, de forma que a posição absoluta seja determinada de acordo com a

função objetivo;

? os algoritmos de ?ltragem são projetados visando e?ciência para reduzir ao máximo o espaço

de busca na primeira aplicação, nem sempre sendo aplicados repetidamente para convergir a

um ponto ?xo de consistência.

Essas decisões de projeto estabelecem uma via dupla entre propagação e busca que torna funda-

mental analisar esses elementos de modo integrado. A forma diversa de rami?cação da busca acaba

por impactar na forma com que a propagação opera para prover suporte, pois é mais bené?co que

exista um alinhamento entre a forma que o espaço de busca é explorado e que a propagação opera

para reduzi-lo. E o mesmo se dá no sentido inverso: se limitada, a forma com que a propagação

opera deve atentar às rami?cações que a busca provavelmente fará na sequência para torná-la mais

e?caz. Dessa forma, considerar a propagação e a busca de forma integrada no caso do EBR é fun-

damental em razão das especi?cidades que foram observadas e das escolhas pertinentes ao projeto

dos resolvedores que elas causaram.

A apresentação que se segue descreve mecanismos de propagação relacionando-os à busca. Em

razão da variedade de tipos de algoritmos de propagação e de busca, o detalhamento considera

apenas alguns dos mais elementares ou mais amplamente aceitos de acordo com referências como

Baptiste et al. (2001), Laborie (2003a), Baptiste et al. (2006) e Vilím (2007). O tratamento terá

um foco muito maior na propagação do que na busca em decorrência da relativa abundância de

abordagens e da consolidação da teoria relativa ao primeiro desses elementos, o que evidencia seu

grau de importância na resolução. Dessa forma, as considerações ?nais sobre a busca contemplam

apenas o que é alheio à propagação.

3.2.1 Propagação

A propagação de restrições no escalonamento ? sobretudo aquela envolvendo restrições globais ?

representa uma das áreas de maior estudo no desenvolvimento de procedimentos de resolução para

o EBR. Por um lado, existem estruturas entre pares de variáveis que podem ser aproveitadas em

mecanismos de propagação localizada por meio de algoritmos de ?ltragem bastante e?cientes. Por

outro lado, restrições globais emergem com facilidade nos modelos e a propagação sobre estruturas



50 ESCALONAMENTO BASEADO EM RESTRIÇÕES 3.2

com maior interdependência é sempre preferível devido ao maior poder de redução do espaço de

busca. De modo semelhante aos níveis de consistência para restrições genéricas, restrições globais

de escalonamento possuem tipos variados de consistência ? mas não necessariamente com alguma

relação de nível estabelecida entre si. Dessa forma, incorre um questionamento ainda mais amplo que

no caso geral da PR sobre a de?nição dos melhores tipos de consistência e algoritmos de ?ltragem

associados.

Propagação Local

A propagação localizada em problemas de escalonamento opera sobre redes booleanas e tem-

porais ? as primeiras relativas às variáveis de ocorrência de determinados eventos e as segundas

relativas às restrições entre o início e o ?m de eventos distintos. Essas redes correspondem a grafos

orientados restringindo de modo conjugado o domínio das variáveis associadas. A respeito da con-

sistência completa nessas redes, é observado por Laborie e Rogerie (2008) que ela pode ser obtida

e?cientemente em modelos binários se isolado cada caso, mas certas formas de integração dos dois

tipos é su?ciente para tornar o tipo de problema resultante NP-Completo.

Redes booleanas O caso mais simples de PSR consiste naquele em que o domínio das variáveis

é binário, sendo denominado de problema de satisfabilidade ou simplesmente SAT. Quando as

relações se limitam apenas a pares de variáveis, temos um 2-SAT. O 2-SAT pode ser resolvido

e?cientemente pela construção de um grafo em que cada vértice representa uma atribuição de um

valor a uma variável e cada aresta uma restrição pela combinação de atribuições que não podem

ocorrer simultaneamente; de forma que o problema não possui solução se, e somente se, houver

um caminho entre os vértices das duas atribuições possíveis a uma variável ? o que acarreta uma

contradição lógica. Quando as relações incluem um número maior de variáveis, Cormen et al. (2002)

observa que é sempre possível reduzi-lo a um 3-SAT ? i.e., a um problema de domínios binários

envolvendo restrições entre até 3 variáveis. De qualquer forma, ele já se torna um problema NP-

Completo no caso geral. No entanto, algumas referências apontam que a decomposição de restrições

em relações booleanas ainda sim pode ser proveitosa. Por exemplo, Brafman (2001) aponta que a

decomposição de alguns problemas de planejamento em relações booleanas leva a modelos nos quais

a maior parte das restrições envolve até duas variáveis. Por essa razão, Brafman (2001) explora o

desenvolvimento de mecanismos de propagação que simpli?quem as restrições não-binárias restantes

para torná-las menores em tamanho e quantidade, de forma que seja viável que a busca opere por

?tentativa-e-erro? na rami?cação das variáveis envolvidas nas restrições remanescentes desse tipo.

Redes temporais A propagação isolada em redes temporais consegue obter frequentemente a

consistência completa da rede de modo e?ciente devido a premissas observadas na manipulação de

marcas de tempo no EBR. Conforme evidencia Baptiste et al. (2006), uma das características mais

peculiares da propagação em redes temporais é que ela opera sobre os limites do domínio e não

sobre cada valor do mesmo. Dois fatores pesam em favor dessa decisão de projeto:

? domínios temporais costumam ser muito maiores do que aqueles em que a consistência sobre

cada valor é aplicada, di?cultando a aplicação desse tipo de algoritmo de ?ltragem;

? boa parte das restrições empregadas entre variáveis temporais invalida as fronteiras do domínio

e não pontos especí?cos em seu interior, de forma que o esforço necessário para contemplar a



3.2 ELEMENTOS COMPLEMENTARES DE RESOLUÇÃO 51

remoção de valores individuais internos em domínios que são notadamente amplos acaba por

não compensar.

Além disso, outro aspecto que caracteriza os algoritmos de ?ltragem em redes temporais é o fato de

que a relação entre variáveis temporais costuma ser binária por expressar o posicionamento relativo

entre determinados eventos. Dessa forma, é possível representar, com relativa precisão, uma rede

de relações temporais através do Problema Temporal Simples (PTS)5.

O PTS consiste em um conjunto de variáveis temporais X = {x1, . . . ,xn} associadas, respecti-
vamente, ao conjunto de domínios contínuos D = {[li1, ls1], . . . , [lin, lsn]} delimitando inferior e su-
periormente cada variável e um conjunto de restrições entre pares de variáveis R = {ri1i2 (xi1,xi2 ) ?
(ai1i2 ? xi1 ? xi2 ? bi1i2 ),xi1 ? X,xi2 ? X} que estabelece limites superiores e inferiores para a
diferença entre o valor de alguns pares de variáveis temporais em X. A vantagem dessa represen-

tação se deve à proposição de ?ltragem do PTS por meio de algoritmos para caminhos de custo

mínimo por Cesta e Oddi (1996), visto que as restrições em R possibilitam estabelecer o menor e o

maior tempo de alocação de qualquer variável xi ? X através de duas aplicações daquele algoritmo.
Na primeira aplicação, obtém-se o tempo mínimo de alocação de cada variável xi como sendo a

distância mínima da origem ao vértice que a representa a partir de um grafo com uma origem ?ctícia

no tempo 0, custo da aresta entre essa origem ?ctícia e o vértice de cada variável xi dado pelos

limite inferior de domínio lii, e custo da aresta entre vértices cujas variáveis possuem uma restrição

ri1i2 dado em um sentido como ai1i2 e no outro sentido como bi1i2. Na segunda aplicação, o tempo

máximo de alocação de cada variável xi é obtido como a negação da distância mínima entre o vértice

representante e um destino ?ctício no tempo 0, sendo o custo da aresta entre o destino e o vértice de

cada variável vi dado pela negação do limite superior, ?lsi, e o custo da aresta entre vértices cujas
variáveis possuem uma restrição ri1i2 dado em um sentido como ?ai1i2 e no outro sentido como
?bi1i2. Por ?m, sendo mantida a representação que gerou os novos limitantes, é possível atualizar
esses limites com base em decisões de rami?cação ao longo do processo de busca.

Propagação Global

A propagação global no EBR costuma depender, direta ou indiretamente, da ordenação relativa

das variáveis temporais e nem sempre se opera de forma completa. O primeiro desses fatores decorre

em parte do motivo já discutido pelo qual a propagação temporal se dá apenas nos limites do

domínio: a dimensão dos domínios é relativamente maior e a determinação dos limites é mais

signi?cativa do que a eliminação de valores especí?cos. Além disso, Laborie (2003a) destaca que

a frequência com que restrições de precedência temporal ocorrem em modelos de EBR torna sua

manipulação fundamental à obtenção de um melhor desempenho na resolução. No entanto, essa

tendência foi se estabelecendo de maneira gradativa: primeiro pela de?nição de tipos de consistência

a partir de hipóteses de ordenação das variáveis e depois pela manipulação explícita dessa ordenação.

Com relação ao segundo fator, a amplitude dos domínios também representa um argumento contra

a convergência da consistência a ponto ?xo, i.e., a aplicação repetitiva dos algoritmos de ?ltragem

para garantir a consistência de?nida, que pode ser necessária se uma modi?cação de domínio induzir

outras modi?cação para aquele nível de consistência. Conforme elencado no princípio da seção 3.2,

uma vez que essas reduções vão se tornando cada vez menos signi?cativas e que o espaço de busca

5Denominado Simple Temporal Problem (STP) em inglês.



52 ESCALONAMENTO BASEADO EM RESTRIÇÕES 3.2

é muito amplo, vale mais à pena direcionar a propagação em função do processo de busca e limitar

sua execução em razão do benefício esperado. Dessa forma, a apresentação de alguns dos tipos de

consistência mais empregados e conhecidos feita a seguir segue o avanço dessa tendência ao longo

dos anos, desde a veri?cação completa de posições absolutas no tempo até o emprego de veri?cações

incompletas e das relações de precedência como subsídio à propagação. A apresentação é organizada

com base em Laborie (2003a) e Baptiste et al. (2006), mas é sintetizada pelo agrupamento de tipos

similares de propagação.

Propagação por tabela de tempos A tabela de tempos6 consiste na propagação pela manipu-

lação de dados absolutos sobre a utilização e disponibilidade dos recursos ao longo do tempo. Dessa

forma, ela serve a uma propagação da disponibilidade por duas vias: tanto de como a disponibili-

dade do recurso impacta no domínio de programação da atividade quanto de como a programação

da atividade impacta na disponibilidade do recurso. A relação a ser observada entre a alocação dos

recursos e a programação das atividades ao longo do tempo é a seguinte:

?
i:inicio(ai)?t&lt;fim(ai),i?[1,n]

demanda(rj,ai) ? capacidade(rj) ?t ? T,j ? [1,m] (3.15)

Propagação disjuntiva e energética As modalidades de propagação disjuntiva e energética

inferem reduções dos domínios temporais a partir da constatação de impossibilidade de concorrência

entre um par de atividades por um determinado recurso.

? Disjuntiva A propagação disjuntiva representa o caso mais simples das duas, no qual a

redução de domínios é obtida pela inferência de uma posição relativa entre as atividades.

Dito de outra forma, uma atividade deve ser concluída antes do início da outra para qualquer

par de atividades (ai1,ai2 ) associadas a um mesmo recurso disjuntivo, conforme a seguinte

relação:

Dis(ai1,ai2 ) ? [fim(ai1 ) ? inicio(ai2 )] ? [fim(ai2 ) ? inicio(ai1 )] (3.16)

? Energética A propagação energética representa uma generalização desse conceito a partir de

demandas arbitrárias para o caso do recurso ser cumulativo em vez de disjuntivo:

[demanda(rj,ai1 ) + demanda(rj,ai2 ) ? capacidade(rj)]?

Dis(ai1,ai2 ) ?j ? [1,m], i1 e i2 ? [1,n], i1 6= i2
(3.17)

Dessa forma, a propagação disjuntiva corresponde ao caso no qual as demandas e a capacidade são

todas unitárias.

Propagação por busca e ausência de arestas Devido à tendência em manipular a ordenação

relativa das atividades na resolução, uma das modalidades mais exploradas de propagação consiste

na análise dessa ordenação entre todas as atividades. Ela representa uma generalização do caso

anterior pela manipulação de uma quantidade arbitrária de atividades por meio da de?nição de

propriedades análogas àquelas de?nidas para cada atividade: para um conjunto de atividades ?,

seja dl? = mini:ai??(dli) a data de liberação, dc? = maxi:ai??(dci) a data de limite de conclusão e

6Denominada timetable em inglês.



3.2 ELEMENTOS COMPLEMENTARES DE RESOLUÇÃO 53

tp? =
?

i:ai??(tpi) o tempo de processamento a plena capacidade do conjunto de atividades ? ? A.
Tal ordenação conjunta pode ser vista como um grafo direcionado denominado grafo de precedências,

sendo cada atividade associada a um vértice e cada aresta orientada representando uma relação de

precedência entre atividades cuja ordem relativa é determinada. Para ?ns de notação, as expressões

ai1 ? ai2 e ai2 ? ai1 denotam ambas que a atividade ai1 deve ser executada antes da atividade
ai2. Dessa representação surgem duas modalidades comuns de propagação:

? Busca de arestas7 Na busca de arestas, o objetivo é inferir novas arestas no grafo de prece-

dências a partir das janelas de execução das atividades. Tal inferência opera entre um conjunto

de atividades ? e uma outra atividade ai /? ?, de forma a estabelecer se ai pode ou não ser a
primeira ou última atividade a ser executada no conjunto ? ?{ai}. Nesse contexto, temos as
seguintes relações de inferência possíveis entre as propriedades e a ordem relativa:

?? ? A ?ai ? A\ ? [dc??{ai} ?dl? &amp;lt;tp? + tpi] ? [ai ? ?] (3.18)

?? ? A ?ai ? A\ ? [dc? ?dl??{ai} &amp;lt;tp? + tpi] ? [ai ? ?] (3.19)

Na primeira relação, infere-se que ai precede as demais atividades em ? pela impossibilidade

de principiar a execução de ? ?{ai} com alguma atividade de ? e concluir antes da data
limite do conjunto ??{ai}. Na segunda relação, infere-se que ai sucede as demais atividades
em ? pela impossibilidade de concluir a execução de ? ?{ai} com alguma atividade de ?
devido à data limite do conjunto ? ?{ai}. No sentido inverso, a ?xação de uma relação de
ordem entre uma atividade e um conjunto reduz o domínio de alocação temporal da atividade

de acordo com as seguintes relações:

?? ? A ?ai ? A\ ? [ai ? ?] ? [fim(ai) ? min
?6=????

(dc?? ? tp??)] (3.20)

?? ? A ?ai ? A\ ? [ai ? ?] ? [inicio(ai) ? max
?6=????

(dl?? + tp??)] (3.21)

A despeito da existência de O(n2n) pares do tipo (ai, ?) para |A| = n, Baptiste et al. (2006)
observa que existe uma relação de dominância de propagação entre subconjuntos de A, de

forma que não mais do que O(n2) dessas tuplas são necessárias para garantir esse tipo de

propagação. O primeiro algoritmo de ?ltragem adotado para propagação por busca de arestas

em recursos disjuntivos foi extraído dos cortes propostos por Carlier e Pinson (1994) para

reduzir o tempo de resolução do Problema de Escalonamento de Chão-de-Fábrica (PEC) e

tinha complexidade de tempo O(nlog(n)). Outros algoritmos foram propostos em sequência,

notadamente um de implementação mais simples mas complexidade O(n2) por Baptiste et al.

(2001) e outro de complexidade O(nlog(n)) ? porém sem convergência da consistência a ponto

?xo ? por Vilím (2007).

? Ausência de arestas8 A propagação por ausência de arestas representa uma generalização

da busca de arestas pela inferência reversa de quais atividades não podem ser a primeira ou a

7Denominada edge-?nding em inglês.
8Denominada not-?rst / not-last em inglês.



54 ESCALONAMENTO BASEADO EM RESTRIÇÕES 3.2

última na execução de um conjunto. Dessa forma, a inferência de uma aresta posicionando uma

atividade ai com relação a um conjunto de atividades ? na busca de arestas é equivalente à

inferência da ausência de |?| possíveis arestas posicionando cada atividade a?i ? ? com relação
ao conjunto ? ?{ai}. Apresentando um tempo maior de execução, a redução dos domínios
resultante desse tipo de propagação domina a propagação por busca de arestas. As reduções

inferidas por esse tipo de propagação são as seguintes:

?? ? A ?ai ? A\ ? [dci ?dl? &amp;lt;tp? + tpi] ? [fim(ai) ? max
i???

(dci? ? tpi?)] (3.22)

?? ? A ?ai ? A\ ? [dc? ?dli &amp;lt;tp? + tpi] ? [inicio(ai) ? min
i???

(dli? + tpi?)] (3.23)

No primeiro caso, infere-se que ai não pode ser a última atividade a ser executada por não ser

possível executar o conjunto ? ?{ai} entre o tempo de liberação dl? e o tempo de conclusão
dci, de forma que a conclusão de ai deve preceder o início de execução de ao menos uma

atividade de ?. No segundo caso, infere-se que ai não pode ser a primeira atividade a ser

executada por não ser possível executar o conjunto ? ?{ai} entre o tempo de liberação dli
e o tempo de conclusão dc?, de forma que o início de ai deve suceder a conclusão de ao

menos uma atividade de ?. Baptiste et al. (2006) e Vilím (2007) observam que os algoritmos

de ?ltragem existentes relevantes a esse tipo de propagação possuem complexidade de tempo

O(n2) no pior caso.

Precedência energética e balanceamento As modalidades de propagação por precedência

energética e por balanceamento foram propostas por Laborie (2003a) como uma forma de valer-

se explicitamente das precedências entre atividades para obter uma redução mais expressiva dos

domínios, em especial no caso em que os domínios temporais das atividades são bastante folgados.

? Precedência energética A propagação por precedência energética infere a postergação do

início de uma atividade ai em razão da demanda pela capacidade de recursos de todas as

atividades que a precedam. Sendo esse conjunto de atividades precedentes a ai representado

como ?, temos a seguinte relação:

[ai ? ?] ? [inicio(ai) ? dl? +
?

i?:ai???
(demanda(rj,ai?) × tpi?)
capacidade(rj)

] ?j ? [1,m] (3.24)

Ela pode ser obtida por um algoritmo de ?ltragem apresentado em Laborie (2003a) em tempo

O(n(p + log(n))) para um conjunto de n eventos de variação da capacidade do recurso e até

p precedências para cada atividade.

? Balanceamento A propagação por balanceamento infere reduções do espaço de busca pela

estimativa de limites à capacidade de um recurso reservatório ao longo do tempo em decorrên-

cia das relações da ordenação dos eventos associados. Esses limites são de?nidos sobre cada

evento t = inicio(ai) ou t = fim(ai) de cada atividade ai ? A, e são de quatro tipos possíveis:
L&lt;min(t) para o menor valor de capacidade do recurso imediatamente antes da ocorrência de

um evento t, L&lt;max(t) para o maior valor nas mesmas circunstâncias; e L
&gt;
min(t) e L

&gt;
max(t) para

os respectivos valores equivalentes imediatamente após a ocorrência do evento t. Cada um



3.2 ELEMENTOS COMPLEMENTARES DE RESOLUÇÃO 55

desses limites é estipulado pelas combinações de maior e menor variação de capacidade em

decorrência dos eventos que alteram a capacidade do recurso e que podem ocorrer antes ou

depois de cada evento. Por meio dessas estimativas, torna-se possível promover quatro formas

de propagação:

? descobrir antecipadamente que uma determinada con?guração sendo construída na re-

solução não é viável pela carência de capacidade no recurso;

? deduzir limites mais restritos de capacidade dos recursos face às possibilidades de pro-

dução e às necessidades de consumo do reservatório;

? reduzir o domínio temporal dos eventos pela inferência de que alguns eventos devem se

posicionar antes ou após determinado evento;

? inferir novas relações de precedência entre os eventos quando o caso anterior se restringir

a uma relação entre pares de eventos.

O algoritmo de ?ltragem proposto por Laborie (2003a) para essa modalidade de propagação

possui complexidade de tempo O(n2) sem a inferência de novas relações de precedência e

O(n3) caso contrário. Por ?m, Laborie (2003a) sugere que as informações sobre o balanço

energético sejam utilizadas como subsídio às estratégias de rami?cação do EBR.

3.2.2 Busca

Conforme mencionado anteriormente, a estruturação da busca no EBR ? sobretudo por recursão

e retrocesso ? se dá em torno dos mecanismos de propagação empregados. De todo modo, os passos

gerais da busca por recursão e retrocesso no EBR consistem nos seguintes segundo Baptiste et al.

(2001):

1. Selecionar um recurso no qual as atividades não estão completamente ordenadas.

2. Selecionar uma atividade para ser executada antes das demais no recurso; ?xar a relação

de precedência entre ela e as demais; manter uma relação das atividades restantes como

substitutas no caso de retrocesso à escolha da primeira atividade no recurso.

3. Iterar sobre o passo anterior até que todas as atividades associadas estejam completamente

ordenadas no recurso.

4. Iterar sobre os passos anteriores até que as atividades estejam completamente ordenadas em

todos os recursos.

Dessa forma, as estratégias de rami?cação no EBR acabam por depender de heurísticas peculiares

a problemas de escalonamento para a ordenação de escolha dos recursos e das atividades durante

a resolução. Decerto que essa escolha não é completamente independente do tipo de propagação

sendo empregado, de forma que a variadas combinações de propagação e busca competem estratégias

diversas. Portanto, as especi?cidades de cada modelo a ser resolvido podem determinar o emprego

de combinações distintas.

Por ?m, convém observar que o caráter declarativo da PR corrobora a elaboração de algoritmos

de busca estruturados de maneira diversa. Notadamente, um dos campos mais profícuos foi o de

busca local. No resolvedor subjacente à linguagem OPL, operadores de busca local para modi?car



56 ESCALONAMENTO BASEADO EM RESTRIÇÕES 3.2

soluções de problemas de escalonamento cumulativo foram propostas em Godard e Laborie (2005) e

mecanismos adaptativos para a escolha dos operadores mais propícios em cada rodada de resolução

foram estudados em Laborie e Godard (2007). No resolvedor subjacente à linguagem Comet, o

estudo descrito em Monette et al. (2009) revela um distanciamento de heurísticas especializadas em

problemas de escalonamento para a aplicação de meta-heurísticas mais propícias a cada modelo em

razão de sua estrutura. Em ambos os casos, evidencia-se a constatação de Dechter (2003) sobre o

propósito de abordagens de busca local: resolver problemas com tamanho em ordens de grandeza

maiores do que seria possível de modo sistemático. Convém observar que essa linha de mecanismos

adaptativos para a resolução de EBRs seguida em ambos os casos já havia sido explorada por

outros autores no âmbito estrito da academia, como Carchrae e Beck (2005). A abordagem de

escolha automatizada condiz com uma linha em evidência no ambiente acadêmico em geral, para

a qual Smith-Miles (2008) provê uma revisão bastante ampla e Battiti et al. (2008) uma discussão

sobre as principais decisões de projeto envolvidas. Portanto, há um forte indicativo que essa linha

de desenvolvimento persista por algum tempo para a resolução de problemas por EBR.



Parte III

ESTUDO DE CASO

57





Capítulo 4

O Problema da Programação de

Recursos Críticos e Sua Abordagem

Recursos críticos como sondas e barcos lançadores de linhas são utilizados nas etapas sequenciais

de exploração, produção e manutenção de poços de petróleo marítimos. Informações de uma etapa

são necessárias às etapas seguintes, de forma que o desenvolvimento e a manutenção dos poços de

um reservatório são projetados a partir dos dados obtidos na etapa de exploração. A exploração é

realizada em um conjunto de localizações nas quais estudos geológicos preliminares identi?caram a

possibilidade de que existam reservas de petróleo e gás em quantidade su?ciente para que a produção

possa ser comercialmente viável. Uma vez con?rmada a existência da reserva por perfurações iniciais,

são feitos planos para a perfuração de um conjunto de poços cuja sequência de perfuração e entrada

em produção é estipulada de forma a maximizar a extração possível naquele reservatório. Alguns

poços são produtores e servem à extração de óleo e gás do reservatório, enquanto outros são injetores

e servem à inserção de água ou gás para manter a pressão de produção do poço. O estabelecimento de

cada novo poço envolve atividades de perfuração, completação e interligação. Ao ?nal da perfuração,

o poço possui um revestimento externo de proteção e um duto interno para o escoamento de ?uidos.

Com a completação, instala-se um componente de controle de vazão na cabeça do poço conhecido

como Árvore de Natal Molhada (ANM). Linhas são conectadas a cada ANM, interligando-as a

uma Unidade Estacionária de Produção (UEP) na superfície ou a um manifold intermediário que

concentra o escoamento de vários poços para reduzir o número de linhas ligadas diretamente à

UEP. Por ?m, atividades periódicas de manutenção são programadas em uma janela temporal

?exível, de forma a manter a operação dos poços dentro dos patamares desejáveis. Dessa forma,

o emprego desses recursos críticos atende a necessidades bastante distintas ao longo do ciclo de

vida dos reservatórios, sendo que a limitação em sua oferta impacta diretamente as operações de

produção da companhia.

As atividades a serem realizadas pelos recursos críticos possuem prazos, relações de precedência

e características técnicas que devem ser obedecidas. Por exemplo, a profundidade na qual é empre-

endida uma atividade deve ser compatível com a faixa de profundidades permitida à operação de

um dado recurso, enquanto que este deve possuir a bordo todos os equipamentos necessários à exe-

cução daquela. Conforme observado no Capítulo 1 e no parágrafo anterior, o nível de detalhamento

dessas atividades aumenta ao longo do ciclo de vida em razão das informações previamente adqui-

ridas. Assim sendo, a programação dos recursos críticos para o desenvolvimento e a manutenção de

59



60 O PROBLEMA DA PROGRAMAÇÃO DE RECURSOS CRÍTICOS E SUA ABORDAGEM 4.2

poços marítimos possui diversas peculiaridades ignoradas quando se considera apenas a etapa de

exploração.

4.1 Decisões e Entidades Relacionadas

A programação de recursos críticos na produção pode ser vista como uma questão de decidir se,

quando e como realizar cada uma dentre várias atividades valendo-se de um conjunto de sondas e

barcos. O tempo de programação das atividades nos recursos é discretizado em dias, a partir de uma

data inicial de?nida como 0. Cada atividade de desenvolvimento está associada a uma localidade

consistindo em um poço marítimo. Algumas atividades podem exigir a instalação de linhas que, por

sua vez, devem ser carregadas previamente em um porto. Os carregamentos de linhas em portos

representam um dos tipos de atividade auxiliar necessárias à completa programação do recurso.

Outros eventos poderiam ser considerados como tipos de atividade auxiliar, como os períodos de

deslocamento e as manutenções programadas dos recursos. No entanto, a falta de liberdade sobre boa

parte desses eventos em relação aos demais faz com que eles não sejam considerados explicitamente

como decisões do problema mas apenas restrições à ocorrência dos restantes. Portanto, as principais

decisões esperadas em uma solução a este problema são as seguintes:

? a alocação de recursos a atividades de desenvolvimento;

? a de?nição do número de cargas a serem associadas a cada recurso;

? a associação de linhas a cada carga;

? a programação temporal das atividades alocadas em cada recurso.

Por convenção de notação no detalhamento do problema, cada tipo de entidade principal em-

prega um índice diferente a seguir. Recursos são representados pelo índice i, que varia entre 1 e nr.

Atividades são representadas pelo índice j, que varia entre 1 e na, sendo as primeiras np atividades

associadas ao desenvolvimento de poços e o restante a cargas em portos. Localidades são represen-

tadas pelo índice k, que varia entre 1 e nlo, sejam elas poços ou portos. Linhas são representadas

pelo índice l, que varia entre 1 e nl. Qualquer outro índice, quando necessário, será representado

por x.

Sendo o número de atividades auxiliares de carga desconhecido, o valor de na é indeterminado

a princípio. Como forma de estabelecer um limite superior ?xo, emprega-se a relação na = np + nl.

Essa relação contempla o caso extremo em que cada linha é carregada separadamente das demais,

de forma que cada atividade j ? [np + 1,np + nl] atende às restrições necessárias ao carregamento
da linha l = j ?np. Dessa feita, uma das decisões do problema passar a ser pela ocorrência ou não
de cada uma das na ?np atividades de carga resultantes.

4.2 Critérios de Otimização

O objetivo do problema da programação de recursos críticos é antecipar ganhos e reduzir custos.

No presente caso, o objetivo primário é maximizar a produção de curto prazo, de?nida como a

quantidade que cada poço irá produzir desde o dia em que é conectado até uma data limite H.

A cada atividade j é associada uma taxa de produção diária pj desde o dia em que é concluída,



4.3 RESTRIÇÕES DO PROBLEMA 61

sendo não-nula somente quando for a atividade de conclusão do desenvolvimento de um poço. Assim

sendo, atividades associadas a poços com maior produção acabam por ter prioridade na escala. No

entanto, nem todas as atividades são concluídas antes dessa data H e outras não possuem impacto

na produção independentemente do dia de conclusão. Por essa razão, um critério secundário é

empregado: a minimização da soma dos tempos de conclusão das atividades da solução. Por meio

desse critério de desempate, a conclusão das atividades nos recursos é antecipada e estes são liberados

o quanto antes. Apesar de fugir ao escopo do problema, essa antecipação representa uma redução

de gastos no caso de recursos alugados ou uma maior disponibilidade futura para atividades ainda

não previstas. Dessa forma, maximiza-se o retorno imediato associado ao emprego dos recursos

disponíveis por meio de uma con?guração que procura reduzir custos futuros.

4.3 Restrições do Problema

4.3.1 Restrições Gerais dos Recursos

? Cada recurso pode realizar apenas uma atividade por vez.

? Cada recurso i possui um período de contrato do dia ici até o dia fci, e não está disponível

fora desse período.

? Um recurso pode realizar apenas atividades que sejam compatíveis com suas características.

Temos cij = 1 se, e somente se, o recurso i e a atividade j forem compatíveis.

? Durante o período de contrato, existem indisponibilidades previstas do recurso. Tais indispo-

nibilidades representam períodos durante os quais nenhuma atividade pode ser realizada pelo

recurso. Para um recurso i, seja niri o número de indisponibilidades associadas e o par (iirix,

firix) as respectivas datas de início e ?m da x-ésima indisponibilidade do recurso i.

? Algumas indisponibilidades podem ser ?exíveis dentro de um intervalo em vez de comple-

tamente pré-determinadas, sendo dirix o tempo de duração da x-ésima indisponibilidade do

recurso i, que deve ocorrer dentro do intervalo temporal [iirix, firix].

? Certas indisponibilidades podem ser parciais, signi?cando uma restrição da capacidade do

recurso que impede a execução de algumas, mas não de todas as atividades. Seja pirix = 1

se, e somente se, a x-ésima indisponibilidade do recurso i for parcial e cirijx = 1 se, e so-

mente se, a possibilidade de realização da atividade j no recurso i for afetada em razão da

indisponibilidade x.

? Apenas um recurso por vez pode operar sobre cada poço.

? Para que um recurso realize atividades consecutivas em localidades distintas, é necessário

considerar o tempo para mover o recurso de um lugar para o outro.

? Alguns recursos não podem aproximar-se mais do que uma certa distância um do outro devido

ao risco de colisão. No entanto, essa restrição não é detalhada por falta de dados à disposição

para teste.



62 O PROBLEMA DA PROGRAMAÇÃO DE RECURSOS CRÍTICOS E SUA ABORDAGEM 4.3

4.3.2 Restrições Gerais de Execução das Atividades

? Cada atividade é realizada ininterruptamente desde seu início até a conclusão.

? Cada atividade j possui datas pré-de?nidas de início mais cedo e início mais tarde, represen-

tadas por imcj e imtj.

? Cada atividade j está relacionada a uma localidade locj.

? Para cada atividade j que não de carregamento, a duração é ?xa e dada por dj .

? Uma atividade pode ser precedida por outras, cada uma exigindo um tempo mínimo de

intervalo entre a conclusão de uma e o início da outra. Sem perda de generalidade, podemos

de?nir prcj1j2 como o tempo mínimo entre a conclusão da atividade j1 e o início da atividade

j2, sendo prcj1j2 = ?? caso não exista uma relação de precedência entre j1 e j2.

? Algumas atividades podem pertencer a um cluster, e todas as atividades de um cluster devem

ser realizadas por um mesmo recurso. Sem perda de generalidade, podemos supor que cada

atividade j está associada a um cluster de indíce clusterj, de forma que atividades pertencentes

a um mesmo cluster tenham valores iguais para esse índice e atividades que não pertencem a

nenhum cluster tenham um valor único.

4.3.3 Restrições de Estoque dos Recursos

? Todo recurso inicia suas atividades com estoque vazio.

? Cada recurso i possui uma capacidade máxima de estoque cei, que é não-nula apenas para

barcos de carregamento.

? Apenas recursos com capacidade de estoque positiva podem realizar atividades de carrega-

mento nos portos.

? Cada porto k pode receber até sk atividades de carregamento ao mesmo tempo.

? Uma atividade de carregamento realizada por um recurso i dura de mici a maci dias.

? O aumento do estoque de um recurso i devido a uma atividade de carregamento é linearmente

proporcional à sua duração, atingindo cei se durar maci dias.

4.3.4 Restrições de Estoque das Atividades

? Cada linha l está associada a uma atividade de conexão cll, na qual a linha é descarregada

do recurso.

? Para realizar a atividade de conexão de uma linha, o recurso precisa primeiramente realizar

a atividade de carregamento envolvendo a mesma linha.

? Cada linha l possui peso pll para ?ns de impacto no estoque do recurso e pode ser carregada

na base bll a partir de sua data de disponibilização dll.

? Atividades de carregamento não estão sujeitas a restrições de cluster ou precedência.



4.4 MODELAGEM POR VARIÁVEIS DE INTERVALO 63

? Uma atividade j de manutenção de linhas já instaladas pode exigir alguma capacidade dis-

ponível cdj no recurso que a realizar.

4.4 Modelagem por Variáveis de Intervalo

A abordagem de resolução do problema apresentado como estudo de caso consiste em um mo-

delo de Escalonamento Baseado em Restrições (EBR) que emprega variáveis de intervalo. Conforme

discutido no Capítulo 3, variáveis intervalares representam uma abstração para o agregado de de-

cisões interdependentes relacionado à modelagem de problemas de escalonamento por meio de uma

sintaxe que facilita a manipulação de eventos opcionais. Tal manipulação se dá através de estruturas

hierárquicas, como é o caso da relação entre uma determinada tarefa e todas as possibilidades de

realização dessa tarefa por con?gurações distintas de uso dos recursos disponíveis. Sendo nosso foco

dirigido à concepção do modelo mais adequado à resolução do problema, enfatizamos as seguintes

diretrizes como orientação às diversas decisões de projeto relativas ao desenvolvimento do modelo

que se segue:

? obter uma representação do problema correta e compacta a partir da sintaxe de modelagem

à disposição;

? reduzir o espaço de busca e intensi?car a propagação decorrente da instanciação de cada

variável de decisão;

? prover diretivas a uma exploração mais e?ciente do espaço de busca resultante do modelo.

Essas questões são debatidas ao longo da descrição do modelo na presente seção. Na sequência, a

seção 4.5 apresenta duas abordagens para estimar um limite superior ao valor ótimo de produção,

de forma a analisar a qualidade das soluções obtidas.

Boa parte das variáveis de decisão e restrições do problema de programação de recursos críticos

pode ser descrita através da sintaxe de variáveis intervalares, para a qual Laborie e Rogerie (2008)

e Laborie et al. (2009) propuseram tanto uma notação algébrica quanto grá?ca. Na descrição que se

segue, as duas modalidades de notação são adaptadas com a ?nalidade de facilitar a compreensão

do modelo sendo descrito. Convém observar que a seção A.5 do apêndice apresenta a implementa-

ção desses conceitos por meio da linguagem OPL, e um exemplo menos detalhado de abordagem

ao problema é apresentado na seção A.5.9. Pontos especí?cos dessa parte do apêndice serão re-

ferenciados conforme necessário ao longo do texto. Além disso, ressaltamos que as representações

grá?cas que complementam a descrição do modelo algébrico não ilustram explicitamente todas as

relações possíveis entre as variáveis do modelo ou os pormenores de cada um deles. A disposição de

ilustrações buscou elucidar ao menos um exemplo de cada tipo de relação do modelo e destacar os

fatores mais relevantes a cada tipo de relação como forma de transmitir visualmente a noção das

hierarquias presentes no modelo.

4.4.1 Associação entre Atividades e Recursos

Cada atividade e cada recurso do problema é representado por meio de um conjunto de variá-

veis de decisão do modelo dispostos em vetores ou matrizes. A representação mais elementar do



64 O PROBLEMA DA PROGRAMAÇÃO DE RECURSOS CRÍTICOS E SUA ABORDAGEM 4.4

conjunto de atividades se dá por meio do vetor de intervalos a, que contém uma variável de inter-

valo associada a cada atividade do modelo, sendo as propriedades de cada variável correspondentes

àquelas da atividade em si. A implementação desse conceito em OPL é descrita na seção A.5.2 do

apêndice. Como as primeiras np atividades do problema referem-se ao desenvolvimento de poços,

sua ocorrência é compulsória e isso repercurte em uma restrição de obrigatoriedade dos respectivos

intervalos:

ocorrencia(aj) = 1 ?j ? [1,np] . (4.1)

A associação entre atividades e recursos se dá pela matriz de intervalos M, que representa o produto

cartesiano dos conjuntos de recursos e atividades, de forma que cada variável mij ? M representa o
intervalo associado ao recurso i realizando a atividade j. O vetor a e a matrix M são relacionados

por restrições alternative, cuja sintaxe em OPL é descrita na seção A.5.4. Essa restrição associa

cada entrada de um vetor a uma coluna da outra matriz1, de forma que no máximo um intervalo de

cada coluna j de M ? representada por Mj ? ocorra e seus valores correspondem aos do intervalo

aj:

alternative(aj,Mj) ?j ? [1,na] . (4.2)

A representação dos eventos associados a cada recurso se dá pelo vetor de sequências r, sendo que

cada sequência ri ? r agrupa as entradas de M associadas ao i-ésimo recurso, ou seja, ri agrupa
as entradas do vetor (MT )i. A representação de sequências em OPL é descrita na seção A.5.5.

Considerando cada sequência como um conjunto dos intervalos, temos o seguinte:

ri = {mij : j ? [1,nr]} . (4.3)

De forma a prevenir que um recurso seja associado a mais do que uma atividade ao mesmo tempo,

a restrição no-overlap é associada a cada sequência ri ? r. Como argumento adicional, é de?nida
uma função de tempo de transição ti : [1,na] × [1,na] ? N entre a conclusão de um intervalo e o
início de outro em função da localização das atividades associadas e do recurso em consideração:

no-overlap(ri, ti) ?i ? [1,nr] . (4.4)

A ?gura 4.1 apresenta os conceitos anteriormente descritos para modelar a associação entre ativi-

dades e recursos, além de um dos tipos de indisponibilidade descritos adiante.

Tanto nessa ?gura quanto nas demais que se seguem são adotadas algumas convenções de nota-

ção para facilitar a compreensão do modelo. Variáveis intervalares são apresentadas como retângulos,

sendo acinzentadas se sua presença é obrigatória. Sequências são apresentadas como quadrados com

cantos arredondados e funções cumulativas como círculos, tendo ambas uma linha diagonal no pre-

enchimento interno. Restrições e composições de sequências ou funções são apresentadas por meio

de setas, sendo rotuladas pela restrição ou regra de agrupamento que de?nem. O agrupamento de

elementos é feito por retângulos mais espessos. Possíveis restrições entre intervalos de um deter-

minado agrupamento são delimintadas por retângulos pontilhados. Por ?m, conforme mencionado

anteriormente, as restrições apresentadas gra?camente representam um tipo de cada e não todas

aquelas que existem no modelo.

1 Por convenção de notação, quando necessário, um vetor formado pela j-ésima coluna de M será representado
como Mj e um vetor formado pela i-ésima linha de M será representado como (M

T )i.



4.4 MODELAGEM POR VARIÁVEIS DE INTERVALO 65

  

matriz de intervalos
opcionais M

vetor (transposto) de
intervalos mistos a 

anp anp+1 anaa1

m1nam11

mnrnamnr1

alternative vetor de 
sequências r

no-overlap
c/ transição

vetor (transposto) de 
funções cumulativas u

ui=0 em indisponibilidades totais fixas

ui= ?
j=1

na
pulso(mij ,1)

ri={mij : j?[1 ,na]}

Figura 4.1: Relação elementar entre intervalos associados a atividades e recursos.

A de?nição dos domínios temporais de programação dos intervalos e dos domínios booleanos

de alocação dos recursos é feita sobre os elementos da matriz M. Essa escolha se deve à maior

e?cácia de propagar da matriz M para o vetor a e do fato de tornar-se desnecessário o emprego de

intervalos para representar a extensão do contrato de cada recurso. A ocorrência de cada intervalo

mij depende da compatibilidade entre o recurso i e a atividade j, condicionado por cij = 1:

ocorrencia(mij) ? (cij = 1) ?i ? [1,nr],j ? [1,na] . (4.5)

O início de cada intervalo mij de desenvolvimento está sujeito tanto ao início do contrato do recurso

ici quanto à data de início mais cedo da atividade imcj:

ocorrencia(mij) ? [inicio(mij) ? MAX(ici, imcj)] ?i ? [1,nr],j ? [1,np] . (4.6)

No caso de atividades de carga, a correspondência entre cada atividade j e a linha l = j ?np leva
à substituição da data de início mais cedo pela data de disponibilização dll, de forma que temos a

seguinte restrição para o início de cada carregamento:

ocorrencia(mij) ? [inicio(mij) ? MAX(ici,dlj?np )] ?i ? [1,nr],j ? [np + 1,na] . (4.7)

De forma similar, o ?m de cada intervalo mij de desenvolvimento está sujeito tanto ao ?m do

contrato do recurso fci quanto à soma da data de início mais tarde imtj da atividade com a

duração dj da mesma:

ocorrencia(mij) ? [fim(mij) ? MIN(fci, imtj + dj)] ?i ? [1,nr],j ? [1,np] . (4.8)

No caso de atividades de carga, apenas o ?m do contrato do recurso é levado em conta:

ocorrencia(mij) ? [fim(mij) ? fci ] ?i ? [1,nr],j ? [np + 1,na] . (4.9)

Por sua vez, a duração de cada intervalo mij associado a uma atividade de desenvolvimento é ?xa



66 O PROBLEMA DA PROGRAMAÇÃO DE RECURSOS CRÍTICOS E SUA ABORDAGEM 4.4

em dj e a duração daqueles associados a atividades de carregamento varia entre os limites de tempo

de carga mici e maci do recurso:

ocorrencia(mij) ? [duracao(mij) = dj] ?i ? [1,nr],j ? [1,np] . (4.10)

ocorrencia(mij) ? [mici ? duracao(mij) ? maci] ?i ? [1,nr],j ? [np + 1,na] . (4.11)

Por ?m, as restrições de cluster são representadas por implicações lógicas entre os elementos de M,

de forma a forçar a ocorrência dos intervalos associados às atividades de um cluster em uma única

linha da matriz:

[clusterj1 = clusterj2 ] ? [ocorrencia(mij1 ) ? ocorrencia(mij2 )] ?i ? [1,nr],j1 ? [1,np],j2 ? [1,np] .
(4.12)

A ?gura 4.2 ilustra as restrições básicas de domínios temporais e de alocação do modelo para as

atividades de desenvolvimento de poços.

  

matriz de intervalos
opcionais M

m1npm11

mnrnpmnr1

ocorrencia(mij1
)?ocorrencia(mij2

)  em clusters

ocorrencia(mij)?(cij=1)
inicio(mij)?MAX (ici ,imc j)
fim(mij)?MIN ( fci ,imt j+d j)

duracao(mij)=d j

mij

Figura 4.2: Restrição de domínios temporais e de alocação no desenvolvimento de poços.

Para representar a ocorrência de indisponibilidades devidas à manutenção dos recursos, estru-

turas diversas são necessárias em razão do grau de detalhamento de cada tipo possível como forma

de garantir um melhor desempenho de resolução nos casos mais simples. Para o caso de indisponi-

bilidades totais, o uso de cada recurso i ao longo do tempo é descrito pela função cumulativa ui do

vetor u. O uso desse tipo de função na linguagem OPL é descrita na seção A.5.7. Cada uma dessas

funções representa uma composição de pulsos unitários de todos os intervalos de M associados ao

mesmo recurso:

ui =

na?
i=1

pulso(mij, 1) ?i ? [1,nr] . (4.13)

Dessa forma, é possível restringir o valor de ui a zero em períodos nos quais o recurso esteja em

manutenção total e ?xa através da restrição always-in, conforme ilustrado na ?gura 4.1:

[dirix = (firix ? iirix) ?pirix 6= 1] ? always-in(ui, iirix,firix, 0, 0) ?i ? [1,nr],x ? [1,niri] .
(4.14)

A extensão para o caso de indisponibilidades variáveis no tempo é feita pelo uso de uma matriz

auxiliar de intervalos MI associada à programação temporal de cada um desses eventos delimitada



4.4 MODELAGEM POR VARIÁVEIS DE INTERVALO 67

da seguinte forma:

ocorrencia(miix) ?i ? [1,nr],x ? [1,niri] . (4.15)

inicio(miix) ? iirix ?i ? [1,nr],x ? [1,niri] . (4.16)

fim(miix) ? firix ?i ? [1,nr],x ? [1,niri] . (4.17)

duracao(miix) = dirix ?i ? [1,nr],x ? [1,niri] . (4.18)

A partir das entradas de MI, é possível estender a restrição anterior ao caso geral de indisponibi-

lidades totais:

[pirix 6= 1] ? always-in(ui,miix, 0, 0) ?i ? [1,nr],x ? [1,niri] . (4.19)

A mesma estrutura poderia ser estendida para o caso de indisponibilidades parciais com o emprego

de uma função cumulativa para cada conjunto distinto de atividades limitado por alguma indispo-

nibilidade. No entanto, a modelagem adotada nesse caso considerou o emprego de sequências que

agrupam cada intervalo de programação de indisponibilidade com intervalos das atividades que são

respectivamente incompatíveis com o mesmo. A composição dessas sequências constitui a matriz

MP , na qual cada elemento mpix consiste em uma sequência associada à indisponibilidade x do

recurso i. Cada sequência mpix agrupa o intervalo de indisponibilidade miix e os intervalos de M

associados ao recurso i cuja compatibilidade é afetada pela indisponibilidade x:

mpix = {miix}?{mij : j ? [1,np] ? cij = 1 ? cirijx = 1} ?i ? [1,nr],x ? [1,niri] . (4.20)

Dessa forma, é possível estabelecer a restrição de no-overlap sobre cada sequência de MP :

[pirix = 1] ? no-overlap(mix) ?i ? [1,nr],x ? [1,niri] . (4.21)

Essa escolha alternativa de modelagem para as indisponibilidades parciais se deu pela necessidade

de uma propagação dedicada à interdependência entre o conjunto de intervalos envolvidos, algo

que não se fazia tão necessário no caso anterior devido à redundância decorrente da restrição de

no-overlap sobre as sequências do vetor r e as funções cumulativas do vetor u.

4.4.2 Associação entre Atividades e Localidades

De acordo com o limite de concorrência, cada localidade do problema é associada a uma sequên-

cia ou a uma função cumulativa, de forma a atender às restrições do problema. Localidades re-

presentando poços são associadas a sequências do vetor p, enquanto que portos são associados a

funções cumulativas do vetor b.

Cada sequência pk ? p representa o conjunto de atividades associadas ao desenvolvimento de
um poço identi?cado pela localidade k:

pk = {aj : j ? [1,np] ? locj = k} ?k ? [1,nlo] . (4.22)



68 O PROBLEMA DA PROGRAMAÇÃO DE RECURSOS CRÍTICOS E SUA ABORDAGEM 4.4

De forma a prevenir que duas atividades sejam programadas de modo concorrente em um poço, a

restrição no-overlap é estabelecida sobre cada sequência pk ? p:

no-overlap(pk) ?k ? [1,nlo] . (4.23)

Para modelar a restrição de distância de segurança entre recursos, a mesma lógica poderia ser usada

para estabelecer restrições sobre sequências representando atividades cuja execução concorrente por

determinados recursos não é permitida.

Cada função cumulativa bk ? b representa o número de cargas ocorrendo ao longo do tempo no
porto identi?cado pela localidade k:

bk =

na?
i=np+1

pulso(aj, 1) ?k ? [1,nlo] . (4.24)

Dessa forma, o controle de concorrência em cada porto pode ser garantido pela seguinte restrição:

bk ? sk ?k ? [1,nlo] . (4.25)

Por ?m, é comum que existam relações de precedência entre atividades relacionadas ao desenvol-

vimento de um mesmo poço, de forma que elas são descritas na presente seção em vez da anterior.

Elas são estabelecidas diretamente sobre os elementos do vetor a:

fim(aj1 ) + prcj1j2 ? inicio(aj2 ) ?j1 ? [1,np],j2 ? [1,np] . (4.26)

Os conceitos de associação entre atividades e localidades no modelo são ilustrados na ?gura 4.3.

  

vetor (transposto) de
Intervalos mistos a

anp anp+1a1

precedências

vetor (transposto) 
de sequências p

no-overlap vetor (transposto) de 
funções cumulativas b

pk={a j : j? [1,np] ?loc j=k} bk= ?
j=np+1

na
pulso(a j ,1)

bk?sk

ana

Figura 4.3: Relação entre intervalos associados a atividades e suas respectivas localidades.

4.4.3 Restrições de Estoque e Transporte de Linhas

O controle do estoque a bordo de barcos é feito por meio de funções cumulativas do vetor l

e das matrizes LB, CLB e DLB. Cada elemento lbik ? LB representa o estoque associado às
linhas carregadas por um recurso i e um porto k, sendo de?nido como a diferença entre a função

cumulativa clbik ? CLB relativa aos carregamentos realizados pelo recurso i no porto k e a função
cumulativa dlbik ? DLB relativa aos descarregamentos equivalentes:

clbik =

na?
j=np+1:locj =k

degrau(fim(mij,cei ?
duracao(mij)

maci
) ?i ? [1,nr],k ? [1,nlo] . (4.27)



4.4 MODELAGEM POR VARIÁVEIS DE INTERVALO 69

dlbik =

nl?
l=1:bll=k

degrau(fim(mi cll,pll) ?i ? [1,nr],k ? [1,nlo] . (4.28)

lbik = clbik ?dlbik ?i ? [1,nr],k ? [1,nlo] . (4.29)

Como pode ser observado pelas relações acima, a cada atividade de carga é associado um acréscimo

de estoque proporcional à sua duração e capacidade de estoque mas inversamente proporcional

ao tempo necessário ao carregamento completo; e a cada atividade de descarga é associado um

decréscimo ?xo proporcional à soma do peso das linhas que descarrega. O estoque no recurso i

é representado ao longo do tempo pela função cumulativa li ? l, que é de?nida sobre cargas e
descargas associadas a cada porto k por meio da função cumulativa lbik ? LB e sobre estocagens
temporárias associadas aos intervalos de (MT )i na forma de pulsos:

li =

nlo?
k=1

lbik +

np?
j=1

pulso(mij,cdj) ?i ? [1,nr] . (4.30)

A de?nição separada da função de estoque associada à carga em cada porto é necessária para

restringir que o volume de origem em cada porto não seja descarregado em maior quantidade do

que foi carregado:

lbik ? 0 ?i ? [1,nr],k ? [1,nlo] . (4.31)

Para completar o controle dos limites de estoque, resta a classe de restrições de estoque dos recursos

em si ao longo do tempo, que atenta apenas ao limite a bordo devido à garantia de não-negatividade

advinda do conjunto de restrições anterior:

li ? cei ?i ? [1,nr] . (4.32)

A ?gura 4.4 ilustra as restrições de estoque estabelecidas sobre cada recurso apresentando a com-

posição de LB diretamente das entradas de M.

  

matriz de intervalos
opcionais M
(i-ésima linha)

minp minp+1 minami1

matriz de funções
cumulativas LB
(i-ésima linha transposta)? ?

j=1 :loc j=k

np
degrau( fim(mi j) ,cll)

?
j=np+1 :loc j=k

na
degrau( fim(mi j ,cei?duracao(mij)maci ))

0?lbik

vetor de funções
cumulativas l

li?cei

pulso(mi j ,cd j)

Figura 4.4: Representação das restrições de estoque do recurso por porto e na totalidade.



70 O PROBLEMA DA PROGRAMAÇÃO DE RECURSOS CRÍTICOS E SUA ABORDAGEM 4.5

De forma a garantir que as linhas com restrição de data sejam carregadas apenas após o prazo

determinado, um conjunto de restrições é estabelecido a partir da estrutura de cargas opcionais

proporcionais ao número de linhas existentes descrita previamente. Nesse contexto, a restrição

associada ao carregamento de cada linha l por cada recurso i é descrita da seguinte forma:

ocorrencia(micll ) ?

MINj?[np+1,na]:ocorrencia(mij )?dlj?np?dllfim(mij) ? inicio(micll )

?i ? [1,nr], l ? [1,nl] .

(4.33)

Dessa forma, a ocorrência de ao menos uma carga cuja data mínima de início é pelo menos tão

tarde quanto a data de disponibilidade da linha em questão e que o tempo de conclusão da mesma

seja menor do que o tempo de início da descarga da linha no mesmo recurso garantem que cada

linha pode ser carregada no tempo certo. A partir dessa garantia, a associação das linhas às cargas

pode ser feita de modo trivial.

4.4.4 Função Objetivo

A composição da função objetivo de maximização fo é baseada em uma combinação balanceada

das funções de produção de curto prazo fop e de somatório dos tempos de conclusão das atividades

foc:

fop =

np?
j=1

MAX(H ?fim(aj), 0) ?pj ; (4.34)

foc =

na?
j=1

(fim(aj)) ; (4.35)

fo = Mp ?fop?Mc ?foc . (4.36)

O balanceamento dos coe?cientes Mp e Mc deve ser feito de forma a garantir que os valores assumidos

por foc não afetem as decisões a ponto de alterar o valor assumido por fop, o que teoricamente

denota-se por Mp ? Mc. Sem perda de generalidade, essa de?nição pode ser feita sobre um dos
coe?cientes para um valor ?xo do outro. No entanto, convém observar que uma diferença de grandeza

entre os coe?ciente além do necessário pode afetar a precisão do resultado. Dessa forma, optou-se

pelo valor ?xo Mp = 1 e, sob a hipótese de valores inteiros para a taxa de produção, Mc tal que
1
Mc

&gt; focMAX. O valor máximo assumível pela função foc nas soluções, focMAX, pode ser estimado

por pré-inspeção dos dados do problema.

4.5 Limitante Superior ao Ótimo

De forma a avaliar a qualidade das soluções obtidas, duas abordagens distintas foram desenvol-

vidas para estabelecer limitantes superiores à produção de curto prazo de instâncias do problema.

Com base nos limitantes obtidos e em sua diferença com relação às soluções obtidas pelo modelo,

é possível estimar a diferença, no pior caso, entre o valor de produção dessas soluções e o valor

ótimo de produção: ela corresponde ao ótimo ser igual ao menor desses limites. As duas aborda-

gens consistem na relaxação de um conjunto de restrições do problema, de forma que uma solução



4.5 LIMITANTE SUPERIOR AO ÓTIMO 71

ótima do problema relaxado possa ser obtida. No entanto, é pouco provável que a solução de tal

problema relaxado seja também uma solução viável do problema original. No primeiro caso, o pro-

blema resultante é resolvido com um algoritmo guloso com baixo custo computacional. No segundo

caso, um modelo de PLI é formulado para ser rodado em um resolvedor de PM. O desenvolvimento

da primeira abordagem é descrito em Serra et al. (2011) e visou estabelecer um limitante que não

dependesse de outras ferramentas de resolução. A segunda abordagem é descrita em Serra et al.

(2012) e visou obter uma estimativa mais precisa por relaxar menos o problema original. Apesar

dos resultados obtidos com a segunda abordagem serem melhores, ambas são descritas a seguir com

o intuito de ilustrar a diferença dos resultados a partir do nível de relaxação adotado em cada caso.

4.5.1 Algoritmo Guloso sobre Relaxação

O algoritmo de inferência de limitante superior opera gerando uma instância relaxada do pro-

blema cuja resolução é trivial e, resolvendo-a, gera um valor de produção superestimado devido às

relaxações. As relaxações presentes na instância gerada são de quatro tipos, cada qual afetando um

aspecto distinto da instância:

1. Número e duração das atividades de desenvolvimento: Reduz o desenvolvimento de

cada poço a uma única atividade cuja duração é dada pelo tempo mínimo entre o início da

primeira atividade e o término da última da sequência da instância original do problema.

2. Produção associada às atividadades: Associa o maior valor de produção de um poço da

instância original à atividade da instância relaxada com menor duração e assim por diante.

3. Disponibilidade e compatibilidade dos recursos: Considera todos os recursos disponíveis

inde?nidamente a partir do início de seu contrato e compatíveis com todas as atividades.

4. Linhas a serem transportadas: Ignora todas os transportes e cargas temporárias da ins-

tância original na instância relaxada.

Assim sendo, a solução ótima dessa relaxação pode ser obtida pela escala das atividades em ordem

não-crescente de produção ? e, por consequência, não-decrescente de duração ? nos recursos disponí-

veis. Dessa forma, a complexidade de pior caso do algortimo é O(n2a +nlo?log(nlo) +nlo?nr), sendo
o primeiro termo relativo à determinação da duração mínima do desenvolvimento de cada poço,

o segundo relativo à ordenação das atividades associadas a cada poço tanto por duração quanto

por produção e o terceiro relativo à alocação dessas atividades nos recursos. A duração mínima do

desenvolvimento de cada poço é obtida pelo emprego de um algoritmo de caminhos mais curtos a

partir de uma única origem através da conversão dos tempos mínimos à conclusão de cada atividade

em vértices para os quais é medida a distância com relação ao vértice associado ao instante inicial

da escala. Portanto, o algoritmo de limitante superior gera uma relaxação cuja produção ótima

é ao menos tão grande quanto a do problema original, resolve-a de modo e?ciente e gerando um

limitante válido à produção de curto prazo.

4.5.2 Modelo de PLI sobre Relaxação

Apesar de válida e de fácil implementação, a estimativa que pode ser obtida pelo método descrito

na seção anterior acaba por ser muito fraca devido à grande quantidade de premissas adotadas para



72 O PROBLEMA DA PROGRAMAÇÃO DE RECURSOS CRÍTICOS E SUA ABORDAGEM 4.5

relaxar o problema. De forma a possibilitar que uma solução ótima seja obtida por um algoritmo

guloso, muitas restrições fundamentais foram ignoradas. Por esse motivo, uma segunda proposta de

estimativa foi desenvolvida com base em um modelo de PLI. Nesse caso, apenas a obrigatoriadade

das atividades e os detalhes relacionados a linhas como existência, necessidade de carga em portos e

manutenção dos limites de estoque nos recursos foram abstraídos. Como resultado da manutenção

de restrições de compatibilidade, do conjunto de atividades de desenvolvimento em cada poço

e da disponibilidade de casa recurso, um limite menor foi obtido em Serra et al. (2012) para o

mesmo conjunto de instâncias e escala adotados em Serra et al. (2011) com o uso da abordagem

anterior. Convém observar que o modelo de PLI não é sempre resolvido rapidamente, de forma que

um tempo limite é estabelecido para que o limitante superior do modelo relaxado seja utilizado no

lugar da solução ótima do mesmo. O modelo descrito a seguir representa a con?guração com melhor

desempenho na análise empírica desenvolvida em Serra et al. (2012).

O conjunto de variáveis de decisão do modelo MIP é descrito na tabela 4.1. Como pode ser obser-

vado, variáveis contínuas foram utilizadas para representar a programação das atividades ao longo

do tempo, sendo acompanhadas por variáveis inteiras para representar a ocorrência da atividade,

sua atribuição a um recurso e seu sequenciamento com relação a outras atividades.

Var. Domain Description

Sj R
+ Tempo de início da atividade j.

Ej R
+ Tempo de ?nalização da atividade j.

Yj {0, 1} Se a atividade j termina antes de H.
Xj R

+ Dias antes da atividade j se concluída se Yj = 1.
Fj R

+ Variável auxiliar que é positiva se Yj = 0.
Wij {0, 1} Se o recurso i é atribuído à atividade j.
Zj1j2 {0, 1} Se a atividade j1 precede a atividade j2.

Tabela 4.1: Variáveis de decisão do modelo PLI do problema relaxado.

A função objetivo (4.37) descreve a maximização da produção até o dia H:

max.
np?
j=1

(H ×Yj ?Xj) ×pj (4.37)

Ainda que seja possivel representar uma produção negativa com essa função se Xj &gt; 0 e Yj = 0 para

uma atividade j, tal situação não ocorre na resolução do problema porque uma produção maior

poderia ser atingida com Xj = 0 e Fj = Ej. Dessa forma, a solução parcial obtida em cada etapa

da busca sobre esse modelo sempre terá Xj = 0 em uma situação desse tipo.

Para as restrições (4.42), (4.50) e (4.53) a seguir, existe um coe?ciente Mj associado a cada

atividade j. Esse coe?ciente deve ter sempre um valor tão grande quanto qualquer atribuição válida

a Ej. Na literatura, esse tipo de coe?ciente geralmente é chamado de ?grande M
2?. Apesar de ser

possível de?nir Mj = imcj, o uso de um valor menor para cada um desses coe?cientes facilitaria

o processo de resolução do problema. Dessa forma, em caráter preliminar, um modelo contendo

apenas as restrições (4.38) a (4.55) é rodado para atualizar o valor de Mj como Ej + H ? 1, onde
Ej é o valor atribuído a Ej como resultado da rodada. Explicações mais detalhadas a respeito

do comportamento do processo de resolução em função do valor desses coe?cientes podem ser

2Denominado ?big M? em inglês.



4.5 LIMITANTE SUPERIOR AO ÓTIMO 73

encontradas em Camm et al. (1990), onde uma avaliação empírica dos problemas de escalabilidade

decorrentes da seleção de valores muito grandes para esse tipo de coe?ciente é discutida.

As restrições (4.38) a (4.40) limitam o valor das variáveis temporais dos conjuntos S e E em

função da data de início mais cedo, da data de início mais tarde e da duração da atividade.

Sj + dj = Ej ?j ? [1,np] (4.38)

Sj ? imcj ?j ? [1,np] (4.39)

Ej ? imtj + dj ?j ? [1,np] (4.40)

A semântica dos conjuntos de variáveis X e Y conforme descrita na tabela 4.1 é garantida pelas

restrições (4.41) a (4.43). Dessa forma, Fj &gt; 0 se, e somente se, Yj = 0 para cada atividade j.

De outra forma, Xj = Ej. Assim sendo, os conjuntos de variáveis X e Y podem ser usados para

compor a função objetivo e representar a produção obtida.

Ej = Xj + Fj ?j ? [1,np] (4.41)

Fj ? Mj × (1 ?Yj) ?j ? [1,np] (4.42)

Ej ? H × (1 ?Yj) ?j ? [1,np] (4.43)

A restrição (4.44) é um corte incluído para facilitar a resolução. Esse corte provê uma ligação

adicional entre os conjuntos Y e X, de forma a evidenciar quando uma atividade não pode ser

realizada antes do dia H.

Xj + Yj ? H ?j ? [1,np] (4.44)

Cortes são restrições inferidas a partir do modelo se levadas em conta as restrições de integralidade.

Essas restrições adicionais não são necessárias para garantir a corretude do modelo, mas elas co-

laboram com a redução do espaço de busca pela eliminação de regiões que não possuam soluções

inteiras, o que facilita a resolução do problema.

As relações de precedência são garantidas pela equação (4.45) sobre os conjuntos de variáveis S

e E, bem como pelo corte adicional (4.46) em Y . Esse corte limita a ocorrência de uma atividade

antes de H ao caso no qual as suas predecessoras também ocorram antes de H.

Ej1 + prcj1j2 ? Sj2 ?j1,j2 ? [1,np] (4.45)

Yj1 ? Yj2 ?j1,j2 ? [1,np],prcj1j2 6= ?? (4.46)

A equação (4.47) garante que cada atividade concluída antes de H é atribuída a um recurso, bem

como que esse recurso seja compatível com a atividade.

?
i?[1,np]:cij =1

Wij = Yj ?j ? [1,np] (4.47)

A equação (4.48) limite a duração total das atividades atribuídas a cada recurso à disponibilidade



74 O PROBLEMA DA PROGRAMAÇÃO DE RECURSOS CRÍTICOS E SUA ABORDAGEM 4.5

de curto prazo do mesmo.

min{H ? 1,fci}?min{H ? 1, ici}

?
?

j?[1,np]:cij =1

dj ×Wij ?i ? [1,nr] (4.48)

As equações (4.49) e (4.50) limitam a programação de cada atividade ao contrato do recurso ao

qual ela é atribuída.

Sj ? ici ×Wij ?i ? [1,nr],j ? [1,np],cij = 1 (4.49)

Ej ? fci + Mj × (1 ?Wij) ?i ? [1,nr],j ? [1,np],

cij = 1 (4.50)

As restrições (4.51) a (4.53) limitam a ocorência simultânea de atividades. Esse tipo de restrição

deve-se à ocorrência de atividades em um mesmo poço e à utilização de um mesmo recurso por

atividades distintas. No caso de atividades em um mesmo poço, o tempo de transição em (4.53) é

nulo. No caso de atividades em localidades distintas, ele é de?nido como o maior tempo de transição

de um recurso compatível com ambas as atividades.

Zj1j2 + Zj2j1 ? 1 ? j1,j2 ? [1,np],j1 &amp;lt;j2 (4.51)

Zj1j2 + Zj2j1 ? Yj1 ? j1,j2 ? [1,np],

j1 6= j2, locj1 = locj2 (4.52)

Ej1 + dtj1j2 ? (Mj1 + dtj1j2 ) × (1 ?Zj1j2 )

? Sj2 ? j1,j2 ? [1,np],j1 6= j2 (4.53)

A atribuição das atividades pertencentes a um mesmo cluster é restrita a recursos capazes de

realizar aquelas atividades programadas no curto prazo pela restrição (4.54) e a um único recurso

pela restrição (4.55).

Wij1 ? 1 ?Yj2 ?i ? [1,nr],j1,j2 ? [1,np],

cij1 = 1,cij2 6= 1,

clusterj1 = clusterj2 (4.54)

Wij1 ? 1 ?Yj2 + Wij2 ? i ? [1,nr],j1,j2 ? [1,np],

cij1 = 1,cij2 = 1,

clusterj1 = clusterj2 (4.55)

Por ?m, o sequenciamento temporal das atividades atribuídas a um mesmo recurso é garantido

pela restrição (4.56). Nesse caso, se duas atividades j1 e j2 são realizadas por um único recurso,



4.5 LIMITANTE SUPERIOR AO ÓTIMO 75

Zj1j2 = 1 ou Zj2j1 = 1 para evitar sua ocorrência simultânea.

Zj1j2 + Zj2j1? Wij1 + Wij2 ? 1

?i ? [1,nr],j1,j2 ? [1,np],

cij1 = 1,cij2 = 1

j1 &amp;lt;j2 (4.56)



76 O PROBLEMA DA PROGRAMAÇÃO DE RECURSOS CRÍTICOS E SUA ABORDAGEM 4.5



Capítulo 5

Análise Experimental do Escalonador

Alguns experimentos foram conduzidos para analisar o desempenho do escalonador obtido a

partir da implementação do modelo proposto em um resolvedor comercial. O objetivo primário

desses experimentos foi avaliar a qualidade das soluções obtidas ao longo do tempo e o resultado

ao ?nal do tempo de resolução estipulado pelo usuário ?nal. Dessa forma, a abordagem descrita no

Capítulo 4 foi implementada e testada sobre um conjunto de dados reais conforme a especi?cação

descrita na seção 5.1. Os experimentos realizados e os resultados obtidos para os mesmos são

apresentados na seção 5.2 e discutidos na seção 5.3.

5.1 Dados Disponíveis e Ambiente de Testes

A avaliação experimental do escalonador foi baseada em um conjunto de dados representando

um cenário real ocorrido no passado. Devido ao fato desse cenário representar uma única instância

do problema, outras instâncias foram geradas a partir desta como forma de avaliar a estabilidade de

desempenho do resolvedor. A instância O representa o cenário completo com 465 atividades em 171

poços. Essa instância foi particionada em conjuntos de atividades de tamanhos similares para gerar

instâncias de porte menor a serem testadas individualmente, todas empregando o conjunto completo

de recursos disponível. O primeiro particionamento das atividades foi em duas metades, H1 e H2,

e a segunda em quatro quartos, Q1 a Q4. A tabela 5.1 descreve as principais características de cada

uma dessas instâncias.

O modelo de variáveis intervalares foi implementado usando a linguagem OPL, para a qual o

Apêndice A provê uma pequena introdução. O escalonador foi executado em uma única thread por

meio do resolvedor IBM Cplex Studio 12.2. O computador usado nos testes possui 4 processadores

Instância Q1 Q2 Q3 Q4 H1 H2 O

Atividades 116 118 116 115 231 234 465
Poços 46 37 45 43 82 89 171
Linhas 17 17 13 19 32 34 66
Sondas 64
Barcos 9
Indisponibilidades 12

Tabela 5.1: Principais características das instâncias testadas.

77



78 ANÁLISE EXPERIMENTAL DO ESCALONADOR 5.2

Instância Q1 Q2 Q3 Q4 H1 H2 O

Tempo Solução Inicial (s)
Média 3,14 2,99 3,86 2,82 10,19 12,71 13,62
Desvio 0,08 0,16 0,22 0,12 0,64 2,63 6,64

Valor Solução Inicial
Média 97,23 86,03 99,08 86,13 95,98 91,86 88,31
Desvio 0,13 22,17 0,52 8,58 1,19 0,41 0,98

Valor Solução Final
Média 99,98 100,00 99,98 99,88 99,66 99,60 98,98
Desvio 0,03 0,00 0,02 0,20 0,28 0,35 1,18

Limitante Superior
Algoritmo 122,20 138,56 117,82 118,30 122,83 125,02 135,61
Modelo 104,14 114,25 100,65 103,52 105,44 105,98 115,81

Tabela 5.2: Principais resultados dos experimentos do escalonador.

Dual-Core AMD Opteron 8220, 16 Gb de memória RAM e sistema operacional Linux. Por ?m, o

algoritmo descrito na seção 4.5.1 para inferir um limitante superior para o ótimo foi implementado

em Java em razão da baixa demanda por recursos do mesmo e à necessidade de compatibilidade e

facilidade de manutenção com relação ao sistema existente. O modelo em PLI descrito na seção 4.5.2

foi implementado em OPL e utilizou o mesmo resolvedor para sua resolução.

5.2 Experimentos Realizados e Resultados

Os testes realizados procuraram avaliar a estabilidade do resolvedor, seu comportamento de

acordo com o tamanho do conjunto de atividades e a qualidade das soluções obtidas com base nos

limitantes obtidos. Eles são similares aos publicados em Serra et al. (2011) e Serra et al. (2012), que

foram ambos realizados em uma versão simpli?cada do problema descrito neste trabalho. Essa versão

simpli?cada diferia por contemplar apenas indisponibilidades totais ?xas e não possuir restrição de

disponibilidade ou porto de embarque das linhas. Tais requisitos foram ignorados na época por ainda

estarem em discussão. Cada instância foi resolvida quatro vezes pelo escalonador pelo tempo limite

de uma hora, sendo registradas as soluções obtidas ao longo do processo de resolução. Como forma de

reduzir o efeito de más escolhas em questões de desempate arbitrário no processo de rami?cação ao

longo da busca, a repetição do processo de resolução foi feita com sementes de aleatorização distintas.

O uso de sementes de aleatorização e o fato de resultados diferentes serem esperados com seu uso

se deve à arbitração de critérios de desempate ao longo da busca, conforme descrito na seção A.4.7

do apêndice. O tempo limite estabelecido é baseado na expectativa de tolerância do usuário ?nal

para obter uma solução, sendo empregado tanto no modelo de PR quanto no de PLI. Por motivo de

sigilo, a medida dos valores de produção apresentados para cada solução é normalizada com base

no valor 100 para a melhor solução obtida em cada instância. Essa normalização também visou

facilitar a comparação de progresso da resolução em instâncias distintas. Os principais resultados

desses experimentos estão resumidos na tabela 5.2.

Como forma de demonstrar o progresso do escalonador enquanto resolve o modelo, os grá?-

cos das ?guras que se seguem representam a melhor solução obtida a cada instante de resolução.

As ?guras 5.1 a 5.4 representam, respectivamente, o progresso nas 4 rodadas realizadas sobre as

instâncias Q1 a Q4. Por sua vez, as ?guras 5.5 e 5.6 ilustram o progresso das 4 rodadas sobre as

instâncias H1 e H2. Por ?m, a ?gura 5.7 apresenta o progresso de resolução das 4 rodadas sobre a

instância O.



5.2 EXPERIMENTOS REALIZADOS E RESULTADOS 79

Figura 5.1: Melhoria da solução obtida em cada rodada do escalonador para a instância Q1.

Figura 5.2: Melhoria da solução obtida em cada rodada do escalonador para a instância Q2.

Figura 5.3: Melhoria da solução obtida em cada rodada do escalonador para a instância Q3.



80 ANÁLISE EXPERIMENTAL DO ESCALONADOR 5.2

Figura 5.4: Melhoria da solução obtida em cada rodada do escalonador para a instância Q4.

Figura 5.5: Melhoria da solução obtida em cada rodada do escalonador para a instância H1.

Figura 5.6: Melhoria da solução obtida em cada rodada do escalonador para a instância H2.



5.3 DISCUSSÃO 81

Figura 5.7: Melhoria da solução obtida em cada rodada do escalonador para a instância O.

5.3 Discussão

Os resultados indicam que o tempo limite estabelecido pelo usuário do escalonador é satisfatório

para evitar ?utuações muito grandes nos resultados ?nais. Isso pode ser observado pelo fato de que

a média do valor das soluções ?nais obtidas nas rodadas para cada instância não ?cou muito abaixo

de 1% da melhor solução obtida. Além disso, os grá?cos de melhor solução obtida ao longo do

tempo evidenciam uma convergência a determinados patamares de valores. No entanto, a tendência

aparente de aumento do valor do limitante com relação à melhor solução obtida e a maior dispersão

das curvas relativas às instâncias com um maior número de atividades evidenciam que os resultados

poderiam ser melhores na hipótese de um tempo limite de execução maior para a resolução de

instâncias maiores.

De qualque forma, a in?uência da quantidade de atividades da instância para a variação dos

resultados obtidos foi mais relevante com relação ao tempo para obtenção e ao valor da solução

inicial obtida do que com relação ao valor da solução ?nal. Para as instâncias Q1 a Q4, apenas

uma rodada de Q2 e três rodadas de Q4 tiveram uma solução inicial com diferença maior do que

3% com relação à melhor solução obtida em uma hora, sendo que as soluções seguintes passam a

?gurar dentro desse patamar. Outro fator relevante para a convergência das rodadas é a quantidade

de linhas da instância, uma vez que a ?utuação observada para os resultados da instância Q4 ? que

possui uma quantidade acima da média para o número de atividades ? foi maior. Nas instâncias H1

e H2, as soluções iniciais de todas as rodadas tinham uma diferença inferior a 10% com relação à

melhor solução obtida em uma hora. No caso da instância O, no máximo duas soluções por rodada

estavam abaixo da diferença de 10%. Com relação à qualidade das soluções, todas as rodadas

obtiveram uma solução ?nal a menos de 16% da solução ótima. Com excessão de Q2, esse valor foi

menor do que 6% nas menores instâncias. Além disso, convém observar que essa distância pode ser

ainda menor, uma vez que a diferença entre o valor das soluções obtidas e o ótimo frequentemente

não equivale à diferença com relação ao limitante. Dessa forma, há uma grande evidência da robustez

do escalonador devido à pequena quantidade de tempo para a obtenção de uma solução inicial, à

estabilidade dos resultados ?nais entre rodadas independentes e sua diferença máxima com relação

ao ótimo.

A despeito desses resultados, ainda há muitas possibilidades a serem consideradas para melhorar



82 ANÁLISE EXPERIMENTAL DO ESCALONADOR 5.3

a qualidade da solução inicial e reduzir o valor do limitante inferido. O desenvolvimento de um

gerador de soluções iniciais para servir de entrada ao escalonador proposto serviria para levar

em conta o conhecimento de quem realiza essa programação manualmente e, por consequência,

evitar a degeneração no início da busca. Se bem-sucedido, esse gerador levaria a uma diminuição

da variação observada entre instâncias e aumentaria a con?ança do usuário ?nal no sistema. A

suspeita sobre a possibilidade de ser possível reduzir o limitante estimado deriva do fato que o

carregamento de linhas sequer foi considerado na relaxação PLI, que obteve os limitantes mais

precisos. No mais, aquele valor é um pouco elevado se levarmos em conta que a melhoria das soluções

obtidas em instâncias menores cessa precocemente em algumas rodadas e melhorias signi?cativas

não são normalmente esperadas nesses casos. Portanto, é possível que uma relaxação ainda menos

simpli?cada do problema possa ser obtida em tempo hábil e levar a uma avaliação mais precisa da

qualidade dos resultados do escalonador.



Parte IV

CONCLUSÃO

83





Capítulo 6

Conclusão

Este trabalho procurou atingir dois objetivos inter-relacionados. O primeiro era de introduzir

em português a técnica de Programação por Restrições (PR) e seu desdobramento com foco na

abordagem de problemas de escalonamento ? o Escalonamento Baseado em Restrições (EBR) ?

como ferramental válido à abordagem de problemas de otimização. A apresentação se deu por

meio de uma revisão bibliográ?ca sobre o tema, incluindo uma de?nição dos principais conceitos, a

contextualização de algumas das ferramentas comerciais disponíveis e um tutorial para facilitar o

uso de uma das linguagens de modelagem mais utilizadas atualmente ? a OPL. O segundo era de

abordar o Problema da Programação de Recursos Críticos, que consiste na programação de sondas

e barcos para o desenvolvimento de poços de petróleo. Tendo em vista as recentes descobertas de

reservas abundantes na camada do pré-sal da costa brasileira, a obtenção e?ciente de soluções de

alta qualidade em tempo razoável é de grande importância para que o país se posicione como um

grande exportador de petróleo nos próximos anos. Dessa forma, a abordagem do problema por meio

do uso da técnica permitiu ilustrar como empregá-la em um problema real, com o intuito de que

sirva de exemplo e encorajamento para que outros pro?ssionais também tentem utilizá-la.

Convém observar que a abordagem proposta representa apenas uma das alternativas possíveis.

Não obstante, os resultados obtidos para o cenário real estudado foram bastante otimistas, uma vez

que uma solução a menos de 16% do ótimo foi obtida para um problema com cerca de 70 recursos

e mais de 400 atividades. Dessa forma, observamos como possibilidades de trabalho futuro tanto

abordar em um maior nível de detalhe o problema tratado quanto recorrer a outras técnicas de reso-

lução para a promoção de uma análise comparativa. Essa segunda possibilidade diz respeito tanto à

resolução do problema quanto à obtenção de um limitante superior mais preciso para avaliar a qua-

lidade das soluções. Portanto, não se espera que este trabalho tenha caráter conclusivo e asserções

de?nitivas em nenhum aspecto, mas antes que sirva como base para futuros desenvolvimentos.

85



86 CONCLUSÃO 6.0



Parte V

APÊNDICE

87





Apêndice A

Programação por Restrições em OPL

O propósito deste apêndice é apresentar os principais elementos da linguagem de modelagem

OPL, com ênfase naqueles relacionados à técnica de programação por restrições. Dessa forma, a

apresentação da linguagem não será completa e alguns conceitos serão introduzidos à medida que

necessários ao escopo de?nido. Ainda sim, essa apresentação cobrirá uma boa parte dos elementos

de uso geral à modelagem de problemas de decisão e de otimização. No entanto, convém a ressalva

de que parte dos elementos são exclusivos à modelagem pela técnica de programação por restrições.

Esse material foi adaptado de uma apostila elaborada pelo autor para ministrar um curso sobre

o emprego da linguagem OPL na técnica de programação por restrições. Boa parte dessa apostila

é baseada no manual da IBM (2010), ainda que em um escopo bastante reduzido e numa estrutura

diferente. Para a adequada compreensão do material, é desejável algum conhecimento de otimização

e de linguagens de programação. O tratamento teórico sobre programação por restrições apresentado

na segunda parte da dissertação pode ser de alguma valia, mas não será exigido de maneira explícita.

No decorrer do texto, será introduzida a linguagem OPL e elementos importantes à modelagem de

problemas combinatórios e de escalonamento, em ordem crescente de complexidade. Dessa forma,

a leitura do apêndice pode ser independente do restante da dissertação ao passo que a forma como

o texto está estruturado difere um pouco devido ao propósito com que foi elaborado originalmente.

A organização do restante do apêndice segue a estrutura descrita a seguir. Na seção A.1, é dada

uma visão geral sobre o que é a linguagem OPL, com especial ênfase ao resolvedor de programação

por restrições CP Optimizer. A separação entre modelo e dados é tratada na seção A.2. Nesse ponto,

começa a descrição da linguagem por meio de diversos exemplos auto-contidos em cada seção, de

forma a facilitar a compreensão sequencial e consulta posterior do material. Essa apresentação se

prolonga por 3 seções: a seção A.3 cobre elementos básicos da linguagem, desde a de?nição do

resolvedor, passando pela manipulação das estruturas de dados mais comuns até a formulação de

expressões; a seção A.4 cobre variáveis de decisão, função objetivo, restrições e pós-processamento,

além de um exemplo no ?nal; e a seção A.5 trata das estruturas especí?cas para problemas de esca-

lonamento, com um exemplo de sua utilização. Por ?m, a seção A.6 apresenta algumas conclusões

e agradecimentos aos revisores das versões preliminares desse texto.

A.1 A Linguagem OPL e o Resolvedor CP

OPL é uma linguagem de modelagem algébrica para a descrição de problemas decisórios ou de

otimização. Ela era de propriedade da ILOG, que foi adquirida em 2009 pela IBM. A descrição

89



90 APÊNDICE A

de um problema de otimização nessa linguagem consiste em um modelo. Uma vez especi?cado o

modelo, um resolvedor compatível com a linguagem pode ser utilizado para resolver o problema.

No caso da linguagem OPL, existem dois resolvedores compatíveis: o CPLEX e o CP.

A OPL pode ser entendida como uma linguagem de programação como outra qualquer, de

acordo com a visão de Knuth destacada por Lustig e Puget (2001), pois ela se propõe a instruir

uma máquina sobre como resolver um determinado problema. Porém, ela não é feita para uso

geral mas para expressar problemas decisórios ou de otimização de maneira clara. Além disso, sua

estrutura é essencialmente declarativa, de forma que boa parte do modelo descrito expressa qual

é o problema e não como resolvê-lo. Porém, tanto no pré quanto no pós-processamento, é possível

incluir alguns trechos de programação imperativa para tratamento dos dados, impressão na tela e

con?guração do resolvedor, conforme veremos adiante.

O grande diferencial da linguagem OPL foi que, ao contrário de suas predecessoras, ela dá su-

porte à descrição de problemas para a utilização de resolvedores de programação por restrições

como o resolvedor CP. Até então, linguagens de modelagem só serviam à descrição de problemas de

programação matemática, desde programação linear a casos especiais de programação não-linear,

que em OPL são cobertos pelo resolvedor CPLEX. Esse diferencial amplia a possibilidade de apli-

cação da linguagem devido às vantagens em se utilizar programação por restrições em alguns tipos

de problemas para os quais as técnicas de resolução utilizando programação matemática não são

viáveis devido ao excessivo consumo de tempo e memória para uma representação completa dos

modelos associados. Nesses casos, mesmo que uma abordagem utilizando programação por restri-

ções resulte em uma solução sem garantias de otimalidade, ao menos é possível obter uma solução

factível em tempo hábil e com menor exigência computacional. E sendo uma ferramenta de mode-

lagem algébrica, a possibilidade de uso dessas técnicas torna-se acessível a um público mais amplo

do que apenas programadores de computadores.

A programação por restrições consiste na modelagem e resolução de problemas combinatórios

empregando variáveis de decisão com domínios discretos e ?nitos, e restrições capazes de expressar

concisamente certas combinações de valores e domínios. A mesma modelagem, em programação

matemática, seria muito mais complexa ou mesmo inviável em alguns casos. Apesar da falta de

garantias das técnicas empregadas na programação por restrições, mecanismos de redução dos do-

mínios baseados na propagação das restrições e algoritmos especí?cos para a resolução de algumas

classes especiais de problemas foram responsáveis por um considerável ganho de credibilidade, conso-

lidando a modelagem em programação por restrições como uma boa prática para diversos problemas

combinatórios e, em especial, de problemas de escalonamento.

A.2 Representação do Modelo e da Entrada de Dados

A descrição do modelo em OPL consiste em um arquivo geralmente com extensão .mod que é

interpretado linha a linha. Como os dados do problema não são sempre os mesmos por variar de

instância para instância, é importante considerar a entrada de dados separadamente. Isso é feito

por meio de um segundo arquivo com extensão .dat. Ao separar modelagem e a entrada de dados,

evita-se que o projetista do modelo se preocupe em tratar detalhes da entrada no mesmo arquivo

utilizado para representar a formulação do problema.

No arquivo de descrição do modelo, interessa-nos manipular o conjunto de dados, descrever o



ELEMENTOS DE USO GERAL DA LINGUAGEM 91

problema de otimização e dar saída a esse resultado de alguma maneira. Dessa forma, não convém

o tratamento explícito da entrada de dados, que só pode ser feito por meio de constantes dentro

do arquivo do modelo. Através do arquivo .dat, a entrada de dados pode ser feita por meio de

acesso a banco de dados, planilhas eletrônicas ou arquivos de texto que obedeçam a algumas regras

de formatação. Por simplicidade, nos ateremos apenas a esse último caso no restante do texto,

especialmente porque o acesso a banco e planilhas é especi?cado por meio de um arquivo de texto

nessa sintaxe, e o leitor pode encontrar facilmente como fazê-lo para uma variedade de plataformas

na documentação o?cial da linguagem. Portanto, o modelo consiste ?sicamente em um arquivo

de texto interpretado em linha de comando em conjunto com um, nenhum ou vários arquivos de

entrada de dados, geralmente com extensão .dat. Vale lembrar que, para que uma execução não

resulte em erro imediato, é necessário que todos os dados necessários à execução do modelo estejam

de?nidos exatamente uma vez ? seja no código do modelo ou nos demais arquivos de entrada de

dados ? e que não exista nenhum dado sem correspondência ao modelo nesses arquivos.

Num exemplo simples de execução em linha de comando com um arquivo de modelo modelo.mod

e um arquivo de dados dados.dat, temos a seguinte chamada:

oplrun modelo.mod dados.dat

Apesar de interpretado em linha de comando, a execução pode ser realizada por meio de ambi-

entes fornecidos pela ILOG como a OPL IDE. Além do desenvolvimento de modelos e execução, a

OPL IDE permite que parâmetros do resolvedor possam ser con?gurados em um terceiro arquivo

de con?gurações com extensão .ops. Entretanto, muitos desses parâmetros podem ser de?nidos no

próprio modelo, motivo pelo qual será abordada apenas essa última opção quanto o assunto for

tratado.

A.3 Elementos de Uso Geral da Linguagem

Nesta seção, são apresentados muitos dos elementos de uso geral da linguagem OPL e alguns

peculiares ao resolvedor CP. É importante frisar ao leitor que não se trata de uma cobertura

exaustiva, mas de uma que garanta ao leitor domínio sobre as estruturas comuns de maior uso.

Essa cobertura procura dar embasamento ao acompanhamento do restante do texto.

Muitos trechos de código serão apresentados, e por isso convém explicitar desde já a convenção

adotada. Todos eles serão delimitados por barras formando um quadro. Trechos de código do modelo

serão apresentados com barras duplas e trechos do arquivo de entrada de dados serão apresentados

com barras simples. A numeração de linhas só ocorrerá se o modelo for completo, não se aplicando a

trechos isolados. No texto subsequente a cada trecho de código, comentários sobre o exemplo dado

podem conter referências a variáveis em itálico ou trechos entre aspas e itálico, representando parte

do código ilustrado ou alguma pequena variação a partir desse código. Esse trecho pode ou não ser

válido na linguagem. Em especial, trechos incorretos apresentados como contra-exemplo não foram

destacados por meio de quadros para evitar que pudessem ser confundidos com os trechos corretos.

A.3.1 Escolha do Resolvedor do Modelo

Devido ao foco restrito à programação por restrição e sua aplicação à modelagem de problemas

combinatórios ou de escalonamento, o texto não se aterá apenas a conceitos gerais da linguagem



92 APÊNDICE A

OPL, mas também a elementos especialmente desenvolvidos para melhor expressar problemas desse

tipo. Assim, ?ca claro que certos modelos desenvolvidos com base nesses elementos não são com-

patíveis com um resolvedor de programação matemática, restando a questão de como poderia o

interpretador do modelo determinar qual resolvedor utilizar para um modelo descrito se ambos ser-

virem. Por padrão, um modelo em OPL é interpretado como sendo de programação matemática, a

menos que na sua primeira linha exista uma referência em contrário. Atualmente, dois resolvedores

são possíveis: o CP para programação por restrições e o CPLEX para programação matemática.

Para utilizar o CP, faz-se necessário constar o seguinte na primeira linha do modelo:

using CP;

A.3.2 Comentários em Arquivos de Modelo e de Dados

Como em muitas outras linguagens, é possível inserir algum texto explicativo que seja ignorado

pelo resolvedor tanto no arquivo de modelo quanto nos arquivos de dados, mas que seja de grande

valia para outros seres humanos compreenderem com maior facilidade um código alheio. Os comen-

tários em OPL possuem a mesma sintaxe que em C++ ou Java: qualquer texto após a ocorrência

de um // numa linha é ignorado, bem como qualquer texto entre uma ocorrência de /* e a próxima

ocorrência de */, conforme o exemplo abaixo:

// Linha comentada .

/?
? Bloco de texto comentado .
?/

A.3.3 Variáveis de Tipos Primitivos e Atribuições

Para modelar qualquer problema relevante, é necessários conhecer primeiramente os tipos pri-

mitivos e estruturas de dados mais básicas da linguagem. Na OPL, existem três tipos primitivos:

int, ?oat e string. Ao longo desse texto, serão enfatizados os dois primeiros tipos. Na declaração

de uma variável, é facultativo realizar uma atribuição inicial no arquivo de modelo. No exemplo

abaixo, são declaradas uma variável inteira sem atribuir um valor, bem como uma variável inteira

e outra de ponto ?utuante com atribuição de valor. Repare que cada instrução é ?nalizada por um

ponto-e-vírgula em OPL:

int noFabricas ;

int noDepositos = 10;

f l o a t taxaProducao = 5 . 0 ;

Para que uma variável tenha seu valor inicial atribuído por alguma fonte de dados externa, é

realizada uma atribuição simbólica utilizando reticências (três pontos) em vez de um valor, conforme

o exemplo abaixo:

int noFabricas = . . . ;

Em correspondência a essa declaração, em algum dos arquivos de dados deverá haver uma atribuição

relacionada, como a apresentada a seguir:

noFabricas = 7;



ELEMENTOS DE USO GERAL DA LINGUAGEM 93

Quando não é atribuído um valor explicitamente, a inicialização da variável terá de ocorrer por

meio de blocos de programação imperativa, representados pela palavra reservada execute, como no

trecho de modelo abaixo:

int noFabricas ;

execute {

noFabricas = 7;

}

Dentro desses blocos, é utilizada uma linguagem de script chamada ILOG Script, cuja estrutura

é baseada em Javascript. Conforme abordado adiante, é possível declarar variáveis nos trechos de

ILOG Script, mas tais variáveis não servem à modelagem do problema e sim a controles internos

desses blocos. A?nal, tais variáveis são visíveis somente dentro dos blocos imperativos e sequer

possuem tipo explícito.

Quando um modelo é interpretado, ele é processado linha a linha. Dessa forma, quando o bloco

é executado, ele só tem visibilidade e poder de ação sobre as variáveis com declaração nas linhas

acima dele. É importante frisar que com os blocos de script é possível alterar o valor atribuído a uma

variável ao longo do processamento do modelo, algo que não se pode fazer de maneira declarativa

na linguagem. O ILOG Script será tratado novamente em outros pontos ao longo do texto.

A.3.4 Estruturas de Dados Básicas: Vetores e Domínios

Por meio de vetores e domínios já se torna possível representar de maneira razoável os dados de

muitos problemas, de forma que boa parte dos exemplos dados ao longo do texto empregarão essas

estruturas de dados.

O vetor de?nido em OPL é muito similar ao encontrado em outras linguagens de programação.

Ele consiste em uma representação compacta de um conjunto de dados por meio de indexação de

uma ou mais dimensões. Um vetor com uma única dimensão consiste em uma sequência de valores,

enquanto que em duas dimensões ele pode ser visto como uma matriz, e assim por diante. Segue

abaixo um exemplo de declaração de vetores de uma dimensão e de duas dimensões em OPL:

int noProcessos [ 1 . . 3 ] ;

f l o a t teorEnxofre [ 1 . . 3 ] [ 1 . . 2 ] ;

Uma diferença a ser notada na declaração de vetores em OPL é que, além do índice ?nal,

declara-se explicitamente o índice inicial em vez de adotar algum padrão como 0 na linguagem C

ou 1 em Pascal. Entre os índices inicial e ?nal, constam dois pontos consecutivos, utilizados em

conjunção com os dois índices para formar o domínio de cada dimensão. Isso remete à de?nição da

estrutura de dados utilizada para representar explicitamente um domínio em OPL, o range, com o

qual é possível tornar a declaração acima mais clara conforme apresentado abaixo:

range dRefinarias = 1 . . noRefinarias ;

range dDerivados = 1 . . noDerivados ;

int noProcessos [ dRefinarias ] ;

f l o a t teorEnxofre [ dDerivados ] [ dRefinarias ] ;

Como pode ser observado, os exemplos sendo apresentados possuem uma convenção sintática

peculiar ? por exemplo, o pre?xo no para quantidades inteiras e o pre?xo d para o domínio variando



94 APÊNDICE A

entre 1 e a quantidade determinada. Apesar de não representar nenhuma regra estrita, essa conven-

ção partiu da observação do autor de algumas nomenclaturas comuns de variáveis nos modelos em

OPL e foi complementada com outras convenções que facilitaram o desenvolvimento de modelos

mais elaborados ao longo do tempo.

A.3.5 Atribuições Básicas a Elementos de Vetores

Da mesma forma que se faz para variáveis de tipos primitivos, é possível atribuir os valores de

um vetor de variáveis pelas formas mencionadas anteriormente: estaticamente, delegando a alguma

fonte de entrada de dados ou por meio de blocos de programação imperativa. Além disso, tanto em

um caso como no outro também é possível usar expressões para uma atribuição declarativa mais

concisa, conforme será visto mais adiante.

No trecho abaixo, os mesmos vetores dos exemplos anteriores são declarados em conjunto com

uma atribuição estática:

int noProcessos [ dRefinarias ] = [ 10 , 15 , 2 0 ] ;

f l o a t teorEnxofre [ dDerivados ] [ dRefinarias ] = [

[ 1/1000 , 1/1000000] ,

[ 1/1200 , 1/1200000] ,

[ 1/1500 , 1/1500000]

] ;

Abaixo, o primeiro desses vetores é representado com delegação de atribuição para alguma fonte

de dados externa:

int peso [ dCarros ] = . . . ;

E a seguir o trecho na fonte de dados:

peso = [ 10000 , 15000 , 20000];

Para realizar atribuições a valores de vetores utilizando ILOG Script, é possível empregar estru-

turas de controle de ?uxo idênticas às encontradas em Javascript. Temos, por exemplo, as primitivas

if, for, while etc, bem como outros operadores da sintaxe de Javascript. Segue um exemplo usando

for:

int peso [ dCarros ] ;

execute {

for ( var ic in dCarros ) {

peso [ ic ] = 5000?( ic +1) ;
}

}

Como pode ser visto no exemplo acima, é possível declarar uma variável sem tipologia utilizando a

palavra reservada var e iterar sobre um domínio com a palavra reservada in no ILOG Script.

Uma variável declarada em um bloco é acessível por outros blocos de script, de forma que

declarar duas vezes o mesmo identi?cador como variável em blocos distintos resultará em erro de

interpretação quando a segunda declaração for atingida pelo interpretador. Dessa forma, outra boa

prática observada consiste em sempre utilizar identi?cadores diferentes para evitar que um pequeno

descuido leve a um erro de interpretação nas linhas ?nais de um modelo, desperdiçando muito



ELEMENTOS DE USO GERAL DA LINGUAGEM 95

tempo de processamento. Por esse motivo, foi utilizado ?var ic? no exemplo em vez de ?var i?, como

seria de praxe.

Devido à falta de tipologia na declaração e à documentação inconclusiva, o autor desconhece

formas de declarar um vetor nos blocos de script mas não pode a?rmar que elas não existam.

Ainda sim, é possível enunciar um vetor na parte declarativa do modelo para utilização na parte

imperativa, como no exemplo dado.

A.3.6 Expressões Numéricas e Predicados

Para realizar algumas atribuições comuns baseadas em relações conhecidas entre os índices no

vetor e o valor a ser atribuído, as formas descritas anteriormente obrigariam o projetista do modelo

a inserir vários trechos de programação imperativa no mesmo. No entanto, é possível evitar isso por

meio de expressões, com as quais representam-se muitas dessas atribuições de maneira declarativa

e muito mais simples. Por exemplo, é possível atribuir um único valor para todas as entradas de

uma matriz em sua declaração:

int n = . . . ;

int matrizNula [ 1 . . n ] [ 1 . . n ] = 0;

Torna-se uma atribuição declarativa mais dinâmica através da utilização de variáveis identi?-

cando os índices do vetor para atribuir valores individualmente para cada elemento do vetor. Por

exemplo, vejamos a operação de transposição da matriz M no trecho de modelo abaixo:

int n = . . . ;

int M[ 1 . . n ] [ 1 . . n ] = . . . ;

int transpostaM [ i in 1 . . n ] [ j in 1 . . n ] = M[ j ] [ i ] ;

É importante ressaltar que as atribuições em expressões sobre valores são feitas com base nos

próprios valores e não por referência. Dessa forma, se a matriz M for alterada após a criação da

matriz transpostaM, tais alterações não re?etirão nessa segunda matriz.

Em OPL, é possível construir expressões numéricas e booleanas, sendo as últimas normalmente

conhecidas como predicados. Nessas expressões, podemos nos valer de variáveis representando índi-

ces do vetor recebendo uma atribuição. Por exemplo, é possível reescrever a atribuição apresentada

na seção anterior com bloco imperativo em uma única linha declarativa por meio de uma expressão:

int peso [ c in dCarros ] = 5000?( c+1) ;

Nesse exemplo, uma expressão numérica atribui um valor para cada elemento do vetor. Ao contrário

do que ocorre para os blocos de programação imperativa, o escopo dessas variáveis sobre os índices

de um vetor é restrito à expressão de atribuição e o identi?cador do índice pode ser utilizado em

outros contextos sem nenhum problema.

Para expressões numéricas com variáveis e constantes inteiras, é possível utilizar operadores

conhecidos de outras linguagens como +, ?, ?, div, mod (ou %). Os dois últimos operadores podem
parecer estranhos a alguns leitores em razão da nomenclatura adotada. Eles representam, respecti-

vamente, as operações para obtenção de quociente e de resto em uma divisão inteira. Além desses

operadores, a função abs pode ser utilizada para obter o valor absoluto do inteiro dado como argu-

mento e o termo maxint é utilizado para representar a constante correspondendo ao maior inteiro

possível em uma variável do tipo int.



96 APÊNDICE A

Em expressões numéricas envolvendo alguma variável ou constante de ponto ?utuante, conta-

se com os operadores +, ?, ?, / e a palavra reservada infinity para representar simbolicamente
uma quantidade in?nita. Em OPL, o operador / é utilizado exclusivamente para divisão de ponto

?utuante, de forma que o resultado de uma divisão de inteiros com / representará sempre o valor

da divisão em ponto ?utuante desses inteiros e não a respectiva divisão inteira.

Para introduzir uma forma de expressão numérica válida e extremamente útil para valores

inteiros e de ponto ?utuante, apresentaremos outro exemplo de manipulação de matrizes. No trecho

de modelagem abaixo, temos a instanciação de uma matriz identidade:

int identidade [ i in 1 . . n ] [ j in 1 . . n ] = (( i==j ) ?(1) : ( 0 ) ) ;

No exemplo anterior, observamos a utilização do operador ternário com a mesma sintaxe e semântica

encontrada em C e outras linguagens: a expressão numérica ((X)?(Y ) : (Z)). Ela é composta por

uma expressão booleana X e duas expressões numéricas Y e Z, sendo seu resultado igual ao de Y

se X for verdadeira e igual a Z caso contrário. Dessa forma, no exemplo, conseguimos que toda

entrada da diagonal principal tenha valor 1 e as demais entradas tenham valor 0.

Expressões de valor booleano também são chamadas de predicados. É possível construir predica-

dos utilizando expressões numéricas, variáveis e constantes numéricas relacionadas pelos operadores

de comparação ==, ! =, &gt;,&amp;lt;, &gt;= e&amp;lt;=. Além disso, predicados podem ser compostos por outros

predicados com base nos operadores booleanos de conjunção (&amp;amp;&amp;amp;), disjunção (||) e negação (!) à
semelhança do que existe em C e outras linguagens similares.

Expressões booleanas também podem ser vistas como expressões numéricas, sendo cada pre-

dicado verdadeiro equivalente à constante true e ao valor 1, e cada predicado falso equivalente à

constante false e ao valor 0. Assim, poderíamos reescrever o exemplo anterior de maneira ainda

mais compacta ? ainda que de modo um tanto quanto obscuro ? como abaixo:

int identidade [ i in 1 . . n ] [ j in 1 . . n ] = ( i = = j ) ;

Uma última ressalva a ser feita com relação à equivalência entre expressões numéricas e predicados

é que, ao contrário de outras linguagens nas quais 0 é falso e qualquer outro valor é verdadeiro,

isso não é sempre verdade em OPL. Dessa forma, no projeto de um modelo, o projetista deve estar

ciente de que não pode esperar mais do que 0 ser equivalente a falso e 1 a verdadeiro. De uma

maneira geral, o que podemos concluir dessa observação é que não é boa prática utilizar valores que

não 0 ou 1 no lugar de expressões booleanas.

Como em outras linguagens, operadores numéricos e lógicos inserem-se em uma relação de pre-

cedência de forma a resolver boa parte das ambiguidades possíveis na interpretação das expressões

válidas na linguagem. Na OPL, essa relação é idêntica à de muitas outras linguagens. Por exemplo, a

multiplicação é precedente à soma, que é precedente a qualquer operador lógico. Na dúvida, ou para

garantir a semântica da expressão sendo construída a despeito de grandes mudanças na linguagem,

parênteses podem ser utilizados à vontade.

A.3.7 Operadores de Agregação e Funções Sobre Vetores

Para concluir a apresentação sobre expressões e predicados, restam os operadores de agregação

e as funções sobre vetores. Os operadores de agregação representam operações muito comuns no

tratamento dos dados de problemas combinatórios. Alguns deles operam sobre os termos de um



ELEMENTOS DE USO GERAL DA LINGUAGEM 97

conjunto indexado numérico, sendo eles min, max, sum e prod. Eles são usados, respectivamente,

para obter o valor mínimo, o valor máximo, a somatória e o produto de um conjunto de termos.

Vide, por exemplo, a atribuição a um vetor usando a expressão max sobre as linhas de uma matriz

M e de uma variável usando a expressão sum sobre os elementos do vetor resultante:

int n = . . . ;

int M[ 1 . . n ] [ 1 . . n ] = . . . ;

int maxLinha [ i in 1 . . n ] = max( j in 1 . . n) M[ i ] [ j ] ;

int somaMaximos = sum( i in 1 . . n) maxLinha [ i ] ;

Além de operadores de agregação para expressões numéricas, também existem operadores de

agregação para predicados, como or e and. O operador or representa um predicado com valor

verdadeiro se algum termo do conjunto indexado for verdadeiro, enquanto que o and é verdadeiro

se todos os termos do conjunto indexado forem verdadeiros.

Um item importante a ser observado é o comportamento desses operadores quando o conjunto for

vazio: min resulta em infinity, max em ?infinity, prod é 1, sum é 0, or é falso e and verdadeiro.
Os termos dos conjuntos utilizados nos operadores de agregação podem ser outros operadores ou

expressões da mesma natureza que o operador, seja ele numérico ou booleano. No exemplo abaixo

sobre como calcular o quadrado de uma matriz M, é ilustrado um caso no qual cada termo de um

somatório consiste em uma expressão numérica sobre o índice k:

int quadradoM [ i in 1 . . n ] [ j in 1 . . n ] = sum (k in 1 . . n) M[ i ] [ k ]?M[ k ] [ j ] ;

Em alguns casos, é possível substituir a composição de operações de agregação por uma única

operação com mais índices. No exemplo abaixo, é de?nido um somatório sobre termos da M em-

pregando dois índices distintos para somar apenas o valor dos elementos abaixo de sua diagonal

principal:

int somaElementosInferioresM = sum( i in 1 . . n , j in 1 . . n : i&gt;j ) M[ i ] [ j ] ;

Para se somar apenas os elementos abaixo da diagonal principal, uma condição foi imposta além

da especi?cação do domínio dos índices. Essa condição delimita quais duplas de valores devem ser

consideradas utilizando o símbolo : acrescido de um predicado que de?ne um critério de ?ltragem.

Quando especi?camos um subconjunto do produto cartesiano dos domínios dos índices para uti-

lizar um operador de agregação, estamos de?nindo um parâmetro formal. Mais adiante, serão vistas

outras situações na linguagem em que parâmetros formais podem ser empregados para representar

conjuntos. Vale ressaltar que, até a presente versão do OPL, parâmetros formais não suportam

a utilização interna de operadores de agregação, isto é, um operador de agregação não pode ser

utilizado dentro do índice de outro operador de agregação.

Em alguns casos especiais, é possível substituir a utilização de operadores de agregação sobre

conjuntos indexados por uma função que opere sobre vetores. Por exemplo, para contar o número de

ocorrências de um valor em um vetor, pode-se utilizar a função count. Essa função recebe um vetor

de uma dimensão e um valor como parâmetros para retornar o número de vezes que o valor aparece

no vetor. Para calcular o desvio padrão de um vetor inteiro, existe a função standardDeviation.

Ambas estão apresentadas no exemplo a seguir:



98 APÊNDICE A

int x = . . . ;

int n = . . . ;

int vetor [ 1 . . n ] = . . . ;

int M[ 1 . . n ] [ 1 . . n ] = . . . ;

int elementosVetorIguaisX = count ( vetor , x) ;

int ocorrenciasXporLinhaM [ i in 1 . . n ] = count (M[ i ] , x) ;

f l o a t desvioPadraoPorLinhaM [ i in 1 . . n ] = standardDeviation (M[ i ] ) ;

Na penúltima linha do exemplo acima, foi utilizada a função count sobre um vetor extraído da

matriz M. Dessa forma, foi contado o número de ocorrências de um valor para cada linha dessa

matriz. Tal vetor foi obtido a partir da matriz M pela não-indexação de sua última dimensão. Fazer

o mesmo de forma tão simples para obter uma coluna de M não é possível, e em princípio isso

poderia limitar a aplicabilidade de funções sobre vetores, como é o caso de count.

Para esses casos, utiliza-se o operador all para criar um vetor unidimensional a partir de um

parâmetro formal sobre um vetor qualquer de uma ou mais dimensões. Esse operador é necessário

porque tais funções não permitem a utilização de parâmetros formais diretamente, como é o caso

dos operadores de agregação. Seguem alguns exemplos:

int ocorrenciasXporColuna [ j in 1 . . n ] = count ( a l l ( i in 1 . . n) M[ i ] [ j ] , x) ;

int ocorrenciasXnaDiagonal = count ( a l l ( i in i . . n , j in 1 . . n : i==j ) M[ i ] [ j ] , x) ;

Na primeira linha do exemplo acima, foi apresentada uma forma de contar as ocorrências de um

valor na coluna de uma matriz por meio da criação de um vetor contendo apenas os elementos

daquela coluna da matriz. Na segunda linha, foi apresentada uma forma de calcular a ocorrência

de um valor na diagonal principal dessa matriz.

O operador all também pode ser utilizado para atribuição em um vetor, isto é, podemos extrair

a coluna de uma matriz para um vetor e até mesmo unir o resultado de algumas dessas operações

para obter um vetor maior por meio da função append, como nos exemplos abaixo:

int coluna2deM [ 1 . . n ] = a l l ( i in 1 . . n) M[ i ] [ 2 ] ;

int colunas2e5deM [ 1 . . 2 ? n ] =
append ( a l l ( i in 1 . . n) M[ i ] [ 2 ] , a l l ( i in 1 . . n) M[ i ] [ 5 ] ) ;

Na primeira linha do exemplo, foi criado um vetor com base na segunda coluna de uma matriz M.

Na segunda linha, foi criado um vetor com o dobro do tamanho do anterior por meio da junção de

dois vetores contendo, cada um, uma coluna de M.

As funções count e standardDeviation não são os únicos exemplos de expressões que utilizem

vetores de uma dimensão como argumento. Quando forem tratadas as restrições especializadas e

predicados para escalonamento, observaremos outras funções com essa característica, expandindo o

leque de possibilidades de aplicação do operador all.

A.3.8 Estruturas de Dados Avançadas: Tuplas e Conjuntos

Devido ao propósito introdutório desse texto, não se entrará em muitos detalhes sobre as es-

truturas de dados mais avançadas disponíveis em OPL: as tuplas e os conjuntos. Entretanto, não

é possivel ignorar as tuplas e conjuntos por completo sem algum prejuízo quando o texto atingir a

parte sobre escalonamento.



MODELAGEM DE PROBLEMAS COMBINATÓRIOS 99

Uma tupla consiste em uma composição de variáveis a partir da qual se de?ne um tipo através

da palavra reservada tuple, possibilitando a declaração de variáveis pre?xando-as com o tipo dado

à tupla, como no exemplo a seguir:

tuple ProcessoConversao {

f l o a t entrada ;

f l o a t saida ;

}

ProcessoConversao conversoes [ 1 . . 3 ] = [

&lt;3.5 , 2.9 &gt; ,

&lt;4.0 , 3.0 &gt; ,

&lt;4.5 , 3.1 &gt; ,

] ;

Com base no exemplo acima, o acesso ao valor de entrada do primeiro processo é dado pela expressão

?conversoes[1].entrada?.

Os conceitos apresentados para a atribuição por expressão também são válidos para tuplas, de

forma que é possível criar expressões indexadas para especi?car uma tupla para cada índice diferente

de um vetor, como na adaptação do exemplo anterior feita abaixo:

ProcessoConversao conversoes [ i in 1 . . 3 ] =

&amp;lt;3 + 0.5? i , 2.8 + 0.1? i &gt;;

Um conjunto consiste em um agrupamento de valores de algum tipo que, ao contrário dos vetores,

não possui dimensões de indexação. No exemplo abaixo, é declarado um conjunto de inteiros sem

qualquer indexação explícita:

{ int } pesos = {10000 , 15000 , 20000};

Claramente, existe uma vantagem expressiva pela utilização de tuplas e conjuntos pelo fato que

as propriedades de uma entidade do modelo possam ser representadas compactamente tanto na

declaração quanto na atribuição dos dados. Dessa forma, é recomendado que o leitor interessado em

um uso prolongado da ferramenta se aprofunde no estudo dessas estruturas para projetar modelos

mais estruturados.

A.4 Modelagem de Problemas Combinatórios

Até esse ponto do texto foram tratados apenas elementos relevantes ao pré-processamento do

problema: escolha do resolvedor, de?nição das estruturas de dados, atribuição dos dados e mani-

pulação inicial dos dados. Com esses elementos em mãos e apropriadamente descritos no modelo,

podemos passar à formulação do problema para ser resolvido pelo resolvedor. Um arquivo de modelo

em OPL geralmente consiste em um único problema a ser resolvido. Após a descrição do problema

ser interpretada e a etapa de resolução concluída, passa-se à etapa de pós-processamento, na qual

novas manipulações de dados tomam lugar e na qual, geralmente, encontram-se rotinas de impressão

para apresentar os resultados obtidos com o modelo da maneira que melhor interessar ao modelador.

Dessa forma, passaremos agora à de?nição do problema e quaisquer outras informações relevan-

tes ao pós-processamento.



100 APÊNDICE A

A.4.1 Variáveis de Decisão de Tipos Primitivos

O primeiro passo para expressar um problema decisório ou de otimização consiste na declaração

de suas variáveis de decisão. A solução de um problema consistirá em uma atribuição válida de

valores a tais variáveis. A escolha dessa atribuição dependerá de outros fatores que serão vistos

adiante, como o conjunto de restrições e a função objetivo.

A palavra reservada dvar é empregada antes do tipo da variável para identi?car que a variável

sendo declarada é de decisão. Dos tipos primitivos, é possível declarar variáveis de decisão usando

int e float, além da opção de acrescer + ao nome do tipo para que a variável seja não-negativa,

isto é, maior ou igual a 0. Além disso, podemos substituir int por boolean se os valores válidos para

a variável forem apenas 0 e 1. Convém observar que as variáveis do tipo float não serão detalhadas

devido ao fato de não serem aceitas em modelos empregando o resolvedor CP. Isso se deve à premissa

de que as variáveis tenham domínio discreto e ?nito em problemas abordados com programação por

restrições. É possível declarar esse domínio explicitamente utilizando a palavra reservada in após o

nome da variável seguida do domínio da mesma. Se um domínio não for especi?cado, são utilizados

os limites de uma variável inteira na arquitetura adotada pelo resolvedor.

Abaixo são apresentados alguns exemplos de declarações de variáveis de decisão inteiras na

linguagem OPL:

dvar int escolha in 1 . . 5 ;

dvar int+ quantidade ;

Na primeira declaração do exemplo, temos uma variável inteira restrita a um domínio através da

utilização do operador in. Na segunda declaração, temos uma variável inteira não-negativa sem

restrição de domínio, ?cando subentendido ao resolvedor que o domínio da variável é 0..maxint.

Os conceitos apresentados acima são naturalmente aplicáveis à declaração de vetores de variáveis

de decisão. Nesse caso, expressões sobre os índices podem ser empregadas para de?nir um domínio

diferente a cada variável do vetor, como pode ser visto no exemplo a seguir:

int noProcessos = . . . ;

range dProcessos = 1 . . noProcessos ;

int nivelMaximoProcesso [ dProcessos ] = . . . ;

dvar int nivel [ p in dProcessos ] in 0 . . nivelMaximoProcesso [ p ] ;

Ao contrário das outras variáveis, as variáveis de decisão de um modelo normalmente não pos-

suem atribuição em sua declaração, apesar disso ser possível em casos mais elaborados fora do escopo

desse texto. No entanto, em algumas situações o modelo sendo desenvolvido pode deixar clara a

necessidade de manipulação de algumas variáveis dependentes de valores de variáveis de decisão.

Tais variáveis poderiam ser de?nidas como variáveis de decisão e essa relação poderia ser expressa

por meio de restrições. No entanto, existe uma alternativa em OPL para evitar uma quantidade

excessiva de variáveis de decisão no modelo: as expressões de decisão, descritas a seguir.

A.4.2 Expressões de Decisão

Uma expressão de decisão pode ser entendida como uma variável que possui o identi?cador dexpr

antes de seu tipo na declaração. Ela sempre recebe uma atribuição na forma de expressão, que pode

envolver constantes, variáveis, variáveis de decisão e outras expressões de decisão. Ao contrário do

que ocorre com as variáveis de decisão, não existe restrição sobre expressões de decisão envolvendo o



MODELAGEM DE PROBLEMAS COMBINATÓRIOS 101

tipo float em modelos utilizando o resolvedor CP. Além disso, as expressões de decisão possibilitam

reduzir o espaço de busca ao estabelecer uma relação entre diferentes parâmetros do sistema sendo

modelado sem necessariamente de?ni-los todos como variáveis de decisão. Dessa forma, é possível

de?nir uma hierarquia entre decisões e facilitar o processo de resolução do problema.

Abaixo temos um exemplo da utilização de expressões de decisão sobre o vetor de variáveis de

decisão previamente de?nido:

int maxNivelProcesso = max (p in dProcessos ) nivelMaximoProcesso [ p ] ;

range dNiveis = 0 . . maxNivelProcesso ;

f l o a t custoExecucaoProcessoNivel [ p in dProcessos ] [ dNiveis ] = . . . ;

dexpr f l o a t custoExecucaoTotal =

sum(p in dProcessos , n in dNiveis )

( nivel [ p]==n) ?( custoExecucaoProcessoNivel [ p ] [ n ] ) : ( 0 ) ;

À primeira vista, pode parecer que a expressão de decisão do exemplo acima poderia ser reescrita

de maneiras mais compactas. Dessa forma, vamos analisar como se suporia que esse trecho poderia

ter sido progressivamente compactado para ilustrar as limitações inerentes.

Primeiro, poderíamos supor que o predicado do operador condicional pudesse ser colocado den-

tro do somatório, criando um parâmetro formal mais restrito. Entretanto, isso não é possível e esse

é um problema bastante comum nos primeiros modelos que se faz em OPL: variáveis e expressões

de decisão não podem constar em parâmetros formais antes do pós-processamento, isto é, enquanto

essas variáveis não possuem um valor ?xo de?nido. É mencionado em muitos pontos do manual o?-

cial da linguagem que certos operadores e predicados não suportam aplicação como meta-restrições,

o que signi?ca que não se pode empregar nessas funções nenhum argumento baseado em variáveis

de decisão ou expressões de decisão. Nesse caso, não é possível escrever ?sum(p in dProcessos, n

in dNiveis : nivel[p]==n)? porque ?nivel[p]? representa uma variável de decisão e a expressão não

pode ser interpretada antes dessa variável ter seu valor decidido pela resolução.

Segundo, poderíamos supor uma compactação ainda maior do modelo usando as variáveis de

decisão para indexação, reescrevendo o somatório como ?sum(p in dProcessos) (custoExecucaoPro-

cessoNivel[p][nivel[p]])?. Entretanto, a limitação mencionada anteriormente também se estende à

utilização de variáveis pre?xadas por dvar e dexpr para o acesso a índices de vetores em expressões

de decisão ou mesmo em restrições. A?nal, isso signi?caria usar uma variável de decisão como índice

de acesso a uma matriz para gerar o valor de uma expressão de decisão durante a execução, algo

que o interpretador não é capaz de fazer por não ter um valor de?nido às variáveis de decisão e

expressões.

Além dessas questões, outra precaução a ser tomada com relação a variáveis de decisão e expres-

sões de decisão se relaciona ao fato de que elas são variáveis sem valor de?nido para manipulação

antes da resolução do problema, que ocorre após o bloco de restrições ? não tratado até esse ponto

do texto. Dessa forma, instruções imperativas que tentem acessar o valor dessas variáveis antes do

pós-processamento podem ter comportamento inesperado. No mais, essas variáveis podem ser uti-

lizadas indistintamente de outros tipos de variáveis na de?nição da função objetivo e das restrições

do modelo, como veremos adiante.



102 APÊNDICE A

A.4.3 Sobre a Impossibilidade de Usar Variáveis float em CP

Visto que os valores que podem ser atribuídos a uma variável de ponto ?utuante também repre-

sentam um conjunto discreto devido à limitação de precisão em máquina, poder-se-ia argumentar

que também seria possível utilizar uma variável de decisão em ponto ?utuante em programação por

restrições, a despeito da di?culdade de implementação de algoritmos de resolução baseados nesse

fato.

Um bom argumento para justi?car a inexistência dessa possibilidade tanto em OPL como em

outras linguagens é o de que o objetivo da programação por restrições consiste na resolução de

problemas combinatórios e não de programação matemática, para os quais outros resolvedores

possuem melhor desempenho. Essa especialização dos algoritmos desenvolvidos para a resolução

de problemas combinatórios em modelos de programação por restrições torna a técnica bastante

competitiva para tais problemas, mas implica em trabalhar sobre domínios com características

bastante peculiares. No caso de um intervalo de valores representáveis por uma variável de ponto

?utuante, isso exigiria o projeto de todo um novo conjunto de algoritmos mais complexos e que

se prestariam, em muitos casos, a resolver problemas que podem ser tratados de maneira mais

elegante por outras técnicas. Ainda sim, é possível que algumas propriedades da solução de um

problema combinatório tenham valores em ponto ?utuante sem que seja necessário representar tais

propriedades como variáveis de decisão do modelo, como vimos para as variáveis de expressão de

decisão.

A.4.4 Função Objetivo

Quando trabalhamos com um problema de otimização, desejamos não apenas obter uma solução

que satisfaça às restrições do modelo ? como será visto adiante. Além disso, podemos querer que

a solução encontrada seja comparada com outras soluções possíveis de acordo com algum critério

quantitativo para que a solução ?nal seja a melhor dentre as encontradas durante a resolução. A essa

medida quantitativa damos o nome de função objetivo, que deve ser maximizada ou minimizada,

conforme o problema e a modelagem dados.

Em OPL, uma função objetivo é declarada após as variáveis de decisão e antes do bloco de

restrições, sendo possível declarar apenas uma função objetivo por modelo. Ela é caracterizada por

alguma das palavras reservadas minimize ou maximize, dependendo do problema ser de minimi-

zação ou de maximização. Após a palavra reservada, a função objetivo declarada segue as mesmas

regras de composição que as expressões de decisão, sendo boa prática em grandes projetos de?nir a

função objetivo apenas sobre uma função linear de expressões de decisão, isto é, a soma do produto

de expressões de decisão por constantes. Embora seja comum que problemas sejam de otimização,

isso nem sempre é verdade e ela pode não ser encontrada no modelo ? caso em que se trata de um

problema decisório. Nesse caso, o resolvedor interrompe a busca quando encontra a primeira solu-

ção, visto que não há razão para continuar a procura se não houver qualquer métrica que justi?que

que a solução encontrada não seja a mais adequada.

Segue abaixo um exemplo de função objetivo de minimização sobre a expressão de decisão

declarada anteriormente:

minimize custoExecucaoTotal ;



MODELAGEM DE PROBLEMAS COMBINATÓRIOS 103

A.4.5 Restrições Básicas Sobre Tipos Primitivos

Uma vez de?nidas as variáveis de decisão e a função objetivo, resta a de?nição do conjunto

de restrições para completar a modelagem do problema. Essa de?nição é feita dentro de um bloco

pre?xado por subject to, como a seguir:

subject to {

// Restrições do modelo .

}

Dentro desse bloco, serão especi?cados apenas predicados. Em termos de programação por restri-

ções, esses predicados de?nirão um problema de satisfabilidade, isto é, um problema para o qual a

solução consistirá em uma atribuição de valores às variáveis de decisão de tal forma que todos os

predicados do bloco de restrições estejam satisfeitos. Se não houver con?guração com a qual isso

seja possível, diz-se que o problema é insatisfatível, não havendo solução.

Conforme mencionado anteriormente, esses predicados podem ser de?nidos em termos de ex-

pressões numéricas envolvendo operações aritméticas inteiras e de ponto ?utuante, operadores de

agregação ou outras funções como abs e count em associação a comparadores, como no exemplo

abaixo:

dvar int+ criancas ;

dvar int+ menores ;

dvar int+ adolescentes ;

subject to {

criancas == menores ? adolescentes ;
}

No exemplo acima, foi de?nida uma relação entre as variáveis de decisão criancas, menores e

adolescentes.

A partir dos próximos exemplos, as restrições serão geralmente apresentadas sem o bloco externo

demarcado com subject to, por simplicidade.

Em muitos problemas de otimização, encontram-se conjuntos de restrições de?nidas sobre ín-

dices. Para fazer o mesmo em OPL, utiliza-se a palavra reservada forall seguida de um par de

parênteses dentro do qual um parâmetro formal é de?nido e um bloco para a de?nição de restrições

que podem contar com os índices do parâmetro formal. No exemplo a seguir, ilustra-se o conceito

com o vetor de variáveis de decisão de?nido na seção anterior:

f o r a l l (p in dProcessos : p&lt;noProcessos ) {

nivel [ p ] &gt;= nivel [ p+1];

}

Com a restrição acima, forçamos que o vetor esteja em ordem não-crescente de valores, i.e., o valor

de nivel[p] nunca é menor que o de nivel[p+ 1]. Observe que os limites de indexação são observados

graças a uma condição no parâmetro formal que impede o estouro do vetor.

Convém frisar novamente que, na de?nição de parâmetros formais dentro do bloco de restrições,

não se pode utilizar variáveis de decisão. Apesar disso, existe uma construção de implicação lógica

que aceita variáveis de decisão. Ela consiste de dois predicados separados por =&gt;, signi?cando que a

veracidade do primeiro implica na veracidade do segundo para que a restrição seja satisfeita. Segue

um exemplo baseado nas mesmas variáveis e em declarações da seção anterior:



104 APÊNDICE A

f o r a l l (p in dProcessos : p&lt;) {

( nivel [ p]==nivelMaximoProcesso [ p ] ) =&gt;

( nivel [ p+1] &amp;lt;nivel [ p ] ) ;

}

A.4.6 Restrições Especializadas Sobre Tipos Primitivos

Além das restrições possíveis pelo rol de elementos descritos até agora, em CP ainda é pos-

sível utilizar algumas restrições especializadas. Essas restrições representam ocorrências comuns

em problemas combinatórios, permitindo modelar vários problemas com uma quantidade menor

de variáveis e que o resolvedor trabalhe de maneira mais e?ciente em tais problemas por existi-

rem algoritmos de redução de domínios especí?cos para essas restrições. São elas: allDifferent,

allMinDistance, inverse, lex e pack.

O predicado allDifferent é verdadeiro se todos os elementos do vetor inteiro unidimensional

dado como argumento forem diferentes entre si. É possível, por exemplo, expressar o seguinte:

a l l D i f f e r e n t ( niveis ) ;

Nesse exemplo, expressa-se que cada nível deverá ser diferente dos demais. Com allDifferent,

evita-se ter que especi?car uma restrição de desigualdade para cada par de elementos distintos do

vetor, reduzindo bastante o tamanho da modelagem e facilitando a resolução do problema.

O predicado allMinDistance representa uma generalização desse conceito, recebendo como

segundo argumento um valor inteiro que especi?ca a diferença absoluta mínima entre quaisquer

dois elementos do vetor. Dessa forma, o valor 0 torna o predicado trivialmente verdadeiro e o valor

1 torna o predicado equivalente ao anterior, isto é, é possível expressar a mesma regra que foi

modelada anteriormente da seguinte forma:

allMinDistance ( niveis , 1) ;

O predicado inverse cria uma relação de bijeção entre dois vetores. Por exemplo, se forem

dados como argumentos os vetores x e y, para qualquer índice i vale que, se x[i] = j, então y[j] = i.

O predicado lex também recebe dois vetores inteiros como argumento, sendo ambos do mesmo

tamanho, e é verdadeiro se o primeiro vetor for lexicogra?camente menor que o segundo vetor, isto

é, se o elemento de cada posição do primeiro for menor ou igual ao do segundo.

Por ?m, o predicado pack representa boa parte das relações existentes em um problema da

mochila com m mochilas e n itens ? i.e., particionar n elementos de acordo com o limite de peso

admitido em cada uma das m partições. Em sua versão mais simples, ele envolve três vetores inteiros

unidimensionais, o primeiro com dimensão m e os outros com dimensão n. Um quarto argumento

opcional consiste em um valor inteiro. O primeiro vetor consiste no peso total de cada mochila,

o segundo vetor na determinação da mochila a qual cada item foi atribuído e o terceiro vetor ao

peso de cada item. O argumento opcional representa a quantidade de mochilas com algum item

atribuído. O terceiro vetor é constante, mas os dois primeiros podem ser ambos de variáveis de

decisão ? mas não apenas um deles e o outro não. Se os dois primeiros vetores forem variáveis de

decisão, o quarto argumento pode ser uma variável de decisão também.

A seguir, é apresentado um exemplo envolvendo a atribuição de passageiros a carros e a relação

do peso dos passageiros com o peso total em cada carro para ilustrar como o predicado pack opera:



MODELAGEM DE PROBLEMAS COMBINATÓRIOS 105

int noCarros = . . . ;

range dCarros = 1 . . noCarros ;

int noPassageiros = . . . ;

range dPassageiros = 1 . . noPassageiros ;

int pesoPassageiro [ p in dPassageiros ] = . . . ;

dvar int pesoNoCarro [ c in dCarros ] ;

dvar int carroComPassageiro [ p in dPassageiros ] in dCarros ;

dvar int carros in dCarros ;

subject to {

pack ( pesoNoCarro , carroComPassageiro , pesoPassageiro , carros ) ;

}

No exemplo, temos dois vetores de variáveis de decisão e uma variável de decisão inteira, todos

completamente interdependentes: o modelo procura determinar em qual carro cada passageiro vai,

o que determina o peso total de passageiros nesse carro de acordo com o peso de cada um deles e

também quantos carros têm pelo menos um passageiro atribuído.

A.4.7 Execução do Resolvedor e Con?gurações Básicas do CP

Uma vez realizado o pré-processamento e processada a de?nição do problema de otimização,

o interpretador realiza o passo geralmente mais demorado, que consiste na resolução do problema

descrito pelo modelo. Na saída visualizada na tela, é possível observar informações gerais sobre o

modelo, o consumo de memória e tempo do processo de busca. Durante a busca, a períodos regulares

ocorre uma saída sobre novas soluções encontradas ou sobre o número de variáveis sem atribuição.

Acompanhando a variação desse valor, com o tempo podemos inferir a di?culdade de resolução do

modelo para uma dada instância do problema e compreender como modelar o problema de forma

que sua resolução seja facilitada.

O processo de busca ocorre apenas se o resolvedor não inferir que o problema é infactível e pode

durar até que uma solução seja encontrada no caso de não haver função objetivo, até a melhor

solução ser encontrada se houver uma função objetivo, até todo o espaço de busca ser examinado

sem que nenhuma solução seja encontrada ou ? caso essas situações não ocorram facilmente ? até

um determinado limite de tempo ou número de iterações ser atingido. Tais limites representam

parâmetros de con?guração do resolvedor. Para surtir efeito no processo de busca, tais parâme-

tros devem ser alterados antes do bloco de restrições do modelo, isto é, no pré-processamento. A

parametrização do resolvedor pode ser realizada por meio de instruções especí?cas nos blocos de

programação imperativa antes do bloco de restrições, como no exemplo abaixo:

execute {

cp . param . TimeLimit = 60;

cp . param . LogPeriod = 1000;

cp . param . randomSeed = 42;

}

Nesse exemplo, foram alterados três parâmetros do resolvedor: estabelecemos que a busca deva

terminar em, no máximo, 60 segundos; que uma linha de estado deve ser impressa na tela a cada

1000 iterações realizadas; e atribuímos uma nova semente aleatória ao algoritmo. A importância da

de?nição e variação das sementes empregadas está relacionada ao emprego de critérios de desempate

na escolha dos próximos passos da busca: quando o critério de avaliação tem um empate técnico



106 APÊNDICE A

entre algumas opções ? como na escolha da próxima variável ou valor a atribuir ?, é possível arbitrar

a escolha com alguma aleatoriedade, de forma que pode ser interessante rodar o resolvedor várias

vezes com sementes distintas.

A ?xação e posterior mudança no valor de uma semente para o modelo pode ser útil quando, por

qualquer motivo, o resolvedor não gera uma solução para uma instância apesar de gerar para outras

instâncias muito parecidas. Se desejarmos avaliar a robustez no desempenho de um modelo, nosso

interesse será em utilizar sementes variadas em execuções sucessivas do modelo sobre uma mesma

instância para avaliar como isso altera os resultados obtidos. Nesse tipo de avaliação, a variação na

qualidade da solução obtida ou no tempo de execução para atingir soluções em um determinado

patamar dá um bom indício da robustez do modelo para o conjunto de instâncias esperado.

A.4.8 Manipulação da Solução e Impressão dos Resultados no Pós-Processamento

Após a resolução do problema do modelo, é possível inserir novas declarações de vetores e blocos

de programação imperativa; de forma a manipular os resultados obtidos para as variáveis de decisão

e expressões de decisão, obtendo assim informações de interesse ao projetista do modelo. No pós-

processamento, as variáveis de decisão são vistas como variáveis comuns nas expressões e podem

ser utilizadas para atribuições a novos vetores. É nesse ponto que geralmente encontram-se blocos

de programação imperativa com rotinas de impressão, apesar de que é possível empregar rotinas

de impressão no pré-processamento. Essas rotinas de impressão consistem nas funções imperativas

write e writeln, com as quais podemos manipular texto da mesma forma como fazemos em Java,

sendo a diferença entre ambas as funções que a segunda pule de linha automaticamente após a

impressão de seu conteúdo.

No exemplo a seguir, ilustra-se um exemplo pela geração de um vetor e impressão da informação

de uma variável de decisão empregada em exemplos anteriores:

int processosPorNivel [ n in dNiveis ] = count ( nivel , n) ;

execute {

writeln (" Niveis definidos a algum processo :") ;

for ( var i n i in dNiveis ) {

i f ( processosPorNivel [ i n i ]&gt;0) {

writeln (" Nivel "+i n i ) ;

}

}

}

Convém observar que o exemplo poderia ainda ser reescrito com menos linhas se, em vez de declarar

um vetor, fosse utilizada diretamente a expressão ?count(nivel,ini)? na condição do if.

A.4.9 Um Exemplo de Problema Combinatório Modelado em OPL

Para não concluir a apresentação dos conceitos elementares da linguagem OPL para a modela-

gem de problemas combinatórios sem um exemplo completo para resolver um problema, segue um

exemplo de Lustig e Puget (2001) baseado no problema das n rainhas. Nesse problema, interessa-nos

posicionar n rainhas em um tabuleiro n×n sem que nenhuma delas possa atacar outra:



MODELAGEM DE PROBLEMAS COMBINATÓRIOS 107

1 using CP;

2

3 int n = . . . ;

4 range dN = 1 . . n ;

5 dvar int rainhaLinha [dN] in dN; // Define onde está a rainha de cada linha .

6

7 subject to {

8 // Duas rainhas não podem f i c a r na mesma linha :

9 a l l D i f f e r e n t ( rainhaLinha ) ;

10

11 // Duas rainhas não podem f i c a r na mesma diagonal :

12 // Verif ica se quaisquer duas rainhas pertencem à mesma diagonal .

13 // Índice das rainhas é ordenado para evitar v e r i f i c a ç õ e s desnecessárias .

14 f o r a l l ( i in dN, j in dN : i &amp;lt;j ) {

15

16 // Relação da diagonal principal : coluna + linha = constante

17 ( rainhaLinha [ i ] + i ) !=( rainhaLinha [ j ] + j ) ;

18

19 // Relação da diagonal secundária : coluna ? linha = constante

20 ( rainhaLinha [ i ] ? i ) !=( rainhaLinha [ j ] ? j ) ;
21 }

22 }

23

24 execute {

25 writeln (" Resultado :") ;

26 for ( var i in dN) {

27 writeln (" Linha " + i + " ? Coluna " + rainhaLinha [ i ] ) ;
28 }

29 }

Para esse exemplo e n = 10, obtemos a seguinte resposta por meio de impressões na tela:

Resultado:

Linha 1 - Coluna 5

Linha 2 - Coluna 9

Linha 3 - Coluna 4

Linha 4 - Coluna 7

Linha 5 - Coluna 8

Linha 6 - Coluna 6

Linha 7 - Coluna 10

Linha 8 - Coluna 1

Linha 9 - Coluna 3

Linha 10 - Coluna 2

Ainda com relação ao exemplo apresentado, uma alternativa ao parâmetro formal ?i in dN, j in

dN : i &amp;lt;j? poderia ser ?i in dN, j in 1..i?. Entretanto, tais ganhos de processamento devem ser

avaliados com cautela, pois podem tornar o código menos legível. Uma vez processado o modelo

para que o resolvedor proceda com a busca por meio de uma representação mais simples, não haverá

diferença entre as duas representações.



108 APÊNDICE A

Pode ser de interesse do leitor saber como obter soluções alternativas do problema. Para tanto,

é necessário um controle externo que solicitasse novas soluções do resolvedor. Isso é feito por meio

de um bloco imperativo declarado com a palavra reservada main em vez de execute no arquivo

de modelo. Apesar de não tratarmos o assunto nesse texto introdutório, é importante que o leitor

saiba da existência desse recurso.

A.5 Modelagem de Problemas de Escalonamento

Um problema de escalonamento consiste na programação da execução de um conjunto de ativi-

dades ao longo de um período de tempo. Nessa seção, apresentaremos estruturas e especializações

interessantes para a modelagem de problemas de escalonamento em OPL, de forma similar ao que

foi feito anteriormente para problemas combinatórios. Esses elementos adicionais não descartam

tudo o que foi visto até o momento para problemas combinatórios, mas servem de complemento

para a obtenção de um grau maior de expressividade.

A.5.1 Problemas de Escalonamento e a Motivação ao Emprego de CP

Em um problema de escalonamento, estamos interessados em decidir, entre outras coisas, quando

certos eventos ocorrem e como cada evento ocorre. Dessa forma, a solução representa uma escala ?

ou programação ? desses eventos. O conjunto de restrições quanto às possibilidades de construção

de uma escala re?etem características dos eventos, regras de ordenação entre eles, a utilização de

algum tipo de recurso compartilhado, o tempo de separação entre eventos consecutivos de acordo

com suas características etc.

Para modelos de programação matemática, as variáveis de decisão associadas a tais eventos

geralmente são vetores booleanos, representando se cada atividade ocorre ou é iniciada em cada

instante de tempo possível, e podem ter muitas dimensões de acordo com os graus de liberdade e

as restrições do problema. Quando a janela de tempo é muito grande e a discretização de intervalos

muito ?na, a resolução de tais modelos pode se tornar inviável. Em muitos casos, não são conhecidas

formas de expressar o problema de uma maneira mais compacta dentro dos limites do que é possível

com programação matemática.

Em programação por restrições, entretanto, os limites de ?exibilização são maiores. Dessa forma,

variáveis de decisão com domínios diversos e algoritmos de resolução especializados dão suporte

a formulações que usam menos memória e tempo de processamento em algumas situações. Isso

possibilita a obtenção de soluções para instâncias de problemas de escalonamento de grande porte

que, de outra forma, não poderiam ser tratados com os recursos computacionais disponíveis.

Os elementos apresentados a seguir servem ao propósito de expressar a modelagem de problemas

combinatórios de escalonamento com semântica mais apurada, o que torna sua representação mais

compacta e facilita a resolução desses modelos pela utilização de algoritmos especializados nessas

estruturas.

A.5.2 Variáveis de Intervalo e Suas Propriedades

Muitas variáveis de um problema de escalonamento podem ser expressas por intervalos, delimi-

tando propriedades como o início e o ?m de um evento. Em OPL, é possível expressar variáveis de

decisão intervalares por meio do tipo interval, como a seguir:



MODELAGEM DE PROBLEMAS DE ESCALONAMENTO 109

dvar interval atividade ;

O início e o ?m de um intervalo representam variáveis de decisão inteiras e interdependentes.

Quando declara-se que um intervalo possui um domínio, é de?nido que o início e o ?m do intervalo

devem pertencer àquele domínio, como no exemplo abaixo:

int pDia = . . . ;

int uDia = . . . ;

range dDias = pDia . . uDia ;

dvar interval escalaAtividade in dDias ;

Além do ínicio e do ?m, uma variável do tipo interval também possui outras propriedades

interdependentes como tamanho e duração. Tais propriedades também podem ter algum grau de

liberdade, situação na qual assumem o papel de variáveis de decisão nas relações entre início e

?m. Para acessar explicitamente os valores de início e ?m de um intervalo em expressões, são

utilizadas as funções startOf e endOf dando como argumento o intervalo. A duração, que consiste

na diferença entre o ?m e o início de um intervalo, pode ser obtida com a função lengthOf. O

tamanho de um intervalo, obtido pela função sizeOf, pode ser menor do que sua duração. Isso

ocorre quando uma função de intensidade é de?nida para o intervalo. Apesar de não se tratarem

funções de intensidade nesse texto introdutório, o conceito pode ser entendido de maneira fácil pelo

seguinte exemplo. Podemos dizer que uma atividade durou uma semana corrida, 7 dias. Entretanto,

seu tamanho pode ser de 5 dias, visto que a função de intensidade possua valor nulo para os dias

do ?m-de-semana.

O tamanho de uma variável também pode ser especi?cado na declaração da variável. Dessa

forma, a de?nição do domínio de um intervalo em sua declaração pode se tornar mais elaborada

do que aquela encontrada em tipos primitivos. No exemplo a seguir, é declarado um intervalo com

tamanho ?xo:

int tAtividade = . . . ;

dvar interval escalaAtividade

in dDias

s i z e tAtividade ;

Abaixo, tem-se um exemplo da declaração de um intervalo com tamanho variável, utilizando

um domínio para delimitar o menor e o maior valor possível para o tamanho do intervalo:

int tMinAtividade = . . . ;

int tMaxAtividade = . . . ;

range dTamAtividade = tMinAtividade . . tMaxAtividade ;

dvar interval escalaAtividade

in dDias

s i z e dTamAtividade ;

Um intervalo também pode ser opcional. Nessa condição, é facultada a opção de que ele não

ocorra, i.e., representa um evento que não necessariamente precisa ser escalonado numa solução

do problema. O primeiro modi?cador da declaração de um intervalo opcional consiste na palavra

reservada optional logo após o identi?cador da variável declarada, como no exemplo abaixo:

dvar interval escalaAtividade optional ;



110 APÊNDICE A

Quando se declara um vetor de variáveis intervalares, é possível de?nir que alguns intervalos do

vetor são opcionais e outros obrigatórios. Nesse caso, ao modi?cador optional é acrescido um par

de parênteses com uma expressão booleana de?nindo se o intervalo é ou não opcional, como abaixo:

int noAtividades = . . . ;

range dAtividades = 1 . . noAtividades ;

int atividadeOpcional [ dAtividades ] = . . . ;

dvar interval escalaAtividades [ a in dAtividades ] optional ( atividadeOpcional [ a ] ) ;

Sobre a utilização dessa estrutura, é importante frisar que, salvo se o valor da expressão entre

parênteses for igual a 1, o intervalo será obrigatório. Isso já foi mencionado quando expressões

numéricas e predicados foram discutidos, mas não custa repetir: apenas o valor 1 é garantidamente

interpretado como verdadeiro e apenas o valor 0 como falso no contexto de uma expressão booleana

em OPL.

Para acessar a informação sobre uma variável intervalar opcional estar presente ou não em uma

solução, é utilizado o predicado presenceOf. Por exemplo, de?ne-se que um intervalo de índice b

par em um vetor de intervalos deve estar presente se o intervalo de índice a que o precede estiver

presente pelo seguinte conjunto de restrições:

f o r a l l (a in dAtividades , b in dAtividades : b==a+1 &amp;amp;&amp;amp; b%2==0) {

presenceOf ( escalaAtividade [ a ] ) =&gt;

presenceOf ( escalaAtividade [ b ] ) ;

}

Ao contrário do que ocorre com os parâmetros formais nos operadores de agregação, a restrição

de implicação lógica permite que condições sobre variáveis de decisão sejam empregadas. Assim,

pode-se usar não apenas o predicado presenceOf, como é possível compor predicados com outras

funções que operam sobre predicados.

Para as funções startOf, endOf, sizeOf e lengthOf vistas anteriormente, existe um segundo

argumento opcional: o valor retornado pela função se o intervalo não estiver presente. Por exemplo,

é possível de?nir que um vetor de atividades opcionais tenha todas as atividades presentes nas

primeiras posições do vetor e que elas estejam dispostas em ordem crescente de início:

f o r a l l (a in dAtividades , b in dAtividades : b==a+1) {

startOf ( escalaAtividade [ a ] , maxint )&amp;lt;= startOf ( escalaAtividade [ b ] , maxint ) ;

}

Restrições desse tipo representam uma prática frequente de modelagem em programação por res-

trições: a quebra de simetria. Uma restrição de quebra de simetria reduz o conjunto possível de

soluções para um problema ao descartar soluções que são equivalentes. Nesse caso, por exemplo,

poderíamos ter soluções cuja diferença fosse apenas a ordem dos intervalos no vetor, sendo desne-

cessário considerar tais soluções.

A.5.3 Restrições de Precedência

Em problemas de escalonamento, é bastante comum estabelecer restrições de precedência entre

eventos. Um projetista pode, por exemplo, de?nir que um intervalo só começa após o ?m de outro

e assim por diante. Apesar das funções que acessam as propriedades de início, ?m e duração de

um intervalo já serem su?cientes para estabelecer muitas dessas relações no conjunto de restrições



MODELAGEM DE PROBLEMAS DE ESCALONAMENTO 111

do modelo, sua frequência levou à de?nição de uma família de predicados de precedência, como o

seguinte:

endBeforeStart ( escalaAtividade [ 1 ] , escalaAtividade [ 2 ] , 5) ;

Na restrição acima, expressa-se que o ?m do primeiro intervalo somado ao valor 5 é menor ou igual

ao início do segundo intervalo. Um exemplo um pouco diferente é o predicado abaixo, que de?ne

que o início dos dois intervalos deve ser igual:

startAtStart ( escalaAtividade [ 1 ] , escalaAtividade [ 2 ] ) ;

De uma maneira geral, temos predicados começando pela propriedade do primeiro intervalo

(start ou end), seguidos de um comparador (Before para ?&lt;=?, At para ?==? e After para ?&gt;=?)

e por ?m a propriedade do segundo intervalo (Start ou End ? esse último, ao contrário do pri-

meiro, começando por letra maiúscula). Esses predicados possuem dois intervalos como argumento

e um terceiro argumento opcional representando um valor a ser somado à propriedade do primeiro

intervalo antes de compará-lo à propriedade do segundo intervalo.

A.5.4 Predicados Sobre Conjuntos de Intervalos

Em algumas situações, pode ser necessário representar um evento por vários intervalos distintos

ou de?nir um intervalo delimitando o início e o ?m de um conjunto de outros intervalos. Em OPL,

existem três predicados que descrevem a relação entre um intervalo a e um conjunto de intervalos

B: span, alternative e synchronize, todos tendo como argumentos um intervalo a seguido de um

vetor unidimensional B.

Com o span, é possível de?nir que um intervalo a inicia junto com o primeiro intervalo presente

de B e termina junto com o último intervalo presente de B, e que o intervalo a é ausente se todos

os intervalos de B forem ausentes, como no exemplo abaixo:

dvar interval escalaAtividade ;

dvar interval escalaAtividades [ dAtividades ] ;

span ( escalaAtividade , escalaAtividades ) ;

Se utilizado como uma restrição do modelo, o predicado span condiciona a presença do intervalo a

à presença de alguma atividade do vetor de intervalos B e vice-e-versa.

Usando alternative, estabelece-se que apenas um intervalo de um vetor B está presente e seu

início e ?m coincidem com aqueles do intevalo a. Por um condicionamento similar ao de span,

se a não estiver presente, nenhum intervalo em B está presente. Por exemplo, é possível ter um

conjunto de atividades que devem ser realizadas e um conjunto de máquinas capazes de realizá-las,

e expressar que uma, e apenas uma, máquina deve realizar cada atividade, como no exemplo a

seguir:



112 APÊNDICE A

int noMaquinas = . . . ;

range dMaquinas = 1 . . noMaquinas ;

dvar interval escalaMaquinaAtividade [ dMaquinas ] [ dAtividades ] optional ;

subject to {

f o r a l l (a in dAtividades ) {

alternative (

escalaAtividades [ a ] ,

a l l (m in dMaquinas ) escalaMaquinaAtividade [m] [ a ] ) ;

}

}

Como em outros casos vistos anteriormente, pelo exemplo dado observa-se que é possível utilizar

o operador all para criar vetores unidimensionais de intervalos para aplicar predicados envolvendo

vetores unidimensionais a qualquer conjunto possível de intervalos.

Por ?m, com synchronize todos intervalos do conjunto B iniciam e terminam junto com o

intervalo a ? se a estiver presente. Ao contrário de span e alternative, no predicado synchronize

a presença de algum intervalo de B não implica na presença do intervalo a e não existe nenhuma

restrição entre os intervalos de B se a for ausente.

A.5.5 Sequências e Transições

Variáveis intervalares podem ser agrupadas em uma sequência, que é um tipo de variável de

decisão declarado com a palavra reservada sequence. Ao criar um escalonamento, o resolvedor

procura ordenar os intervalos de cada sequência para só então de?nir o instante de alocação para

cada intervalo do conjunto. Uma sequência é declarada por um vetor unidimensional. Esse vetor é

especi?cado após a palavra reservada in, como no exemplo abaixo:

dvar sequence todasAtividades in escalaAtividades ;

Para interesse imediato, com sequências consegue-se de?nir que não podem haver sobreposições

em um grupo de intervalos e ainda de?nir o tempo de transição entre intervalos consecutivos na

ordenação. Mas isso só ocorre se uma restrição for imposta sobre a sequência. No exemplo abaixo,

de?ne-se uma sequência sobre os intervalos de índice par de um vetor de intervalos, e é estabelecido

que apenas um deles pode ocorrer por vez através do predicado noOverlap:

dvar sequence atividadesPares

in a l l (a in dAtividades : a % 2 == 0) escalaAtividades [ a ] ;

subject to {

noOverlap ( atividadesPares ) ;

}

Além de impedir que dois intervalos se sobreponham numa sequência, com noOverlap é pos-

sível de?nir uma separação entre a conclusão de um intervalo e o início do intervalo seguinte na

sequência por meio de um argumento adicional especi?cando o tempo de transição entre tipos de

intervalos. O primeiro passo para que isso seja possível consiste em associar a cada intervalo de

uma sequência um inteiro representando seu tipo na própria declaração da sequência por meio da

palavra reservada types seguida de um vetor unidimensional de inteiros com o mesmo tamanho que

o vetor de intervalos especi?cado antes, de forma que cada entrada de um vetor seja associada à



MODELAGEM DE PROBLEMAS DE ESCALONAMENTO 113

entrada correspondente do outro vetor. Além disso, é necessário passar como argumento da restri-

ção noOverlap o tempo de separação de intervalos consecutivos de acordo com o inteiro associado

a cada intervalo. Isso é feito por meio do argumento opcional de noOverlap. Ele consiste em um

conjunto de tuplas, sendo cada tupla formada por três inteiros. Assim, a quantidade de unidades

de tempo entre o ?m de um intervalo e o início do seguinte é consultado nesse conjunto, sendo o

primeiro inteiro relativo ao tipo do intervalo anterior, o segundo ao tipo do posterior e o terceiro

estabelece o tempo de separação.

Um exemplo de declaração de sequência com tipos para os intervalos e tempo de separação entre

intervalos consecutivos é apresentado a seguir:

dvar sequence todasAtividades

in a l l (a in dAtividades ) escalaAtividades [ a ]

types a l l (a in dAtividades ) a ;

tuple TempoTransicao { int de ; int para ; int tempo ; };

{ TempoTransicao } fTransicao = . . . ;

subject to {

noOverlap ( todasAtividades , fTransicao ) ;

}

No exemplo apresentado, cada intervalo da sequência possui um identi?cador inteiro para seu tipo.

Temos uma tupla representando uma estrutura com três inteiros: o tipo inicial, o tipo ?nal e o

tempo entre o ?m de uma atividade do primeiro tipo e o início de uma atividade do segundo tipo

na sequência, usado na declaração de um conjunto que serve de função de transição, dado como

segundo argumento do predicado noOverlap.

A atribuição a tuplas foi apresentada de maneira bem super?cial em um ponto anterior do texto.

Apenas para deixar claro como declarar no arquivo de entrada de dados o tempo de transição para

o exemplo acima, é apresentado abaixo um exemplo envolvendo dois tipos e os quatro respectivos

tempos de transição:

fTransicao= {&lt;1, 1 , 0&gt;,&amp;lt;1, 2 , 10&gt;,&amp;lt;2, 1 , 10&gt;,&amp;lt;2, 2 , 0&gt; };

No exemplo apresentado acima, o tempo de transição entre atividades do mesmo tipo é 0 e o tempo

de transição entre atividades de tipos distintos é 10.

Por ?m, vale observar que a declaração dos nomes dos campos da tupla é irrelevante para sua

utilização na de?nição dos tempos de transição, de forma que o projetista tem toda a liberdade

de de?nir a nomenclatura que mais lhe agradar, desde que mantida a ordem de que a primeira

variável representa o tipo da atividade anterior, a segunda do tipo seguinte e a terceira o tempo de

separação.

A.5.6 Modelagem de Recursos Limitados

Em muitos problemas de escalonamento, além de eventos que podem ou não ocorrer, é possível

que existam recursos com propriedades que restrinjam a possibilidade de execução conjunta desses

eventos. Muitas restrições envolvendo recursos associados a determinados conjuntos de eventos

podem ser modelados em OPL por meio de funções cumulativas e de estado, quando não por

predicados sobre sequências, conforme já mencionado. Por exemplo, uma máquina pode exigir

certas con?gurações para realizar uma determinada atividade e outras para realizar outra atividade,

de forma que os intervalos representando cada uma delas não podem se sobrepor, ao passo que



114 APÊNDICE A

atividades com con?gurações idênticas podem ser realizadas simultaneamente. Entretanto, pode

também ser o caso de haver um limite para o número de atividades realizadas ao mesmo tempo.

Enquanto que no primeiro caso temos uma situação que pode ser modelada por uma função de

estado, no segundo é possível realizar a modelagem por meio de uma função cumulativa ? ambos

os casos retratados nas próximas seções.

A.5.7 Funções Cumulativas

Com as funções cumulativas, é possível modelar propriedades do sistema que variam ao longo

do tempo em função da contribuição numérica de expressões relacionadas ao início e/ou ?m de

um conjunto de intervalos, abrindo a possibilidade de expressar restrições sobre essas propriedades.

Uma função cumulativa é identi?cada em sua declaração pela palavra reservada cumulFunction e

consiste em uma função temporal constante por partes e composta por degraus, cujos termos são

expressões que aumentam ou diminuem o valor da função ao início e/ou ?m de um intervalo. Tais

expressões elementares podem ser pulsos ou degraus.

Um pulso, de?nido pela função pulse, em sua forma mais simples recebe como argumento um

intervalo a e um valor constante positivo b. Ele representa uma função com valor 0 antes do início

de a, b entre o início e o ?m de a, e 0 após o ?m de a.

Um degrau pode ser de?nido por ao menos duas funções distintas: stepAtStart ou stepAtEnd.

Em sua forma mais simples, também recebe como argumento um intervalo a e um valor constante

positivo b. No caso de stepAtStart, representa uma função com valor 0 antes do início de a e b do

início de a em diante. No caso de stepAtEnd, uma função com valor 0 antes do ?m de a e b do ?m

de a em diante.

A essa constante positiva b das funções mencionadas, será dado o nome de coe?ciente de variação.

As restrições mais simples que podem ser formuladas com funções cumulativas consistem na

comparação da função com um inteiro, indicando uma relação válida para a função em todo o seu

domínio. Por exemplo, para de?nir que no máximo 5 atividades podem ocorrer simultaneamente, é

possível expressar o seguinte:

cumulFunction atividadesSimultaneas =

sum(a in dAtividades ) pulse ( escalaAtividade [ a ] ,1) ;

subject to {

atividadesSimultaneas&amp;lt;= 5;

}

Como pode ser visto no exemplo acima, foi criada uma função cumulativa composta por diversos

pulsos. Nunca é demais lembrar que o coe?ciente de variação das funções de pulso e degrau deve

ser uma constante inteira positiva, mas ainda assim é possível somar e subtrair pulsos e degraus

na composição de uma expressão de função cumulativa. Por exemplo, para expressar que o número

de atividades pares ocorrendo em qualquer instante de tempo é maior que o número de atividades

ímpares, é possível de?nir o seguinte no modelo:



MODELAGEM DE PROBLEMAS DE ESCALONAMENTO 115

cumulFuncion saldoAtividadesPares =

sum(a in dAtividades : a % 2 ==0) pulse ( escalaAtividade [ a ] ,1)

? sum (a in dAtividades : a % 2==1) pulse ( escalaAtividade [ a ] ,1) ;
subject to {

saldoAtividadesPares &gt;= 0;

}

Também é possível expressar restrições sobre partes do domínio da função por meio do predicado

alwaysIn que, em sua forma mais simples, leva como argumentos uma função cumulativa F , o

intervalo a no qual o valor da função é restrito e os valores constantes de mínimo x e máximo y

permitidos à função dentro desse intervalo. Por exemplo, é possível expressar que sempre haverá ao

menos uma e no máximo cinco atividades ocorrendo em cada instante desde o início da primeira

atividade de um vetor até o término da última, conforme o exemplo a seguir:

dvar interval escalaAtividade ;

dvar interval escalaAtividades [ dAtividades ] ;

cumulFunction atividadesSimultaneas =

sum(a in dAtividades ) pulse ( escalaAtividade [ a ] ,1) ;

subject to {

span ( escalaAtividade , escalaAtividades ) ;

alwaysIn ( atividadesSimultaneas , escalaAtividade , 1 , 5) ;

}

Nas funções pulse, stepAtStart, stepAtEnd e alwaysIn, o intervalo dado como argumento

pode ser substituído por duas constantes representando o início e o ?m de um intervalo ?xo. Por

exemplo, pode-se expressar que exatamente duas atividades devem ocorrer simultaneamente no

intervalo entre 31 e 40 do exemplo acima da seguinte forma:

alwaysIn ( atividadesSimultaneas , 31 , 40 , 2 , 2) ;

Em modelos mais elaborados, a variação da função cumulativa em função de alguns intervalos

pode ter graus de liberdade. Isso é obtido pela substituição da constante b das funções de pulso e

degrau por duas constantes x e y, representando que a variação do valor da função cumulativa em

decorrência dos eventos de início e/ou ?m de um dado intervalo pode assumir algum valor inteiro

entre x e y. Por exemplo, para um determinado recurso podemos ter um conjunto de atividades de

descarga que devem ser realizadas e de atividades de carga opcionais, estas últimas realizadas para

manter o estoque do recurso, como no exemplo abaixo:



116 APÊNDICE A

int noCargas = . . . ;

int noDescargas = . . . ;

range dCargas = 1 . . noCargas ;

range dDescargas = 1 . . noDescargas ;

int limEstoque = . . . ;

int estoquePorDescarga [ dDescargas ] = . . . ;

dvar interval atividadesCarga [ dCargas ] optional ;

dvar interval atividadesDescarga [ dDescargas ] ;

cumulFunction estoque =

sum(a in dCargas )

stepAtEnd ( atividadeCarga [ a ] ,1 , limEstoque )

?
sum(a in dDescargas )

stepAtEnd ( atividadeDescarga [ a ] , estoquePorDescarga [ a ] ) ;

subject to {

estoque &gt;= 0;

estoque&amp;lt;= limEstoque ;

}

No modelo apresentado, ao término de cada atividade de descarga ocorre uma variação negativa

especí?ca do estoque. Devido à existência da restrição de que o estoque deva ser sempre não-

negativo mas não maior que um limite, atividades de carga também são alocadas para que ocorram

variações positivas no estoque modelado pela função. A variação decorrente de cada atividade de

carga é variável, assumindo qualquer valor inteiro positivo até o limite máximo do estoque. Por não

assumirmos um valor sempre ?xo para o impacto de um intervalo na função cumulativa, evitamos

problemas com combinações de cargas e descargas que gerem estoques residuais, por exemplo. Para

explicar um pouco melhor, imagine que permitíssemos apenas uma carga completa, isto é, no valor

do limite máximo do estoque. Se não houver um conjunto de descargas que esvazie completamente

o estoque do recurso, isso implica que não há como realizar uma nova carga com o recurso e ele não

poderá ser recarregado para realizar outras atividades de descarga. A variação na função cumulativa

em função do início ou ?m de um intervalo pode ser medida como uma expressão de decisão por meio

das funções heightAtStart e heightAtEnd, que recebem como argumento um intervalo a e uma

função cumulativa F e devolvem a variação da função cumulativa ocorrida em F , respectivamente,

no início ou ?m de a por conta de expressões envolvendo a. Essa variação soma ou subtrai as

contribuições de cada termo de F de acordo com o sinal que precede cada termo. De posse dessa

função, podemos estabelecer uma relação entre o tempo da atividade de carga e sua variação de

estoque, como no exemplo a seguir:

f o r a l l (a in dCargas ) {

lengthOf ( atividadeCarga [ a ] ) == heightAtStart ( atividadeCarga [ a ] , estoque ) ;

}

As funções heightAtStart e heightAtEnd aceitam um terceiro argumento opcional com o valor

a ser devolvido caso o intervalo seja opcional e não esteja presente.

Um último ponto a se observar sobre funções cumulativas refere-se à questão do limite de

precisão do tipo inteiro: se a soma dos valores dos pulsos e degraus de todos os termos exceder o

limite representável, o resolvedor pode considerar o problema infactível mesmo que exista solução

para o problema e que as restrições do modelo impossibilitem que a função assuma um valor que



MODELAGEM DE PROBLEMAS DE ESCALONAMENTO 117

não possa ser representado por um inteiro.

A.5.8 Funções de Estado

Além de funções baseadas na contribuição numérica dos intervalos, uma outra forma de analisar

propriedades e estabelecer relações entre intervalos consiste nas funções de estado. Uma função de

estado é declarada pela palavra reservada stateFunction, mas não possui uma fórmula explícita

em função dos intervalos. A relação entre uma função de estado e intervalos é feita por predicados

no conjunto de restrições.

Comecemos pelo predicado alwaysIn, que é idêntico ao apresentado anteriormente para funções

cumulativas. Quando se de?ne que uma função de estado deve ter sempre um valor entre um mínimo

e um máximo no domínio de um intervalo, limita-se as possibilidades de concorrência de intervalos.

Por exemplo, é possível de?nir que atividades pares e ímpares não ocorram simultaneamente da

seguinte forma:

stateFunction tipoAtividade ;

subject to {

f o r a l l (a in dAtividades : a % 2 == 0) {

alwaysIn ( tipoAtividade , escalaAtividades [ a ] , 0 , 0) ;

}

f o r a l l (a in dAtividades : a % 2 == 1) {

alwaysIn ( tipoAtividade , escalaAtividades [ a ] , 1 , 1) ;

}

}

Pelo exemplo acima, força-se que o valor da função de estado tipoAtividade sempre seja 0 durante

a execução de atividades de índice par e sempre seja 1 durante a execução de atividades de índice

ímpar. Dessa forma, uma atividade par e uma atividade ímpar nunca concorrerão pelo recurso ?

apenas uma delas pode ocorrer a cada instante.

Além de alwaysIn, também existem os predicados alwaysEqual, alwaysConstant e alwaysNoState.

O alwaysEqual consiste em uma especialização do alwaysIn, recebendo apenas um valor v em vez

de um valor mínimo e outro máximo como argumento, para expressar que o valor da função de

estado F deve ser igual a v durante o intervalo a. No exemplo anterior, isso signi?caria não ter

que colocar duas vezes o mesmo valor para forçar a igualdade. O alwaysConstant é uma forma

de generalização do alwaysEqual, que determina que o valor da função de estado seja constante

no domínio do intervalo, sem especi?car que valor seria esse. De forma complementar, o predicado

alwaysNoState estabelece que a função de estado não deve ter estado de?nido no intervalo dado.

Além das restrições sobre os predicados mencionados, é possível estabelecer o tempo de transição

entre estados da função. Essa transição é modelada com conjuntos de tuplas, da mesma forma como

é feito para as sequências. Porém, ela é associada diretamente à função de estado em sua declaração

com a palavra reservada with, como abaixo:

tuple tempoTransição { int de ; int para ; int tempo ; };

{ tempoTransição } fTransição = {&amp;lt;i , j , (( i==j ) ?(0) : ( 1 ) )&gt; : i in 0 . . 1 , j in

0 . . 1 };

stateFunction tipoAtividade with fTransição ;

Nesse exemplo, foi estabelecido um tempo unitário de transição entre os estados numericamente

identi?cados por 0 e 1.



118 APÊNDICE A

A.5.9 Um Exemplo de Problema de Escalonamento Modelado em OPL

Para concluir a apresentação dos elementos para modelagem de problemas de escalonamento,

será dado como exemplo um modelo completo para uma versão bem simples do problema de pro-

gramar recursos móveis para a execução de um conjunto de atividades. Ele é tratado em maiores

detalhes na terceira parte dessa dissertação.

Nessa versão simples, temos um conjunto de atividades e um conjunto de recursos. Cada ati-

vidade possui uma localização associada e deve ser realizada por um recurso. Um recurso só pode

fazer uma atividade por vez e dois recursos não podem ocupar o mesmo lugar ao mesmo tempo.

Para realizar atividades consecutivas em locais diferentes, a alocação de cada recurso deve conside-

rar o tempo de deslocamento necessário entre terminar a atividade anterior em um local e começar

a atividade seguinte em outro local. Segue um exemplo de modelo para esse problema:



MODELAGEM DE PROBLEMAS DE ESCALONAMENTO 119

1 using CP;

2

3 int noAtividades = . . . ;

4 range dAtividades = 1 . . noAtividades ;

5

6 int noRecursos = . . . ;

7 range dRecursos = 1 . . noRecursos ;

8 int noLocais = . . . ;

9 range dLocais = 1 . . noLocais ;

10

11 // Vetor que , numericamente , associa cada atividade a um l o c a l .

12 int localizacao [ a in dAtividades ] = . . . ;

13 // Definição da tupla representando o tempo de transição entre l o c a i s .

14 tuple Transicao { int deLocal ; int paraLocal ; int tempoDeslocamento ; };

15 // Vetor de conjuntos

16 {Transicao} tempoTransicao [ r in dRecursos ] = . . . ;

17

18 dvar interval escalaAtividade [ a in dAtividades ] ;

19 dvar interval escalaAtividadeRecurso [ a in dAtividades ] [ r in dRecursos ] optional ;

20

21 // Agrupamento das atividades realizadas por cada recurso ,

22 // associando tipo r e l a t i v o à localização .

23 dvar sequence sqAtvRecurso [ r in Resources ]

24 in a l l (a in Atividades ) escalaAtividadeRecurso [ a ] [ r ]

25 types a l l (a in Atividades ) localizacao [ a ] ;

26 // Agrupamento das atividades realizadas por cada l o c a l .

27 dvar sequence sqAtvLocal [ l in Locais ]

28 in a l l (a in dAtividades : location [ a]==l ) escalaAtividade [ a ] ;

29

30 subject to {

31 // Cada atividade é realizada por exatamente um recurso .

32 f o r a l l (a in dAtividades ) {

33 // Força com que cada atividade (com intervalo obrigatório ) esteja

34 // presente em apenas um intervalo de recurso ( os intervalos da

35 // matriz Atividade x Recurso são opcionais ) .

36 alternative ( escalaAtividade [ a ] ,

37 a l l ( r in dRecursos ) escalaAtividadeRecurso [ a ] [ r ] ) ;

38 }

39

40 // Cada recurso r e a l i z a uma atividade por vez , e separa?as pelo tempo
41 // de deslocamento entre os l o c a i s de atividades consecutivas .

42 f o r a l l ( r in dRecursos ) {

43 noOverlap ( sqAtvRecurso [ r ] , tempoTransicao [ r ] ) ;

44 }

45

46 // Apenas uma atividade pode ser realizada por vez em cada l o c a l .

47 f o r a l l ( l in dLocais ) {

48 noOverlap ( sqAtvLocal [ l ] ) ;

49 }

50 }



120 APÊNDICE A

A.6 Considerações Finais e Agradecimentos

A expectativa do autor com relação a este material é que ele sirva à apresentação dos conceitos

necessários para familiarizar o leitor com a modelagem algébrica de modelos utilizando a técnica

de programação por restrições. Como subsídio, foi utilizada a linguagem OPL em razão de sua

maturidade e popularidade. Para um aprofundamento na prática atual usando OPL, recomenda-se

tanto o manual da IBM (2010) quanto uma leitura de Laborie (2009). É importante observar que

alguns artigos mais antigos como Hentenryck et al. (2000) e Lustig e Puget (2001) apresentam uma

sintaxe e certas estruturas que foram descontinuadas em versões posteriores. Entretanto, sua leitura

permanece útil à compreensão dos princípios que nortearam o desenvolvimento da linguagem e o

funcionamento do resolvedor.

Esse texto contou com a colaboração de vários revisores, que contribuíram para torná-lo mais

acessível e direto por meio de uma leitura minuciosa. Até a presente versão, foram eles: Gilberto

Koji Nishioka, Edson Mikio Nishida, Daniel Felix Ferber, Gustavo Pacianotto Gouveia e Yoshiko

Wakabayashi.



Referências Bibliográ?cas

Aarts e Lenstra(1997) E. H. L. Aarts e J. K. Lenstra. Local Search in Combinatorial Optimiza-
tion. Wiley. Citado na pág. 10

Accioly et al.(2002) R. Accioly, F. J. M. Marcellino e H. Kobayashi. Uma aplicação da programa-
ção por restrições no escalonamento de atividades em poços de petróleo. Em Simpósio Brasileiro
de Pesquisa Operacional. Sobrapo. Citado na pág. 7

Acergy-Group(2010) Acergy-Group. Polar queen apr 10.pdf. http://www.acergy-group.com/
publicroot/webresources/6P6D55RDUN/$?le/Polar%20Queen%20Apr%2010.pdf, 2010. For-
mato PDF. Acesso em: 1 jun. 2010. Citado na pág. 5

Aloise et al.(2006) D. J. Aloise, D. Aloise, C. T. M. Rocha, C. C. Ribeiro, J. C. R. Filho e L. S. S.
Moura. Scheduling workover rigs for onshore oil production. Discrete Applied Mathematics, 154:
695?702(5). Citado na pág. 8

Arbelaez et al.(2009) A. Arbelaez, Y. Hamadi e M. Sebag. Online heuristic selection in cons-
traint programming. Em Proceedings of the International Symposium on Combinatorial Search
(SoCS'09), páginas 674?681. Citado na pág. 33

Baptiste et al.(2001) P. Baptiste, C. Le Pape e W. Nuijten. Constraint-Based Scheduling: Applying
Constraint Programming to Scheduling Problems. Kluwer. Citado na pág. 33, 42, 49, 53, 55

Baptiste et al.(2006) P. Baptiste, P. Laborie, C. Le Pape e W. Nuijten. Constraint-based sche-
duling and planning. Em F. Rossi, P. van Beek e T. Walsh, editors, Handbook of Constraint
Programming, chapter 22. Elsevier. Citado na pág. 41, 42, 49, 50, 52, 53, 54

Barták(2001) R. Barták. Theory and practice of constraint propagation. Em Proceedings of the
3rd Workshop on Constraint Programming for Decision and Control (CPDC2001), páginas 7?14.
Wydavnictvo Pracovni Komputerowej. Citado na pág. 14, 19, 25, 26

Barták(1999) R. Barták. Constraint programming: In pursuit of the holy grail. Em Proceedings
of the Week of Doctoral Students (WDS99), páginas 555?564. MatFyzPress. Citado na pág. 13, 14,
19, 21, 25, 31, 34, 37

Barták(2008) R. Barták. Book review: Constraint Processing, Handbook of Constraint Program-
ming. Computer Science Review, 2(2):123 ? 130. Citado na pág. 15

Battiti et al.(2008) R. Battiti, M. Brunato e F. Mascia. Reactive Search and Intelligent Optimi-
zation. Springer. Citado na pág. 10, 56

Bazaraa et al.(1990) M. S. Bazaraa, J. J. Jarvis e H. D. Sherali. Linear Programming and Network
Flows. Wiley. Citado na pág. 4

Beldiceanu et al.(2007) Nicolas Beldiceanu, Mats Carlsson, Sophie Demassey e Thierry Petit.
Global constraint catalogue: Past, present and future. Constraints, 12:21?62. Citado na pág. 27

121

http://www.acergy-group.com/publicroot/webresources/6P6D55RDUN/$file/Polar%20Qu een%20Apr%2010.pdf
http://www.acergy-group.com/publicroot/webresources/6P6D55RDUN/$file/Polar%20Qu een%20Apr%2010.pdf


122 REFERÊNCIAS BIBLIOGRÁFICAS

Bessière e Hentenryck(2003) C. Bessière e P. V. Hentenryck. To be or not to be ... a global
constraint. Em Francesca Rossi, editor, Principles and Practice of Constraint Programming,
volume 2823 of Lecture Notes in Computer Science, páginas 789?794. Springer Berlin Heidelberg.
Citado na pág. 27

Bockmayr e Kasper(1998) A. Bockmayr e T. Kasper. Branch and infer: A unifying framework
for integer and ?nite domain constraint programming. INFORMS Journal on Computing, 10:
287?300(3). Citado na pág. 14

Bondy e Murty(2008) A. Bondy e U. S. R. Murty. Graph Theory. Springer. Citado na pág. 4

Brafman(2001) R. I. Brafman. A simpli?er for propositional formulas with many binary clauses.
Em Proceedings of the 17th International Joint Conference on Arti?cial Intelligence (IJCAI'01).
Citado na pág. 50

Brailsford et al.(1999) S. C. Brailsford, C. N. Potts e B. M. Smith. Constraint satisfaction
problems: Algorithms and applications. European Jornal of Operational Research (EJOR), 119:
557?581. Citado na pág. 15, 18, 33

Camm et al.(1990) J. D. Camm, A. S. Raturi e S. Tsubakitani. Cutting big M down to size.
Interfaces, 20:61?66. Citado na pág. 73

Carchrae e Beck(2005) T. Carchrae e J.C. Beck. Applying machine learning to low knowledge
control of optimization algorithms. Computational Intelligence, 21:372?387. Citado na pág. 56

Carlier e Pinson(1994) J. Carlier e E. Pinson. Adjustment of heads and tails for the job-shop
problem. European Jornal of Operational Research (EJOR), 78:146?161. Citado na pág. 53

Cesta e Oddi(1996) A. Cesta e A. Oddi. Gaining e?ciency and ?exibility in the simple tempo-
ral problem. Em Proceedings of the 3rd Workshop on Temporal Representation and Reasoning
(TIME'96). Citado na pág. 51

Cormen et al.(2002) T. H. Cormen, C. E. Leiserson, R. L. Rivest e S. Cli?ord. Algoritmos ?
Teoria e Prática. Editora Campus. Citado na pág. 4, 29, 50

Dechter(2003) R. Dechter. Constraint Processing. Morgan Kaufmann. Citado na pág. 15, 19, 21,
23, 29, 34, 35, 36, 37, 56

do Nascimento(2002) J. M. do Nascimento. Ferramentas computacionais híbridas para a oti-
mização da produção de petróleo em Águas profundas. Dissertação de Mestrado, Instituto de
Computação, Universidade Estadual de Campinas, Brasil. Citado na pág. 7

Dynadec(2009) Dynadec. Comet 2.0 Tutorial, 2009. Citado na pág. 38, 42, 46

Feo e Resende(1989) T. A. Feo e M. G. C. Resende. A probabilistic heuristic for a computatio-
nally di?cult set covering problem. Operations Research Letters, 8:67?71. Citado na pág. 7

Focacci et al.(2000) F. Focacci, A. Lodi, M. Milano e D. Vigo. An introduction to constraint
programming. Ricerca Operativa, 91. Citado na pág. 22

Glinz e Berumen(2009) I. Glinz e L. Berumen. Optimization model for an oil well drilling
program: Mexico case. Oil and Gas Business, 1. Citado na pág. 8

Glover(1989) F. Glover. Tabu search ? part I. ORSA Journal on Computing, 1:190?206(3). Citado
na pág. 7

Godard e Laborie(2005) D. Godard e P. Laborie. Randomized large neighborhood search for
cumulative scheduling. Em Proceedings of the 2005 International Conference on Automated Plan-
ning and Scheduling (ICAPS 2005), páginas 81?89. Citado na pág. 38, 56



REFERÊNCIAS BIBLIOGRÁFICAS 123

Gomes e Selman(2007) C. Gomes e B. Selman. The science of constraints. Constraint Program-
ming Letters, 1:15?20. Citado na pág. 39

Gomes et al.(1998) C. P. Gomes, B. Selman e H. Kautz. Boosting combinatorial search through
randomization. Em Proceedings of the Fifteenth National Conference on Arti?cial Intelligence
(AAAI-98), páginas 431?437. Citado na pág. 36

Hasle et al.(1996) G. Hasle, R. Haut, B. Johansen e T. Ølberg. Well activity scheduling ? an
application of constraint reasoning. Em B. Braunschweig e B. A. Bremdal, editors, Arti?cial
Intelligence in the Petroleum Industry: Symbolic and Computational Applications II, páginas
209?228. Technip, Paris. Citado na pág. 7

Hentenryck(2010) P. V. Hentenryck. Constraint programming as declarative algorithmics. Em
F. Benhamou, N. Jussien e B. O'Sullivan, editors, Trends in Constraint Programming. Wiley.
Citado na pág. 13, 39

Hentenryck e Michel(2007) P. V. Hentenryck e L. Michel. Synthesis of constraint-based local
search algorithms from high-level models. Em Proceedings of the 22nd National Conference on
Arti?cial Intelligence (AAAI-07), páginas 273?278. Citado na pág. 39

Hentenryck et al.(1992) P. V. Hentenryck, Y. Deville e C. M. Teng. A generic arc-consistency
algorithm and its specializations. Arti?cial Intelligence, 57. Citado na pág. 25

Hentenryck et al.(2000) P. V. Hentenryck, L. Perron e J. F. Puget. Search and strategies in opl.
ACM Transactions on Computational Logic (TOCL), 1:285?320(2). Citado na pág. 18, 38, 39, 120

Hooker(2007) J. N. Hooker. Good and bad futures for constraint programming (and operations
research). Constraint Programming Letters, 1:21?32. Citado na pág. 30

Hooker(2006) J. N. Hooker. Integrated Methods for Optimization (International Series in Opera-
tions Research &amp;amp; Management Science). Springer-Verlag New York, Inc. Citado na pág. 10

Hoos e Stützle(2005) H. H. Hoos e T. Stützle. Stochastic Local Search: Foundations and Appli-
cations. Morgan Kaufmann. Citado na pág. 37

IBM(2010) IBM. ILOG CPLEX Optimization Studio 12.2 documentation for ODM Enterprise,
2010. Citado na pág. 16, 18, 38, 42, 89, 120

Ja?ar e Lassez(1987) J. Ja?ar e J. L. Lassez. Constraint logic programming. Em Proceedings of
the 14th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Languages (POPL
'87), páginas 111?119. Citado na pág. 37

Kantorovich(1975) L. V. Kantorovich. Mathematics in economics: Achievements, dif-
?culties, perspectives. http://www.nobelprize.org/nobel_prizes/economics/laureates/1975/
kantorovich-lecture.html, 1975. Último acesso em 6/9/2011. Citado na pág. 13

Kautz et al.(2002) H. Kautz, E. Horvitz, Y. Ruan, C. Gomes e B. Selman. Dynamic restart
policies. Em Proceedings of the Eighteenth National Conference on Arti?cial Intelligence (AAAI-
02), páginas 674?681. Citado na pág. 33, 36

Koopmans(1975) T. C. Koopmans. Concepts of optimality and their uses. http://www.
nobelprize.org/nobel_prizes/economics/laureates/1975/koopmans-lecture.html, 1975. Último
acesso em 6/9/2011. Citado na pág. 13

Laborie(2009) P. Laborie. IBM ILOG CP Optimizer for detailed scheduling illustrated on three
problems. Em W. J. van Hoeve e J. N. Hooker, editors, Integration of AI and OR Techniques
in Constraint Programming for Combinatorial Optimization Problems, volume 5547 of Lecture
Notes in Computer Science, páginas 148?162. Springer Berlin Heidelberg. Citado na pág. 120

http://www.nobelprize.org/nobel_prizes/economics/laureates/1975/kantorovich-lecture.html
http://www.nobelprize.org/nobel_prizes/economics/laureates/1975/kantorovich-lecture.html
http://www.nobelprize.org/nobel_prizes/economics/laureates/1975/koopmans-lecture.html
http://www.nobelprize.org/nobel_prizes/economics/laureates/1975/koopmans-lecture.html


124 REFERÊNCIAS BIBLIOGRÁFICAS

Laborie(2003a) P. Laborie. Algorithms for propagating resource constraints in AI planning and
scheduling: Existing approaches and new results. Arti?cial Intelligence, 143:151?188. Citado na pág.
38, 49, 51, 52, 54, 55

Laborie(2003b) P. Laborie. Resource temporal networks: De?nition and complexity. Em Proce-
edings of the 18th International Joint Conference on Arti?cial Intelligence (IJCAI'03). Citado na
pág. 46

Laborie e Godard(2007) P. Laborie e D. Godard. Self-adapting large neighborhood search:
Application to single-mode scheduling problems. Em Proceedings of the 3rd Multidisciplinary
International Conference on Scheduling: Theory and Applications (MISTA 2007), páginas 276?
284. Citado na pág. 37, 38, 56

Laborie e Rogerie(2008) P. Laborie e J. Rogerie. Reasoning with conditional time-intervals. Em
Proceedings of the 21st International Florida Arti?cial Intelligence Research Society Conference
(FLAIRS 2008). Citado na pág. 38, 46, 50, 63

Laborie et al.(2009) P. Laborie, J. Rogerie, P. Shaw e P. Vilím. Reasoning with conditional time-
intervals, part ii: An algebraical model for resources. Em Proceedings of the 22st International
Florida Arti?cial Intelligence Research Society Conference (FLAIRS 2009). Citado na pág. 38, 46,
63

Lustig e Puget(2001) I. J. Lustig e J. F. Puget. Program does not equal program: Constraint
programming and its relationship to mathematical programming. Interfaces, 31:29?53(6). Citado
na pág. 13, 14, 16, 30, 37, 38, 90, 106, 120

Monette et al.(2009) J. N. Monette, Y. Deville e P. V. Hentenryck. Aeon: Synthesizing schedu-
ling algorithms from high-level models. Em Proceedings of 11th INFORMS Computing Society
Conference. Citado na pág. 39, 56

Moura et al.(2008a) A. V. Moura, C. C. de Souza, A. A. Cire e T. M. T. Lopes. Planning
and scheduling the operation of a very large oil pipeline network. Em Peter Stuckey, editor,
Principles and Practice of Constraint Programming, volume 5202 of Lecture Notes in Computer
Science, páginas 36?51. Springer Berlin Heidelberg. Citado na pág. 8

Moura et al.(2008b) A. V. Moura, R. A. Pereira e C. C. de Souza. Scheduling activities at oil wells
with resource displacement. International Transactions in Operational Research, 15:659?683(25).
Citado na pág. 7

Nethercote et al.(2007) N. Nethercote, P. J. Stuckey, R. Becket, S. Brand, G. J. Duck e G. Tack.
MiniZinc: Towards a standard CP modelling language. Em C. Bessière, editor, Principles and
Practice of Constraint Programming, volume 4741 of Lecture Notes in Computer Science, páginas
529?543. Springer Berlin Heidelberg. Citado na pág. 39

Nocedal e Wright(2000) J. Nocedal e S. J. Wright. Numerical Optimization. Springer. Citado na
pág. 4

Paiva(1997) R. O. Paiva. Itinerário de sondas com quanti?cação de perdas através de simulador
de reservatórios. Dissertação de Mestrado, Faculdade de Engenharia Mecânica, Universidade
Estadual de Campinas, Brasil. Citado na pág. 8

Pereira et al.(2005) R. A. Pereira, A. V. Moura e C. C. de Souza. Comparative experiments with
GRASP and constraint programming for the oil well drilling problem. Em S. E. Nikoletseas,
editor, WEA, volume 3503 of Lecture Notes in Computer Science, páginas 328?340. Springer.
Citado na pág. 7



REFERÊNCIAS BIBLIOGRÁFICAS 125

Puget(2004) J. F. Puget. Constraint programming next challenge: Simplicity of use. Em Mark
Wallace, editor, Principles and Practice of Constraint Programming, volume 3258 of Lecture Notes
in Computer Science, páginas 5?8. Springer Berlin Heidelberg. Citado na pág. 38, 39

Refalo(2004) P. Refalo. Impact-based search strategies for constraint programming. Em Mark
Wallace, editor, Principles and Practice of Constraint Programming, volume 3258 of Lecture Notes
in Computer Science, páginas 557?571. Springer Berlin Heidelberg. Citado na pág. 32, 33, 38

Régin(1994) J. C. Régin. A ?ltering algorithm for constraints of di?erence in CSPs. Em Procee-
dings of the Twelfth National Conference on Arti?cial Intelligence (AAAI-94), páginas 362?367.
Citado na pág. 28, 29

Scott(1999) M. L. Scott. Programming Language Pragmatics. Morgan Kaufmann. Citado na pág. 37

Serra e Wakabayashi(2010) T. Serra e Y. Wakabayashi. The full employment theorem for solver
designers and related issues in CP modeling. Em Anais do V Workshop de Teses e Dissertações
em Andamento (WTDIA). SBC. Citado na pág. 15, 39

Serra et al.(2010) T. Serra, G. Nishioka e F. Marcellino. A constraint programming approach to
the problem of oil well drilling scheduling with resource displacement and inventory management.
Em ALIO-INFORMS Joint International Meeting. ALIO-INFORMS. Citado na pág. 7

Serra et al.(2011) T. Serra, G. Nishioka e F. J. M. Marcellino. A constraint-based scheduling
of o?shore well development activities with inventory management. Em Simpósio Brasileiro de
Pesquisa Operacional. Sobrapo. Citado na pág. 7, 71, 72, 78

Serra et al.(2012) T. Serra, G. Nishioka e F. J. M. Marcellino. On estimating the return of resource
aquisitions through scheduling: An evaluation of continuous-time MILP models to approach the
development of o?shore oil wells. Em Scheduling and Planning Applications woRKshop (SPARK).
AAAI. Citado na pág. 7, 71, 72, 78

Sipser(2007) M. Sipser. Introdução à Teoria da Computação. Thomson. Citado na pág. 4

Smith-Miles(2008) K. A. Smith-Miles. Cross-disciplinary perspectives on meta-learning for al-
gorithm selection. ACM Computing Surveys (CSUR), 41. Citado na pág. 15, 56

Thomas(2004) J. E. Thomas. Fundamentos de Engenharia de Petróleo. Interciência. Citado na pág.
3

van Beek(2006) P. van Beek. Backtracking search algorithms. Em F. Rossi, P. van Beek e
T. Walsh, editors, Handbook of Constraint Programming, chapter 4. Elsevier. Citado na pág. 29, 30,
31, 34, 35

van Hoeve et al.(2011) W. J. van Hoeve, M. Hunting e C. Kuip. The aimms interface to constraint
programming. Em T. Achterberg e J. C. Beck, editors, Proceedings of CPAIOR Late Breaking
Abstracts, páginas 41?43. Konrad-Zuse-Zentrum fur Informationstechnik Berlin. Citado na pág. 39

Vazirani(2001) V. V. Vazirani. Approximation Algorithms. Springer-Verlag. Citado na pág. 9

Vilain et al.(1990) M. Vilain, H. Kautz e P. van Beek. Constraint propagation algorithms for tem-
poral reasoning: A revised report. Em Readings in qualitative reasoning about physical systems.
Morgan Kaufmann. Citado na pág. 46

Vilím(2007) P. Vilím. Global Constraints in Scheduling. Tese de Doutorado, Faculty of Mathe-
matics and Physics, Charles University, República Tcheca. Citado na pág. 49, 53, 54

Williams(2005) H. P. Williams. Model Building in Mathematical Programming. Wiley. Citado na
pág. 18



126 REFERÊNCIAS BIBLIOGRÁFICAS

Wolsey(1998) L. A. Wolsey. Integer Programming. Wiley. Citado na pág. 4

Yue(2008) Z. Q. Yue. 9320168.jpg. http://www.panoramio.com/photo/9320168, 2008. Largura:
2272 pixels. Altura: 1704 pixels. Tamanho: 1017,17KB. Formato JPEG. Acesso em: 1 jun. 2010.
Citado na pág. 5

http://www.panoramio.com/photo/9320168


Índice Remissivo

águas profundas, 5
árvore, 4

algoritmo
AC, 24
AC-1, 24
AC-2, 24
AC-3, 24
AC-4, 24
AC-5, 25
AC-6, 24
AC-7, 24
BJ, 35
BT, 31
CBJ, 35
de aproximação, 9
de busca, 29, 55
de caminhos mais curtos, 71
de ?ltragem, 14, 19, 24, 25, 28
de retrocesso baseado em con?ito, 35
de retrocesso por salto, 35
FC, 34
MAC, 34
PC, 25
PC-1, 25
PC-2, 25
PC-3, 25
PC-4, 25
PC-5, 25

alocação, 6, 8
antecipação

parcial, 34
total, 34

arco, 20
atividade

elástica, 43
não-preemptiva, 43
opcional, 44, 46
preemptiva, 43

barcos lançadores de linhas, 5
busca, 13, 29, 39, 41, 55

algoritmo de, 55

completa, 29
corte na, 37
degeneração da, 31, 35
dicotômica, 30
espaço de, 63
estocástica, 29, 36
exaustiva, 29
incompleta, 29
local, 9, 29, 36
local estocástica, 37
por discrepância limitada, 33, 36
por factibilidade, 29
tabu, 7, 9

classe de problemas
NP, 4
NP-Completo, 4, 15, 19, 24, 50
NP-Difíceis, 4, 7, 15

codi?cação
dual, 26
por variáveis ocultas, 27

conjunto
de con?ito, 35
de valores de suporte, 24

consistência, 14, 19, 33, 49
k-consistência, 21
k-consistência forte, 21
n-consistência, 22
(i,j), 23
1-consistência, 21
2-consistência, 21
3-consistência, 21
binária, 20, 21, 24
níveis de, 21

completa, 19, 22
de arco, 20
de nó, 20
direcional em nível de aresta, 22
em k-ésimo nível, 21
em nível de aresta, 21, 24, 34
em nível de caminho, 21, 25
em nível de vértice, 21, 24
forte, 21

127



128 ÍNDICE REMISSIVO

generalizada, 27, 28
inversa, 24
manutenção da, 34
níveis de, 14, 19, 21, 22
níveis intermediários de, 25
ponto ?xo de, 49, 51, 53
por conjunto unitário, 23
por limites, 23, 50
restrita em nível de caminho, 23
técnicas de, 19
tipos de, 19

CP
conferência, 28

data
de liberação, 43, 52
limite de conclusão, 43, 52

detecção tardia de con?ito, 31, 33, 35
domínio

de restrição, 22
de variável, 14

downstream, 5

emparelhamento máximo, 5, 28
escalonamento, 7, 8, 41

baseado em restrições, 9, 41, 63
exploitation, 5
exploração, 5

factibilidade, 29
ferramentas comerciais, 38
função

cumulativa, 48
degrau, 48
pulso, 48

de custo de transição, 45
de estado, 48
de tempo de transição, 44, 48, 64

grafo, 4, 16
bipartido, 5, 28
corte de um, 5
de precedências, 53
do modelo, 21, 27
do modelo dual, 26
hipergrafo, 27
subgrafo, 4
subgrafo induzido, 4, 27

grafos
isomor?smo de, 5, 27
ordenação topológica de, 4
orientação de, 4
rotulação graciosa de, 16

GRASP, 7, 9

heurística, 9
construtiva, 9
de busca local, 9
meta-heurística, 9

inferência, 19
geração de, 19

inviável, 30

linguagem
AIMMS, 39
algébrica, 38
Comet, 38, 39, 56
de modelagem abstrata, 39
MiniZinc, 39
OPL, 16, 17, 38, 42, 55, 63, 77
Prolog, 37

meta-aprendizagem, 15
modelagem, 14, 18, 39, 41, 42
modelo, 13, 14, 18, 42, 63

binário, 26
dual, 26
insatisfatível, 28

nó, 20
nível

de planejamento, 8
operacional, 8
tático, 8

ORCA
sistema, 7

ordenação
das atribuições, 32
dinâmica, 32
estática, 32

otimalidade, 29
otimização numérica, 3

paradigmas, 37
princípio

da casa dos pombos, 28
da sub-estrutura ótima, 29
de falhar primeiro, 32

problema
combinatório, 3, 9, 16
da seleção de algoritmos, 15
das n rainhas, 17
de escalonamento de chão-de-fábrica, 53
de formulação da estratégia ótima de rami-

?cação, 33
de otimização da satisfação de restrições, 14
de satisfação de restrições, 14



ÍNDICE REMISSIVO 129

de satisfabilidade, 50
de satisfabilidade 2-SAT, 50
do escalonamento de chão-de-fábrica, 7
insatisfatível, 19, 33
satisfatível, 33
temporal simples, 51

produção, 5
programação, 8

dinâmica, 29
funcional, 37
inteira, 15
lógica, 37
lógica por restrições, 37
linear, 3, 13
linear inteira, 3, 9, 14
matemática, 8
por restrições, 7, 9, 13

projeção, 26
propagação, 41, 63

de restrições, 14, 19, 49
disjuntiva, 52
energética, 52
global, 27, 51
local, 27, 50
por ausência de arestas, 53
por balanceamento, 54
por busca de arestas, 53
por precedência energética, 54
por tabela de tempos, 52

quebra de simetrias, 18

rami?cação, 31, 78
estratégias de, 31
heurísticas para, 32
tipos de, 31

recursão, 29, 30
recurso

capacidade do, 45
cumulativo, 45
disjuntivo, 45
estado do, 44
reservatório, 45
tipo de estado do, 44

redes booleanas, 50
rejeição, 35
relaxação, 71
resolvedor caixa-preta, 39
restrição, 14

alldi?erent, 17, 18, 28
alternative, 47, 64
always-constant, 48
always-in, 48, 66

always-nostate, 48
anti-funcional, 25
aprendizado de, 35
aridade de, 26
binária, 20
binarização de, 26
declarativa, 14
enumarativa, 14
fraca, 15
funcional, 25
global, 27, 39, 47
algorítmica, 28
operacional, 28
semântica, 28

implícita, 35
monotônica, 25
no-overlap, 47, 64, 67, 68
redundante, 18, 26, 35
span, 47
unária, 20, 24

retrocesso, 29, 30
cronológico, 31
dinâmico, 35
inteligente, 35

SAT, veja problemade de satisfabilidade
sequência de intervalos, 47
simetria, 18
sintaxe, 63
sistemática de exploração, 29
solução equivalente, 18
sondas marítimas, 5
sudoku, 17

técnicas
preventivas, 33
reativas, 34

trabalho redundante, 31, 35, 36

upstream, 5

vértice
grau do, 22

valor de suporte, 24
variável

de decisão, 14
de intervalo, 46, 63

variável intervalar, veja variável de intervalo
veri?cação adiantada, 34


	Lista de Abreviaturas
	Lista de Figuras
	Lista de Tabelas
	I INTRODUÇÃO
	Introdução
	Referências e Notas de Apoio à Leitura
	A Indústria de Petróleo e a Programação de Recursos Críticos
	Problemas de Escalonamento e a Programação por Restrições
	Organização do Restante do Trabalho


	II DESCRIÇÃO DA TÉCNICA
	Programação por Restrições
	Modelagem
	Aplicabilidade em Função da Modelagem
	Boas Práticas em Modelagem

	Propagação de Restrições
	Técnicas de Consistência Binária
	Técnicas de Consistência Generalizada

	Busca
	Busca por Recursão e Retrocesso
	Busca Local e Estocástica

	Paradigmas
	Ferramentas Comerciais
	Modelagem Abstrata


	Escalonamento Baseado em Restrições
	Modelagem e Paradigmas Descritivos
	Caracterização por Atividades e Recursos
	Caracterização por Variáveis de Intervalo

	Elementos Complementares de Resolução
	Propagação
	Busca



	III ESTUDO DE CASO
	O Problema da Programação de Recursos Críticos e Sua Abordagem
	Decisões e Entidades Relacionadas
	Critérios de Otimização
	Restrições do Problema
	Restrições Gerais dos Recursos
	Restrições Gerais de Execução das Atividades
	Restrições de Estoque dos Recursos
	Restrições de Estoque das Atividades

	Modelagem por Variáveis de Intervalo
	Associação entre Atividades e Recursos
	Associação entre Atividades e Localidades
	Restrições de Estoque e Transporte de Linhas
	Função Objetivo

	Limitante Superior ao Ótimo
	Algoritmo Guloso sobre Relaxação
	Modelo de PLI sobre Relaxação


	Análise Experimental do Escalonador
	Dados Disponíveis e Ambiente de Testes
	Experimentos Realizados e Resultados
	Discussão


	IV CONCLUSÃO
	Conclusão

	V APÊNDICE
	Programação por Restrições em OPL
	A Linguagem OPL e o Resolvedor CP
	Representação do Modelo e da Entrada de Dados
	Elementos de Uso Geral da Linguagem
	Escolha do Resolvedor do Modelo
	Comentários em Arquivos de Modelo e de Dados
	Variáveis de Tipos Primitivos e Atribuições
	Estruturas de Dados Básicas: Vetores e Domínios
	Atribuições Básicas a Elementos de Vetores
	Expressões Numéricas e Predicados
	Operadores de Agregação e Funções Sobre Vetores
	Estruturas de Dados Avançadas: Tuplas e Conjuntos

	Modelagem de Problemas Combinatórios
	Variáveis de Decisão de Tipos Primitivos
	Expressões de Decisão
	Sobre a Impossibilidade de Usar Variáveis float em CP
	Função Objetivo
	Restrições Básicas Sobre Tipos Primitivos
	Restrições Especializadas Sobre Tipos Primitivos
	Execução do Resolvedor e Configurações Básicas do CP
	Manipulação da Solução e Impressão dos Resultados no Pós-Processamento
	Um Exemplo de Problema Combinatório Modelado em OPL

	Modelagem de Problemas de Escalonamento
	Problemas de Escalonamento e a Motivação ao Emprego de CP
	Variáveis de Intervalo e Suas Propriedades
	Restrições de Precedência
	Predicados Sobre Conjuntos de Intervalos
	Sequências e Transições
	Modelagem de Recursos Limitados
	Funções Cumulativas
	Funções de Estado
	Um Exemplo de Problema de Escalonamento Modelado em OPL

	Considerações Finais e Agradecimentos

	Referências Bibliográficas
	Índice Remissivo


</field>
	</doc>
</add>