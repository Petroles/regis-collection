<?xml version="1.0" encoding="utf-8"?>
<add>
	<doc>
		<field name="docid">BR-TU.06427</field>
		<field name="filename">10970_Ramos_RafaelGuimaraes_M.pdf</field>
		<field name="filetype">PDF</field>
		<field name="text">UNICAMP
Rafael Guimarães Ramos
Ambiente Virtual de Simulação e Visualização do Comportamento "de Risers
Campinas
2013
UNICAMP
Universidade Estadual de Campinas
Faculdade de Engenharia Elétrica e de Computação
Rafael Guimarães Ramos
Ambiente Virtual de Simulaçao e Visualizaçao do Comportamento de Risers
Dissertação de mestrado apresentada ao Programa de Pós-Graduação em Engenharia Elétrica da Faculdade de Engenharia Elétrica e de Computação da Universidade Estadual de Campinas como parte dos requisitos exigidos para a obtenção do título de Mestre em Engenharia Elétrica. Area de concen-tracão: Engenharia de Computacão.
Orientador: Prof. Dr. José Mario De Martino
Este exemplar corresponde à versão final da dissertação defendida pelo aluno Rafael Guimarães Ramos, e orientada pelo Prof. Dr. Jose Mario De Martino
Campinas
2013
Ramos, Rafael Guimarães, 1987-
R147a	Ambiente virtual de simulação e visualização do comportamento de risers /
Rafael Guimarães Ramos. - Campinas, SP : [s.n.], 2013.
Orientador: José Mario De Martino.
Dissertação (mestrado) - Universidade Estadual de Campinas, Faculdade de Engenharia Elétrica e de Computação.
1.	Ambiente virtual. 2. Simulação computacional. 3. Estruturas marítimas -Hidrodinâmica. 4. Visualização. I. De Martino, José Mario,1958-, II. Universidade Estadual de Campinas. Faculdade de Engenharia Elétrica e de Computação. III. Título.
Informações para Biblioteca Digital
Título em inglês: Virtual environment for simulation and visualization of riser behavior
Palavras-chave em inglês:
Virtual environment
Computer simulation
Marine structures - Hydrodynamics
Visualization
Área de concentração: Engenharia de Computação
Titulação: Mestre em Engenharia Elétrica
Banca examinadora:
José Mario De Martino [Orientador]
Renato Pavanello
Léo Pini Magalhães
Data de defesa: 05-06-2013
Programa de Pós-Graduação: Engenharia Elétrica
COMISSÃO JULGADORA - TESE DE MESTRADO
Candidato: Rafael Guimarães Ramos
Data da Defesa: 5 de junho de 2013
Titulo da Tese: "Ambiente Virtual de Simulação e Visualização do Comportamento de Risers"
Dedico este trabalho à minha
FAMÍLIA E AOS MEUS AMIGOS.
Agradecimentos
Agradeço,
ao Prof. José Mario De Martino pela orientaçao e incentivo,
ao Prof. Celso Morooka e seus orientados Denis Shiguemoto, Maurécio Suzuki e Raphael Tsu-kada, por todas as explicacões sobre risers e pelo material de apoio,
ao Rodrigo Mologni, colega de sala, que em diversos momentos me ajudou no uso e instalaçõo das ferramentas utilizadas,
aos voluntarios da avaliacõo de usabilidade, pela disponibilidade e paciência em participar do teste,
ao CNPq pelo apoio financeiro concedido durante o peréodo de mestrado,
a FEEC/UNICAMP a otima estrutura que oferece aos estudantes e pesquisadores,
a todos os colegas de laboratério pelas diversas dicas e étima convivência e companheirismo.
Idéia, do grego antigo idea, por sua vez derivado de idein, ver.
Online Etymology Dictionary (adaptado)
Resumo
Este trabalho apresenta um ambiente de visualização interativo em tempo-real para a simulaçao do comportamento de risers rígidos verticais. O riser é um duto cilíndrico essencial na extração de oleo em éguas profundas e ultra-profundas, uma tarefa desafiadora que impãe diversas cargas sobre a estrutura. Ondas, correntes e movimentos da plataforma são algumas dessas fontes de tensão, que podem levar a danos por fadiga ou mesmo rupturas. Simulacães computacionais sao uma ferramenta de grande valia para prevenir e diagnosticar tais problemas, mas em geral apresentam a desvantagem de produzir um grande volume de dados numíericos de difícil interpretaçao. Técnicas de visualização científica podem ser utilizadas para representar os dados de uma maneira mais intuitiva e realista. Entretanto, os sistemas identificados na literatura apresentam limitações quanto à interação em tempo-real. A visualizacão é realizada como um playback, apés a simulação ter sido completada, e sempre que os parâmetros de simulacão sao alterados o usuário deve esperar um tempo considerável enquanto os resultados sao recalculados. Neste trabalho, o ambiente desenvolvido permite a visualizaçcãao do comportamento do riser com interaçcãao em tempo-real, em que o novo comportamento do riser íe obtido imediatamente apoís os paraâmetros de simulaçcaão serem alterados pelo usuíario.
Palavras-chave: Ambiente Virtual. Simulação Computacional. Estruturas Marítimas - Hidrodinâmica. Visualização.
Abstract
This work presents a visualization environment with real-time interaction for the simulation of vertical rigid risers. The riser is a cylindrical pipe essential for the extraction of oil in deep and ultra-deep waters, a challenging task that imposes several loads over the structure. Waves, currents and platform movements are some of these stress sources, that may lead to fatigue damage or even rupture. Computer simulations are a tool of great value for preventing and diagnosing such problems, but have usually the drawback of producing a large volume of numerical data difficult of being interpreted by the user. Scientific visualization techniques can be used to represent data in a more intuitive and realistic way. However, projects identified in the literature present limitations regarding real-time interaction. The visualization is performed as a playback, after the simulation has been completed, and whenever simulation parameters are changed, the user has to wait a considerable time for the results to be recalculated. In this work, the developed simulation environment allows visualization of riser behavior with real-time interaction, where the new riser behavior is obtained immediately after simulation parameters are changed by the user.
Key-words: Virtual Environment. Computer Simulation. Marine Structures - Hydrodynamics. Visualization.
Lista de Figuras
1.1	Plataforma com Risers Rígidos Verticais.......................................... 3
1.2	Módulos do ambiente desenvolvido................................................. 5
2.1	Representação por plots. Fonte: Simantiras e Willis 2001, pógina 13, Figura 11.	9
2.2	Representação de vortices por imagem 2D. Adaptado de: Al-Jamal e Dalton 2004,
pógina 88, Figura 13............................................................. 9
2.3	Representação de vortices e curvatura do riser por gróficos 3D. Adaptado de:
Chen e Chen 2010, pógina 5, Figura 5............................................ 10
2.4	Outra representação de vórtices e curvatura do riser por gráficos 3D. Adaptado
de: Zhu et al. 2011, pógina 791, Figura 3....................................... 10
2.5	Isosuperóficies de pressão via gráficos 3D. Adaptado de: Holmes et al. 2006,
paógina 7, Figura 11.	........................................................ 11
2.6	Cores em gróficos 3D para representar intensidade de esforço sobre o tubo. Adap-
tado de: Alexander 2007, pagina 81, Figura 27................................... 12
2.7	Software de simulação de riser com visualizacão dos resultados em ambiente
grófico 3D. Fonte: Petrobras et al. 2005, pógina 39, Figura 3.2................. 12
2.8	Ambiente colaborativo com visualizaçcãao animada 3D do riser. Fonte: Santos et
al. 2011, pógina 6, Figura 6.................................................... 13
2.9	Outro ambiente com visualizaçcãao animada 3D do riser. Segundo a fonte, trata-se
de um esboço da interface. Fonte: Bernardes 2004, pógina 119, Figura 20......... 14
2.10	Ambiente de visualização 3D para ajuste de parámetros de simulação. Fonte:
Morooka et. al. 2008, pógina 7, Figura 7........................................ 14
2.11	Software comercial Orcaflex desenvolvido por Orcina Ltd.. Fonte: Pógina Web
de Orcina Ltd................................................................... 15
3.1	Representacão esquemótica do metodo de elementos finitos........................ 18
3.2	Fluxo do Solver RiserProd....................................................... 20
3.3	Fluxo do Solver aprimorado para interatividade em tempo-real.................... 20
3.4	Pipeline de Visualização. Fonte: Mologni dos Santos 2011, pagina 18, Figura 2.3.	22
3.5	Representação por esquematica da interface de visualizacao, dividida em Cena
3D e Painel de Controle......................................................... 23
3.6	Janelas do VRP, interface para o RiserProd existente previamente a este trabalho. 24
4.1	Janela principal do ambiente de visualização..................................... 28
4.2	Iniciando uma simulação: escolhe-se uma configuração de riser e o nUmero de
elementos do modelo e a simulação está pronta para ser visualizada............... 28
4.3	E possivel explorar o ambiente virtual aplicando rotacão, translacão e escala. . .	29
4.4	Para maior realismo e imersao, á possável optar por uma visualização com o mar
extendendo-se atá o horizonte, bem como utilizar visao stereo tridimensional. . .	30
4.5	Apontando com o mouse sobre o riser e pressionando o botão p, o elemento cor-
respondente á marcado no ambiente de visualização (esfera vermelha) e realçado
na tabela da aba Results......................................................... 31
4.6	Diagrama com as classes principais que compãe o Solver. Para não sobrecarregar
o diagrama, foram omitidas as subclasses de MyMatrix e Force..................... 31
4.7	Diagrama representando o fluxo de chamadas (indicado por setas) que ocorre ao
executar a Análise Estática para uma configuração TTR. O polimorfismo e a sobrecarga de máetodos assegura que a anáalise áe executada para a configuraçcãao de riser específica................................................................. 33
4.8	Diagrama de classes do Modulo de Visualizaçao. Como Scene contám muitas
classes, apenas algumas estãao representadas, para naão sobrecarregar o diagrama. 34
4.9	Medidas de tempo de execuçao do Solver, tomadas em quatro etapas distintas. .	35
4.10	Tempo de espera a cada mudança de parâmetros, computado como a soma das
três primeiras etapas. A Análise de Vibraçães Livres e a Montagem de Matrizes sãao as que mais contribuem na medida ........................................... 35
4.11	Taxa de quadros máxima suportada em função do numero de elementos, tomado
como o inverso das medidas da Analise Dinâmica................................... 36
4.12	Nota média e desvio padrâo de cada pergunta...................................... 38
4.13	Notas mádia e desvio padrâo de cada pergunta apos normalização................... 39
Lista de Tabelas
4.1	Notas dadas pelos voluntários para cada pergunta..................................
37
Lista de Acrônimos e Notação
KX , KY matriz de rigidez inline e transversal, respectivamente
DX , DY matriz de amortecimento inline e transversal, respectivamente
MX , MY matriz de massa inline e transversal, respectivamente
FX , Fy	vetor das forças sobre o riser nos planos inline e transversal, respectivamente
X, Y vetor dos deslocamentos inline e transversal, respectivamente
X,Y	vetor das velocidades inline e transversal, respectivamente
X,Y	vetor das acelerações inline e transversal, respectivamente
VRP Visual Riser Prod, interface para o Solver RiserProd
o / •
Sumario
1	Introdução	1
1.1	Motivação................................................................... 1
1.2	Objetivo.................................................................... 4
1.3	Contribuições............................................................... 4
1.4	Visão Geral................................................................. 5
2	Revisão Bibliográfica	7
2.1	Simulação de Riser.......................................................... 7
2.2	Visualizaçao Científica..................................................... 8
2.3	Visualizaçao da Simulação de Riser.......................................... 8
2.4	Consideraçães Finais....................................................... 15
3	Metodologia	17
3.1	Simulação do Riser......................................................... 17
3.1.1	Modelo teorico ..................................................... 17
3.1.2	RiserProd: Uma implementaçao já existente do simulador ............. 19
3.1.3	Requisitos para um simulador interativo em tempo-real............... 19
3.1.4	Implementando o simulador interativo em tempo-real a partir do RiserProd 20
3.1.5	Avaliando o desempenho do novo Solver............................... 21
3.2	Visualizaçcaão da Simulacçãao ............................................. 21
3.2.1	Fundamentos ........................................................ 21
3.2.2	Tácnicas para Visualizar a Simulação................................ 22
3.2.3	Interface de Usuário ............................................... 23
3.2.4	Implementando o Mádulo de Visualizacão ............................. 23
3.2.5	VRP: um Mádulo de Visualização já existente para o RiserProd........ 24
3.2.6	Avaliando a Visualizacão............................................ 24
3.3	Integrando Solver e Modulo de Visualizaçao................................. 25
3.4	Consideracães Finais....................................................... 25
4	Resultados	27
4.1	Protátipo Desenvolvido..................................................... 27
4.2	Visão Geral do Código................................................. 30
4.3	Avaliação do Desempenho	do	Solver................................... 34
4.4	Avaliação da Usabilidade do	Ambiente de Visualização e Simulação...... 36
4.5	Consideraçães Finais.................................................. 39
5	Conclusões	40
5.1	Limitaçães............................................................ 41
5.2	Trabalhos Futuros..................................................... 42
Bibliografia	44
A	Questionário	para	Avaliaçõo	de	Usabilidade	47
B	Documentacao	do	Código	do	Sistema	Desenvolvido	59
Capítulo J__
Introdução
1.1	Motivação
A exploração de petróleo em águas profundas e ultraprofundas á uma tarefa desafiadora, sobretudo devido as condições ambientais adversas a serem enfrentadas. A grande importancia deste recurso mineral no cenário global, entretanto, tem impulsionado essa atividade, especialmente no caso do Brasil, que possuiu aproximadamente 94% de suas reservas provadas de petráleo em campos marítimos (Agência Nacional do Petráleo 2012).
O processo de obtencao de petráleo em alto mar pode ser dividido em três etapas1: Pros-pecção, Perfuração e Produção. Na etapa de Prospeccao, á feita a localização das reservas de petróleo, utilizando diferentes técnicas, que incluem o uso de ondas de choque, medidas das variaçães nos campos gravitacional e magnático, ou ainda farejadores de hidrocarbonetos. Na etapa seguinte, áe feita a perfuracçaão do poçco utilizando-se uma broca. Por fim, na uáltima etapa, Producçãao, o áoleo áe extraindo do poçco e levado atáe a plataforma.
Uma estrutura essencial nas etapas de perfuração e producao á o riser (Figura 1.1), um tubo delgado cilindrico que atende a multiplas funçoes, entre elas a de transportar o petráleo desde o poco atá a unidade de produção. De um modo geral, existem dois tipos de riser, os rígidos e os flexíveis, e a operação a ser realizada determina o tipo de riser utilizado.
Existem diversos tipos de configuraçães de riser. O Top Tension Riser (TTR) á um tubo rágido e vertical que tem as extremidades presas na cabeçca do pocço e na unidade de produçcãao, e deve estar sempre tracionado no topo para garantir sua estabilidade. Tambám rígidas e verticais são as configuracães Collector, em que o tubo fica preso apenas no topo, e Tower, que possui apenas a base presa. A configuração Collector á utilizada para coletar a água do mar, já o tipo Tower á utilizado em uma configuração híbrida conhecida como HRT (Hybrid Riser Tower), no qual aláem do duto de açco haá uma báoia no topo do riser (topo que fica submerso) e tubos flexáveis chamados jumpers partindo do topo para a embarcaçao. Ha ainda o Steel Catenary Riser (SCR), que á rígido e possui a forma de catenária, e o Subsea Pipeline, em que o duto
1Aqui a divisão em três etapas e os termos empregados foram escolhidos de forma a facilitar a compreensão das explicaçães posteriores e evitar ambiguidades. Diferentes nomenclaturas podem ser encontradas em outras fontes. Em algumas, é feita apenas a divisao entre Exploração e Produção, onde por Exploração entende-se a prospeccão e estudo das reservas e Produção tanto a perfuração quanto a extração do petróleo. Utiliza-se ainda em algumas fontes o termo Explotaçcaão, designando a extraçcãao do recurso natural, contrapondo-se a Exploraçcãao.
é rígido e disposto na horizontal. Todos estes são risers rígidos e nao podem sofrer grandes deflexães. Ademais, TTR, Collector e Tower compoem o subgrupo dos risers rígidos verticais, jé que além de serem tubos rígidos são utilizados na posiçao vertical. Por fim, além dos risers rígidos, existe também a classe dos risers flexíveis, que toleram deflexães maiores.
O escolha pelo uso de cada configuração de riser varia conforme a situacão. Durante a etapa de perfuracão, apenas risers rígidos podem ser utilizados. O riser tem nesta etapa a funcão de guiar a broca desde a plataforma atíe a cabeçca do poçco, bem como transportar o fluido de perfuraçcaão. O fluido de perfuraçcaão íe uma mistura de íagua, argila e outros compostos químicos que tem por função lubrificar e resfriar a broca, dar sustentação ao riser e impedir que o petróleo escape do pocço assim que o reservatoírio íe atingido. O riser utilizado na perfuracçãao possui diámetro variando entre 0,50m e 1,00m. Caso a embarcacao provoque um deslocamento horizontal (offset) acima do limite seguro para o riser, este pode ser desconectado hidraulicamente da cabeçca do poçco.
Na etapa de producão, podem ser utilizados tanto risers rígidos como flexíveis. O riser nesta etapa tem a funçcaão de transportar os hidrocarbonetos da cabeçca do poçco atíe a embarcaçcaão. O riser rígido utilizado na produçao possui diametro da ordem de 0,25m, não pode sofrer grandes deflexães e deve estar sempre tracionado. Jé o riser flexível pode sofrer maiores deflexães e durante o uso permanece suspenso na forma de uma catenaíria. O diáametro do riser flexível varia de 0,064m a 0,41m.
Durante seu tempo de uso, o riser íe submetido a carregamentos que provocam a movi-mentaçcaão da estrutura, podendo levar a fraturas ou mesmo rupturas por fadiga do material. Correnteza, ondas, movimentaçcãao da plataforma, bem como a diferençca de pressãao entre a aígua do mar e o fluido interno, saão alguns dos principais fatores que influenciam o comportamento do riser. Outro fator importante é a VIV (Vortex Induced Vibration), a vibracão induzida pelo desprendimento de víortices ao longo da parede do riser.
A necessidade de prevenir e diagnosticar danos no riser, somado aos altos custos tanto da produçcãao do equipamento quanto de sua manutençcãao, tornam importante o uso de modelos computacionais que simulam o comportamento desta estrutura. Com o uso de um simulador, pontos de falha no riser podem ser detectados com antecedáencia, antes mesmo do riser ser fabricado. Outro caso de uso importante para um simulador íe o de auxiliar no diagníostico do problema de um riser em operacçãao. O simulador pode indicar mais precisamente o tipo e a localizacão do problema, atenuando eventuais custos de manutenção. Entretanto, o grande volume de dados numíericos produzido pela simulaçcaão torna dificil a interpretaçcãao dos resultados pelo usuério. Uma forma de mais tornar mais intuitiva a compreensão destes dados é utilizar a visualizaçao científica.
A visualizaçao científica é um ramo específico da visualização de dados, às vezes chamada apenas de visualizacao, e que consiste em representar dados na forma de imagens2. Prova-
2 A relação entre o que é visualizacao e o que é computação gráfica pode variar conforme a definição de cada um dos campos, podendo haver sobreposições entre as éreas. Uma distinçao é de que a visualizacão trata de como representar dados, muitas vezes abstratos e sem correspondente visual obvio, numa forma visual, enquanto a computacão gráfica lida com as técnicas para se representar tais elementos gráficos num computador. Desta forma, a visualizaçao em principio possuiria certa independência da computacão, ao contrario da computação gráfica. Entretanto, a preponderancia do computador como ferramenta para produçao e manipulacão de dados, bem como a importêancia da interatividade na visualizaçcãao tornam forte a ligaçcãao entre visualizaçcãao e computaçcãao
Figura 1.1: Plataforma com Risers Rígidos Verticais.
velmente o exemplo mais comum de visualização seja o dos mapas meteorolágicos, mostrados na previsão do tempo dos jornais. A visualizaçao tambám pode ser utilizada para representar modelos de engenharia, na representação de átomos e moláculas, de dados financeiros ou estatísticas sociais, ou ainda de redes como a Internet ou uma rede elétrica. A função da visualização é a de auxiliar o usuário a interpretar um conjunto de dados. Técnicas de visualizacão, se bem aplicadas, tem a capacidade de sintetizar grande quantidade de informacao, provendo ao usuário uma leitura rápida e intuitiva da informação. Esta fluidez á ainda mais importante dentro de um contexto interativo, em que o ciclo de leitura e produçcãao de dados repete-se diversas vezes.
A visualizacçaão cientáfica trata especificamente de dados das áareas cientáficas e de engenharia. Estes dados, sendo geralmente grandezas fásicas, apresentam certas caracterásticas comuns, como a de serem dados escalares, vetoriais ou tensoriais, e de estarem distribuádos no tempo e no espaco. Sendo assim, um conjunto de tácnicas de visualizacão científica pode ser utilizado para representar uma grande variedade de aplicaçães. Dentre as tácnicas mais comuns está o uso de cores para representar escalares, setas para vetores, linhas de fluxos para campos e elipsoáides para tensores.
Utilizando a visualização científica, os dados de simulação podem ser representados numa forma mais intuitiva para o usuário. As multiplas grandezas do riser, como tensao, força e deslocamento de cada elemento, todas elas variantes no tempo, podem ser sintetizadas numa animação provendo uma visao global do comportamento do riser. Tambám os parâmetros de simulaçcãao, que determinam fatores como correnteza ou profundidade, podem ser representados visualmente na mesma cena. Um outro fator que enriquece ainda mais a compreensão do fenômeno áe interatividade com a simulaçcãao, na qual áe permitido que o usuáario altere as condiçcãoes
gráfica.
ambientais e do riser, explorando diferentes casos de estudo3. Entretanto, como seró visto no Capótulo 2, a interatividade na visualizaçao de simulaçães de riser ó uma funcionalidade desejada e que apresenta limitaçães nos trabalhos indentificados na literatura. Nas aplicações mais completas em termos de visualização, a mudança de parâmetros ó possível apenas interrompendo-se visualizacçaão, que sóo pode ser retomada apóos os resultados da simulacçaão terem sido recomputados para o intervalo de estudo, o que acarreta um tempo de espera. Este tempo de espera, por sua vez, prejudica a fluidez da interacão e da exploração.
1.2	Objetivo
O objetivo deste trabalho ó especificar, desenvolver e avaliar um ambiente virtual interativo em tempo-real para simulação e visualização do comportamento de risers rígidos verticais. Neste sistema, o usuaório poderaó visualizar em gróaficos animados os dados da simulacçãao, tanto parâmetros quanto resultados, e poderá alterar os parâmetros, que correspondem às condicães ambientais e do riser, sem que haja interrupcçaão da visualizacçãao ou tempo de resposta longo a ponto de prejudicar a fluidez da interaçcaão. Eó importante ressaltar que, neste trabalho, o tempo-real refere-se à fluidez na interatividade, e nao que o tempo de visualizaçao da simulação corresponda necessariamente ao do fenâomeno real.
1.3	Contribuições
São contribuições deste trabalho:
•	O desenvolvimento de um módulo de simulação numórica (Solver) apto ao uso interativo em tempo-real, a partir de uma adaptação do simulador RiserProd, que não atende os requisitos para tal tipo de interaçcãao.
•	O desenvolvimento de um móodulo de visualizaçcãao, responsóavel por representar visualmente os resultados e parâametros do moódulo de simulacçaão e de gerenciar a interaçcãao com o usuaório, atravóes de uma interface que permite o ajuste dos paraâmetros da simulaçcãao.
•	A integracçãao dos referidos móodulos em um uónico ambiente de simulaçcãao e visualizaçcãao de risers.
•	Uma avaliaçcãao do desempenho do ambiente, revelando quais os limitantes para o uso interativo em tempo-real do ambiente desenvolvido.
•	Uma avaliaçcaão da usabilidade do ambiente.
3Segundo Telea (Telea 2008), o processo de interação e interpretação dos dados representados visualmente pode se dar de duas formas distintas. Uma maneira é aquela em que o usuário possui apriori questães que deseja elucidar e a visualização deve auxiliar neste processo. Encontrar os pontos de maximo e ménimo num conjunto de dados ou verificar se os dados estão bem distribuédos no espaço sao alguns exemplos dessas perguntas. Uma outra abordagem é quando o usuário não procura por nada especéfico, ou mesmo nao sabe o que procurar, e a visualizaçao releva caracterésticas interessantes e inesperadas sobre o conjunto de dados. Vale lembrar que as duas abordagens podem ocorrer simultaneamente, complementando-se.
novos resultados
Figura 1.2: Módulos do ambiente desenvolvido.
1.4	Visão Geral
Sendo um ambiente de simulação e visualização, o sistema foi dividido em dois módulos, um de simulaçao (chamado de Solver) e um de visualizaçao, que interagem compondo uma unica aplicação (Figura 1.2).
No modulo de simulação, o comportamento do riser ó calculado segundo as equaçães da hidrodinâmica de estruturas offshore, utilizando a abordagem numórica do Mótodo de Elementos Finitos. Condiçães ambientais e do riser correspondem a parâmetros no modelo matemótico, e o comportamento ó expresso em varióveis como deslocamento, velocidade e força computadas pelo modelo.
Jó no modulo de visualização, os dados da simulaçao, tanto parâmetros quanto resultados, são processados pelo pipeline de visualizaçao e apresentados na forma grófica para o usuario. Também ó este modulo o responsavel por gerenciar a interação com o usuório, devendo prover interfaces apropriadas para mudanca de parâmetros. O módulo de visualização encapsula o de simulação, e o usuório não possui acesso ao segundo senao atravós do primeiro. Do ponto de vista do usuório, pode-se dizer que a visualização e a simulação.
Este trabalho, alóm de desenvolver os dois módulos e integra-los numa unica aplicação, avaliou o ambiente desenvolvido segundo sua performance e sua usabilidade. Quanto a performance, a avaliaçao visa identificar quais os fatores limitantes para um uso interativo em tempo-real. Jó quanto a usabilidade, o objetivo ó verificar se o ambiente ó de fato útil para engenheiros trabalhando com risers.
Nos proximos capítulos, estes e outros aspectos do trabalho são detalhados e discutidos.
Em primeiro lugar, no Capótulo 2, Revisão Bibliogrófica, sao expostos resumidamente os trabalhos relacionados a este que, ou serviram de base para este trabalho, ou trataram do mesmo tema. Assim, são discutidos trabalhos da órea de simulaçao de riser e tambóm de visualização. Por fim, constata-se que, nos trabalhos identificados na literatura, a visualização da simulaçcaão com interatividade em tempo-real óe ainda limitada.
No Capótulo 3, Metodologia, ó descrito como o projeto foi realizado, desde sua modelagem matemóatica, requisitos do sistema, atóe ferramentas escolhidas. Tambóem sãao descritos os móetodos escolhidos para se avaliar o Solver e a interface desenvolvidos.
No Capótulo 4, os resultados obtidos seguindo-se a metodologia do capótulo 3 são descritos. A aplicaçcaão desenvolvida óe apresentada, bem como uma visãao geral do cóodigo e os resultados das avaliacçãoes da interface e do Solver.
Por fim, no Capétulo 5, sõo mostradas as conclusões obtidas com esse trabalho, suas limita-cçõoes e os posséveis trabalhos futuros.
Capítulo ______________
RevisãoBibliográfica
2.1	Simulação de Riser
A hidrodinâmica de estruturas offshore possui uma literatura consolidada. O livro de S. K. Chakrabarti, Hydrodynamics of Offshore Structures (Chakrabarti 1987) descreve a dinâmica de diversos tipos de estrutura, inclusive risers, segundo os vários modelos de onda existentes. Para o fenomeno de geração de vártices, Kubota (Kubota 2003) indica que diversos modelos tâm sido propostos, utilizando as equaçães de Navier-Stokes com dependância no tempo. Tais modelos variam significativamente quanto às consideracães básicas e aproximacães empregadas, de forma que cada modelo deve apenas ser utilizado quando tais pressupostos estiverem de acordo com a realidade.
Devido as dificuldades em se obter soluções analíticas para sistemas de equaçães diferenciais parciais como as da hidrodinamica de estruturas offshore, frequentemente modelos numáricos são utilizados para o estabelecimento de soluçães aproximadas com um grau desejado de precisão. Uma técnica importante á o Método de Elementos Finitos, muito utilizada para analise estrutural. Com a tácnica, uma estrutura continua á discretizada em um conjunto de elementos finitos interligados, sendo o sistema de equacçãoes diferenciais parciais convertido para um sistema de equaçcãoes algáebricas ou de equaçcãoes diferenciais ordinaárias, que pode ser solucionado por máe-todos de álgebra linear ou mátodos iterativos. Os livros Finite Element Procedures (Bathe 1996) e The Finite Element Method in Engineering Science (Zienkiewicz 1971) tratam do mátodo em detalhe.
O trabalho de Ferrari e Bearman (Ferrari &amp;amp; Bearman 1999a) estabelece um modelo matemático de simulação, sendo este o utilizado no presente trabalho. No modelo, os coeficientes hidrodinâamicos utilizados nas equaçcoães da estrutura devem ser passados como parâametros e o Método de Elementos Finitos á utilizado para obter a solucão aproximada. Diversos trabalhos (Morooka, Coelho, Ribeiro, Ferrari &amp;amp; Franciss 2005, Morooka, Coelho, Kubota, Ferrari &amp;amp; Ribeiro 2004, Morooka &amp;amp; Tsukada 2011, Kubota 2003) seguiram-se ao de Ferrari e Bearman, aperfeiçcoando o modelo proposto.
2.2	Visualizacão Científica
As principais técnicas para visualização de dados são tratadas no livro de Alexandru Telea, Data Visualization (Telea 2008). No livro, tanto a visualizaçao cientéfica quanto a visualizaçao de outras aplicaçães sao explorados, numa abordagem desvinculada de linguagens especéficas. Engel et al., no livro Real Time Volume-Graphics (Engel, Hadwiger, Kniss, Rezk-Salama &amp;amp; Weiskopf 2006), tratam das técnicas para visualizaçao de dados volumétricos, importante para certas aplicacçãoes dentro da visualizaçcãao cientifica, como visualizaçcaão de tomografia computadorizada. Já o livro The Visualization Toolkit, de Schroeder et al. (Schroeder, Martin &amp;amp; Lorensen 2006), trata da biblioteca VTK para visualização, cobrindo os diversos componentes oferecidos pelo VTK para a construção de aplicacães de visualização.
2.3	Visualizacão da Simulação de Riser
Dentre os trabalhos de simulação de riser são relativamente poucos aqueles cujo foco principal ée a visualizaçcãao dos dados de simulacçãao, a maioria tratando dos modelos mateméaticos de simulaçcãao. Mesmo para estes trabalhos, entretanto, existe a necessidade de representar os dados de simulaçcãao. A seguir sãao descritas as abordagens utilizadas em diversos trabalhos, comecçando pelas mais simples, de trabalhos cujo foco nãao era a visualizaçcãao, e terminando com aquelas mais completas, dos trabalhos que tinham por objeto de interesse a visualizaçcãao em si.
Dentre as abordagens mais simples para visualizacçaão, héa o uso de plots 2D, em que as grandezas do riser sao representadas como curvas. O trabalho de Simantiras e Willis (Simantiras &amp;amp; Willis 2001) é um exemplo (Figura 2.1). Outro trabalho que utiliza plots para representar resultados de simulação é o Visual RiserProd (ou apenas VRP), um modulo de visualizacão desenvolvido para o simulador RiserProd (por ser uma interface já existente para o simulador utilizado neste trabalho, ela é discutida com mais detalhes na Seçao 3.2.5 do Capítulo 3). Ainda restrito a gréaficos bidimensionais, existem trabalhos que utilizam graéficos 2D para representar os vértices formados (Figura 2.2). Cada imagem representa o vortice em uma dada profundidade. Os trabalhos de Al-Jamal e Dalton (Al-Jamal &amp;amp; Dalton 2004), Chaplin et al. (Chaplin, Bearman, Cheng, Fontaine, Graham, Herfjord, Huarte, Isherwood, Lambrakos, Larsen, Meneghini, Moe, Pattenden, Triantafyllou &amp;amp; Willden 2005), Chain e Varyani (Chai &amp;amp; Varyani 2002) e Zhu et al. (Zhu, Lin, Jia &amp;amp; Yang 2010) utilizam esse tipo de representação, bem como plots 2D para representar outros resultados.
Outros trabalhos, por sua vez, fazem uso de graéficos tridimensionais para visualizar os resultados. O trabalho de Chen e Chen (Chen &amp;amp; Chen 2010) é um exemplo, onde o riser é mostrado como um tubo curvado pela correnteza, exibindo os véortices em certos pontos do riser (Figura 2.3). Os vértices são representados por linhas coloridas representando os fluxos. Uma abordagem muito semelhante ée empregada por Ferrari (Flatschart, Meneghini &amp;amp; Jr. 2004). Zhu et al. (Zhu, Ou, Lin &amp;amp; Hu 2011), por outro lado, utilizam uma representação ligeiramente diferente. O riser ée apresentado apenas como um cilindro, sem curvatura, poréem os voértices são em alguns casos apresentados de forma conténua ao longo do riser e em outros apenas para certas profundidades (Figura 2.4). Entretanto, tais visualizacoes sao apenas figuras estéticas, nãao animacçãoes.
Figura 2.1: Representação por plots. Fonte: Simantiras e Willis 2001, página 13, Figura 11.
Figura 2.2: Representação de vortices por imagem 2D. Adaptado de: Al-Jamal e Dalton 2004, página 88, Figura 13.
Figura 2.3: Representação de vórtices e curvatura do riser por gráficos 3D. Adaptado de: Chen e Chen 2010, pagina 5, Figura 5.
Figura 2.4: Outra representação de vortices e curvatura do riser por gráficos 3D. Adaptado de: Zhu et al. 2011, página 791, Figura 3.
Figura 2.5: Isosuperóficies de pressão via gróficos 3D. Adaptado de: Holmes et al. 2006, pagina 7, Figura 11.
Gróficos 3D são utilizados também para outros fins além da representacao de vórtices ou da curvatura do riser. Holmes et al. (Holmes, Jr. &amp;amp; Constantinides 2006) utilizam gráficos tridimensionais para representar as isosuperfócies de pressao sobre o riser (Figura 2.5), enquanto Alexander (Alexander 2003) os emprega para exibir a variação de esforços sobre o riser (Figura 2.6). No primeiro caso, diferentes isosuperfócies são exibidas em diferentes cores, enquanto no segundo as cores saão utilizadas para representar a intensidade do esforcço em cada regiãao do riser.
Todos os trabalhos apontados acima tinham por foco a simulacão e não a visualizacão dos resultados. Os trabalhos citados a seguir apresentam um foco maior na visualizacão da simulacão, e combinam algumas das caracterósticas acima descritas com outras originais.
O sistema Anflex(Petrobras 2005), desenvolvido em conjunto pela Petrobras e pela PUC-Rio, óe um software para simulaçcaão de risers em que os resultados sãao visualizados em um ambiente grófico 3D (Figura 2.7). Estes resultados podem ser visualizados apenas após toda a simulaçao ter sido computada. Na visualizaçcaão, o riser, a embarcaçcaão, a superfócie e o fundo do mar saão representados de forma animada, e os esforçcos ao longo do riser sãao indicados atravóes de cores.
Santos et al. desenvolveram o Environ (Santos, Soares, Carvalho &amp;amp; Raposo 2011), uma plataforma colaborativa para engenharia de petróoleo que inclui visualizaçcãao de riser (Figura 2.8). O riser óe representado em gróaficos 3D e as forçcas e outras grandezas fósicas saão exibidas
Figura 2.6: Cores em gráficos 3D para representar intensidade de esforgo sobre o tubo. Adaptado de: Alexander 2007, página 81, Figura 27.
Figura 2.7: Software de simulacão de riser com visualização dos resultados em ambiente gráfico 3D. Fonte: Petrobras et al. 2005, página 39, Figura 3.2.
Figura 2.8: Ambiente colaborativo com visualização animada 3D do riser. Fonte: Santos et al. 2011, página 6, Figura 6.
com cores e setas. Estes dados sao gerados previamente numa etapa de simulação, e sá então áe realizada a animaçcaão. Sendo um ambiente colaborativo, diversos usuaários podem utilizar a plataforma simultaneamente, trocar informacães e inserir anotaçães na cena 3D.
O trabalho de Bernardes (Bernardes 2004) tambám oferece um ambiente de visualização de riser, em que o riser e as grandezas físicas são representadas em gráficos 3D (Figura 2.9). O valores sãao computados tambáem numa etapa anterior. O trabalho tem como diferencial a visualizaçcãao de muáltiplos riser, com deteccçãao de colisãao entre eles.
Ja o trabalho de Morooka et al. (Morooka, Brandt, Matt &amp;amp; Franciss 2008) realiza visualização 3D não dos resultados mas dos parâmetros de simulaçao. Corrente, ondas e profundidade podem ser visualizados e alterados na interface (Figura 2.10). A simulação á feita em seguida e os resultados exibidos em plots 2D . No trabalho, há um foco no realismo da cena 3D, especialmente na representaçcãao da áagua.
Por fim, o software OrcaFlex (Orcina 2013b) á uma ferramenta comercial desenvolvida pela empresa Orcina que oferece simulaçao e visualização do comportamento de diversas estruturas offshore, entre elas, o riser. O usuario pode, através de um ambiente virtual (Figura 2.11), montar o cenáario a ser simulado, adicionando e posicionando as diversas estruturas. Apáos isto, pode-se iniciar a simulação numárica. A medida que a simulacão á executada, a representação visual da simulação á atualizada com os novos dados. Concluda a simulacão, pode-se reproduzir a animação da simulacão numa taxa de quadros mais fluida, bem como inspecionar os resultados atravás de gráficos (plots) e tabelas.
Assim, como uma caracterástica comum para estes trabalhos, tem-se que nenhum deles oferece simulaçcãao e visualizaçcãao interativas em tempo-real. A visualizaçcãao áe sempre uma etapa separada da simulação, o que prejudica a fluidez na interatividade, ja que a cada mudança de parâmetros o usuário deve esperar pela simulação ser concluída. Uma ressalva deve ser feita para o software OrcaFlex, jáa que os resultados sãao visualizados na medida que sãao produzidos. Entretanto, as instrucães de uso contidas no manual do Orcaflex(Orcina 2013a) indicam que a
Figura 2.9: Outro ambiente com visualização animada 3D do riser. Segundo a fonte, trata-se de um esboço da interface. Fonte: Bernardes 2004, página 119, Figura 20.
Figura 2.10: Ambiente de visualização 3D para ajuste de parâmetros de simulação. Fonte:
Morooka et. al. 2008, página 7, Figura 7
Figura 2.11: Software comercial Orcaflex desenvolvido por Orcina Ltd.. Fonte: Pagina Web de Orcina Ltd.
forma de uso padrão do programa é esperar toda a simulação ser executada para então visualizar os resultados.
2.4	Considerações Finais
Como visto neste capétulo, a simulação de risers e a visualizaçao cientéfica sao areas de estudo jé bastante desenvolvidas. Entretanto, a visualizaçao de risers, combinação dos dois campos, apresenta ainda certas limitacães. Dentre os trabalhos de simulação de riser são poucos aqueles que tem por foco a visualizacão dos dados, sendo o foco da maioria dos trabalhos os modelos mateméticos de simulacão. Alguns dos trabalhos utilizam plots 2D para representar as grandezas fésicas variantes e imagens bidimensionais para exibir os vortices para uma dada profundidade. Outros utilizam gréficos 3D, uns para visualizar os vértices ao longo do tubo e sua curvatura, outros para mostrar com cores as variacães de tensão sobre o riser. Os trabalhos mais completos de visualizaçcãao combinam as diversas abordagens numa animaçcãao tridimensional.
Porém, mesmo estes trabalhos mais completos possuem limitacães. Um quesito importante na visualização é a interatividade, que permite ao usuério explorar o conjunto de dados, auxiliando na busca por respostas especéficas ou ainda revelando aspectos inesperados sobre o fenômeno estudado. Os atuais trabalhos sobre visualizaçao de riser possuem a limitação de que simulaçcãao e visualizaçcaão ocorrem em etapas separadas, de forma que o usuaério deve esperar pela simulação ser concluéda toda vez que mudar os parômetros, o que compromete a fluidez na interaçcãao. Uma possével exceçcãao ée o software comercial OrcaFlex, em que a visualizacçãao ée atualizada a medida que os resultados da simulaçao são produzidos; mesmo neste caso, entretanto, o
uso padraão da ferramenta consiste em esperar a simulaçcaão ser concluíida para sío entaão realizar a visualização. Assim, como dito no Capítulo 1, este trabalho visa superar esta limitação, fazendo com que simulaçcãao e visualizaçcãao ocorram concomitantemente e permitindo uma interaçcaão que naão interrompa este processo.
Capítulo _____
Metodologia
Neste capátulo são descritos os diversos aspectos envolvidos no projeto e na implementação do ambiente de visualizaçcãao e simulaçcaão. Tais aspectos incluem os fundamentos matemáaticos da simulacao, o projeto da interface de usuario, a estrutura do software implementado e as ferramentas utilizadas. Sendo um ambiente de visualizacão e simulação, o sistema desenvolvido esta estruturado em dois grandes mádulos: o Solver e o Mádulo de Visualizacão. O Solver é o mádulo que produz o comportamento do riser a partir de um modelo matemático x. Alám de implementar o modelo matemáatico de simulacçãao, o Solver deve permitir a alteracçaão de parâa-metros de simulacçãao em tempo-real, mantendo sempre a produçcãao dos resultados de simulaçcãao numa taxa compatável ao passo da animaçcaão. O Máodulo de Visualizaçcãao, por sua vez, encapsula o Solver e provâe a visualizaçcãao animada dos dados da simulaçcãao, tanto parâametros quanto resultados, e gerencia a interaçcãao com o usuáario, provendo funcionalidades que facilitem a mudancça de paraâmetros, inspeçcaão de resultados e demais ajustes de configuraçcãao.
3.1	Simulação do Riser
3.1.1	Modelo teórico
O modelo teoárico para simular o comportamento do riser tem por base as equaçcoães da hidrodinâmica de estruturas offshore e utiliza o mátodo de elementos finitos para obter uma solução numárica. Proposto inicialmente por Ferrari e Bearman (Ferrari &amp;amp; Bearman 1999a), o modelo foi aprimorado por estes e outros autores em trabalhos subsequentes (Morooka et al. 2005, Mo-rooka et al. 2004, Morooka &amp;amp; Tsukada 2011, Kubota 2003). Maiores detalhes sobre o modelo podem ser encontrados nestes trabalhos e aqui áe apresentada uma explicaçcaão simplificada.
O riser áe considerado como um conjunto de elementos de viga interligados entre si, sob o efeito de uma carga produzida pela combinaçcãao da correnteza, onda, pressãoes hidrostáaticas, movimento da plataforma e peso do práprio riser, conforme mostrado na Figura 3.1. Esse conjunto de forçcas no espaçco tridimensional áe decomposto em dois planos ortogonais: o plano
xPara evitar qualquer confusão, Solver e simulador numérico são utilizados como sinônimos neste trabalho, referindo-se exclusivamente a parte do programa que soluciona numericamente as equacães do modelo matematico do riser.
Figura 3.1: Representaçao esquematica do mátodo de elementos finitos.
inline, paralelo a correnteza, e o plano transversal, ortogonal tanto ' correnteza quanto ao fundo do mar. Esta decomposicão simplifica o equacionamento do problema, que í representado matricialmente da seguinte forma:
Mx XX + Dx X + Kx X = Fx
(3.1)
My Y + Dy Y + Ky Y = Fy	(3.2)
Esta e uma formulacão similar ' utilizada para a dinâmica de um corpo rígido, mas adaptada, com o uso de matrizes, para multiplos elementos. Na Equaçao 3.1, para o caso inline, no lugar de uma massa, um coeficiente de amortecimento e um coeficiente de elasticidade, tem-se as matrizes de massa, de amortecimento e de rigidez, respectivamente Mx, Dx e Kx. X, X, XX são por sua vez os vetores de posiçao, velocidade e aceleração de cada elemento, e Fx o vetor com as cargas sobre cada elemento. O problema transversal íe representado de maneira semelhante (Equacão 3.2), mas í importante notar que nao so as cargas, como tambím as matrizes My, Dy e Ky podem ser diferentes do plano inline.
Partindo-se destas equacçãoes, sãao realizadas trâes aníalises para se determinar o comportamento do riser : analise estíatica, de vibraçcoães livres e dinâamica. A aníalise estaítica considera a estrutura em equilíbrio e visa encontrar o deslocamento e o ângulo de inclinação dos elementos. Como velocidade e aceleracão sao nulos, apenas a matriz de rigidez K í utilizada2. Como K depende,
2Para simplificar a notação, quando nao importar se o caso é inline ou transversal, as matrizes M, D, K e o
em parte, da posição dos elementos (a chamada componente geométrica da matriz de rigidez), é utilizado o método de Newton-Raphson, um método iterativo que converge para a soluçao do problema, refinando a cada iteraçao, a matriz K e a posiçao. A análise de vibracões livres visa encontrar a frequência natural de vibracao do riser, isto é, aquela na qual o riser pode entrar em ressonancia. A analise considera apenas as matrizes de massa e rigidez, utilizando os valores calculados na anéalise anterior para a matriz de rigidez K. A frequêencia natural ée determinada encontrando-se os autovalores do sistema. Por fim, a análise dinêmica computa o comportamento do riser para cada intervalo de tempo. Todas as matrizes M, D e K sao consideradas, sendo D computada usando M, K e as frequências naturais. A análise é feita pela integraçao no tempo usando o método de Newmark-Beta (Newmark 1959)
3.1.2	RiserProd: Uma implementação já existente do simulador
Uma implementacõo jé existente deste modelo de simulaçõo é o programa batizado de RiserProd. Implementado na linguagem Fortran 90, com o médulo LAPACK para élgebra linear em Fortran 77, o RiserProd nõo foi feito pensando-se no uso em tempo-real, nem pode ser diretamente utilizado para tal. O RiserProd realiza a simulaçõo do riser para um intervalo de tempo prée-determinado, produzindo todos os resultados para cada time-step em arquivos, na forma de um log. Os parêmetros de simulaçõo sõo também armazenados num arquivo, que é lido pelo programa no início da simulaçõo. O simulador apenas péra assim que todos os resultados tenham sido produzidos , de forma que, quanto maior o intervalo de estudo estipulado, mais tempo o programa leva para retornar os resultados, o que jéa ée um problema para o uso em tempo-real. Aléem disso, o uso de arquivos ée outro fator a contribuir para um tempo de execuçcõao maior. Estas limitações entretanto, em nada impediram que o RiserProd fosse tomado como base para a implementaçcõao de um novo simulador que estivesse apto ao uso em tempo-real.
3.1.3	Requisitos para um simulador interativo em tempo-real
Um simulador interativo em tempo-real deve permitir que os paraêmetros de simulaçcõao sejam alterados a qualquer momento, sem que a simulaçcõao seja interrompida e sem um tempo de resposta perceptével toda vez que um parêmetro for alterado, o que prejudicaria a fluidez na interaçcõao. Aléem disto, neste tipo de sistema naõo ée possével definir o intervalo de estudo da simulaçcaõo a priori, jaé que a simulaçcõao deve prosseguir enquanto o usuéario estiver utilizando o ambiente de visualizaçao. Um intervalo arbitrário até poderia ser definido, sendo atualizado à medida que a simulaçcõao ée executada, mas, ainda assim, quanto maior o intervalo estabelecido, maior o tempo para computar os dados, o que compromete o imperativo de tempo de resposta baixos na mudancça de parêametros. Assim, um modelo melhor para uma simulacçõao interativa em tempo-real ée, ao invées de prée-computar os resultados antes de visualizéa-los, calculéa-los sob demanda, à medida que a simulaçõo for avançando. Para isto, entretanto, é necessario garantir que os dados sejam produzidos numa taxa compatével à frequência da animaçõo, por exemplo, 30 quadros por segundo.
vetor F serão utilizados, para se referir tanto as do caso inline quanto do transversal. Quando houver diferença entre os casos, esta será explicitamente indicada.
Figura 3.2: Fluxo do Solver RiserProd.
Figura 3.3: Fluxo do Solver aprimorado para interatividade em tempo-real.
3.1.4	Implementando o simulador interativo em tempo-real a partir do RiserProd
Um simulador interativo em tempo-real foi obtido a partir do RiserProd fazendo-se algumas modificações, de acordo com os requisitos apresentados na seção anterior. No RiserProd, uma simulação é um processo indivisível, que inicia com a passagem de um arquivo de parâmetros, seguida da realizacão das anélise estatica, de vibracães livres e dinâmica (para todo o intervalo de estudo), e por fim, escrevendo os resultados em arquivos de saída, conforme mostrado na Figura 3.2.
Para o novo simulador, esse fluxo deve ser reestruturado e o uso de arquivos eliminado, utilizando um buffer para armazenar os resultados e que pode ser compartilhado com a interface de visualizacão. Na nova estrutura (Figura 3.3), as anélises estética e de vibrações continuam sendo realizadas sempre e apenas quando um novo conjunto de parâmetros é passado. Jé a anaílise dinâamica, ao invíes de ser realizada para todo um intervalo de estudo quando novos parâametros sãao passados, passa a ser realizada a cada quadro de animaçcãao mas agora para um unico passo da simulacao. A integracao no tempo realizada na anélise dinâmica depende de certas condiçães de contorno tais como deslocamento e velocidade dos elementos. Os valores utilizados para tais condicçãoes sãao aqueles gerados no passo anterior, exceto na primeira vez em que a anaélise ée executada, em que deslocamento e velocidade sãao iguais a zero.
Aléem destas reestruturaçcãoes, a nova implementaçcãao difere do RiserProd por estar codificada em C++. Esta decisao ocorreu pois o Fortran, apesar de ainda popular na area de computação
cientófica, nãao óe mais tãao utilizado fora deste nicho, podendo haver problemas de compatibilidade dele com recursos mais recentes (como integracão com a interface escrita em Python). Alóm disso, C++ ó uma linguagem que oferece orientação a objetos, proporcionando um código mais organizado, e conhecida por ter um alto desempenho em tempo de processamento. Quanto ao módulo LAPACK para algebra linear, este foi substituódo por sua versão em C, o CLAPACK.
3.1.5	Avaliando o desempenho do novo Solver
A capacidade do ambiente de simulaçcãao e visualizaçcaão suportar interaçcaão em tempo-real óe limitada pelo Solver, pois o custo computacional deste moódulo óe proporcional ao nuómero do elementos do modelo de simulaçcãao. Para o caso do moódulo de visualizaçcãao, naão hóa grande variaçcãao de desempenho. Assim, apenas o desempenho do Solver óe avaliado de maneira formal.
O desempenho do Solver ó avaliado segundo dois mótodos: profiling pelo Visual Studio e medicao direta do tempo. A medida dos tempos ó feita utilizando a função clock() da biblioteca time.h e visa determinar o tempo de execucão de cada uma das analises do Solver. Para o caso da anóalise dinaâmica, ela óe decomposta em duas etapas medidas separadamente, pois embora a anóalise dinaâmica seja executada para cada passo da animacçãao, certos cóalculos de matrizes realizados no começco desta anaólise precisam ser executados apenas quando novos parâametros saão fornecidos. Assim, a medida dos tempos do Solver óe realizada para quatro etapas: Anóa-lise Estótica, Anólise de Vibracães Livres, Montagem de Matrizes e Anólise Dinamica (aqui referindo-se a parte que ó executada a cada passo da animacão). Pelo profiler do Visual Studio, ó possóvel descobrir quais os pontos específicos do programa que contribuem com maior carga de processamento, enquanto a medida direta retorna quanto tempo durou a execucçãao de determinado trecho de código. O Visual Studio oferece duas formas diferentes para realizar o profiling. Na primeira, chamada de CPU Sampling, o estado do programa ó capturado em diferentes momentos ao longo da execuçcaão e a anóalise óe feita com estes dados. O outro móetodo de profiling por sua vez realiza a contagem de quantas vezes cada funçcãao óe chamada e o quanto de processamento ela realiza (para distinguir funçães que processam dados realmente de outras que apenas chamam outras funcçãoes).
3.2	Visualizaçao da Simulação
3.2.1	Fundamentos
Visualizar os dados de simulacçãao significa transformar informacçãao numóerica em elementos visuais, como cores e formas. Segundo Telea (Telea 2008), o processo de visualização segue um conjunto bem definido de etapas, denominado de Pipeline de Visualizaçao. São quatro as etapas: importação, filtragem, mapeamento e renderizacão. Na etapa de importação, dados brutos são importados de alguma fonte externa e armazenados numa estrutura de dados apropriada à visualizacçãao. Na etapa de filtragem, dados desnecessaórios sãao eliminados, ou ainda novos dados saão calculados e incluódos no conjunto, processo chamado de enriquecimento dos dados. No mapeamento, o conjunto de dados filtrado e enriquecido óe mapeado para formas visuais bi ou tridimensionais. Por fim, na etapa de renderizacçãao, estas formas visuais sãao desenhadas na tela,
dispositivo de medição ou 4-simulação
introspecção sobre o fenómeno original
dados brutos
Figura 3.4: Pipeline de Visualização. Fonte: Mologni dos Santos 2011, página 18, Figura 2.3.
gerando a imagem final. A Figura 3.4 ilustra esse processo.
Na visualização científica, costuma-se trabalhar com dados constituídos de um conjunto de amostras e de suas propriedades geometricas e topológicas. Embora dados muitas vezes estejam disponíveis em sua forma contínua, como uma função, a manipulação de dados contínuos ó mais difícil e lenta do que a de dados discretos. O conjunto de dados ó efetivamente uma malha, onde cada víertice íe uma amostra, podendo armazenar muíltiplos valores escalares, vetoriais e tensoriais. A geometria dos dados estabelece a posiçcaão de cada víertice, e a topologia, como os víertices conectam-se entre si.
O VTK (Schroeder et al. 2006), sigla para The Visualization Toolkit, í um framework orientado a objetos para programacão de aplicaçães de Visualização Científica. O VTK oferece classes de objetos que implementam as diversas etapas do pipeline de visualização, sendo eles componentes que devem ser conectados uns aos outros de forma a compor o pipeline. São fornecidas classes apropriadas para armazenar os dados em suas diversas formas intermediarias, bem como funcionalidades necessarias a maioria das aplicaçcãoes graficas, como criaçcaão de janelas e interação com o mouse. O framework é implementado em C++, utilizando OpenGL para renderizacçaão de graficos, o que a torna bastante eficiente. Pode tambem ser utilizado em outras linguagens como Tcl/Tk, Python e Java, atraves de bindings com a implementacão em C++.
3.2.2	Técnicas para Visualizar a Simulação
Uma forma intuitiva de visualizar os dados de simulação é criar uma cena que reproduza a situaçao real. Partindo-se deste princípio, aqui a simulação é visualizada mostrando o riser em movimento e seu ambiente, isto e, o mar, o leito marinho e a embarcaçcaão. Assim, dados como diâmetro do riser, deslocamento e velocidade de cada elemento, profundidade do oceano, ou mesmo o flutuadores dispostos ao longo do riser podem ser representados de maneira natural e intuitiva. Outros dados importantes como correnteza ou pressao do fluído interno, embora não sejam normalmente visíveis na natureza, sao representados atraves de setas ou cores, duas tecnicas ja consagradas na visualização. Para grandezas vetoriais, como forças de excitaçao sobre o riser ou a correnteza, utilizam-se setas, enquanto para grandezas escalares como pressaão, densidade ou elasticidade do material do riser, o uso de cores mostrou-se mais adequado. Atra-ves desta abordagem, é possível fornecer uma visão geral dos diversos aspectos da simulação. Detalhes e realismo na representaçao podem, em alguns casos, ser sacrificados, buscando-se uma visualizaçcãao mais intuitiva do todo.
Figura 3.5: Representacão por esquematica da interface de visualizacão, dividida em Cena 3D e Painel de Controle.
3.2.3	Interface de Usuário
A interface de usuario ó responsavel por realizar duas funcães: apresentar a visualizacao e receber comandos do usuório. Partindo desta consideracão, a interface estó dividida em dois elementos: uma cena 3D e um painel de controle (ver esquema da Figura 3.5). Na cena 3D, ó exibida a visualizaçao da simulacão, que pode ser ampliada, transladada e rotacionada pelo usuório. Ja no painel de controle, o principal propósito ó permitir ao usuario o ajuste dos parâmetros da simulação, embora tambóm outras configuracães do aplicativo possam ser alteradas via painel. O grande nómero de parâmetros, uns quantitativos outros qualitativos, reforçou a escolha pelo painel de controle como interface para ajuste de parâmetros. Uma possóvel alternativa, em que a interacao com os parâmetros fosse de alguma maneira realizada na cena 3D (arraste e clique p.e.) poderia sobrecarregar a cena com muita informacão, alóm do fato de que nem todos os parâametros possuem representaçcaão visual intuitiva e em algum momento, uma representação textual ou numórica seria necessaria. Um painel de controle prove uma melhor organização e os widgets são um recurso jó bem estabelecido.
3.2.4	Implementando o Modulo de Visualização
Para implementar o Modulo de Visualização, foi escolhida a linguagem Python e os frameworks Qt para janelas e widgets e VTK para visualizacão. O VTK foi escolhido por implementar diversas tecnicas de visualização e ser amplamente utilizado pela comunidade de visualização científica. A escolha pelo VTK acabou determinando em parte a escolha das outras ferramentas. O VTK pode ser utilizado com Python e apresentou um bom desempenho na visualizacão, alcançando taxas de mais de 30 quadros por segundo na animação. Alem disso, Python é uma linguagem que acelera em muito o processo de programação, especialmente se comparada a C/C++. Por fim, o Qt, um framework para desenvolvimento de interfaces gréficas
Figura 3.6: Janelas do VRP, interface para o RiserProd existente previamente a este trabalho.
de usuário bastante difundido, possui integraçao tanto com Python quanto com o VTK e e de fácil utilizaçao, possuindo um ambiente gráfico para edição dos widgets.
3.2.5	VRP: um Modulo de Visualização já existente para o RiserProd
Ja existia previamente a este trabalho um Modulo de Visualizaçao para o RiserProd original, o VRP (DutoRisk Manual de Usuário (Interface e Solver) 2009), citado previamente na Secão
2.3	do Capítulo 2. O modulo consiste de uma interface grafica organizada em janelas e botães atravás da qual o usuário pode iniciar uma simulação e analisar os resultados. Para a simulacão, o usuáario pode escolher qual Solver deseja utilizar, um deles sendo o RiserProd. Como nãao áe uma ambiente interativo em tempo-real, o usuário primeiramente deve entrar com os parâmetros, executar a simulação para todo o intervalo de estudo, e so então visualizar os resultados. A visualizacão e realizada atraves de tabelas e plots 2D. Na Figura 3.6 á mostrada uma imagem da interface. Como tanto o VRP quanto o presente trabalho utilizam o mesmo Solver, o VRP mostra-se apropriado como base de comparaçcãao para o Modulo de Visualizaçcãao aqui proposto. Tal comparação e efetuada na avaliação de usabilidade, discutida na Subseção 3.2.6 a seguir.
3.2.6	Avaliando a Visualização
Foi afirmado na Seçao 1.1 do Capítulo 1 que um simulador e util no projeto, analise e diagnáostico de risers, e que recursos de visualizaçcaão e interaçcãao em tempo-real contribuem para uma compreensao mais intuitiva da simulacao; espera-se, portanto, que o ambiente desenvolvido apresente estas qualidades. Baseado nestas características, tambem acredita-se que o ambiente se destaque mais em permitir uma visãao global da simulacçãao, sintetizando seus diversos aspectos, do que na visualizaçcãao de dados individuais.
Como forma de avaliar a presença ou nao destas características, foi elaborado um teste para ser realizado com usuários que tenham experiância com risers. O teste consiste em colocar à disposicão o ambiente de visualizaçao, bem como instruçães explicando o seu propásito e a forma de uso, e pedir para que o usuáario utilize o programa e responda um questionáario. A forma como o usuaário deve utilizar o programa áe livre, sendo pedido apenas que execute uma ou mais simulaçcãoes e explore as diversas caracterásticas do software. As questãoes cobrem diversos aspectos, abrangendo perguntas sobre a utilidade do ambiente para os diferentes propoásitos de projeto, anáalise e diagnáostico de risers, sobre a qualidade da animaçcaão e da interatividade, e se a visualizaçao da simulacão á intuitiva, entre outras. Também sao feitas algumas perguntas comparando o ambiente desenvolvido com o VRP (mencionado na Subseçao 3.2.5). As questães devem ser respondidas dando notas de acordo com a escala de Likert, isto á, de 1 a 5, sendo 1 a pior e 5 a melhor nota. O voluntaário pode adicionalmente comentar a nota dada no campo Justicativa, sendo isto opcional. O questionário aplicado encontra-se no Apândice A.
3.3	Integrando Solver e Modulo de Visualização
Por fim, á necessário integrar o Solver e o Mádulo de Visualização de forma a comporem uma unica aplicação. A abordagem escolhida foi encapsular o Solver como mádulo Python utilizando o SWIG e passáa-lo ao Máodulo de Visualizaçcãao, onde poderaá ser utilizado como um mádulo Python. O SWIG á uma ferramenta muito utilizada (por exemplo, pelo Google) para realizar de forma automatizada o encapsulamento e binding de programas em C/C++ com outras linguagens como Python, Ruby e PHP. Para tanto, deve-se escrever em um arquivo de extensaão .i quais as classes e funcçãoes C/C++ deverãao estar disponáveis para uso pela outra linguagem. Executando o SWIG com este arquivo de entrada, um header C/C++ .h e um arquivo Python .py sao gerados. Adicionando o header ao cádigo C/C++ e compilando como uma biblioteca, á gerado um arquivo que juntamente ao arquivo .py gerado anteriormente, permite que a biblioteca seja importada como um máodulo Python.
Assim, os mátodos do Solver podem ser invocados dentro do codigo Python e tambem os dados do Solver podem ser lidos e escritos. Uma unica complicação existente á quanto ao acesso de dados vetoriais, já que no C/C++ o vetor á um ponteiro. A soluçao para este caso áe implementar no práoprio arquivo .i getters e setters apropriados para esses dados, que dado o ándice retornam o valor do elemento naquela posição do vetor.
3.4	Consideracães Finais
Neste capátulo, foram mostrados os diversos aspectos necessários no projeto e na imple-mentaçcaão do ambiente de visualizaçcãao e simulaçcãao. Foi visto como o software do ambiente foi estruturado em dois máodulos, um responsáavel pela simulaçcaão, o Solver, e um responsáavel pela visualizacçãao. Da parte do Solver, apáos expor os fundamentos matemaáticos da simulaçcãao de riser e os requisitos necessáarios para operar com interacçãao em tempo-real, foi explicado como o RiserProd, um Solver que já implementava o modelo matematico descrito, pâde ser adaptado para o uso em tempo-real. Foi tambáem descrito o máetodo utilizado para avaliar o desempenho
do Solver desenvolvido. Quanto ao Modulo de Visualizaçõo, além de discutir o propésito e os fundamentos da visualizaçõo cientéfica, foram indicadas as técnicas escolhidas para visualizar a simulacõo de riser, bem como o design da interface de usuério desenvolvida para tal e as ferramentas utilizadas na implementaçao do módulo. Além disso, foi explicado o método proposto para avaliar a usabilidade do ambiente. Por fim, foi mostrado como os dois modulos que compoõem o ambiente de visualizaçcõao e simulacçaõo puderam ser integrados em um uénico aplicativo. No capétulo seguinte sõo mostrados e discutidos os resultados obtidos a partir dos métodos descritos aqui.
Capítulo T__
Resultados
O ambiente de simulaçõo e visualizaçõo de risers foi implementado e avaliado conforme especificado no Capétulo 3. No presente capétulo, o protoétipo desenvolvido ée apresentado, sendo descritas suas principais características. Também uma visõo geral do cédigo do protétipo é mostrada. Maiores detalhes do coédigo podem ser consultados na documentaçcaõo apresentada no Apêndice B. Por fim, sao apresentados e discutidos os resultados das analises de desempenho e usabilidade.
4.1 Protótipo Desenvolvido
O protétipo foi desenvolvido conforme especificado no Capétulo 3. Na Figura 4.1 é mostrada a janela principal da aplicaçõo, que é constituéda de duas partes principais: à esquerda, a visualizacao em gréficos tridimensionais e à direita o painel de controle. Adicionalmente, hé tambéem uma barra de menu na parte superior da janela.
Para iniciar uma simulacçõao, o usuéario deve primeiro determinar a configuraçcõao do riser, na opçao New-&gt;Model, na barra de menu (Figura 4.2). Em seguida, o numero de elementos do modelo de elementos finitos da simulaçcõao deve ser especificado. Feito isto, um conjunto padraõo de parêametros ée estabelecido e a simulaçcõao estaé pronta para ser executada e visualizada. Atravées de um botõao Play, o usuéario pode iniciar ou pausar a simulaçcõao. Com o botõao Reset, o riser ée recolocado em sua posiçcõao inicial, reiniciando a simulaçcõao com o mesmo conjunto de paraêmetros. Os parêametros podem ser alterados a qualquer momento no painel de controle, na aba Parameters. Muéltiplos parêametros podem ser alterados de uma vez, mas ée necessaério ativar o botõo Apply para indicar que os novos parêmetros podem ser submetidos. Também no painel de controle outras opçcoões podem ser ajustadas.
A visualizaçcõao da simulaçcaõo reproduz em computacçõao gréafica o cenaério de operaçcaõo de um riser, onde o usuério pode vê-lo movimentando-se sob o efeito das cargas ambientais. Sendo uma cena 3D, é possével aplicar transformacoes de rotaçõo, translaçõo e escala, como na Figura 4.3. Na cena, aléem do riser, sõao representados as boias, a embarcacçaõo, a superfécie e o fundo do mar. Como o objetivo do sistema ée prover uma visaõo geral e intuitiva da simulaçcõao, a relaçcõao de escalas entre alguns elementos, como entre o riser e a embarcaçcõao, naõo segue a da realidade, pois poderia dificultar a visualizaçcõao. Tambéem a passagem do tempo na visualizacçõao nõao ée
Figura 4.1: Janela principal do ambiente de visualização.
Figura 4.2: Iniciando uma simulacão: escolhe-se uma configuração de riser e o numero de elementos do modelo e a simulaçcãao estaé pronta para ser visualizada.
Figura 4.3: E possivel explorar o ambiente virtual aplicando rotação, translação e escala.
necessariamente igual a da simulaçao. Sao visualizados também os diversos dados da simulação, tanto parâmetros quanto resultados. Um conjunto de setas sobre o riser representa as forças de excitação, enquanto um outro conjunto de setas dispostas um pouco afastadas do riser mostra o perfil de correnteza marítima. Os méximos de deslocamento nos planos inline e transversal são marcados com linhas verdes. Por fim, cores são utilizadas sobre a parede do riser para representar diferentes dados da simulaçcãao, como coeficiente de arrasto ou pressaão interna.
Alguns aspectos da visualização podem ser ajustados na aba Display do painel de controle, como qual a grandeza a ser representada por cores. Tambem nesta aba é possível ajustar as escalas do deslocamento e forçcas sobre o riser, jaí que estes podem ser muito pequenos para serem visualizados apropriadamente. Para facilitar este processo, atravíes do botãao Auto Scale íe escolhido automaticamente um conjunto de escalas adequado. Objetos da visualizaçcãao, como as linhas de maíximo deslocamento ou o modelo da embarcaçcãao, podem ser desabilitados para deixar a visualizaçcãao menos carregada de elementos visuais. Por fim, para aumentar o realismo e a imersão, é possível optar por um estilo de visualizacão como o da Figura 4.4, com o mar estendendo-se bem alem da embarcação (e não contido por um bounding box), e tambím ativar o uso de visãao estíereo tridimensional.
Alem de visualizar os dados no ambiente de realidade virtual, é possível tambem inspecionar os dados na forma numerica, na aba Results do painel de controle. Nela, uma tabela com os dados de deslocamentos, velocidades e forçcas produzidos pela simulaçcãao saão exibidos para cada elemento, divididos nas componentes inline e transversal. Clicando-se em um dos elementos da tabela, uma marcaçcaão e colocada sobre o riser no ambiente virtual, na posiçcãao do elemento correspondente. Inversamente, ao colocar o mouse sobre o riser e pressionar a tecla P, o elemento daquela posição é realcado na tabela (Figura 4.5.
Figura 4.4: Para maior realismo e imersão, á possível optar por uma visualização com o mar extendendo-se ate o horizonte, bem como utilizar visão stereo tridimensional.
O Solver do protótipo desenvolvido reproduz exatamente os cálculos do simulador original RiserProd. A validaçao dos resultados do novo simulador foi feita por comparacão de alguns casos de simulação executados tanto no Solver desenvolvido quanto no RiserProd. Uma validação mais exaustiva e formal dos resultados do novo Solver porám nao foi realizada neste trabalho.
4.2	Visão Geral do Código
Uma descricão geral do cádigo do Protátipo desenvolvido é aqui apresentada. Maiores detalhes podem ser consultados na documentação apresentada no Apendice B. Seguindo a arquitetura descrita no Capítulo 3, o cíodigo encontra-se dividido em dois grandes moídulos: o coídigo do Solver em C++ e o do Mádulo de Visualizacão em Python. Os módulos operam em conjunto formando uma unica aplicacão, sendo os metodos do Solver invocados pelo Mádulo de Visualizacao. Na Figura 4.6, á mostrado um diagrama com as classes principais do Solver, e na Figura 4.8, um diagrama das classes do Mádulo de Visualização.
A simulacao realizada pelo Solver á consituáda de três análises, as Análises Estática, de Vibraçães Livres e Dinêmica. Cada uma destas analises encontra-se implementada como uma classe no cádigo do Solver, respectivamente nomeadas de StaticAnalysis, FreeVibrationAnalysis e DynamicAnalysis. Funcionando como uma engine, cada uma possui um metodo run, que recebendo como parêmetro um objeto do tipo Riser, realiza todos os cálculos correspondentes a determinada análise e armazena no objeto fornecido os resultados produzidos. O tipo Riser á definido no cádigo do Solver, assim como subclasses que definem configuraçães especificas de riser: TTR, Collector e Tower. Fazendo uso de sobrecarga de método (method overloading), os
Figura 4.5: Apontando com o mouse sobre o riser e pressionando o botao p, o elemento correspondente é marcado no ambiente de visualizaçao (esfera vermelha) e realçado na tabela da aba Results.
Figura 4.6: Diagrama com as classes principais que compõe o Solver. Para nõo sobrecarregar o diagrama, foram omitidas as subclasses de MyMatrix e Force.
máetodos run das classes de anaálise aceitam como parêametro cada um destes subtipos de Riser, realizando operaçcãoes diferentes conforme o tipo passado.
Nos caálculos realizados pela anáalises, saão calculadas e manipuladas diversas matrizes como as de Massa, Amortecimento e Rigidez, entre outras. Todas estas encontram-se definidas no cádigo do Solver como filhas da classe base MyMatrix. Estas matrizes foram definidas como classes ao invás de utilizar diretamente vetores (arrays) de duas dimensães pois estas matrizes compartilham de algumas caracterásticas nãao usuais. Em primeiro lugar, nem todos os elementos das matrizes apresentam valores diferentes de zero, estando estes concentrados em faixas bem definidas da matriz. Assim, de forma a economizar memáoria, áe adotado um procedimento de compressaão da matriz, na qual apenas os valores diferentes de zero saão armazenados. Como um efeito disso, o acesso a elementos da matriz deixa de ser trivial, dado que áe necessáario uma conversão dos ándices da matriz para a forma comprimida. Na classe base MyMatrix, encontram-se mátodos que facilitam a interacão com a matriz, como getters e setters. Alám disso, algumas matrizes, com a de Massa, Amortecimento e Rigidez (nomeadas no cáodigo de MassMatrix, DampingMatrix e StiffnessMatrix, respectivamente), contam com mátodos assemble, que, recebendo como parêametro um objeto de uma subclasse de Riser, calculam os valores da matriz, preparando-a para ser usada pelas anaálises. Pelas anaálises tambáem sãao utilizadas classes derivadas de Force, que implementam as cargas que atuam sobre o riser.
A classe Riser e suas subclasses servem basicamente de contêeiner para outros dados da simulaçcãao, tanto paraêmetros como resultados, e sãao passadas como argumento para diversos máetodos. A classe Riser tambáem contáem máetodos que tem funcçaão auxiliar, como calcular um certo dado do riser a partir de outros dados.
Finalmente, tem-se a classe Solver e a classe Model. A classe Solver áe aquela que agrega as demais, funcionando como a classe principal do Solver. Possui, entre outros, os máetodos newModel (para definir uma configuração de riser), staticAnalysis, freeVibrationAnalysis e dynamicAnalysis. A classe contám tambám entre seus atributos, ponteiros para objetos das classes StaticAnalysis, FreeVibrationAnalysis e DynamicAnalysis, e um ponteiro para um objeto da classe Model. Os objetos das anáalises servem obviamente para realizar as anaálises do Solver. A classe Model por sua vez, á uma classe que serve de intermediario entre o Solver e a classe Riser. A classe Model possui, como a classe Riser, subclasses para cada configuracçãao de riser (TTRModel, CollectorModel, TowerModel). Cada uma possui como atributo um objeto da subclasse de Riser apropriada, bem como máetodos staticAnalysis, freeVibrationAnalysis e dynamicAnalyis, que recebem como argumento a classe da anaálise correspondente e chamam por sua vez o máetodo run dela passando o objeto do subtipo de Riser apropriado. A ideia por tráas da aparente complexidade de classes e chamadas de máetodos áe se valer do polimorfismo e da sobrecarga de máetodo para implementar as diversas anáalises para as diversas configuraçcoães de riser sem precisar armazenar ou verificar informaçcãoes quanto ao tipo de configuraçcãao utilizada. Com esta organizacçãao, por exemplo, a classe Solver mantáem apenas um atributo de tipo Model, sem precisar saber como qual tipo especifico estáa lidando (exceto no momento em que um áe criado, no mátodo newModel). O diagrama da Figura 4.7 ilustra esta logica, mostrando como se dáa o fluxo de chamadas de máetodo ao realizar a anáalise estáatica para uma configuraçcãao TTR, por exemplo.
Figura 4.7: Diagrama representando o fluxo de chamadas (indicado por setas) que ocorre ao executar a Anóalise Estóatica para uma configuraçcãao TTR. O polimorfismo e a sobrecarga de móetodos assegura que a anóalise óe executada para a configuraçcãao de riser especófica.
Para o código do Módulo de Visualização, os objetos correspondem em sua grande maioria aos objetos visuais da interface de visualizaçao, exceto pela classe principal App. Tem-se, por exemplo, a classe Interface, que implementa a janela principal e seus diversos widgets. Esta por sua vez, contém um objeto Scene, para a cena 3D onde ó feita a visualizacão propriamente, e Panel, onde ó implementado o painel de controle. O objeto Scene contóm ainda outros objetos, representando os elementos da cena, como Riser para o riser, Water para a superfície do mar, WaterFlow, para o perfil de correnteza ou Forces, para as forças de excitação representadas como setas.
Os móetodos destas classes sãao vaórios e de propóositos bem especóficos, mas todas possuem tanto um mótodo construtor init— quanto um update. O mótodo init— ó chamado quando o objeto ó instanciado e cria e inicializa seus atributos. Para o caso de classes como Riser ou Water que representam elementos da visualização, o mótodo________imL_ cria os mappers, actors e
demais objetos do VTK que compãem o pipeline de visualização, enquanto que para a classe Panel, o mótodo conecta os diversos widgets do painel de controle ao seus respectivos callback. O móetodo update, por outro lado, atualiza os dados do objeto a medida que a simulaçcãao óe executada.
Por fim, a classe App óe a classe que define como móetodos as princiapis funcionalidades da aplicação, alóm de conter uma instância de Interface e uma de Solver, importado do C++ via SWIG. Entre os mótodos oferecidos pela classe tem-se newModel, para criar um novo modelo de simulaçao; generate, que invoca as anólises estótica e de vibrações livres do Solver e ó chamada sempre que novos parâmetros são passados; play, pause e reset, para controlar a visualização da simulacçãao, e update, que invoca um passo da analise dinâamica e chama o metodo update de Interface, que chama o update de Scene e de Panel, e assim por diante. A frequância com que o metodo update e invocado e controlado por um relogio disponóvel como classe do Qt.
Figura 4.8: Diagrama de classes do Modulo de Visualizacão. Como Scene contám muitas classes, apenas algumas estaão representadas, para nãao sobrecarregar o diagrama.
4.3	Avaliação do Desempenho do Solver
Os resultados da medida dos tempos em cada uma das quatro etapas em funçcãao do nuámero de elementos, de acordo com o mátodo descrito na Seçao 3.1.5 do Capátulo 3, sao mostrados na Figura 4.9 a seguir. Cada um dos valores apresentados foi obtido como a mádia de dez amostras medidas e as barras de erro nos gráaficos representam o desvio padraão. O nuámero de amostras foi considerado satisfatoário devido ao baixo desvio padraão resultante. As medidas foram tomadas ao executar o Solver em uma máquina com processador Intel Core i7 2.80 GHz e 12GB de memoria RAM e sistema operacional Windows 7 de 64 bits.
A medida dos tempos permite analisar os limites para o uso interativo em tempo-real do Solver. Conforme discutido no Capátulo 3, saão dois os requisitos que devem ser assegurados para interaçcãao em tempo-real. O primeiro áe que, ao realizar uma mudançca nos parâametros da simulacao, seja pequeno o tempo de espera para se obter o novo comportamento do riser. O segundo fator áe que a taxa com que os resultados da simulaçcãao sãao calculados deve ser adequada ao passo da animacçãao de 30 quadros por segundo.
O tempo de resposta apáos a mudancça de parâametros áe igual a soma das etapas de Anáalise Estaática, Anaálise de Vibracçãoes Livres e Montagem de Matrizes. No gráafico da Figura 4.9, fica evidente como a contribuicçãao da Anáalise Estáatica para o tempo total áe pouco significativa se comparada a de Vibraçcãoes Livres e a Montagem de Matrizes. O graáfico da Figura 4.10 mostra o tempo de espera a cada mudançca de paraâmetros, em funcçãao do nuámero de elementos. Considerando o limite de 1 segundo de resposta, o nuámero máaximo de elementos suportado áe de 150; para 2 segundos, o limite sobe para 200 elementos.
10	30	50	70 90 110 130 150 1 70 190 210 230 250 270 290
•Análise Estática
-♦-Análise de Vibrações Liwes
Montagem de Matrizes
■♦Análise Dnâmica
El em entos
Figura 4.9: Medidas de tempo de execuçõo do Solver, tomadas em quatro etapas distintas.
Figura 4.10: Tempo de espera a cada mudança de parêmetros, computado como a soma das três primeiras etapas. A Analise de Vibrações Livres e a Montagem de Matrizes sõo as que mais contribuem na medida
Elementos
Figura 4.11: Taxa de quadros máxima suportada em função do número de elementos, tomado como o inverso das medidas da Analise Dinamica.
A taxa com que os resultados sao produzidos, por sua vez, está relacionada ao tempo gasto numa execução da Analise Dinamica. A Figura 4.11 mostra a taxa suportada em função do numero de elementos, que á obtido pelo inverso dos tempos medidos da Análise Dinamica. Para manter uma taxa de 30 quadros por segundo, o numero máximo de elementos suportado é de 170.
O profiling pela ferramenta do Visual Studio aponta os pontos de gargalo no processamento. As funçães que consomem mais tempo de processamento segundo o profiler são duas, uma que realiza Decomposição de Gauss e outra que realiza inversão de matriz. A primeira á utilizada na Analise de Vibracães Livres enquanto a segunda á empregada na Montagem de Matrizes, condizendo com as medidas de tempo obtidas para estas etapas (Figura 4.9), que foram bem maiores do que das outras.
4.4	Avaliação da Usabilidade do Ambiente de Visualização e Simulação
A avaliação de usabilidade, descrita na Seção 3.2.6 do Capátulo 3, foi feita com nove usuários. Reconhece-se ser um numero pequeno para uma amostra, mas o fato de ser necessário que os voluntários tivessem experiência com risers foi um grande limitante para a seleção de pessoal para o teste. Outra limitacao foi o fato de apenas dois voluntários terem ja utilizado o VRP, de forma que os demais nãao puderam responder as questãoes 13 a 19. Mesmo assim, o resultado dos testes revelou algumas informaçcoães interessantes.
A Tabela 4.1 mostra o resultado das avaliaçães realizadas e o gráfico da Figura 4.12 mostra a máedia das notas para cada questãao.
Como existe espaçco para subjetividade na hora de atribuir as notas, pois algumas pessoas tendem a evitar notas mais extremas ou evitar dar notas baixas, a máedia simples poderia nãao
Perguntas /Voluntarios	1	2	3	4	5	6	7	8	9
Categoria Geral:									
1 - Para a finalidade de projeto de risers, o ambiente testado é:	5	3	5	3	3	5	-	5	3
2 - Para a finalidade de analise do comportamento de risers, o ambiente testado é:	5	4	5	3	3	5	-	5	4
3 - Para a finalidade de diagnostico de problemas em risers, o ambiente testado e:	4	2	5	3	2	4	-	4	3
4 - Para a finalidade de visualizar o comportamento global do riser, o ambiente testado e: (	5	4	5	3	4	4	3	4	4
5 - Para a finalidede de visualizar individualmente cada resultado da simulacão, o ambiente testado e:	5	2	5	3	4	4	3	4	4
6 - Quanto a facilidade de uso, o ambiente testado e:	4	5	4	4	5	5	4	5	4
7 - Quanto à aparência do ambiente testado, ela e:	5	5	4	4	4	5	4	5	4
Categoria Visualização:									
8 - Quanto à representacão da simulação na forma de um ambiente de realidade virtual, ela e:	4	4	5	4	5	5	3	4	3
9 - Quanto à qualidade da animaçao (fluidez), ela e:	4	4	5	4	5	5	-	5	4
Categoria Interativade:									
10 - Quanto à interatividade, ela e:	5	5	4	4	5	5	4	5	4
11 - Quanto ao tempo de resposta ao mudar parêametros, ele é: )	5	5	4	4	4	5	4	5	5
12 - Quanto à organização do painel de controle, ela e:	4	5	4	4	5	4	4	5	4
Categoria Comparação com o VRP:									
13 - Para a finalidade de projeto de risers, o ambiente testado e: [comparado ao VRP]	-	-	5	-	-	5	-	-	-
14 - Para a finalidade de analise do comportamento de risers, o ambiente testado e: [comparado ao VRP]	-	-	3	-	-	4	-	-	-
15 - Para a finalidade de diagnostico de problemas em risers, o ambiente testado e: [comparado ao VRP]	-	-	3	-	-	4	-	-	-
16 - Para a finalidade de visualizar o comportamento global do riser, o ambiente testado e: [comparado ao VRP]	-	-	3	-	-	5	-	-	-
17 - Para a finalidede de visualizar individualmente cada resultado da simulaçcãao, o ambiente testado e: [comparado ao VRP]			3			4			
18 - Quanto a facilidade de uso, o ambiente testado e: [comparado ao VRP]	-	-	5	-	-	5	-	-	-
19 - Quanto à aparência do ambiente testado, ela e: [comparado ao VRP]	-	-	5	-	-	5	-	-	-
Tabela 4.1: Notas dadas pelos voluntários para cada pergunta.
Figura 4.12: Nota média e desvio padrão de cada pergunta.
representar adequadamente os resultados. Assim, as notas dadas por cada voluntario foram divididas pela nota média dada por ele e então calculadas as médias das notas normalizadas para cada questao (Figura 4.13).
E fácil notar que não ha muita disparidade nos gráficos das Figuras 4.12 e 4.13 (quanto a proporçao entre as notas) e ambos apontam as mesmas conclusães. O ambiente desenvolvido aparenta ser mais apto para uso no projeto e, especialmente, na anáalise de risers do que para diagnástico de problemas. Um dos voluntarios apontou no campo Justificativa para este quesito (o da questao 3) que o ambiente 'nao leva em consideração criterios de falha e segurança do riser, sendo que o usuario deve inspecionar visualmente o resultado'. Para a finalidade de visualizar a simulaçcaão como um todo, a nota máedia foi maior do que para a visualizaçcaão de resultados individuais, porám a diferença foi pequena, contrariando o esperado (de que fosse claramente melhor para visualizaçao global da simulacão), conforme discutido na Subsecão 3.2.2 do Capítulo
3.	Alguns usuáarios destacaram que seria desejaável representar os resultados tambáem em graáficos 2D ou permitir que sejam salvos em arquivos para serem utilizados externamente. As notas de 6 a 12 mostram que o ambiente de fato apresenta os diferenciais de visualizacão intuitiva e interativa em tempo-real e áe de fáacil uso. Nestes quesitos os comentaários em geral consistiam de sugestãoes de novas funcionalidades, como exibir uma janela com dados de um elemento do riser ao clicar nele. Já as notas de 13 a 19, devido a baixa quantidade de amostras, impedem uma conclusãao mais sáolida, mas trazem ainda alguma informacçaão. Os resultado para estes toápicos apontam para a facilidade de uso do programa, mostrando-o como melhor que a do VRP, aláem de indicar que o programa tambáem áe melhor que o VRP para projeto de risers, sendo equivalente
Figura 4.13: Notas mídia e desvio padrão de cada pergunta após normalização. ao VRP nos demais aspectos.
Finalmente, tem-se que o ambiente teve notas mídias nas perguntas sempre acima de trâs (considerado aqui o mínimo aceitável), com a mídia destas notas sendo de 4,2 num máximo de 5, o que sugere, pelo menos baseado na opiniao dos voluntarios, a boa qualidade do ambiente desenvolvido.
4.5	Considerações Finais
Foram discutidos neste capítulo os resultados obtidos pela aplicação dos procedimentos descritos no Capítulo 3. Em primeiro lugar, foi apresentado o protótipo desenvolvido, descrevendo e explicando suas principais características e funcionalidades. Entao, foi fornecida uma visão geral do cíodigo do protoítipo, apresentando as principais classes e como elas se relacionam entre si. Finalmente, foram mostrados os resultados das avaliações de desempenho e de usabilidade. A avaliaçao de desempenho revelou que o Solver suporta interação em tempo-real com uma taxa de animação de 30 quadros por segundo para atí 170 elementos. A avaliaçao de usabilidade sugere que, segundo os usuíarios, o ambiente desenvolvido íe de fíacil uso, apresentando visuali-zaçao intuitiva e boa interatividade em tempo-real. Alím disso, foi revelado que o ambiente de visualizacao í mais adequado para projeto e anílise do comportamento de risers do que para diagníostico de problemas, e que íe apenas ligeiramente melhor para visualizar o comportamento global do riser do que para visualizar características específicas.
Capítulo ^7_
Conclusões
Neste trabalho, foi proposto e desenvolvido um ambiente virtual para simulaçõo e visuali-zaçcaõo de risers régidos verticais. O riser ée uma importante estrutura utilizada na perfuracçõao e exploraçõo de poços de petroleo offshore, sendo um duto que liga o poço a unidade de producao, e que ée responséavel, entre outras coisas, por guiar a broca de perfuraçcõao ou escoar o petroéleo e o gés extraédos do poco. Devido as condicões ambientais como ondas, correnteza e vortices induzidos sobre o duto, o riser sofre o efeito de cargas que diminuem sua vida útil. Simulaçõo por computador ée uma ferramenta importante, seja para prever posséveis problemas como para diagnosticar aqueles que jaé ocorrem. A visualizacçõao cientéfica ée tambéem de grande valia, pois permite representar o grande volume de dados numéericos produzidos por simulacçõoes em uma forma visual de mais faécil compreensõao. O ambiente apresentado suporta a visualizaçcõao de risers com o diferencial de permitir a interaçcõao em tempo-real com a simulaçcaõo. No sistema desenvolvido, o usuaério pode alterar dados de simulacçõao, tais como o perfil de correnteza ou a elasticidade do material do riser, e visualizar o novo comportamento imediatamente, sem precisar interromper a visualizaçcõao ou esperar toda a simulaçcõao ser recomputada. Nos outros sistemas de visualizaçcõao de riser identificados na literatura, ée preciso primeiro realizar toda a simulaçcõao para séo entõao visualizéa-la, o que compromete a fluidez da interaçcaõo, especialmente em casos onde o usuéario deseja explorar sequencialmente diferentes conjuntos de paraêmetros.
O sistema foi desenvolvido como dois méodulos que interagem compondo uma uénica apli-caçcõao: o Solver, méodulo responséavel pela simulaçcõao, e o méodulo de visualizaçcaõo. O Solver segue o modelo matemaético de Ferrari e Bearman para a simulaçcõao, que utiliza uma abordagem de Elementos Finitos, tendo sido aperfeiçcoado em trabalhos posteriores e culminado no software RiserProd. Como o RiserProd original nõo esté apto para uso com interaçao em tempo-real, foi necessério aprimoré-lo para tal uso. Os resultados do novo simulador foram validados comparando-os com os do RiserProd original, para alguns casos de estudo. A visualizaçcõao da simulacçõao ée feita atravées de uma representaçcõao virtual do riser em seu cenéario de operaçcõao. O tubo, o mar e a embarcaçcõao sõao representados com auxélio de téecnicas de computaçcaõo gréafica 3D, bem como correnteza, forças e pressões sobre o riser e outros dados da simulaçõo, que sõo visualizados por meio de setas ou cores no ambiente virtual. Parêametros da simulaçcõao e outros ajustes do programa podem ser alterados atravées de um painel de controle.
Aléem de desenvolver o ambiente de simulacçõao e visualizacçõao, foram realizadas tambéem ava
liações de desempenho e de usabilidade. A avaliação de desempenho teve como objetivo medir a capacidade do Solver suportar interatividade em tempo-real, bem como identificar os gargalos no processamento. A avaliacão de usabilidade por sua vez, visou identificar se o ambiente desenvolvido atende àquilo a que se propãe, isto í, de ser uma ferramenta útil ao engenheiro que trabalha com risers, apresentando os diferenciais de visualizaçcãao intuitiva e interatividade em tempo-real.
Apíos detalhar os míetodos utilizados para desenvolver o ambiente e avaliía-lo, foram mostrados e discutidos os resultados obtidos. Apíos apresentar o protoítipo implementado e explicar seu funcionamento, uma visãao geral do coídigo foi descrita, indicando as principais classes e míetodos e como elas se relacionam. Foram apresentados tambíem os resultados das avaliçcãoes realizadas. A avaliacçãao de desempenho revelou que o Solver em seu atual estado íe capaz de suportar uma interatividade em tempo-real para atí 170 elementos para uma taxa de 30 quadros por segundo para a animaçcãao. A avaliacçãao de desempenho indica tambíem que as etapas de maior custo saão aquelas associadas a inversãao de matrizes. A avaliaçcaão de usabilidade por sua vez sugere que o ambiente desenvolvido oferece uma representacçãao visual intuitiva do comportamento do riser e com interativadade em tempo-real satisfatíoria. Revelou tambíem que o ambiente íe mais adequado para o projeto e aníalise do comportamento de risers do que para diagníostico de problemas.
Assim, sãao contribuiçcãoes deste trabalho:
•	O desenvolvimento de um módulo de simulaçao numírica (Solver) apto ao uso interativo em tempo-real, a partir de uma adaptaçcãao do simulador RiserProd, que nãao íe capaz de ser utilizado para tal tipo de interaçcãao.
•	O desenvolvimento de um míodulo de visualizacçãao, responsíavel por representar visualmente os dados do míodulo de simulaçcaão e de gerenciar a interacçãao com o usuíario, atravíes de uma interface que permite ajuste dos parâmetros da simulação.
•	A integracçãao dos referidos míodulos em um uínico ambiente de simulaçcaão e visualizaçcãao de risers.
•	Uma avaliaçcaão do desempenho do ambiente, revelando quais os limitantes para o uso interativo em tempo-real do ambiente desenvolvido.
•	Uma avaliaçcãao da usabilidade do ambiente.
5.1 Limitações
Este trabalho possui, naturalmente, algumas limitacães, que não puderam ser superadas por questãoes de escopo do projeto ou pelo tempo e volume de trabalho adicionais que demandariam.
Uma das limitaçcoães deste trabalho íe o nuímero míaximo de elementos do modelo de simulacçãao em que íe possivel obter uma visualizaçcaão interativa em tempo-real. A avaliaçcaão de desempenho mostrou que o limite maximo í de 170, acima do qual a fluidâz da interação passa a ser comprometida. A princípio, seria desejavel alcançar um numero da ordem de 1000 elementos, o
que proporcionaria uma simulacçãao precisãao adequada. Para alcançcar este nuámero, saão necessáa-rias otimizacães no Solver, especialmente nos gargalos que limitam melhores performances. A avaliaçcaão revelou que estes estãao ligados a etapas que realizam inversãao de matrizes.
Algumas deficiâencias tambáem foram reveladas pela avaliaçcaão de usabilidade. O ambiente desenvolvido foi apontado como nãao taão adequado para diagnáostico de problemas pois nãao apresenta recursos para aplicar os critáerios de falha e segurançca de risers. Alguns usuáarios apontaram limitaçcãoes no modelo de simulaçcaão, como a impossibilidade de especificar um nuámero de elementos maior para certas regiãoes do riser, refinando a precisãao em áareas cráticas. Modificaçcãoes no modelo da simulaçcãao, poráem, foram consideradas fora do escopo deste trabalho.
Por fim, pode-se citar tambám o baixo numero de voluntarios utilizado na avaliacão de usabilidade, fator que torna as anáalises derivadas dos resultados menos categáoricas.
5.2	Trabalhos Futuros
O projeto realizado e as limitaçcoães apresentadas sugerem possáveis continuaçcoães para este trabalho. Uma das possibilidades á realizar uma validaçao mais formal e detalhada dos resultados produzidos pelo Solver desenvolvido. Outro possibilidade consiste em otimizar o Solver de forma a permitir interacçãao em tempo-real com um nuámero maior de elementos. Um nuámero que conferiria precisaão adequada seria da ordem de 1000 elementos. Pelas informaçcãoes reveladas pelo profiling do Solver, o atual gargalo no processamente sao a decomposicão de Cholesky e a de Gauss, ambas ligadas a inversão de matrizes, operação tradicionalmente custosa em termos computacionais. Uma abordagem possível para otimizar estas operaçães seria explorar o paralelismo em GPU ou multicore, pois diversos cáalculos semelhantes saão realizados para cada elemento do riser, o que sugere uma soluçcaão paralela.
Ainda quanto ao Solver, alguns voluntaários no teste de usabilidade citaram limitaçcoães do modelo de simulacçãao, como a impossibilidade de especificar diferentes nuámeros de elementos para certas regiães especificas do riser (em geral, maior resolucão nas extremidades, onde os esforços são cráticos). Outra possibilidade á, ao invás de trabalhar para aprimorar o modelo atual, permitir que o máodulo de visualizacçãao interaja com diferentes Solvers. Para isso, aláem de implementar o mádulo de visualizacão de forma a ser mais flexável, qualquer novo Solver deve atender aos requisitos que possibilitem uso em tempo-real, conforme mostrados neste trabalho.
Tambáem para o moádulo de visualizaçcaão, áe possável aprimoráa-lo acrescentando novos recursos. Alguns foram jáa sugeridos pelos voluntáarios do teste de usabilidade, como funcionalidades que apliquem os critáerios de segurancça de risers, ou que mostrem numa janela popup os dados de um elemento clicado. Outra possibilidade áe oferecer mais opçcãoes para controle e representacçãao de escalas no ambiente, tanto na dimensaão espacial como temporal. Atualmente, a escalas dos deslocamentos e forçcas do riser podem ser alteradas, mas as dimensoães relativas entre o riser e a embarcacçãao, por exemplo, naão refletem a da realidade. Embora isso ocorra para facilitar a visualizaçcãao, oferecer opçcãoes para controlar tambáem as escalas destes e outros elementos da visualizaçcãao aparenta ser um recursos desejáavel.
Por fim, áe possável refinar a avaliaçcãao de usabilidade, incluindo novos voluntáarios no teste ou mesmo incluindo novas perguntas que por ventura sejam consideradas pertinentes, como
perguntas que avaliem a imersãao e realismo do ambiente.
Bibliografia
Agência Nacional do Petróleo, G. N. e. B. (2012). Anuário estatístico brasileiro do petróleo, gás natural e biocombustíveis - 2012.
Al-Jamal, H. &amp;amp; Dalton, C. (2004). Vortex induced vibrations using large eddy simulation at a moderate reynolds number, Journal of Fluids and Structures 79: 73-92.
Alexander, C. R. (2003). Development of a Composite Repair System for Reinforcing Offshore Risers, PhD thesis, Texas A&amp;amp;M University.
Bathe, K. (1996). Finite Element Procedures, Prentice-Hall Inc.
Bernardes, J. L. (2004). Desenvolvimento de um ambiente para visualização tridimensional da dinâmica de risers, Master’s thesis, Escola Politócnica da Universidade de São Paulo.
Chai, Y. &amp;amp; Varyani, K. (2002). Three-dimensional lump-mass formulation of a catenary riser with bending, torsion and irregular seabed interaction effect, Ocean Engineering 29: 15031525.
Chakrabarti, S. K. (1987). Hydrodynamic of Offshore Structures, Computational Mechanics Publications, Springer Verlag.
Chaplin, J., Bearman, P., Cheng, Y., Fontaine, E., Graham, J., Herfjord, K., Huarte, F. H., Isherwood, M., Lambrakos, K., Larsen, C., Meneghini, J., Moe, G., Pattenden, R., Tri-antafyllou, M. &amp;amp; Willden, R. (2005). Blind predictions of laboratory measurements of vortex-induced vibrations of a tension riser, Journal of Fluids and Structures 21: 25-40.
Chen, K. H. C. &amp;amp; Chen, C. R. (2010). Vertical riser viv simulation in uniform current, Journal of Offshore Mechanics and Arctic Engineering 132: 337-341.
DutoRisk Manual de Usuário (Interface e Solver) (2009). Manual Impresso, Laboratórito de Sistemas Marítimos de Produção e Risers.
Engel, K., Hadwiger, M., Kniss, J. M., Rezk-Salama, C. &amp;amp; Weiskopf, D. (2006). Real-Time Volume Graphics, A K Peters/CRC Press.
Ferrari, J. A. &amp;amp; Bearman, P. (1999a). Hydrodynamic loading and response of offshore risers, Proceedings of the 18th International Conference on Offhosre Mechanics and Arctic Engineering.
Flatschart, R. B., Meneghini, J. R. &amp;amp; Jr., J. A. F. (2004). Parallel simulation of a marine riser using mpi, Proceedings of OMAE04.
Holmes, S., Jr., O. H. O. &amp;amp; Constantinides, Y. (2006). Simulation of riser viv using fully three dimensional cfd simulations, Proceedings of OMAE2006.
Kubota, H. Y. (2003). Comportamento dinâmico de um riser rígido de produção, Master’s thesis, Unicamp. Biblioteca Digital da Unicamp.
Morooka, C. K., Brandt, D. M., Matt, C. G. C. &amp;amp; Franciss, R. (2008). Features of a time domain simulation tool for rigid riser design, Anais da Rio Oil &amp;amp; Gas Expo and Conference 2008.
Morooka, C. K., Coelho, F. M., Kubota, H. Y., Ferrari, J. A. &amp;amp; Ribeiro, E. J. B. (2004). Investigations on the behavior of vertical production risers, Proceedings of OMAE2004.
Morooka, C. K., Coelho, F. M., Ribeiro, E. J. B., Ferrari, J. A. &amp;amp; Franciss, R. (2005). Dynamic behavior of a vertical riser and service life reductu, Proceedings of OMAE2005.
Morooka, C. K. &amp;amp; Tsukada, R. I. (2011). Dynamic behavior of pipelines and risers due to vortex-induced vibration in time domain, Marine Systems &amp;amp; Ocean Technology 6: 17-26.
Newmark, N. M. (1959). A method of computation for structural dynamics, Journal of Engineering Mechanics ASCE 85, EM3 pp. 67-94.
Orcina (2013a). Orcaflex manual, http://www.orcina.com/SoftwareProducts/OrcaFlex/ Documentation/OrcaFlex.pdf. Acessado em Junho de 2013.
Orcina (2013b). Orcaflex website, http://www.orcina.com/SoftwareProducts/OrcaFlex/. Acessado em Junho de 2013.
Petrobras, T.-R. (2005). Anflex multilinhas - manual do usuário, versão 6.4.1 r5.5.
Santos, I. H. F., Soares, L. P., Carvalho, F. &amp;amp; Raposo, A. (2011). A collaborative vr visualization environment for offshore engineering projects, Proceedings of the 10th International Conference on Virtual Reality Continuum and Its Applications in Industry.
Schroeder, W., Martin, K. &amp;amp; Lorensen, B. (2006). The Visualization Toolkit, Kitware.
Simantiras, P. &amp;amp; Willis, N. (2001). Steel catenary risers - allegheny offshore viv monitoring campagin and large scale simulation of seabed interaction, Deep Offshore Technology International.
Telea, A. C. (2008). Data Visualization, A K Peters, Ltd.
Zhu, H. J., Ou, Z. P., Lin, Y. H. &amp;amp; Hu, F. F. (2011). Large eddy simulations of unsteady wakes behind riser in offshore deep water, Advanced Materials Research 268 - 2 70 : 787-792.
Zhu, H., Lin, Y., Jia, Q. &amp;amp; Yang, X. (2010). Simulations of suppressive effect of viv on marine riser with splitter plates, ICCSIT, pp. 337-341.
Zienkiewicz, O. C. (1971). The Finite Element Method in Engineering Science, McGraw-Hill Publishing Company Limited.
Apêndice 1. X___________________________________
Questionário para Avaliaçãode Usabilidade
Segue abaixo o questionório elaborado para a avaliacao de usabilidade do sistema desenvolvido neste trabalho, conforme exposto na Seção 3.2.6 do Capótulo 3. Os resultados do teste são apresentados e discutidos na Seçao 4.4 do Capótulo 4.
1	- Introdução
O presente documento é um questionário para avaliação do ambiente de simulação e visualização de riser desenvolvido como parte do projeto de mestrado de Rafael Guimarães Ramos e orientado pelo Professor José Mario De Martino, da Faculdade de Engenharia Elétrica e de Computação da Unicamp.
O ambiente desenvolvido tem a finalidade de auxiliar o engenheiro de petróleo no estudo de riser, bem como no projeto e no diagnóstico de problemas deste equipamento. Através do programa, o usuário pode realizar uma simulação do comportamento do riser e visualizar os dados de simulação num ambiente virtual em gráficos 3D. Os parâmetros de simulação podem ser ajustados durante a visualização e o novo comportamento do riser é reproduzido imediatamente.
2	- Instruções de Uso do Ambiente
2.1 Iniciando a simulação
Para iniciar uma simulação, após iniciar o programa, o usuário deve primeiro criar um modelo do riser, clicando em New -&gt; Model -&gt; e escolhendo o modelo (Figura 1). O modelo determina se o riser é preso no topo (Collector) , no fundo (Tower) ou em ambos (TTR). Em seguida, é necessário escolher o número de elementos do modelo (Figura 2). Quanto maior o número de elementos maior a precisão nos resultados, porém a execução pode ficar lenta dependendo do hardware. Nas máquinas testadas, o ambiente manteve bom desempenho até 180 elementos.
Figura 1, criando novo modelo (esquerda), e Figura 2(direita), escolhendo número de elementos
Criado um modelo, a janela obtida deve ser semelhante a da Figura 3. Um conjunto padrão de parâmetros é utilizado para a simulação, que pode ser iniciada clicando no botão Play no painel e pausada pelo mesmo botão. Por fim, para melhor visualizar, ajuste as opções de visualização na aba Display. Como os deslocamentos do riser são muito pequenos em comparação seu comprimento, é necessário ajustar a escala destas grandezas. Clicando-se no botão Auto Scale dentro da aba Display, a escala é ajustada automaticamente para melhor visualizar o deslocamento do riser. Alternativamente, estas escalas podem ser ajustadas manualmente nesta aba. Ainda na aba Display, é possível escolher qual dentre certos atributos da simulação é visualizado por cores.
New
S x
i5 x
Display Results
Parameters
Riser
Tube
Riser Ends
Bottom:
Top Tension
500,00
Platform
Ocean
Flags
Apply
Internal Flow | Floaters | Dampinr
1
Figura 3 - janela do ambiente, com ambiente de visualização à esquerda e o painel à direita. Os botões Apply e Play podem ser visto na parte inferior do painel.
A qualquer momento, com a simulação rodando ou pausada, é possível alterar os parâmetros da simulação. Isto é feito na aba Parameters. Os diferentes parâmetros encontram-se agrupados em grupos e subgrupos dentro desta aba. Mais de um parâmetro pode ser alterada de uma única vez, mas é necessário clicar no botão Apply para submeter os novos valores.
2.2 Visualização da Simulação
A visualização da simulação contém diversos elementos representando os diversos aspectos da simulação. Primeiramente, temos o riser, representado como um tubo no centro da cena, a embarcação, o fundo e a superfície do mar e os flutuadores sobre o riser. Há também diversos elementos visuais que representam grandezas físicas da simulação. Além do tubo (que representa o riser) se movimentar, sobre ele são colocadas setas que representam a força de excitação e cores para representar diferentes grandezas (conforme escolhido na aba Display). Uma unica seta apontada para cima é utilizada para exibir a tensão de topo e curvas na cor verde são traçadas para indicar o máximo deslocamento do riser. Por fim, setas dispostas um pouco afastadas do riser são utilizadas para representar a correnteza. A Figura 4 ilustra estes elementos.
Figura 4 - Visualização da simulação
Sendo uma visualização 3D, é possível interagir com a cena clicando e arrastando o mouse. Clicando e arrastando com o botão esquerdo, é feita a rotação da cena; com o do meio, a translação, e com o da direita, escala (a escala também pode ser feita rolando o botão do meio).
Os valores numéricos das forças, deslocamentos e velocidades de cada elemento são exibidos na aba Results. Ao clicar sobre algum destes valores na tabela, uma esfera vermelha é colocada sobre o riser na posição do elemento correspondente. Inversamente, ao colocar o mouse sobre uma parte do riser e pressionar o botão 'p' do teclado, o elemento na posição indicada é selecionado e realçado na tabela.
3	- Instruções para o Questionário
Tendo lido as instruções, você terá até 10 minutos para explorar livremente o programa e se familiarizar com seu uso. Crie uma simulação, inicie a animação, altere parâmetros, interaja com a visualização, conforme a instruções da seção 2; repita quantas vezes quiser. Em caso de dúvida, pergunte ao supervisor presente.
Após a familiarização, avise o supervisor e então responda o questionário presente na seção 4. No questionário são feitas perguntas quanto a utilidade do programa como ferramenta para auxiliar o engenheiro de petróleo tanto no estudo do comportamento de um riser, quanto para o projeto de risers ou diagnóstico de problemas. São feitas também perguntas quanto a qualidade da visualização e da interatividade do programa. Por fim, há perguntas comparando o ambiente aqui apresentado com o VRP, um outro ambiente para visualização de risers desenvolvido na Unicamp. Caso nunca tenha utilizado o programa ou não lembre do seu funcionamento, não é necessário responder esta parte do questionário.
As questões são todas objetivas, e você deverá marcar a opção que mais se adequar a sua percepção. No quadro Justificativa, pede-se que, se possível, escreva sucintamente uma justificativa quanto à opção marcada. Durante o questionário, você pode utilizar o ambiente sempre que achar necessário, para confirmar suas impressões antes de marcar a resposta.
4	- Questionário. Responda dando notas de 1 a 5 e explique sucintamente o porquê no quadro Justificativa
Categoria Geral
1) Para a finalidade de projeto de risers, o ambiente testado é :
(1)	nada útil
(2)	pouco útil
(3)	útil
(4)	muito útil
(5)	extremamente útil
Justificativa:
2)	Para a finalidade de análise do comportamento de risers, o ambiente testado é :
(1)	nada útil
(2)	pouco útil
(3)	útil
(4)	muito útil
(5)	extremamente útil
Justificativa:
3)	Para a finalidade de diagnóstico de problemas em risers, o ambiente testado é :
(1)	nada útil
(2)	pouco útil
(3)	útil
(4)	muito útil
(5)	extremamente útil
Justificativa:
(1)	nada adequado
(2)	pouco adequado
(3)	adequado
(4)	muito adequado
(5)	extremamente adequado
Justificativa:
5)	Para a finalidade de visualizar individualmente cada resultado da simulação, o ambiente testado é:
(1)	nada adequado
(2)	pouco adequado
(3)	adequado
(4)	muito adequado
(5)	extremamente adequado
Justificativa:
6)	Quanto à facilidade de uso, o ambiente testado é:
(1)	muito difícil
(2)	difícil
(3)	médio
(4)	fácil
(5)	muito fácil
Justificativa:
7)	Quanto à aparência do ambiente testado, ela é:
(1)	muito ruim
(2)	ruim
(3)	média
(4)	boa
(5)	muito boa
Justificativa:
Categoria Visualização
8)	Quanto a representação da simulação na forma de um ambiente de realidade virtual, ela é:
(1)	nada intuitiva
(2)	pouco intuitiva
(3)	intuitiva
(4)	muito intuitiva
(5)	extremamente intuitiva
Justificativa:
9)	Quanto à qualidade da animação (fluidez), ela é:
(1)	muito ruim
(2)	ruim
(3)	média
(4)	boa
(5)	muito boa
Categoria Interatividade
10)	Quanto à interatividade, ela é:
(1)	muito limitada
(2)	limitada
(3)	média
(4)	boa
(5)	muito boa
Justificativa:
11)	Quanto ao tempo de resposta ao mudar parâmetros, ele é:
(1)	muito inadequado
(2)	inadequado
(3)	médio
(4)	adequado
(5)	muito adequado
Justificativa:
12)	Quanto à organização do painel de controle, ela é:
(1)	muito confusa
(2)	confusa
(3)	média
(4)	intuitiva
(5)	muito intuitiva
Categoria Comparação com o VRP (não responder caso nunca tenha utilizado o VRP)
13)	Para a finalidade de projeto de risers, o ambiente testado é :
(1)	muito pior que o VRP
(2)	pior que o VRP
(3)	tão bom quanto o VRP
(4)	melhor que o VRP
(5)	muito melhor que o VRP
Justificativa:
14)	Para a finalidade de análise do comportamento de risers, o ambiente testado é :
(1)	muito pior que o VRP
(2)	pior que o VRP
(3)	tão bom quanto o VRP
(4)	melhor que o VRP
(5)	muito melhor que o VRP
Justificativa:
15)	Para a finalidade de diagnóstico de problemas em risers, o ambiente testado é:
(1)	muito pior que o VRP
(2)	pior que o VRP
(3)	tão bom quanto o VRP
(4)	melhor que o VRP
(5)	muito melhor que o VRP
16)	Para a finalidade de visualizar o comportamento global do riser, o ambiente testado é:
(1)	muito pior que o VRP
(2)	pior que o VRP
(3)	tão bom quanto o VRP
(4)	melhor que o VRP
(5)	muito melhor que o VRP
Justificativa:
17)	Para a finalidade de visualizar individualmente cada resultado da simulação, o ambiente testado é:
(1)	muito pior que o VRP
(2)	pior que o VRP
(3)	tão bom quanto o VRP
(4)	melhor que o VRP
(5)	muito melhor que o VRP
Justificativa:
18)	Quanto à facilidade de uso, o ambiente testado é:
(1)	muito pior que o VRP
(2)	pior que o VRP
(3)	tão bom quanto o VRP
(4)	melhor que o VRP
(5)	muito melhor que o VRP
19)	Quanto à aparência do ambiente testado, ela é:
(1)	muito pior que o VRP
(2)	pior que o VRP
(3)	tão bom quanto o VRP
(4)	melhor que o VRP
(5)	muito melhor que o VRP
Justificativa:
Apêndice J—J_______________________
Documentaçãodo Código do Sistema Desenvolvido
Segue abaixo a documentaçcaõo do coédigo do sistema desenvolvido neste trabalho. O coédigo foi desenvolvido de modo a atender a metodologia apresentada no Capétulo 3 e uma visaõo geral do cédigo é apresentada na Seçao 4.2 do Capitulo 4. Na documentaçõo a seguir, maiores detalhes saõo fornecidos.
Documentação do Código do Ambiente de Visualização e Simulação de Risers
Esta é a documentação do código do Ambiente de Visualização e Simulação de Risers desenvolvido como parte do mestrado de Rafael Guimarães Ramos e orientado pelo professor José Mario De Martino, da Faculdade de Engenharia Elétrica e de Computação (FEEC) da Unicamp. A documentação descreve as classes do código e seus métodos, explicando o propósito de cada uma e como se relacionam entre si. Primeiramente, apresentamos as classes do Solver e, em segundo lugar, as classes do Módulo de Visualização.
Documentação do Solver
TowerModel		CollectorModel			TTRModel
1					1
					
3
Model		Solver
fstaticAnalysis[engine¡StaticAnalysis*) +freeVibrationAnalysis(engine:FreeVibrationAnalysis* +dynamicAnalysis(engine:DynamicAnalysis*)		O )	fstaticAnalysis{) +freeVibrationAnalysis() fdynamicAnalysis()
	
Figura 1 - Diagrama de classe do Solver.
A descrição das classes do Solver está dividida em grupos de acordo com o papel que cada uma cumpre na simulação. Na Figura 1 são mostradas as principais classes do Solver, como se relacionam e os grupos a que pertencem. As classes do grupo Analysis são aquelas responsáveis por executar a simulação propriamente dita, recebendo um objeto do tipo Riser como parâmetro, realizando os cálculos de acordo com estes valores e armazenando no mesmo objeto os resultados obtidos. As classes do grupo Riser, que inclui a classe Riser mencionada acima, são as classes que funcionam como contêiner de dados. O grupo Matrix consiste das classes que implementam as diversas matrizes utilizadas nos cálculos da simulação (matriz de rigidez, massa, etc) e o grupo Force, similarmente, os vetores de força aplicados sobre o riser. Por fim, o grupo Outros contém as demais classes, como a classe Solver, que é a classe principal deste módulo e encapsula as demais.
Marcações: Algumas classes e métodos encontram-se marcados na documentação com um dos seguintes sinais.
(R) Embora corretamente implementado, é possível que exista uma forma melhor de organizar a implementação do método/classe, entretanto isto não foi explorado.
Grupo Analysis
As classes do grupo Analysis implementam as três análises que constituem a simulação: análise estática (classe StaticAnalysis), de vibrações livres (FreeVibrationAnalysis) e dinâmica (DynamicAnalysis). A forma de uso delas é semelhante. Basta instanciar um objeto da classe e invocar o método run dela, passando o ponteiro para um objeto de uma subclasse de Riser. A análise é feita de acordo com os parâmetros armazenados neste objeto e os resultados são nele escritos.
==StaticAnalysis==
Classe que implementa a análise estática. A forma de uso consiste em instanciar um objeto da classe e invocar o método run, passando o ponteiro de um objeto de alguma subclasse de Riser (TTR, Collector ou Tower). Os parâmetros da análise são tomados a partir deste argumento, e nele são escritos os resultados da análise.
A análise estática considera o riser como uma estrutura em equilíbrio estático representável na forma K*X = F e visa calcular a posição dos elementos do riser (vetor X) para o conjunto de cargas imposta sobre a estrutura (vetor F). O método utilizado é o método de Galerkin, que iterativamente estima a matriz de rigidez (o K da equação), que em parte depende da posição dos elementos, para estimar um vetor X, o que leva a uma nova estima de K, e assim em diante.
StaticAnalysis();
Construtor da classe. Não faz nada de adicional.
void run(TTR*);
Método que executa a análise estática completa, inline e transversal, para TTR. Chama o template do método inlineAnalysis e transAnalysis para o tipo TTR*.
void run(Tower*);
Método que executa a análise estática completa, inline e transversal, para Tower. Chama o template do método inlineAnalysis e transAnalysis para o tipo Tower*.
void run(Collector*);
Método que executa a análise estática completa, inline e transversal, para Collector. Chama o template do método inlineAnalysis e transAnalysis para o tipo Collector*.
void run(Pipeline*);
(P) Método que executa a análise estática completa, inline e transversal, para Pipeline. Chama o template do método inlineAnalysis e transAnalysis para o tipo Pipeline*.
Template que executa a análise estática no plano inline. Chama initInline para inicializar a análise, iterativeInlineAlgol para o algoritmo principal e finalInline para finalizar. É utilizado um template pois, embora a análise seja semelhante para todas as configurações, a matriz de rigidez criada varia conforme a configuração de riser.
template&amp;lt;class SpecificRiserType&gt; void transAnalysis(SpecificRiserType*);
Template que executa a análise estática no plano transversal. Chama initTrans para inicializar a análise, iterativeTransAlgol para o algoritmo principal e finalTrans para finalizar. É utilizado um template pois, embora a análise seja semelhante para todas as configurações, a matriz de rigidez criada varia conforme a configuração de riser.
template&amp;lt;class SpecificRiserType&gt; void initInline(SpecificRiserType*);
Template que aloca as estruturas usadas na análise estática inline. É utilizado um template pois, embora a inicialização seja semelhante para todas as configurações, a matriz de rigidez criada varia conforme a configuração de riser.
void finalInline();
Desaloca as estruturas criadas na análise estática inline.
template&amp;lt;class SpecificRiserType&gt; void iterativeInlineAlgol(SpecificRiserType*);
Realiza o algoritmo do método de Galerkin para o plano inline. É utilizado um template pois, embora o método seja semelhante para todas as configurações, a matriz de rigidez criada varia conforme a configuração de riser.
template&amp;lt;class SpecificRiserType&gt; void initTrans(SpecificRiserType*);
Template que aloca as estruturas usadas na análise estática transversal. É utilizado um template pois, embora a inicialização seja semelhante para todas as configurações, a matriz de rigidez criada varia conforme a configuração de riser.
void finalTrans();
Desaloca as estruturas criadas na análise estática transversal.
template&amp;lt;class SpecificRiserType&gt; void iterativeTransAlgol(SpecificRiserType*);
Realiza o algoritmo do método de Galerkin para o plano transversal. É utilizado um template pois, embora o método seja semelhante para todas as configurações, a matriz de rigidez criada varia conforme a configuração de riser.
void tension_sr(Riser*);
Calcula a tensão ao longo do riser. Aceita a ponteiro para classe Riser, mas é efetivamente utilizado apenas pelas subclasses Tower e TTR.
void tension_sr(Collector*);
void tension_sr(Pipeline*);
(P) Calcula a tensão ao longo do riser, específico para configuração Pipeline.
void desbf_stat();
Função auxiliar chamada pelos métodos iterativeInlineAlgol e iterativeTransAlgol,
==FreeVibrationAnalysis==
Classe que implementa a análise de vibrações livres. A forma de uso consiste em instanciar um objeto da classe e invocar o método run, passando o ponteiro de um objeto de alguma subclasse de Riser (TTR, Collector ou Tower). Os parâmetros da análise são tomados a partir deste argumento, e nele são escritos os resultados da análise.
A análise de vibrações livres considera o riser como uma estrutura em movimento oscilatório não amortecido sem cargas aplicadas sobre a estrutura, representável na forma K*X + M*X" = 0. Tal equação leva a outra, (MA-1*K-wA2*I)*Y = 0, onde X = Y*eAiwt e w = (w1,w2,...,wn), as frequências naturais do sistema. A equação é solucionada encontrando os autovalores do sistema, wA2.
FreeVibrationAnalysis();
Construtor da classe. Não faz nada de adicional.
void run(TTR*);
Método que executa a análise de vibrações livres completa, inline e transversal, para TTR. Chama o template do método inlineAnalysis e transAnalysis para o tipo TTR*.
void run(Tower*);
Método que executa a análise de vibrações livres completa, inline e transversal, para Tower. Chama o template do método inlineAnalysis e transAnalysis para o tipo Tower*.
void run(Collector*);
Método que executa a análise de vibrações livres completa, inline e transversal, para Collector. Chama o template do método inlineAnalysis e transAnalysis para o tipo Collector*.
void run(Pipeline*);
(P) Método que executa a análise de vibrações livres completa, inline e transversal, para Pipeline. Chama o template do método inlineAnalysis e transAnalysis para o tipo Pipeline*.
Realiza a análise de vibrações livres no plano inline. Após alocar as matrizes de massa e rigidez, elimina um grau de liberdade das matrizes originais(reduce), completa com os elementos simétricos (simetry), realiza a decomposição de cholesky (choleskyInline) gerando a matriz para a qual são calculados os autovalores (eigen). Por fim, desaloca as estruturas.
template&amp;lt;class SpecificRiserType&gt; void transAnalysis(SpecificRiserType*);
Realiza a análise de vibrações livres no plano transversal. Após alocar as matrizes de massa e rigidez, elimina um grau de liberdade das matrizes originais(reduce), completa com os elementos simétricos (simetry), realiza a decomposição de cholesky (choleskyInline) gerando a matriz para a qual são calculados os autovalores (eigen). Por fim, desaloca as estruturas.
void elem(TTR*,int*);
Função que auxilia na redução dos graus de liberdade.
void elem(Tower*,int*);
Função que auxilia na redução dos graus de liberdade.
void elem(Collector*,int*);
Função que auxilia na redução dos graus de liberdade.
void elem(Pipeline*,int*);
(P) Função que auxilia na redução dos graus de liberdade.
template&amp;lt;class SpecificRiserType&gt; void reduce(SpecificRiserType*);
Reduz os graus de liberdade das matrizes de massa e rigidez, eliminando rotação e mantendo apenas translação inline e transversal.
void simetry(Riser*);
Gera a versão simétrica das matrizes reduzidas.
void choleskyInline(Riser*);
Usando a decomposição de Cholesky para inversão de matrizes, o método calcula a matriz A = MA-1*K (M e K com dimensões reduzidas e M simétrico) da qual serão calculados os autovalores. O método de Cholesky é usado pois gera uma matriz L tal que M = L*Lc (Lc sendo a transposta conjugada de L) que, por ser triangular, é mais fácil de ser invertida.
void eigen(Riser*);
Calcula os autovalores da matriz A = (MA-1)*K. Usa funções da biblioteca CLAPACK para isso.
==DynamicAnalysis==
A análise dinâmica considera o riser como uma estrutura em movimento oscilatório amortecido com cargas aplicadas sobre a estrutura, representável na forma K*X + D*X' + M*X" = F. A matriz de amortecimento D é calculada a partir das matrizes M e K e das frequências naturais, enquanto o F é em parte constante e em parte variável no tempo. A posição X do riser é calculada nesta análise para cada instante de tempo, através do método de Newmark-Beta.
DynamicAnalysis();
Construtor da classe. Inicializa alguns atributos do objeto.
void run(TTR*);
Método que executa a análise dinâmica completa, inline e transversal, para TTR. Chama o template do método inlineAnalysis e transAnalysis para o tipo TTR*.
void run(Tower*);
Método que executa a análise dinâmica completa, inline e transversal, para Tower. Chama o template do método inlineAnalysis e transAnalysis para o tipo Tower*.
void run(Collector*);
Método que executa a análise dinâmica completa, inline e transversal, para Collector. Chama o template do método inlineAnalysis e transAnalysis para o tipo Collector*.
void run(Pipeline*);
(P) Método que executa a análise dinâmica completa, inline e transversal, para Pipeline. Chama o template do método inlineAnalysis e transAnalysis para o tipo Pipeline*.
void reset(Riser*);
Reinicia a análise dinâmica, colocando o riser na sua posição inicial.
void deleteMatrixes();
Desaloca matrizes utilizadas na análise dinâmica.
Real time();
Retorna o instante da simulação (não o tempo real que a simulação durou até o momento, mas o tempo no modelo de simulação).
Cria as matrizes utilizadas na análise dinâmica. É utilizado um template pois embora este método em si não varie conforme a configuração de riser, as matrizes criadas pedem um tipo específico de riser.
template&amp;lt;class SpecificRiserType&gt; void iterativeAlgol(SpecificRiserType*);
Executa o algoritmo principal da análise dinâmica. É utilizado um template pois embora este método em si não varie conforme a configuração de riser, as matrizes utilizadas pedem um tipo específico de riser. Chama inlineTimeAnalysis e transTimeAnalysis, que executam a análise para cada plano, inline e transversal.
void initInlineTimeAnalysis(Riser*);
Inicializa a análise dinâmica no plano inline, gerando as forças nesta direção.
void initTransTimeAnalysis(Riser*);
Inicializa a análise dinâmica no plano transversal, gerando as forças nesta direção.
template&amp;lt;class SpecificRiserType&gt; void inlineTimeAnalysis(SpecificRiserType*);
Realiza a análise dinâmica no plano inline.
template&amp;lt;class SpecificRiserType&gt; void transTimeAnalysis(SpecificRiserType*); Realiza a análise dinâmica no plano transversal.
void storePreviousValues(Riser*);
Armazena os valores de deslocamento, velocidade e força atuais para poderem ser utilizados no próximo time step da análise dinâmica como "valores anteriores".
void inLoad(Riser*,Real*,bool);
Calcula as cargas sobre o riser no plano inline.
Utiliza o generate de InlineForce.
void trLoad(Riser*,Real*,bool);
Calcula as cargas sobre o riser
no plano transversal.
Utiliza o generate de TransForce.
Grupo Riser
As classes do grupo Riser implementam as classes que armazenam os parâmetros e resultados da simulação. A classe Riser é a classe principal deste grupo, contendo em si os diversos dados do riser como diâmetro interno e externo, resistência do material (estes, parâmetros da simulação), bem como deslocamento, velocidade e força sobre os elementos do riser (resultados da simulação). Certos atributos de Riser são representados pelas outras classes do grupo, como Environment (para os dados correspondentes ao ambiente) e Platform (para dados da plataforma). A classe Riser possui quatro subclasses, TTR, Tower, Collector e Pipeline (cuja implementação foi descontinuada por estar fora do escopo do trabalho). Embora
==Riser==
A classe Riser é o principal contêiner de dados do Solver, contendo os parâmetros e resultados da simulação. Suas subclasses TTR, Collector e Tower (e Pipeline, cuja implementação foi descontinuada por estar fora do escopo do trabalho) definem os tipos específicos de riser tratados na simulação. Objetos dessas classes são passados (por ponteiro) como argumento dos métodos run das classes StaticAnalysis, FreeVibrationAnalysis e DynamicAnalysis.
Dentre os dados contidos na classe temos informações do riser, como os diâmetros interno e externo (inDiam e exDiam), a densidade do material (matDensity) e diversos outros. Contém também objetos que representam dados do ambiente (Environment), da plataforma (Platform), do fluído interno (InternalFlow) e dos flutuadores ao longo do riser (Floaters).
Muitos dos dados, em geral os vetores com um item para cada elemento do riser, tem seus valores gerados a partir de outros dados contidos em Riser. É o caso, por exemplo, dos coeficiente de arrasto (CD) e massa adicional (CA), que são dados inicialmente para alguns pontos e interpolados para cada elemento. O método enrichParameters é responsável por esta etapa, de inicializar atributos de Riser a partir do valor de outros atributos do mesmo objeto (processo referido como “enriquecimento” dos dados).
Riser(int,int);
Construtor da classe. Aloca os vetores utilizados.
~Riser();
Destrutor da classe. Desaloca os vetores criados antes.
void defaultParameters();
(R) Atribui um conjunto de parâmetros padrão. Será removida.
void enrichParameters();
Inicializa dados de Riser a partir de outros atributos do mesmo objeto. Na realidade, apenas chama outras funções mais específicas que fazem isto.
void _riser();
"Enriquece" dados específicos do riser, como dimensões dele (_dimensions), flutuadores (_floaters) e fluxo interno (_flow).
void _platform();
"Enriquece" dados ligados a plataforma.
void _environment();
"Enriquece" dados ligados ao ambiente, calculando a pressão hidrostática externa e chamando _current para correnteza, _waves para onda e _drag para as constantes hidrodinâmicas.
void _weights();
"Enriquece" dados ligados ao peso do riser. Diversos pesos médios por elemento são calculados, como peso médio acima da água, peso abaixo, peso apenas da parede do riser e peso com flutuador.
void _dimensions();
"Enriquece" dados ligados as dimensões, calculando o comprimento total acima e abaixo do nível do mar e a inclinação do riser.
void _floaters();
Interpola para cada elemento do riser os dados dos flutuadores
void _flow(Real*);
"Enriquece" dados ligados ao fluxo interno, chamando a função apropriada conforme o tipo de fluido interno.
void flowoil();
Chamado por _fLow, no caso de fluxo para apenas óleo.
void flowog();
Chamado por _fLow, no caso de fluxo para óleo e gás.
void flownone();
Chamado por _fLow, no caso sem fluxo.
void _waves();
"Enriquece" dados referentes as ondas.
void _current();
"Enriquece" dados referentes a correnteza, interpolando para cada elemento o perfil de correnteza.
void _drag();
void interpolate(Profile*,Real*);
Utilizado para interpolar as constantes hidrodinâmicas (CA e CD).
Real elemLength(int);
Retorna o tamanho do elemento dado o índice dele.
Real wall(int);
Retorna o peso da parede do elemento dado o índice dele.
Real floaters_effect(int);
Retorna o peso do flutuador naquele elemento dado o índice dele.
Real buoyancy(int);
Retorna o efeito do empuxo no elemento dado o índice dele.
Real mass(int);
Retorna a massa do elemento dado o índice dele.
Real weight(int);
Retorna o peso do elemento, contando flutuador e efeito do empuxo, dado o índice do elemento.
Real addMassInline(int);
Retorna a massa adicional inline do elemento dado o índice dele.
Real addMassTrans(int);
Retorna a massa adicional transversal do elemento dado o índice dele.
void print(int);
Imprime dados do riser. Apenas para debug.
==TTR, Collector, Tower e Pipeline==
Apenas definem as classes, sem conter diferenças nos métodos.
==Floater==
A classe FLoater representa os flutuadores presos ao riser. Não é necessário um objeto desta classe para cada flutuador, mas um único já é responsável por armazenar todos os dados dos flutuadores (Riser possui apenas uma instância desta classe). Os vetores atributos desta classe tem tamanho igual ao número de flutuadores, cada elemento do vetor correspondendo a um flutuador. Para o k-ésimo flutuador, a posição k do vetor first indica qual o primeiro elemento de riser que contém este flutuador, e Last o último. O vetor density guarda a densidade do flutuador e exDiam o diâmetro externo. Estes vetores são alocados pelo método init, cujo argumento é o número de flutuadores, mas os vetores devem ser preenchidos diretamente.
void init(int);
Método utilizado para indicar o número de flutuadores, alocando memória para eles.
Floater();
Construtor da classe. Inicializa atributos.
==Platform=
Classe que contêm informações sobre a plataforma.
void defvals();
Inicializa um conjunto padrão de parâmetros.
==Wave==
Classe que contêm informações sobre as ondas.
void defvals();
Inicializa um conjunto padrão de parâmetros.
==Current==
Classe que contêm informações sobre o perfil de correnteza. O perfil é dado em pontos chave que depois são interpolados linearmente pela função _current de Riser. O vetor depth contém a profundidade de cada um destes pontos e current a correnteza. É necessário utilizar
Current();
Construtor da classe. Inicializa algumas variáveis.
void defvals();
Inicializa um conjunto padrão de parâmetros.
void initProfile(int);
Aloca um perfil de correnteza com o número de pontos especificado no argumento.
==Profile==
Classe utilizada para guardar a informação do perfil de variação dos coeficientes de arrasto e de massa adicional (CA e CD, tanto inline quanto transversal). Basta instanciar a classe e utilizar addPoint para incluir um novo ponto, passando a posição e o valor do coeficiente. O método _drag de Riser posteriormente utiliza estes dados para interpolar linearmente os coeficientes para cada elemento do riser.
Profile();
Construtor da classe. Inicializa atributos.
void reset();
Remove todos os pontos do perfil.
void addPoint(Real c,Real v);
Adiciona um ponto, passando posição e valor do coeficiente.
==Environment==
Classe que representa os dados do ambiente. Contém outras classes mais específicas como Current e Wave.
void defvals();
Inicializa um conjunto padrão de parâmetros.
==InternalFlow==
Classe que representa o fluxo interno no riser, que pode ser de óleo, óleo e gás, ou nenhum.
Os métodos da classe são utilizados pelos métodos flowoil, flowog e flownone da classe Riser.
Grupo Matrix
(R) As classes do grupo Matrix implementam as diversas matrizes utilizadas na análises da simulação. Como os elementos concentram-se em faixas bem definidas das matrizes convencionais, nestas classes são linearizados e armazenados em vetores unidimensionais para poupar memória. As classes MyMatrix e também as derivadas desta, AsymmetricMatrix e SymmetricMatrix, implementam as funcionalidades básicas deste tipo de matriz. As demais implementam matrizes mais especificas, como as de massa, rigidez e amortecimento, sendo que estas mesmas possuem múltiplas versões (Lumped x consistente, inline x transversal).
O conjunto de classes definidas pode ser reorganizado, talvez definindo uma classe base para matrizes na forma Lumped e na forma consistente e passando os métodos decompGauss e decompGauss2 para elas.
==MyMatrix==
Classe base para as demais matrizes, implementando diversos métodos utilizados por elas. Ao invés de armazenar os elementos numa matriz comum (duas dimensões), os dados são linearizados e armazenados num vetor unidimensional, já que os valores diferentes de zero concentram-se apenas em uma faixa bem definida da matriz original. Assim, o acesso aos elementos da matriz é feito pelos métodos insertVaLue, addVaLue e getVaLue. O mapeamento para a forma linear é feito pelo método virtual map, que é nesta classe apenas definido, sendo implementado nas subclasse AsymmetricMatrix e SymmetricMatrix.
A classe dispõe de três construtores. Um aceita três parâmetros: tamanho total do vetor, dimensão original e tamanho da banda onde concentram-se os elementos. Outro aceita apenas dimensão e banda, sendo o tamanho calculado como o produto deles. Um terceiro construtor não pede argumentos mas também não inicializa nenhum destes atributos nem aloca o vetor.
Por fim, temos os métodos decompGauss e decompGauss2. Os métodos realizam a decomposição de
Gauss da matriz, com a diferença de que o primeiro é utilizado para matrizes na forma consistente e o segundo na forma lumped.
MyMatrix();
Construtor para classe, não realiza nada.
MyMatrix(int,int,int);
Construtor que recebe tamanho do vetor, dimensão da matriz original e banda da matriz, alocando o vetor.
MyMatrix(int,int);
~MyMatrix();
Destrutor da classe, desaloca vetor.
bool insertValue(Real,int,int);
Insere valor na posição dada (internamente, converte o par de índices para o índice linearizado.
bool addValue(Real,int,int);
Adiciona valor na posição dada (internamente, converte o par de índices para o índice linearizado.
Real getValue(int,int);
Retorna o valor da posição dada (internamente, converte o par de índices para o índice linearizado.
void decompGauss(Real*,Real*);
(R) Realiza decomposição gaussiana para matrizes da forma consistente. Ideal seria mover este método para outra classe, talvez alguma nova que defina uma consistente genérica.
void decompGauss2(Real*,Real*);
(R) Realiza decomposição gaussiana para matrizes da forma lumped. Ideal seria mover este método para outra classe, talvez alguma nova que defina uma lumped genérica.
void print(bool);
Imprime informações sobre a matriz. Para debug.
==SymmetricMatrix==
Semelhante a classe base MyMatrix, acrescenta apenas a implementação do método map na versão para matriz simétrica.
==AsymmetricMatrix==
Semelhante a classe base MyMatrix, acrescenta apenas a implementação do método map na versão para matriz assimétrica.
==StiffnessMatrix==
Implementa a matriz de rigidez na forma consistente, sendo utilizada na análise estática e na de vibrações livres. Nos construtores é feita a alocação da memória do vetor que guarda os dados da matriz e de outras estruturas internas que variam conforme o tipo de riser. O
StiffnessMatrix(TTR*);
Construtor para configuração TTR. Aloca vetor e outras estruturas.
StiffnessMatrix(Tower*);
Construtor para configuração Tower. Aloca vetor e outras estruturas.
StiffnessMatrix(Collector*);
Construtor para configuração Collector. Aloca vetor e outras estruturas.
StiffnessMatrix(Pipeline*);
(P) Construtor para configuração Pipeline. Aloca vetor e outras estruturas.
~StiffnessMatrix();
Destrutor da classe, desaloca estruturas.
virtual Real* genMatrix(TTR*);
Calcula o valor dos elementos da matriz para a configuração TTR.
virtual Real* genMatrix(Tower*);
Calcula o valor dos elementos da matriz para a configuração Tower.
virtual Real* genMatrix(Collector*);
Calcula o valor dos elementos da matriz para a configuração Collector.
virtual Real* genMatrix(Pipeline*);
(P) Calcula o valor dos elementos da matriz para a configuração Pipeline.
template&amp;lt;class SpecificRiserType&gt; void assembleMatrix(SpecificRiserType*);
Algoritmo principal do cálculo da matriz. É chamado por alguma das versões de genMatrix. É um template pois o algoritmo não varia conforme o tipo de riser, mas geomMatrix e elastMatix sim.
void geomMatrix(Riser*,int,Real[6][6]);
Calcula um setor 6x6 do componente geométrico da matriz. Utilizado para configurações diferentes de Pipeline.
void geomMatrix(Pipeline*,int,Real[6][6]);
(P) Calcula um setor 6x6 do componente geométrico da matriz. Utilizado para configuração Pipeline.
void elastMatrix(Riser*,int,Real[6][6]);
Calcula um setor 6x6 do componente elástico da matriz. Utilizado para configurações diferentes de Pipeline.
void elastMatrix(Pipeline*,int,Real[6][6]);
Calcula um setor 6x6 do componente elástico da matriz. Utilizado para configuração Pipeline.
==LumpedStiffnessMatrix==
Implementa a matriz de rigidez na forma lumped, sendo utilizada na análise dinâmica. No construtor é feita a alocação da memória do vetor que guarda os dados da matriz. O método genMatrix calcula os valores dos elementos da matriz a partir da versão consistente. Caso se chame o método genMatrix sem passar o segundo argumento (que seria a matriz consistente), o método cria a matriz consistente antes de prosseguir.
virtual Real* genMatrix(TTR*);
Gera a matriz para a configuração TTR. Cria uma matriz de rigidez consistente (StiffnessMatrix) e passa para genMatrix(TTR*,StiffnessMatrix*).
virtual Real* genMatrix(Tower*);
Gera a matriz para a configuração Tower. Cria uma matriz de rigidez consistente (StiffnessMatrix) e passa para genMatrix(Tower*,StiffnessMatrix*).
virtual Real* genMatrix(Collector*);
Gera a matriz para a configuração CoLLector. Cria uma matriz de rigidez consistente (StiffnessMatrix) e passa para genMatrix(CoLLector*,StiffnessMatrix*).
virtual Real* genMatrix(Pipeline*);
(P) Gera a matriz para a configuração PipeLine. Cria uma matriz de rigidez consistente (StiffnessMatrix) e passa para genMatrix(PipeLine*,StiffnessMatrix*).
Real* genMatrix(TTR*,StiffnessMatrix*);
Calcula para TTR os valores da matriz de rigidez na forma Lumped a partir da forma consistente.
Real* genMatrix(Tower*,StiffnessMatrix*);
Calcula para Tower os valores da matriz de rigidez na forma Lumped a partir da forma consistente.
Real* genMatrix(Collector*,StiffnessMatrix*);
Calcula para CoLLector os valores da matriz de rigidez na forma Lumped a partir da forma consistente.
Real* genMatrix(Pipeline*,StiffnessMatrix*);
(P) Calcula para Pipeline os valores da matriz de rigidez na forma Lumped a partir da forma consistente.
template&amp;lt;class SpecificRiserType&gt; void assembleMatrix(SpecificRiserType*,StiffnessMatrix*); Algoritmo principal que calcula a matriz. Chamado por genMatrix e utiliza os métodos que vem abaixo.
==MassMatrix==
Implementa a matriz de massa na forma consistente, sendo utilizada na análise de vibrações livres. Nos construtores é feita a alocação da memória do vetor que guarda os dados da matriz e de outras estruturas internas que variam conforme o tipo de riser. Os métodos genMatrix e assembLeMatrix calculam os valores dos elementos da matriz, utilizando o método auxiliar LocaLMatrix, que calcula um setor 6x6 da matriz. Este método é apenas virtual, sendo implementado nas subclasses InLineMassMatrix e TransMassMatrix.
==InlineMassMatrix==
Verão inLine da classe base MassMatrix, acrescentando apenas a implementação do método LocaLMatrix para o caso inLine.
==TransMassMatrix==
Verão transversal da classe base MassMatrix, acrescentando apenas a implementação do método localMatrix para o caso transversal.
==LumpedMassMatrix==
Implementa a matriz de massa na forma lumped, sendo utilizada na análise dinâmica. Nos construtores é feita a alocação da memória do vetor que guarda os dados da matriz e de outras estruturas internas que variam conforme o tipo de riser. Os métodos genMatrix e assembleMatrix calculam os valores dos elementos da matriz, utilizando o método auxiliar localMatrix, que calcula um setor 2x2 da matriz. Este método é apenas virtual, sendo implementado nas subclasses InlineMassMatrix e TransMassMatrix.
==LumpedInlineMassMatrix==
Verão inline da classe base LumpedMassMatrix, acrescentando apenas a implementação do método localMatrix para o caso inline.
==LumpedTransMassMatrix==
Verão transversal da classe base LumpedMassMatrix, acrescentando apenas a implementação do método localMatrix para o caso transversal.
==DampingMatrix, InlineDampingMatrix e TransDampingMatrix==
Implementam a matriz de amortecimento, utilizada na análise dinâmica, sendo a primeira a base para as outras duas, específicas para o caso inline e transversal, respectivamente. O construtor apenas aloca a memória interna necessária e genMatrix gera a matriz a partir das matrizes de massa e rigidez.
==MATR1, inlineMATR1, transMATR1, MATR2, inlineMATR2, transMATR2, MATR3, inlineMATR3 e transMATR3==
Matrizes utilizadas na análise dinâmica, são calculadas a partir das matrizes de massa, rigidez e amortecimento.
Grupo Force
==Force==
Classe base que representa as forças agindo sobre o riser. O construtor aloca o vetor interno de acordo com o número de elementos passado como parâmetro. O método generate, que preenche o vetor com os valores apropriados, é apenas declarado, sendo implementado mas subclasses.
==InlineForce==
Esta subclasse de Force implementa a força no plano inline, sendo utilizada na análise
==TransForce==
Esta subclasse de Force implementa a força no plano transversal, sendo utilizada na análise dinâmica. O método generate invoca os métodos viv, drag, added, que aplicam as diferentes cargas (vindo da viv, arrasto, massa adicional).
==StaticForce==
Esta subclasse de Force implementa a força sobre o riser na análise estática. Serve de base para outras duas classes mais específicas, InlineStaticForce e TransStaticForce.
==StaticInlineForce==
Implementa a força inline para a análise estática. O método generate calcula os valores apropriados.
==StaticTransForce==
Implementa a força transversal para a análise estática. O método generate calcula os valores apropriados.
==Load==
Utilizada na análise estática, encapsula a classe StaticForce e a utiliza para calcular o vetor Q. O método gen calcula este vetor, chamando por sua vez Load.
Outros
==Solver==
A classe Solver é a classe principal do simulador e é com ela principalmente que o Módulo de Visualização interage. O método newModel cria um novo modelo de simulação, recebendo como parâmetro o tipo de riser (na forma de string) e o número de elementos. Com um modelo criado, é possível executar as análises chamando as funções staticAnalysis, freeVibrationAnalysis e dynamicAnalysis. O método time retorna o instante da simulação (da análise dinâmica) e reset reinicia a análise dinâmica.
==Model==
A classe ModeL encapsula a classe Riser e como esta, possui sublclasses para cada configuração de riser (TTRModeL, TowerModeL, CoLLectorModeL e PipeLineModeL). Com elas é possível, utilizando polimorfismo e sobrecarga de método, invocar as análises sem precisar de variáveis e condicionais para fazer os cálculos de modo diferenciado conforme o tipo de riser.
Por exemplo, ao criar um novo modelo de TTR pelo método newModel de Solver, é instanciada a subclasse de Model apropriada, TTRModel, mas que fica referenciada pelo ponteiro model de tipo Model*. Ou seja, o Solver não sabe qual o tipo especifico de Model está alocado. Ao chamar a análise estática pela classe Solver, isto é, solver-&gt;staticAnalysis, é chamado por ela o método model-&gt;staticAnalysis, que executa não o método da classe base Model, mas da classe especifica TTRModel. Este método, por fim, invoca o método run do objeto staticAnalysis passado como argumento, passando para ele o objeto data de tipo TTR.
==TTRModel, TowerModel, CollectorModel e PipelineModel==
Classes que representam os modelos específicos de Model.
Documentação do Módulo de Visualização
A descrição das classes do Módulo de Visualização está aqui agrupada de acordo com as classes a que pertencem. A Figura 2 mostra as principais classes do módulo e como se relacionam entre si. A classe principal é a classe App, que contem as classes Interface e Solver, está última importada do módulo Solver. A classe Interface por sua vez contém as classes Scene, que implementa a cena 3D onde é visualizada a simulação, e Panel, que implementa o painel de controle. A cena 3D é implementada utilizando o VTK e o painel utilizando o Qt.
Figura 2 - classes do Módulo de Visualização
Scene.py
Contém as classes que implementam a representação virtual do cenário de operação de um riser. A classe Scene atua como o contêiner para as demais classes que instanciam os elementos específicos da visualização (riser, mar, forças). Além de alguns métodos mais específicos, todas possuem um construtor  init  e um método update. O primeiro cria e conecta os objetos VTK do pipeline de visualização e o segundo atualiza os dados de entrada do pipeline (p.e. atualizando posições ou escala dos elementos).
==Scene==
def __init__(self,app,iren):
Construtor. Cria e inicializa o renderer (fornecido pelo VTK) a ser utilizado para a visualização. Cria os demais elementos da cena e adiciona seus respectivos actors na cena.
def scaleToScene(self,val):
Converte distâncias para a escala da cena.
def scaleToModel(self,val):
Faz o processo inverso do método anterior.
def EndPickEvent(self,obj,event):
Detecta um pick event, utilizado para selecionar um elemento do riser.
def frontView(self):
Posiciona a câmera em vista frontal.
def sideView(self):
Posiciona a câmera em vista lateral.
def topView(self):
Posiciona a câmera em vista superior.
def hideShipModel(self,hide):
Oculta ou mostra o modelo da embarcação.
def showMaxDisplacements(self,show):
Oculta ou mostra os máximos deslocamentos.
def record(self):
def visualStyle(self,option):
Seleciona o modo de visualização: contido no bounding box ou com o mar extenso.
def hideFloaters(self,hide):
Oculta ou mostra os flutuadores ao longo do riser.
def hideNumbers(self,hide):
Oculta ou mostra a profundidade em números na cena.
def reset(self):
Zera as linhas de máximo deslocamento.
def update(self):
Invoca update dos elementos da cena.
==SceneObj==
Classe base para as demais classes que representam os elementos da visualização (riser, mar, embarcação, etc). Implementa funcionalidades comuns a todas, como criar o Actor do VTK.
==Mesh==
def update(sel_f,timeStamp):
Atualiza a posição da embarcação, fazendo-a balançar com o movimento das ondas. No momento, apenas para propósito ilustrativo.
==Terrain==
Implementa o fundo do mar. Utiliza Perlin Noise sobre um plano para gerar a rugosidade e uma textura para maior realismo.
==Water==
Implementa a superficie do mar. Utiliza Perlin Noise sobre um plano para gerar as ondas e uma textura para maior realismo.
def __init__(sel_f,scene,app,texture=None):
def update(sel_f,timeStamp):
Atualiza a posição das ondas. Embora o Solver leve em conta parâmetros de onda, no momento as ondas representadas não seguem estes parâmetros, sendo apenas ilustrativas.
==Riser==
Representa o riser. Utiliza um spline para interpolar os elementos, gerando um tubo com curvatura suave. Cores são mapeadas sobre a superfície do riser para representar diversos dados da simulação, como forças sobre o duto ou coeficientes de arrasto.
def update(sel_f):
Atualiza a posição do riser e o mapeamento de cores.
==Box==
Representa o bounding box que envolve os demais elementos da cena virtual (exceto no modo sem o bounding box).
==Force==
Representa com setas ao longo do riser as forças que agem sobre o tubo. Escala e orienta as setas de acordo com magnitude das componentes inline e transversal (isto é, as componentes não são representadas separadamente).
def update(sel_f):
Atualiza a posição, orientação e magnitude das setas, fazendo-as acompanhar o movimento do riser.
==TopTension==
Representa com uma seta apontada para cima a tensão de topo aplicada no riser.
==Cursor==
Implementa uma esfera vermelha que marca o elemento do riser selecionado (ao apontar com o mouse e pressionar a tecla P).
==Floaters==
Representa os flutuadores dispostos sobre o riser.
def update(sel_f):
Atualiza a posição dos flutuadores, para acompanharem o riser.
==RefPole==
Implementa linhas verticais, utilizadas p.e. para marcar a posição inicial do riser.
==MaxProfile==
Implementa as linhas de máximo deslocamento,
Panel.py
O arquivo Panel.py contém uma única classe, Panel, que implementa o painel de controle do módulo de visualização, utilizando diversos recursos do Qt. O método _init_ inicia as
estruturas do Qt utilizadas, criando o painel e as funcionalidades dos widgets. Grande parte do painel foi criada através do ambiente visual QtCreator, de modo que o código apenas carrega as informações contidas no arquivo Panel.ui gerado pelo QtCreator. Para atribuir as funcionalidades dos widgets, é utilizado o método connect do widget correspondente, passando-se a função a ser chamada quando o widget for utilizado. Os demais métodos da classe Panel, de um modo geral, implementam as funções chamadas pelos widgets, ou são métodos auxiliares.
Interface.py
O arquivo Interface.py contém uma única classe, Interface, que implementa a interface do módulo de visualização. Serve de contêiner para dois outros objetos, um da classe Panel e outro da classe Scene, que implementam respectivamente o painel de controle e a cena 3D onde é feita a visualização. Implementa também funcionalidades da barra de menu superior.
main.py
O arquivo main.py contém uma única classe, App, que é a classe principal do módulo. Serve de contêiner para a classe Interface e para a classe Solver, esta última importada do módulo Solver.</field>
	</doc>
</add>