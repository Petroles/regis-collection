<?xml version="1.0" encoding="utf-8"?>
<add>
	<doc>
		<field name="docid">BR-TU.12965</field>
		<field name="filename">18778_arquivo6881_1.pdf</field>
		<field name="filetype">PDF</field>
		<field name="text">
Universidade Federal de Pernambuco
Centro de Informática

Pós-graduação em Ciência da Computação

Systematic Development of Trustworthy
Component-based Systems

Rodrigo Teixeira Ramos

Tese de Doutorado

Recife
Agosto de 2011



Universidade Federal de Pernambuco
Centro de Informática

Rodrigo Teixeira Ramos

Systematic Development of Trustworthy Component-based
Systems

Trabalho apresentado ao Programa de Pós-graduação em
Ciência da Computação do Centro de Informática da Uni-
versidade Federal de Pernambuco como requisito parcial
para obtenção do grau de Doutor em Ciência da Com-
putação.

Orientador: Augusto Cezar Alves Sampaio
Co-orientador: Alexandre Cabral Mota

Recife
Agosto de 2011



 
 
 
 
 
 
 
 
 
 
 
 
 

 
 
 

 
 
 
 

 
 
 
  
  

                       Catalogação na fonte 
       Bibliotecária Jane Souto Maior, CRB4-571  
  
 
Ramos, Rodrigo Teixeira                  
       Systematic Development of Trustworthy 
Component-based Systems / Rodrigo Teixeira Ramos - 
Recife: O Autor, 2011. 
       xi, 157  folhas : il., fig. 
 
       Orientador: Augusto Cezar Alves Sampaio. 
       Tese (doutorado) - Universidade Federal de 
Pernambuco. CIn, Ciência da Computação, 2011. 
 
        Inclui bibliografia e apêndice. 
 
        1. Engenharia de software. 2. Métodos formais. 3. 
Verificação de sistemas. 4. Verificação por construção. I. 
Sampaio, Augusto Cezar Alves (orientador).  II. Título. 
         
          005.1                     CDD (22. ed.)                   MEI2011 – 
133 
 
 
 
 





I dedicate this work to my parents, who always offered me
their love, care and support.



Acknowledgements

I would like to thank all those who supported me in my doctoral study and the work on my
thesis.

First and foremost, I am grateful to my parents and my wife, whose support, love and
patience made this work possible. I am thankful to my mother for always motivating me to
realise my dreams. I thank my father for showing the importance of education. Both were
confronted with a difficult life since they were very young, and made a better life for our
family through hard work and dedication. I am also very lucky to have found my great love,
my wife Renata, who has taught me the pleasure of life beyond the academia.

I am deeply indebted to my advisors Augusto Sampaio and Alexandre Mota for the help and
counselling received all these years. They have introduced me to the life of research, ten yeas
ago. Since then, they have shared with me valuable advices, and more importantly friendship.
Thank you!

The Centro de Informática at Universidade Federal de Pernambuco proved to be a very
pleasant environment where to work. I appreciate the office mates and friends I made there for
all discussions and the pleasant time I spent with.

For their invaluable suggestions and timely advices, I am grateful to the professors Ana
Cristina Melo, David Deharbe, Juliano Iyoda, Marcio Cornelio and Paulo Borba, the members
of my doctoral evaluation committee. I am also in gratitude to the professors Zhiming Liu,
Jean-Marc Jezequel and Olivier Barais for receiving me as an intern in their institutes during
the time of my studies. These experiences strongly influenced on the result of my work.

Finally, my thanks go to the institute that provided financial support for my research work.
Through my doctoral study, my work was partially supported by CAPES – Coordenação de
Aperfeiçoamento de Pessoal de Nível Superior.

iv



Resumo

Apesar de componentes serem tratados como unidades básicas de composição no desenvolvi-
mento baseado em componentes (CBD), para que eles obtenham um disseminado status de
serem facilmente conectados como ‘peças de lego’ a integração de componentes precisa ser
cuidadosamente projetada, sistematizada e verificada; somente isto poderá garantir arquiteturas
confiáveis. Além dos argumentos gerais sobre redução de custo através de reuso, abordagens
CBD precisam oferecer uma interessante, e frutífera, oportunidade para o desenvolvimento de
sistemas críticos de alta qualidade e viável no contexto industrial.

Para alcançar esta meta, propomos neste trabalho uma abordagem sistematizada para a
construção de sistemas baseados em componentes (CBS) confiáveis. A abordagem foca na
realização de análises que consideram preocupações de engenharia no CBD. Ela se baseia em
um modelo de componentes que caracteriza os blocos de construção de nossa abordagem de
desenvolvimento, e que impõe as restrições necessárias para sua interação segura. Além disto,
definimos restrições de construção para o nosso modelo de componentes, baseadas em regras
de composição para componentes. Estas permitem verificar quando dois componentes são
compatíveis para trocarem informações.

As regras de composição compreendem um método sistematizado para preservar, por cons-
trução, propriedades comportamentais em composições de componentes; em particular, fo-
camos na preservação de progresso local e da ausência de deadlock nas composições. Como
conseqüência, é possível prever o comportamento de uma vasta gama de CBS, antes de sua im-
plementação, com base em propriedades conhecidas do sistema. Em nossa abordagem, também
propomos alternativas de verificação mais amenas: a) predições de condições de composição
baseadas na análise de metadados de componentes; b) simplificações em verificações de com-
ponente associados a estilos arquiteturais específicos.

Toda a abordagem é apoiada pela álgebra de processos CSP, que oferece modelos semân-
ticos que suportam uma vasta gama de verificações e comparações de processos. Além disto,
ilustramos a aplicação desta abordagem através de dois estudos de caso, que focam em difer-
entes aspectos da nossa abordagem, e verificamos mecanicamente a preservação de proprieda-
des comportamentais de componentes na evolução dessas aplicações.

Palavras-chave: Componentes de software, correção por construção, previsibilidade na com-
posição, CSP.

v



Abstract

In component-based development (CBD), components are taken as units of composition. Nev-
ertheless, to achieve the widely disseminated status of components being plugged together as
simple ‘Lego Pieces’, the integration of components must be carefully designed, systematised
and verified; only this can ensure reliable architectures. Beyond the general arguments about
savings by reuse, CBD approaches must offer an interesting, and fruitful, opportunity for high-
quality critical systems development that is feasible in an industrial context.

To achieve this goal, in this work, we propose a systematic approach to build trustworthy
component-based systems. The approach focuses on performing analyses that are intended to
address engineering concerns on CBD. It relies on a component model which characterises
the building blocks of our systematic development approach, and imposes the necessary con-
straints for their safe interaction. Moreover, we define constructive constraints for development
activities in this component model. The constructive constraints for our component architec-
tural model are based on composition rules for components. These notions allow checking, for
instance, whether two components are compatible for them to interoperate.

The composition rules comprise a systematic method to preserve behavioural properties by
construction in component composition; in special, we focus on the preservation of deadlock-
freedom and local progress in compositions. As a consequence, it is possible to predict the
behaviour of a wide range of component-based systems prior to their implementation, based
on known properties of the system components. In addition, lightweight alternatives for heavy
verifications are proposed in two ways on this approach: a) verifications of composition side
conditions are improved by carrying out partial verification results on component metadata
throughout component compositions; b) in the second alternative, simplified alternative verifi-
cations are proposed for components in specific architectural styles.

The entire approach is underpinned by the CSP process algebra, which offers rich semantic
models that support a wide range of process verification, and comparisons. We illustrate the
application of our approach through two case studies, which focus on different aspects of our
approach, and we mechanically verify the preservation of behavioural component properties in
the evolution of such applications.

Keywords: Software components, correction by construction, composition predictability,
CSP.

vi



Contents

1 Introduction 1
1.1 Some research opportunities 2
1.2 The approach and contributions 3
1.3 Thesis outline 4

2 Background on componentware 6
2.1 Component-based development 7
2.2 Software architecture 9

2.2.1 Component models, technologies and frameworks 10
2.2.2 Software component contracts 12

2.3 Formal methods on components 13
2.4 Desiderata for component-based critical systems 14

3 Specification and refinement of concurrent systems 17
3.1 Process algebra 17
3.2 CSP syntax 18
3.3 CSP semantic models 23

3.3.1 Traces model 23
3.3.2 Stable failure model 25
3.3.3 Failure/divergence model 28

4 I/O processes and communication protocols 31
4.1 I/O processes 32
4.2 Communication protocols 37

4.2.1 Protocol compatibility 41
4.2.1.1 Verifying compatibility via process refinement 43

4.3 Buffering 47
4.3.1 I/O buffers 48
4.3.2 Buffer tolerance 49
4.3.3 Buffering self-injection 53

4.4 Safe hiding 57

5 The BRIC component model 59
5.1 A component-based system example 60
5.2 BRIC component model 60

5.2.1 Interfaces 60

vii



CONTENTS viii

5.2.2 Regular components 62
5.2.3 Connectors 66
5.2.4 Composition 67
5.2.5 Wrapping 71

5.3 Architectural styles 72
5.3.1 Interaction components 73
5.3.2 Naive client-servers 75
5.3.3 Protocol oriented components 75

5.4 BRICK components 76

6 A rigorous strategy for component compositions 80
6.1 Local analysis 80

6.1.1 Desirable quality attributes 81
6.2 Composition rules 83

6.2.1 General composition rules 83
6.2.2 Trustworthy component systems 89
6.2.3 Rule compositionality 90

6.3 Verification improvements using architectural styles 93
6.3.1 Wrapping interactions 93
6.3.2 Improving composition support using component metadata 95

7 Case studies 99
7.1 The dining philosophers example 99
7.2 A routing coordinator example 107

8 Conclusions, related and future work 113
8.1 Summary 114
8.2 Related work 116

8.2.1 Component models 116
8.2.2 Reasoning model 118

8.3 Future work 122

A Relation between protocol compatibility and conflict freedom 125

B Proofs of composition rules with metadata 129

C Cases study in FDR 138
C.1 FDR-CSP 138
C.2 Auxiliary processes 139
C.3 The dining philosopher’s example 140
C.4 Routing coordination 143



List of Figures

2.1 Bank Decomposition [ABB+01]. 8

5.1 An example of a simple ATM System. 60
5.2 The Client behaviour. 64
5.3 Composition using a buffer 68

6.1 Three composition rules proposed in this work. 83

7.1 The Dining Philosophers Problem 100
7.2 Interleave of Philosophers 103
7.3 Communication between philosophers and their left forks 104
7.4 Communication between philosophers and their right forks 105
7.5 Communication of the last philosopher and his left fork 106
7.6 Communication of between all philosophers and their forks 107
7.7 Case Study: A more elaborate ATM System. 108
7.8 The composition steps of basic connectors to form the network of connectors. 111

ix



List of Definitions

3.1 Definition (Traces refinement) 23
3.2 Definition (Stable failure refinement) 26
3.3 Definition (Deadlock-free process) 26
3.4 Definition (Failures/divergences refinement) 29

4.1 Definition (I/O channels) 32
4.2 Definition (Process input and output events) 32
4.3 Definition (Input determinism) 32
4.4 Definition (Strong output decisiveness) 34
4.5 Definition (I/O process) 37
4.6 Definition (Communication protocol) 37
4.7 Definition (Projection) 39
4.8 Definition (Protocol implementation) 40
4.9 Definition (Protocol satisfaction) 40
4.10 Definition (Equivalent protocols) 40
4.11 Definition (Conjugate protocols) 41
4.12 Definition (Protocol compatibility) 41
4.13 Definition (Strong protocol compatibility) 42
4.14 Definition (Dual protocol) 43
4.15 Definition (Dual protocol implementation) 43
4.16 Definition (Communication context process) 45
4.17 Definition (Communication context process implementation) 45
4.18 Definition (I/O confluence) 50
4.19 Definition (Finite output property) 52
4.20 Definition (Buffering self-injection compatibility) 53
4.21 Definition (Decoupled channels) 56
4.22 Definition (Safe hiding) 57

5.1 Definition (I/O type) 60
5.2 Definition (Interface) 61
5.3 Definition (Component contract) 62
5.4 Definition (Component contract instantiation) 66
5.5 Definition (Abstract connector) 66
5.6 Definition (Connector instantiation) 67
5.7 Definition (Asynchronous binary composition) 69
5.8 Definition (Asynchronous unary composition) 70

x



LIST OF DEFINITIONS xi

5.9 Definition (Wrapping) 72
5.10 Definition (Interaction patterns) 73
5.11 Definition (Interaction process) 74
5.12 Definition (Interaction component) 74
5.13 Definition (Default interaction component implementation) 74
5.14 Definition (Naive client-server component) 75
5.15 Definition (Protocol oriented component) 75
5.16 Definition (Enriched component contract) 77
5.17 Definition (Enrich Component Contract) 79

6.1 Definition (Service conformance) 81
6.2 Definition (Interleave composition) 84
6.3 Definition (Communication composition) 85
6.4 Definition (Feedback composition) 87
6.5 Definition (Reflexive composition) 88
6.6 Definition (Extended feedback composition) 90
6.7 Definition (Extended communication composition) 91
6.8 Definition (Interaction channels) 94
6.9 Definition (Wrapping interaction) 94
6.10 Definition (Enriched interleaving composition) 95
6.11 Definition (Enriched communication composition) 96
6.12 Definition (Enriched feedback composition) 97
6.13 Definition (Enriched reflexive composition) 98
A.1 Definition (Deadlock state) 126
A.2 Definition (Strong conflict) 126



CHAPTER 1

Introduction

Although component-based system development (CBSD) has been around for a long time
[Mah90], over the last decade it has re-emerged as a promising paradigm to deal with the
ever increasing need for mastering complexity, evolution and reuse in the design of computer
based systems. The basic motivation for this paradigm is to replace conventional programming
with the composition and configuration of reusable and independent units, called components.

Nevertheless, in order to ensure the success of the component-based method, it is es-
sential that we trust in the behaviour of the components and, furthermore, of the systems
based on them. Such trustworthiness is even more important in critical applications. For
instance, avionics systems must have high reliability and continue to operate upon a fail-
ure [MJG+10], autonomous agents in a manufacturing system must correctly obey their sched-
ule [Weh00, BGL+08]. Errors in these systems are caused not only by failures of individual
components, but by dysfunctional interactions between non-failed components.

The reason of dysfunctional interactions is that real industrial components do not always
fit together like ‘Lego Pieces’, or just using a simple glue code. Integration solutions are often
developed in an ad hoc manner, in which incompatibilities are not discovered until their side
effects emerge during implementation [HGK+06]. Critical issues for system construction are
related to the design of the communication-based interaction mechanisms that permit compo-
nents to work together [Spi04]. The correct design of these elements is critical; otherwise the
system may malfunction in subtle ways or may not work at all. This concern is even more acute
when a group of components are put together and coordinated to accomplish a collective set of
tasks [PA98]. Therefore, it is crucial to verify whether Component Based Systems (CBS) sat-
isfy some desired properties. In fact, most dysfunctional interactions are originated by classical
problems in concurrent systems, such as deadlock and livelock.

Safety-related properties, including deadlock- and livelock-freedom, are emergent system
attributes [Lev95]. In other words, these are properties that emerge from the interactions among
multiple system components, and their analysis might not reside in any component system
in particular. For this reason, emergent properties cannot be tested directly in an efficient
way. In [Min07, MCMM08], it was shown that deciding deadlock-freedom and liveness in
interaction systems is NP-hard. Therefore, it is desirable to establish (stronger) conditions that
are easier to test and entail the desired properties [GGMC+06].

To help development, these conditions should be intrinsic to the design and implementation
rules used by component developers and application integrators [Wal03, MH05]. In this way,
a system engineer, who is not an expert in analytic theory, can reason about properties of the
design.

Problems are inevitable after all. It is impossible to foresee every possible situation in

1



1.1 SOME RESEARCH OPPORTUNITIES 2

which a given system might be used. Problems will surely arise when two or more systems that
have not interfaced together before are integrated. The sooner and easier these problems are
identified and resolved, the greater is the success of the component based method.

1.1 Some research opportunities

Unfortunately, it is at present difficult to verify important properties of component-based sys-
tems in industry. Most well known industrial component models, which define components and
how they integrate, are widely based on simple, low-level granularity components (EJB [DK06]
and COM/DCOM [Mic11]). These are represented by syntactical interfaces, which lack be-
havioural information and restrict component verifications [FG03].

Ironically, the idea of higher-level granularity component models, such as Wright [AG97,
ADG98], Fractal [BCL+06] and SOFA [BHP06], has been still waiting for full commercial
exploitation [Pla05]. Higher-level granularity component models complement the syntactical
information of a component with behaviour. The behaviour can be discriminated between
different kinds, usually associated to the component, port and assembly behaviour [HJK10].
The former, also called protocol, represents the whole observable behaviour of the component.
The behaviour associated to a port, also called port-protocol, is those observed from one point
of interaction of the component. The latter is related to the established interaction of one
component with another.

Nevertheless, formal description methods are getting more and more attention in the devel-
opment of critical systems because of their accuracy and the use of theorem proving mecha-
nisms [Chi09]. Much effort is devoted to the correctness of component-based systems (CBS)
[AG97, BCD02, HLL06b, Sif10, CZ07]. These works define a component model with a precise
meaning, or adopt a formal notation to specify the system. This makes it possible to analyse
the systems and to provide tool support in verifications.

The practice to date has been to verify and validate the system after it has been built
[HLL06b, PV02, CCH+09] – the system is designed, implemented and then verified and vali-
dated. The major issue is the high cost to fix a problem that is found in a late stage in develop-
ment, especially when the problem requires redesigning the system to meet reliability or some
other quality attribute requirement.

Instead of verifying the entire system, other more promising approaches focus on iteratively
identifing problems in compositions. However, in most approaches the cost of subsequent com-
positions is not alleviated by the results of the previous ones [ADG98, BCD02, CK96]. Every
composition is taken as a monolithic system for verification, and properties of its constituting
parts are not considered. Verification methods do not take advantage of the hierarchical struc-
ture of component-based systems. In other words, these methods are not compositional, and
have scalability problems by not using local analysis when this is possible.



1.2 THE APPROACH AND CONTRIBUTIONS 3

1.2 The approach and contributions

This thesis describes a theoretical foundation for the development of correct component-based
systems (CBS). We propose a correct by construction strategy for ensuring the preservation
of properties of a CBS from proved properties of its interaction model and of its components.
We consider the freedom of deadlock and livelock. Although we focus on these properties, the
strategy presented here can be applied to predict other safety and liveness properties. Moreover,
the ideas in this thesis can be transferred to other formal models, and support the implementa-
tion of practical tools for component-based development.

This approach is intended to address engineering concerns, and make the expertise on cor-
rectness available to engineers who are not experts in understanding the origin of dysfunctional
interactions between non-failed components in the system. Moreover, we claim that a construc-
tive approach, in opposition to a posteriori verification, is more suitable to component based
systems. It preserves quality attributes of the system by construction, and identifies problems
early in the design phase. Moreover, we use local analysis, when this is possible, to scale the
verifications in our approach.

To underpin this approach, we propose important design constraints. Satisfying these con-
straints at development, we can certainly trust on the resulting system. Part of these constraints
comprises our component model for components. It characterises which kinds of components,
as well as interactions, are supported in this work. To allow further verifications, we focus
on behavioural rich components, in which not only syntactical information about component
operations is presented, but also the behaviour with the possible valid sequences of operations
that the component can perform. The other constraints are the constructive constraints for
these components. They aimed to assist system evolution. In this work, we focus on notions
that predict quality attributes of components in compositions, which is one of the main activ-
ities in Component-Based Development [Szy02]. These notions allow checking whether the
behaviours of two components are compatible for them to interoperate. The entire approach
is based on the CSP process algebra [Ros98], which allows us to formally address property
characterisation and preservation.

We consider that there are four main contributions in this thesis. Each contribution is built
on top of the previous one. Moreover, altogether, they form our strategy for correct by con-
struction component-based systems.

A study on the behavioural compatibility of protocols. We start by performing a study on
protocols in isolation, independent of being associated to components. This study shows
whether two protocol specifications are compatible to interoperate. The study consid-
ers both synchronous and asynchronous mediums, and presents test characterisations to
verify such compatibility. In [RSM10], we have presented our initial results on the com-
patibility of protocols, which have been evolved until the current state presented in this
thesis.

The BRIC component model. In this thesis we define a generic component model, which
imposes the necessary constraints that characterise the components we deal with, and
how they interact. It is aligned with the concepts of other practical component mod-



1.3 THESIS OUTLINE 4

els [BHP06, HLL06b, MB05] and covers a wide variety of applications. Each com-
ponent is represented by a contract, which describes the dynamic behaviour, interfaces
and interaction points of the component. Connectors are presented in the model at two
different abstraction levels: one aimed for reuse, and the other representing their instan-
tiation. Despite the former level represents connectors as a distinct first-class entity, the
latter allows to represent connector instances as components. The component model
also describes how components interact and how white-box can be packaged into black-
box components. The basic notions of this component model were originally presented
in [RSM09, RSM10]; [RSM09] emphasises the benefits of certain architectural styles,
also presented in this thesis, to assist verifications.

A correct by construction strategy for BRIC components. We present a strategy for com-
position that is based on a comprehensive set of basic composition rules for BRIC com-
ponents. The proposed rules can be regarded as safe steps to form a wide variety of
trustworthy component systems. The systematic use of these rules guarantees, by con-
struction, the absence of deadlock and livelock. Most of the side-conditions of these
rules are based on the notion of port-protocols, which is the behaviour associated to each
point of interaction (port) of the component. The verification using port-protocols is
more efficient since the (whole) behaviour of a component is typically much broader (if
we compare the number of states and transitions) than its port-protocols. The proposed
set of rules covers component systems with arbitrary topologies, including those with
cycles. An application of these composition rules for tree-topology component-based
system structures is presented in [RSM09]. The conformance notion, in where the rules
are based on, was first presented in [RSM08].

A strategy using enriched component contracts with metadata. To improve the practical
application of our rules, we propose an architectural style, called BRICK. In this style,
component contracts are enriched with metadata to carry additional information useful
in composition verifications. Furthermore, we present a new set of composition rules
that take this metadata into consideration. The metadata of the composition is directly
derived from the metadata of its constituting components. As a result, the complexity of
compositions is reduced, and the value of the component-based method is improved.

1.3 Thesis outline

We have organised the presentation of this thesis in the following structure.
Chapters 2 and 3 are devoted to background. Chapter 2 presents some of the foundation

concepts on component-based development in which this thesis builds on. These are used
throughout the thesis to understand the context where and how components are used. It shows
different views on this field, and, in particular, the adoption of formal methods in such ap-
proaches. Chapter 3 introduces the formalism that underlines our work, the CSP notation.

In Chapter 4, we present the basic notions that underline our approach, independent of the
notion of components. We characterise the desired behaviour of systems in this thesis; these



1.3 THESIS OUTLINE 5

are reactive, and characterised by the communication of input and output events. We also in-
troduce the notions of communication protocols (also called port-protocol) in this context, and
present our notions and test characterisations for protocol compatibility in both synchronous
and asynchronous mediums.

Chapter 5 defines the BRIC component model. It presents the notion of component con-
tracts and connectors. It also defines how components interact. At the end of this chapter, we
present some architectural styles, which specialise our architectural model to specific applica-
tion domains. In particular, we present the BRICK component model, which allows component
contracts to have metadata (additional information used in composition); the components that
satisfy the BRICK component model are a subset of the components that satisfy the BRIC.

In Chapter 6, we present the constructive constraints of our component models, BRIC and
BRICK. It presents our composition rules for components in these models. These rules pre-
serve deadlock-freedom by construction, considering that the components involved in the as-
sembly satisfy this property. Both sets of components, the ones for BRIC and BRICK, have
the same number of rules; each one has a corresponding rule in the other set. Within this con-
text, the set of composition rules for BRIC components is aimed at more general components.
By contrast, the set of rules for BRICK are intended for components with enriched contracts.
The latter set of rules performs simple calculations with the metadata in substitution to more
general verifications in the original rules for BRIC components. As a result, the complexity
of verifications for BRICK is reduced, and the composition task is simplified. We also present
improvements on such composition rules when applied to other specific architectural styles pre-
sented in Chapter 5. We present notions to preserve livelock-freedom after applying wrapping
operators (operations that transform white-box into black-box components).

Chapter 7 evaluates our approach on two case studies. Each case study covers a different
purpose. The first one is the seminal dining philosophers problem, and is aimed at comparing
our approach to others in the literature. The second one shows the diversity of our approach in
constructing systems for coordinating other components.

Finally, Chapter 8 presents our general conclusions, pointing out our main contributions.
We analyse the advantages and disadvantages of our approach comparing with related works,
and we discuss some topics for future work.



CHAPTER 2

Background on componentware

By definition, all systems comprise components. These components result from problem de-
composition, a standard problem-solving technique in computer science: divide to conquer.
Etymologically speaking, components are the parts that constitute the whole system1; in turn,
the whole comprises its parts. In the software area, for instance, different concepts about how
systems should be organised result in different kinds of components, which might have noth-
ing more in common than the name ‘component’. In fact, the term software component has a
genealogy at least as long as those of ‘software engineering’ and the ‘software crisis’ [McI68];
all these ideas were originally reported in the famous NATO conference [NR69]. However,
since its origins, component notions and definitions developed in many (in some cases, contra-
dictory) directions, influenced by different areas of computer science, such as object-oriented
programming, reuse and software architecture. Today, the following definition [Szy02] is the
most frequently used.

“A component is a unit of composition with contractually specified interfaces and
explicit context dependencies only. A component can be deployed independently
and is subject to composition by third parties.”

This definition is still not fully accepted by the industry and academy [BDH+98]. The
reason is that component concepts subtly differ in the way that they are observed during devel-
opment. Despite it has been widely used, the definition above emphasises just one perspective
in using components as the building blocks of a development approach. It emphasises, for in-
stance, the composition and deployment of components. Other perspectives can consider, for
instance, the component at the design phase. Component-driven architectures [MT00] view
components as architectural entities and focus on the design of elegant architectures. Process
models, like the one proposed by [ABB+01], mainly focus on efficient development methods
for software product families or reuse of third-party components; improving productivity via
the reuse of components or part of their behaviour (the one common to a product family). All
these perspectives for building systems from components are called more broadly component-
ware approaches.

In this chapter, we study several componentware approaches, and understand their com-
monalities. This is used as a basis to the rest of this thesis to understand the context where
components are used in practice. Based on the study of these approaches we draw desirable

1Engineering large-scale systems is fundamentally different from programming in the small. A programming
language statement is inadequate as the unit of development. Instead, components must become the building
blocks of a system.

6



2.1 COMPONENT-BASED DEVELOPMENT 7

issues of an approach for the development of trustworthy component based development sys-
tems. The desiderata for component-based critical systems is presented in Section 2.4

In each section that follows, we focus on a different perspective in componentware. All
existing approaches cited in this chapter are organised in these sections according to their main
characteristics [BRSV99]: development process model, description techniques and formal sys-
tem model. This does not propose a rigid classification schema for those approaches. In fact,
approaches can present more than one of these characteristics. Section 2.1 discusses concepts
and principles common in process oriented approaches. Section 2.2 discusses architecture-
centric approaches, including component models and frameworks. Finally, in Section 2.3 we
discuss how formal methods are used to support the development of critical component-based
systems.

2.1 Component-based development

The idea of constructing large systems from small pieces (components) can reduce the devel-
opment time and improve the final product quality [Szy02], and then it is possibly the greatest
motivation for using this approach. In this scenario, it can be justified that the majority of
research, as well as its results, are new CBD methods proposals in order to address a lot of
weaknesses in this area [AAG+07].

As any other development process, developing components requires a systematic approach.
However, there are somewhat differences from traditional (object-oriented) development pro-
cess. The Component-based Software Engineering (CBSE) approach changes the nature of
software, so they need some original phases for the architecture of components.

In CBSE, considerably more time is devoted to business rules, business process modelling,
analysis, and design. Much less time is spent in development, while testing occurs throughout
the process. A detailed discussion of all tasks in component development would fill a complete
book [DW98, ABB+01, SDS01, CD01], therefore, for the sake of brevity, we detail only some
common activities on the analysis and design phases in this section. These activities were
selected because they generally take more time than traditional development ones take.

In summary, the building activities start top-down to introduce the building blocks of the
system. As the activities continue towards lower granularity blocks, interfaces between the
blocks are also defined. When the module is expected to correspond to a component, a tem-
porary bottom-up approach can be taken; if desired capability can only be achieved by a set of
components, their integration into a super-component should be carried out.

Figure 2.1 illustrates a regular component-based development. In this example, a banking
application is the software system that is to be built. The need for this software and definition
of the problem is described in an early specification phase. After deciding to develop soft-
ware and determining its boundaries there is need to decompose the whole system (Bank) into
reusable and cohesive sub-components (such as the Teller and Converter component contracts),
since these sub-components may be necessary in other software applications or systems. De-
composition also provides flexibility for developers, such that a project manager can distribute
components to different developers so that cost will be minimised. After decomposition, each
sub-component is considered independently and specified in detail. After specifying each com-



2.1 COMPONENT-BASED DEVELOPMENT 8

Figure 2.1 Bank Decomposition [ABB+01].

ponent, it is searched in possible repositories and domains. If there is an available component
in the repository then it is integrated into the system without writing any new code (such as
the Converter component). Nevertheless, sometimes there is no such ready-made component
that complies with our requirements exactly. If there is a component that complies with re-
quirements approximately then this component can be adapted to new requirements without
corrupting previous interactions within some other software systems. If there is no component
that complies with the requirements, then the only alternative is to create a new one using prin-
ciples of CBSE such as flexibility, reusability and maintainability (such as the Teller). Before
the integration phase, there is a need for testing each component separately. Finally at the in-
tegration phase, with the help of interfaces of components, it is possible to glue components to
each other in the light of requirements.

As presented above, much time is devoted to design in CBD. For this reason, CBD is
usually used in combination with other methods. For instance, despite the differences of
Component-based Software Engineering (CBSE) and Reuse-oriented Software Engineering
(or simply ‘reuse’) in both technical as well as organisational dimensions, both approaches
are highly compatible, and one can benefit from using both approaches. Both paradigms have
the same business goals: increase productivity and quality. However, they subtly differ in their
approaches towards achieving these goals. CBSE approaches focus on improving productivity
by reduction of development time and by improving flexibility of systems. By contrast, reuse
based approaches emphasise cost reduction as a means of increasing productivity. To achieve
this, it avoids costs in projects through the use of artefacts resulting from previous projects, and
emphasise the dissemination of knowledge for sharing the subject of reuse within an organisa-
tion. As a result, despite the fact that it is possible to develop systems in a component-based



2.2 SOFTWARE ARCHITECTURE 9

style without doing reuse, components are independent units of composition and they are com-
monly considered a unit of reuse.

2.2 Software architecture

Not all componentware approaches [BDH+98] directly define software architecture concepts
that give concrete guidance to designers and architects. Approaches to software architecture
and componentware are overlapping. Both consider the structure, the composition and the
behaviour of software systems. In fact, the software architecture approach is an integral part of
an integrated componentware methodology [BHB+03].

One commonly used definition [BCK03] for software architecture is given below:

“The software architecture of a program or computing system is the structure or
structures of the system, which comprise software elements, the externally visible
properties of those elements, and the relationships among them.”

In this definition, the component notion is rather general and weak. A component can be
everything from a database engine to a class written in an object oriented programming lan-
guage. However, this definition gives some important implications. For instance, the definition
implies that every software system has an architecture, because every system can be shown to
be composed of elements and relations among them. In the most trivial, and uninteresting, case,
a system is itself a single element, and an architecture. More elaborate structures are desirable,
since recurring patterns on such structures might represent interesting quality attributes.

The architecture embodies information about how the elements relate to each other. Thus,
an architecture is foremost an abstraction of a system that suppresses details of elements that do
not affect how they use, are used by, relate to, or interact with other elements. The ‘externally
visible’ properties refer to those assumptions that other elements can make of an element,
such as its provided services, fault handling, shared resource usage, and so on. Architecture
is concerned with the public details; private details of elements (details that have to do solely
with internal implementation) are not architectural. For instance, the behaviour of each element
is part of the architecture since this behaviour can be observed or discerned from the point of
view of another element. This does not mean that the ‘exact behaviour’ of every element must
be documented in all circumstances; but to the extent that an element’s behaviour influences
how another element interacts with it and, furthermore, influences the system as a whole.

In the next sections, we discuss architectural characteristics of software components. In
Section 2.2.1 we present an overview of existing approaches for component-driven architec-
tures. It also discusses the benefits of separating computation (what a component does) and
coordination (how a component interacts with the external world) concerns in the architecture.
In Section 2.2.2, we show some general components aspects related to their interaction and,
furthermore, that are associated to component contracts (the ‘externally visible’ properties of a
component).



2.2 SOFTWARE ARCHITECTURE 10

2.2.1 Component models, technologies and frameworks

In commercial component technologies, such as Sun’s Enterprise JavaBeansT M [DK06] and
Microsoft’s COM+ [Mic11], a software component is taken as an implementation, ready to
execute, with well-defined interfaces that enable third-party composition (roughly, integration
with other components). The concept of component as implementation is a familiar one found
in the marketplace, and it is most often used by practitioners to refer to commercial off-the-shelf
(COTS) products.

In order to have an architectural constraint conscious design of software components, it is
necessary to merge such an implementation perspective with one that equates components as
design abstractions; this union is denoted architectural components [BBB+00]. This can be
achieved by bridging the gap between component technologies and software architecture.

COTS products may implement functionality and coordination in a way that is unique to
a product. On the opposite, architectures provide abstractions, which enable developers to
centre on the ‘big picture’ in developing a system, and provide means for analysing system
designs with respect to quality attributes. In contrast to ordinary implementations, architectural
components are required to implement a contract that prescribes how components may interact
or other architectural constraints. These contracts are constituent parts of a component model.
It is compliance with a component model that makes a component architectural.

In this context, component-based systems rely upon well-defined standards and conven-
tions (component model) and a support infrastructure (component framework). The component
model imposes design constraints on component developers, and the framework enforces these
constraints in addition to providing useful services, such as persistence and transactions.

In analogy to operating system, components are to frameworks what processes are to op-
erating systems. The framework manages resources shared by components, and provides the
underlying mechanisms that enable communication (interaction) among components. Many
examples of component frameworks can be seen in practice. For instance, the Enterprise
JavaBeansT M (EJB) [DK06] specification defines a framework of servers and containers to
support the EJB component model, with servers responsible for providing persistence, transac-
tion and security services while containers are responsible for managing component life cycle.

By imposing standards and conventions on component developers, component models can,
for instance, bring as a result a uniform composition method and appropriate quality attributes.
The former would result from imposing composition assumptions about what a component
must provide to or require from other in interaction, thereby reducing chances for accidental
mismatches that inhibit composition of components. The latter results from standardising the
types of component used in a system and their patterns of interaction, since it is consensual that
the quality attributes of a system will depend upon its software architecture. Closely related to
quality attributes is quality of service, which can also be obtained by specifying that patterns
of interaction are transactional, or encrypted, and so forth.

Software architecture techniques are usually either descriptive or formal. Descriptive ap-
proaches [Obj07, GMW00] provide diagram types for (graphically) representing static and
dynamic aspects. Formal ones [ADG98, HLL06b] are based on a well defined mathemati-
cal formalism, used to unambiguously express the basic building blocks and their relations
as well as their properties: component, interface, connector and configuration. Other ap-



2.2 SOFTWARE ARCHITECTURE 11

proaches [BHP06, RSM05] merge these techniques with notations hiding the underlying for-
malism to the user.

Description techniques only cover a small part of a componentware technology. Specially
UML [Obj07], in its newest 2.0 version, might just be observed as a vehicle to draw detailed
diagrams of software. This is also due to the fact that there is no formal model underlying the
semiformal UML notation.

Architecture Description Languages (ADLs) [MT00] are component-based techniques, in-
tended to describe software architectures, which typically subsumes a formal semantic the-
ory [MT00]. They differ from regular component technologies by making a system’s structure
explicit, distinguishing component computation from component interactions, and providing a
high-level model that can be manipulated and analysed before any changes are affected. More-
over, they impose design rules correlated to desirable quality attributes through component
types, patterns of interaction, and other constraints. In addition, ADLs typically distinguish the
following specifications:

• Component behavioural specification: ADLs are concerned with component functional-
ity. ADLs typically provide support for specifying both functional and non-functional
characteristics of components. Non-functional requirements include those associated
with safety, security, reliability, and performance. Depending on the ADL, timing con-
straints, properties of component inputs and outputs, and data accuracy may all be spec-
ified.

• Component protocol specification: Some ADLs [ADG98, PV02] support the specifica-
tion of relatively complex component communication protocols. Other ADLs [Sha95]
allow the type of a component to be specified (e.g., filter, process, etc.) which in turn
restricts the type of connector that can be used with it.

• Connector specification: ADLs contain structures for specifying properties of connec-
tors, where connectors are used to define interactions between components. In some
ADLs [BB04], connector specifications take the form of predicates, while in others
[ADG98], connector specifications are expressed as a first entity class.

Having components and connectors as it is possible to distinguish concerns about compu-
tation and coordination in system. In general (not limited to computer science), coordination is
defined as [MC94]:

The act of managing interdependencies between activities performed by entities in
order to achieve some goals.

The separation of concerns raises an awareness of the importance of managing dependen-
cies. For instance, the managers of a process often focus on how to manage activities. However,
if a critical dependency of a process is not managed well, the process’s efficiency and effective-
ness become low even if all activities in the process perform well [Lil03].

Coordination problems arise in the organisation of interactions of a group of entities that
collaborate and cooperate to accomplish some task and to satisfy some goals. It is because



2.2 SOFTWARE ARCHITECTURE 12

entities cooperate that they can accomplish more elaborated actions, but it is also because of
their multiplicity that they must coordinate their actions and resolve conflicts.

Basically, there are two different ways to realise a purpose into a solution: endogenously
or exogenously [PA98]. In the former, coordinating activities are spread over the many com-
ponents of the system. In the latter, the entire purpose is assigned to a specific entity, called in
general connector [MMP00, Spi04, AM02], which coordinates the components from ‘outside’.
The exogenous coordinators provide a better separation of concerns: they tend to coordinate
entities, rather than activities or data. Moreover, connectors separate computation from the
coordination itself; this simplifies system specification, understanding, construction, evolution
and validation of properties.

2.2.2 Software component contracts

As we have previously discussed, component contracts are vital constituting parts of a compo-
nent model. They represent the ‘externally visible’ properties of a component, which affects
how it uses, is used by, relates to, or interacts with other components.

In order to define which information belong to these contracts, we present in this section
four primary functional aspects of a software component [RM04]: (1) interface, (2) static be-
haviour, (3) dynamic behaviour, and (4) interaction protocol. Each of the four modelling as-
pects represents and helps to ensure different characteristics of a component. Moreover, the
four aspects have complementary strengths and weaknesses.

Interface modelling is the most frequently performed activity associated to component con-
tracts. It has become routine, spanning modern interface definition languages (IDLs) on
component technologies [Mic11, Obj08], ADLs [MT00], and general-purpose modelling
notations, such as UML [Obj07]. One primitive interface is composed of services that
represent data operations performed by one component on behalf of another component.
Composition at this level is performed matching interface names and services signatures
(names and their respective input/output parameter types). However, software modelling
solely at this level does not guarantee many important properties, such as interoperability
or substitutability of components: two components may associate vastly different mean-
ings with identical interfaces.

Static Behaviour modelling extends interface modelling on several approaches with static be-
havioural semantics [LW94, RG02, ZW97]. Such approaches describe the behavioural
properties of a system at specific snapshots in the system’s execution. This is done pri-
marily extending interfaces with state variables, invariants on these states, and pre- and
post-conditions associated with the interface operations. These techniques are successful
at describing what the state of a component should be at specific points of time. However,
they are not expressive enough to represent how the component arrives at a given state.

Dynamic Behaviour modelling suppress deficiencies associated with static behaviour models.
Modelling dynamic component behaviour results in a more detailed view of the compo-
nent and how it arrives at certain states during its execution. It describes the legal order-
ing of provided or required service calls of the component, considering all its interfaces.



2.3 FORMAL METHODS ON COMPONENTS 13

While this view of component modelling has not been practised as widely as interface or
static behaviour modelling, there are several notable examples of it. For instance, UML
has adopted a StateChart-based technique [Har87] to model the dynamic behaviours of
its conceptual components. Other variations of state-based techniques (e.g., FSM) have
been used for similar purposes [FG03]. Finally, some ADLs [ADG98, HLL06b] have
used process algebras to model dynamic behaviours of its components.

Interaction Protocol modelling focuses on legal protocols of interaction among components.
This view of modelling describes the legal ordering of services calls of a component at
its interaction point (using operation in the interface). Protocols can be observed as a
continuous external view of a component execution. Several techniques [ADG98, FG03,
PV02] for specifying interaction protocols have been developed. These techniques are
based on the same notations of dynamic behaviour techniques.

The four aspects complementary strengths and weaknesses, as well as their consistent treat-
ment in literature suggest the possibility of using the four modelling aspects in concert [RM04].
There is still much confusion about the difference of the above modelling views. In practice,
interfaces represent the operations of a component; static behaviour complements interfaces
with conditions about the execution of these operators; and, dynamic behaviour associates op-
erators to transitions among internal states of the component. Finally, protocols are associated
to the observable behaviour of the component.

As interfaces are the base of all other views, and are the most used one, interfaces are
sometimes used as a synonym of component contracts. However, the degree of detail of the
component contract depends of the characterisation of components in the system (this is related
to concept of component model in Section 2.2.1). This can have one of these elements, part
or all of them. Other elements might also be necessary in the component contract to represent
other needs. We use in this work the name interface to represent a set of operators (or events).
Protocols are observable behaviours of the component. If the behaviour is restricted to the one
observed via one of the ports, it is called port-protocol.

2.3 Formal methods on components

The formal method community has always been interested in issues of composition and modu-
larity and thus in component issues. The reason is obvious: when defining semantics or when
trying to prove properties of programs, modularity is a key issue. Hence a comprehensive body
of knowledge has been developed in foundational research.

This body of knowledge cannot be directly applied by the research community, however.
Specific components issues have to be understood, before being semantically mapped into for-
mal methods. This comprises questions of the description of components, in particular, of
their formal specification, formal modelling as well as the question of composition. From a
methodological point of view the most interesting question is certainly how to describe com-
ponent interfaces in a way such that components can easily be composed and in particular that
the behaviour and the properties of a composed system can be derived exclusively from the
specifications of the interfaces.



2.4 DESIDERATA FOR COMPONENT-BASED CRITICAL SYSTEMS 14

Reasoning on component-based system is directly associated with how components are
characterised in their component models, and furthermore with their contracts (see Section
2.2.2). As previously discussed, while practical component approaches mainly address inter-
operability at the signature level, the way to describe and reason on the interactive behaviour
of concurrent components requires that more elaborate functional aspects are present in the
components contracts.

In principle, there are quite different approaches to the modelling and contract specification
of components. One is the idea to model the component in a state-based view (static behaviour).
In that case we describe the interface of the component in terms of the state changes in which
the component is involved. A more practical technique for doing that was developed in object
orientation [Mey92, Mey97] under the term design by contract. Most of the work is this area
is more pragmatic and a careful comprehensive theoretic foundation of this approach is still
missing.

Also a number of other theoretical works in computer science implicitly addresses the no-
tion of a component. A lot of the theoretical work in modelling distributed concurrent sys-
tems implicitly has a concept of components. In particular, we select process algebras [Mil80,
Ros98], which focus on providing a high-level view on modelling of communication among
parallel processes. They study concurrent systems in terms of observable actions of the par-
ticular parts of the system (processes). Then, a system is described by forms of composition
between process and their algebraic properties. Some architecture description languages are
based on process algebras (such as Wright [AG97, ADG98] which is based on CSP [Ros98]).

2.4 Desiderata for component-based critical systems

The high quality development of critical systems is difficult. Systems, whose correct func-
tioning human life and substantial commercial assets depend on, need to be developed very
carefully. Systems that have to operate under the possibility of system failure need to be scru-
tinised to exclude possible weaknesses.

Part of the difficulty in developing critical systems is that correctness is often in conflict with
cost. Where accurate design methods pose high cost through personnel training and complexity
use, they are all too often avoided. Beyond the general arguments about savings by reuse, the
componentware approach offers an interesting, and fruitful, opportunity for high-quality critical
systems development that is feasible in an industrial context.

The componentware approach has the potential not only to reduce costs, but at the same
time to increase the quality of critical systems. This observation prompts some challenges,
pointed by [BHB+03], that one has to overcome to exploit this opportunity, which includes the
following:

1. Adaptation of an appropriate notion of component to critical system application domains.

2. Correct use of critical components in the system context and the application domain.

3. Conflict between flexibility and level of criticality guarantees when defining components.



2.4 DESIDERATA FOR COMPONENT-BASED CRITICAL SYSTEMS 15

Analysing the overview on componentware approaches presented in this chapter, we ob-
serve some insights about how to solve the above challenges.

Component Model: An appropriate notion of component for critical systems can be achieved
by defining a new component model. In this model, architecture should specifically omit
certain information about elements that are not related to their interaction, and reinforce
those that are. Furthermore, the full verification of interoperability issues and concur-
rency problems, such as deadlock, requires more than the limited static information in
interfaces. The behaviour is what allows elements to interact with each other, and it is
clearly an important part of the component model.

The complementary strengths and weaknesses of the aspects presented in Section 2.2.2,
as well as their consistent treatment in literature suggest [RM04] the possibility of us-
ing the four modelling aspects in concert. Moreover, the variety of verification purposes
suggests that some of these modelling aspects can also be discriminated at different lev-
els, when this is possible. For instance, protocols can represent the whole observable
behaviour of the component, or the behaviour associated to an interaction point (port) of
the component (with other components in the system); the latter is called port-protocol.
Port-protocols are not directly distinguished by the interfaces of the ports. For instance,
two ports might have behavioural equivalent port-protocols, but be associated to the same
interface.

Although it is interesting to distinguish connectors from components at design time, there
is no advantage in having such distinction at integration. The reason is that there are
no observable differences in their implementation, and a uniform composition strategy
is more suitable to systematic development approaches. For this reason, practical ap-
proaches [MB05] to describe software architectures usually describe connectors as pat-
terns of services with abstract and generic interfaces at the design phase, and then in-
stantiate these abstract connectors into concrete components when they are assembled to
components. This improves the reuse of connectors to mediate a wide variety of compo-
nents with different interfaces.

Constructive Constraints: To safely employ critical components within the system, a suitable
methodology for component-based construction of critical system is necessary . The
methodology must introduce critical concerns into the development activities, such that
quality attributes associated to one component (produced in-house or by a third party)
contributes to the quality of the entire system. This is an important issue, since com-
ponents are interesting reusable assets. Furthermore, the cost of exhaustive verifications
and validations in one component make it worth considering their reuse in multiple sys-
tems. To be consistent with this principle, quality attribute associated to a component
must be preserved, by construction, during the system evolution. Thus, in component-
based development, considerably more time is devoted to analysis and design activities.
In this context, two tasks draw more attention: component substitutions and composi-
tions. If constructive constraints are associated to the design activities, and satisfied at
development, components can be safely integrated and deployed.



2.4 DESIDERATA FOR COMPONENT-BASED CRITICAL SYSTEMS 16

Flexibility and Criticality: As problems are identified earlier, fewer costs are inflicted to the
development budget. For this reason, predicting the resulting quality attributes of com-
positions at design is more suitable than identify them at deployment, or after the system
has been built. A lightweight approach must focus on architectural abstractions, and
on properties amenable for compositional reasoning. Moreover, it must have a uniform
mathematical treatment that enables reasoning technologies. To successfully achieve this
goal, it is essential that the component model be co-dependent of a major design strategy,
which imposes rules to the target component technology, but which does not inhibit the
independent evolution of this technology. In fact, the approach would impose healthi-
ness conditions that a component must satisfy, and which can be implemented in most
component technologies.



CHAPTER 3

Specification and refinement of concurrent systems

This chapter concerns with laying the mathematical foundations for the thesis. The moti-
vation for such foundations is to unambiguously specify systems and analyse them with the
aim of anticipating possible omissions and errors introduced in the specification phase. More
precisely, the chapter introduces the process algebra CSP (Communicating Sequential Pro-
cesses) [Ros98], which is one of the formalisms that dominates the modelling and verification
of concurrent reactive systems.

Reactive systems typically consist of a number of agents which operate in parallel and
communicate with each other by means of message passing. Each agent in a reactive system
constantly communicates and interacts with its environment (other agents): it reacts to stimuli
from the environment (hence the adjective reactive). More broadly, CSP is used for describing
patterns of communication by algebraic expressions. These may be manipulated and trans-
formed according to various laws in order to establish important properties of the system being
described.

The chapter focuses on the features of CSP, as presented in [Ros98], necessary for under-
standing the specifications in this thesis. We start the chapter by giving an overview on the
field of process algebra, presenting the most important notations on this field and arguing the
choice of CSP as the formal notation of this work. The next sections introduce the key features,
syntax and the denotational semantic of CSP used throughout this thesis. While we introduce
the syntax, we describe how processes interact (sending and receiving messages) and present
the main operators (used in the thesis) for building large specifications. Related to the seman-
tics, we elaborate on the traces, stable failures and the failures/divergence model. A model
supplies a precise mathematical meaning to CSP processes, come with refinement notions, and
is consistent with the algebraic laws which govern them. We also discuss how each semantic
model is deployed for the verification of some interesting properties of concurrent systems. To
complement the syntax presented here, we list, in Appendix C, the syntax of CSP as used by
the model checker FDR, a tool that supports correctness analysis in CSP.

3.1 Process algebra

Process algebra is the branch of Computer Science which studies mathematical models of pro-
cesses, regarded as agents that act and interact continuously with other similar agents and with
their common environment [Hoa06]. A process refers to the behaviour of a system [Bae05]. A
system is anything showing behaviour, in particular the execution of a system, the actions of a
machine or even the actions of a human being.

17



3.2 CSP SYNTAX 18

In the last quarter century, several different process calculi have been constructed and ex-
plored; many of them owe their inspiration to the seminal work on CCS [Mil80], and others
have been based more on CSP [Hoa85]. Both, CCS and CSP have succeeded admirably in their
original aims to occupy the opposite extremes on almost any standard of comparison [Hoa06].

CCS, as well as its variants, is defined in terms of its operational semantics, while the CSP
approach [Hoa85, Ros98] has always been to regard behavioural models. Process Operational
semantic definitions of languages have the advantage that they are direct, understandable. On
the other hand, definitions, such in CSP, in abstract models, intended to capture the extensional
meaning of a program in some sense, have the advantage of ‘cleanliness’ and allow us to reason
about programs in the more abstract models.

Despite CCS and CSP still occupy extreme positions in all variations of process calculi, the
similarities across the whole range are far more significant than their differences [Hoa06]. And
for this reason, there are several efforts [HH10, Ros10] to unify the two modelling styles in
order to enable practicing engineers to exploit a combination of their complementary advan-
tages. Both works presented in [HH10, Ros10] aim that, in a different but equally valid sense,
CCS is a subset of CSP; that is a conclusion which does not require us to make any judgement
whether the subset is superior to the full set, or vice-versa. We might say that, in general, the
operators of CCS have elegant operational definitions, whereas the CSP operators have fairly
elegant denotational definitions.

He and Hoare [HH10] show that there is a retraction which projects every process of CCS
onto its closest approximation in the CSP subset. Using another strategy, [Ros10] defines what
means a CSP-like operational semantics, based on basic CSP operators plus an additional one,
needed to complete the general simulation result. It shows that not only CCS is CSP-like, but
also its variant ? -calculus [SW03]. These efforts to unify these modelling styles demonstrated
not only the power of CSP, but also the great elegance of CCS and the ? -calculus.

In this work, we use CSP, as defined in [Ros98], as our formal notation. The reason for using
CSP is that its denotational semantics has proved convenient for reasoning, and it provides the
main design concepts necessary for this work. The laws of CSP have been inspiring to prove
rules for components, as illustrated in this work.

Moreover, components are intrinsically black-box modules of the system. Thus any opera-
tor used to express its behaviour must make sense over a model in which details of individual
linear runs of the behaviour (process) are recorded by an observer who cannot, of course, see
internal actions (as the ? action present in CCS). Despite mobility, present in ? -calculus, being
a recurring notion in several studies of component architectures, its use is immaterial to the
scope of this work. Taken these reasons in consideration, CSP fits the necessary requirements
to underline the concepts and the strategy presented in this work.

3.2 CSP syntax

The basic idea of CSP concerns the communication between processes: communication takes
place over named channels and is synchronous. Communication is the only means of inter-
action between processes. On their turn, processes are defined in terms of a set of events ?,
which are the communication primitives. An event is a single, atomic, and instantaneously



3.2 CSP SYNTAX 19

occurring action that a process engages in. However, an event may still contain various pieces
of information, and, therefore, have some structure. A structured event is given by a communi-
cation channel which carries messages. In order to model values v being communicated along
a channel ch, each possible communication is described as a separate possible event ch.v in the
process. The declaration of a channel assumes the form:

channel ch : T1....Tn

In the expression above, ch is a name, and T1....Tn are types. So that, an event ev = ch.v1 ...vn
is consistent with this declaration if vi is of type Ti,1 ? i ? n; observe that n can also be zero.
Given some set of channels Ch, we write {|Ch|} to denote the set of events consistent with the
declaration of channels ch ?Ch. This notation is taken from FDR.

To help identifying the channels used in a trace, we define chans(t) as a function that takes
a trace t and returns the channels used within it.

chans(??) = /0
chans(?c.x?^ t) ={c}?chans(t)

. To illustrate our notions, we present the motivating example of a client-server interaction.
This is a version of the example presented in [RSM09]. However, for the sake of brevity, it is
slightly modified to focus on the discussion of the CSP notation. The original version of the
example [RSM09] is presented when we start to cope with notions related to component-based
systems (Section 5).

This example is used as a running example in this chapter and in the next one. The following
datatypes and channels are used in the example.

datatype DAT ASV = wd.Int|reqBal|ackW d.Bool|resBal.Int
datatype DAT AU S = insertCard.Int|enterPin.Int|withdraw.Int|balance|

takeCard|takeCash|takeSlip

channel cus : DAT AU S
channel csv : DAT ASV

As we focus on the interaction between the client and the server, we explain only the events
used in their communication: in the example, the events in DAT ASV are those used by the client
to interact with the server, and vice-versa. It contains the events for withdrawing money (tagged
with wd) and for requiring and receiving an account balance (tagged with reqBal and resBal,
respectively). These events use the (assumed) built-in data types Bool and Int to represent
boolean and integer values, respectively.

Besides primitives for communication (sending and receiving messages over channels),
represented by ?, two special actions are used to model executions of CSP processes: the
invisible action ? (modelling steps internal to a process) and the termination action X; these
events are, therefore, not observed by the environment. Altogether, they constitute the set of
actions Act = ?X,? = ??{?,X}.

Furthermore, a set of process names (or identifiers) PName is used for giving names to CSP
processes, which are used for declaring processes and during their specification to refer other



3.2 CSP SYNTAX 20

processes. CSP processes are usually evaluated in the context of a set of process equations with
the form:

Name = P

which associate processes with names; here, Name ? PName, and P is a process specification.
Moreover, the CSP language contains a large number of operators for building specifi-

cations (which are also processes) from already defined processes. The set LCSP of all CSP
process terms is generated by the following rules:

P ::= STOP %% Deadlock process

| SKIP %% Terminating process

| a ? P %% Prefix

| P 2 Q %% External choice

| P u Q %% Internal choice

|ua : A • f (a) %% Indexed internal choice
| 2a : A • f (a) %% Indexed external choice

| P ; Q %% Sequential composition

| P A?B Q %% Alphabetised parallel

| P?
A

Q %% Generalised parallel

| P ? Q %% Synchronous parallel

| P ||| Q %% Interleaving

| P \ A %% Hiding

| P[[R]] %% Renaming

| bool&amp;amp;P %% Boolean guard

| Name %% Process naming

Here, a ? ? is an event, A ? ? and B ? ? are set of events, R ? ?×? is a renaming relation upon
events, and bool is an boolean expression, and f ? ?×LCSP is a parametrised process that takes
an event and returns a process. The process name Name ? PName is an identifier which stands
for the definition of a process. This also allows for the definition of recursive processes.

Parameters can be used to represent aspects of the process state, and can appear in guards:
we write bool&amp;amp;P to denote the process that behaves as P if the boolean bool is true, and can per-
form no events otherwise. The atomic processes SKIP and STOP both denote termination; SKIP



3.2 CSP SYNTAX 21

denotes successful termination, whereas STOP denotes deadlock. SKIP does nothing except
indicate it has reached the end of a pattern of communication by performing the termination
event X. STOP is not capable of executing any event, not even termination. The most basic
operator is the prefix operator ; if P is a process and an event then a ? P denotes a process that
is initially ready to engage in a. If this event occurs, then subsequent behaviour will be that of
P.

There are two types of choice operators in CSP: one denoting internal choice and the other
denoting external choice. An internal (also called nondeterministic) choice is resolved between
the processes involved without reference to the environment (i.e. other processes running in
parallel), whereas an external choice may be influenced by the environment and is resolved by
the first event to occur. These operators each come in two forms: the binary operator; and the
choice over an indexed set of processes.

Processes can be composed sequentially: the process P ; Q first behaves as P and then,
if P successfully terminates (ends by a SKIP), behaves as Q. Alternatively processes can be
composed in parallel. We write the alphabetised P A?B Q to denote the process in which P can
perform only events in A, Q can perform only events in B, and they must simultaneously engage
in events in the intersection of A and B. So, it is conventional for the interface A of process P
to contain at least all of the events used in the definition of P. Similarly, B should contain all of
the events appearing in Q. Differently, the synchronised parallel P?

A
Q denote that P and Q can

evolve independently, but must synchronise on every event in the set A; the difference with the
alphabetized operator is that if both processes in P?

A
Q are allowed to communicate a particular

event a /? A, either P or Q can do a independently. In the generalised parallel P ? Q, P and Q
must synchronise in all events. In fact, it is an abbreviation for P A?B Q when A and B are the
alphabets of P and Q, respectively. In an interleaving parallel combination no synchronisation
is required; in the combination P ||| Q, the two processes evolve independently. In fact P ||| Q
is an abbreviation for P?

/0
Q. In all parallel and interleaves combinations, the process P and

Q must also agree on termination, even though the event does not appear explicitly in the
synchronisation sets A and B. This means that a parallel and an interleave combination does not
terminate until all of its components are terminated.

Finally, we introduce the hiding operator: P \ A is a process that behaves as P, except that
both the requirement to synchronise upon and the ability to observe events from the set A has
been removed. Regarding the renaming operator, P[[R]] is a process that behaves as P, except
that some events are replaced by others according to the renaming function R.

In our example, the client behaviour is formally written in CSP by the process CL as follows.

CL =cus.insertCard?num ? cus.enterPin? pin ?
(CLDRAW 2 CLBAL) ; cus!takeCard ?CL

CLDRAW =cus.withdraw?val ? csv!wd.val ? csv.ackWd?a ? cus!takeCash ? SKIP
CLBAL =cus.balance ? csv!reqBal ? csv.resBal?x ? cus!takeSlip ? SKIP

To help readability in our specification, we assume that a request event with an input parameter
takes the form ch.tag?x, where ch is the name of a channel and x acts as an input pattern, which
can be empty (as in the event balance) or with a variable (as in insertCard?num). The notation



3.2 CSP SYNTAX 22

ch!v is used for response events, where v is an expression. The data processing starts by acquir-
ing the card number from the environment using the channel cus. Next, the prefix operator (?)
states that the event cus.enterPin? pin takes place, representing the validation of the user token
and password. Then, CL offers two choices deterministically (2) : it engages either on the
events withdraw or balance, to withdraw money or to check the account balance, respectively.
Each of the alternative operations is started by the occurrence of the csv!wd or the csv!reqBal
event, and can be completed by the csv.ackW d?a or the csv.resBal?x event, respectively. The
events cus!takeCash, cus!takeCard and cus!takeSlip inform the user about the operation result
and finalisation.

Now we present the server, which provides bank services to the client. Syntactically, the
dynamic behaviour of the server is written in CSP as follows SV process.

SV = csv.wd?x ? (ua : Bool • csv!ackW d.a)? SV
2 csv.reqBal ? (uy : Int • csv!resBal.y)? SV

The process SV offers a deterministic choice (2) between a withdraw and a balance request,
which is represented by the occurrence of the communications csv.wd?x and csv.reqBal. After
receiving a withdraw or balance request, it internally decides (nondeterministic choice u) the
value of the withdraw acknowledgement (ackW d!a) and that of the balance response (resBal.y);
the nondeterministic choice is usually associated to abstract internal actions of the component,
which decides the value that is output.

The ATM system can be represent by the parallel composition of the client (CL) and server
(SV ), as illustrated below.

ATM = CL ?
csv

SV

In this example, the client (CL) can communicate with the user (through channel us) indepen-
dent of the server, but must synchronise with the server (SV ) on every event in the sv, which
represents their communication medium.

In addition to operators among processes, the CSP language has also operators among
traces, which are sequence of events. So, when reasoning about possible sequences of in-
teraction, we use these operators. In this work, will use filter (|? ) and hiding (\) operators
on sequences. Given a sequence s and a set A, the sequence s |? A is the longest subsequence
of s containing only elements from the set A. Conversely the sequence s \ A is the longest
subsequence of s containing no elements from the set A. There are also other operators over
sequences. The length #s of a sequence s is the number of elements it contains. The value of
#(s |? A) gives the number of occurrences of events from A in s. This will be abbreviated s ? A.
In the case where A is a singleton set a, the set brackets will be elided and s ? a will abbreviate
s ?{a}. Similarly, s |? a will abbreviate s |? {a}.

The account of the CSP language given here is incomplete. Only the core language has been
considered with certain ‘advanced’ operators omitted. The language described corresponds
to the modern version of CSP, as given in [Ros98], which differs slightly from the language
presented in [Hoa85].



3.3 CSP SEMANTIC MODELS 23

3.3 CSP semantic models

CSP offers a number of approaches to semantics. A process written in CSP may be understood
in terms of operational semantics (where the process is transformed to a labelled transition sys-
tem, with transitions representing communications); or in terms of algebraic semantics (where
properties of a process – such as equivalence to some other process – may be deduced by syn-
tactic transformations on the process text following a set of algebraic laws); or in terms of
denotational semantics (where the process corresponds to a value in some mathematical model,
typically a complete partial order or a complete metric space). The latter is the dominant one,
and of particular interest for our work.

In the next subsections we describe the three denotational models: traces, failures and
failures-divergences [Ros98].

3.3.1 Traces model

The traces model denotes a CSP process according to its traces, which are the set of sequences
of communications in which the process is willing to engage. Let A?X = ???{s ^?X?|s ? ??}
be the alphabet of communications. Formally in the traces model each process is identified by
a set T ?A?X that satisfies the following healthiness condition:

T1. T is nonempty and prefix-closed. This means that it always contains the empty trace ??
and if s ^t ? T then s ? T .

Given a CSP process P, the traces of P are denoted as traces(P). Table 3.1 reports the se-
mantic clauses of the basic processes in the traces model. STOP never communicates anything:
its set of traces consists only of the empty trace ??; the traces of an action prefix process are
the traces of the prefixed process P, each prefixed with the event a first communicated and the
empty trace added. In the clause of the prefix choice ?x : X ? P, which is the only way to in-
troduce a variable x, every free occurrence of x in the process P is syntactically substituted by
a communication. Details about the other constructors are presented in [Ros98].

As an example, let us consider the processes CLBAL presented in the last section. The trace
set of CLBAL is given by:

traces(CLBAL) ={??,?cus.balance?,?cus.balance,csv.reqBal?,
?cus.balance,csv.reqBal,csv.resBal.true?,
?cus.balance,csv.reqBal,csv.resBal. f alse?
?cus.balance,csv.reqBal,csv.resBal.true,cus.takeSlip?,
?cus.balance,csv.reqBal,csv.resBal. f alse,cus.takeSlip?}

A process C is a trace refinement of A if, and only if, it contains all traces within A.

Definition 3.1 (Traces refinement). Let P, Q be CSP processes. P is a trace refinement of Q,
written as Q vT P, if and only if: traces(P)? traces(Q).



3.3 CSP SEMANTIC MODELS 24

traces(STOP) ={??}
traces(SKIP) ={??,?X?}
traces(div) ={??}
traces(a ? P) ={??}?{?a?^ s|s ? traces(P)}
traces(?x : X ? P) ={??}?{?a?^ s|s ? traces(P)? a ? X}
traces(P ; Q) =(traces(P)???)?{s ^ t |s ^?X?? traces(P)? t ? traces(Q)}
traces(P 2 Q) =traces(P)?traces(Q)
traces(P u Q) =traces(P)?traces(Q)

traces(P?
X

Q) =
?
{s?

X
t |s ? traces(P)? t ? traces(Q)}

traces(P X?Y Q) ={s ? (X ?Y )?X |s |? X ?{X}? traces(P)? s |? Y ?{X}? traces(Q)}
traces(P ? Q) =traces(P)?traces(Q)

traces(P ||| Q) =
?
{s ||| t |s ? traces(P)? t ? traces(Q)}

traces(P \ X) ={s \ X |s ? traces(P)}
traces(P[[R]]) ={t | ?s ? traces(P)• s R?t}

Table 3.1 Semantic clauses for the traces model.

Two processes P and Q are traces-equivalent, P ?T Q, if P vT Q and Q vT P, i.e., traces(P) =
traces(Q). The process STOP is the most refined process in the traces model, i.e., P vT STOP for
all processes P.

The refinement notion in CSP (independent of the semantic model) has many properties
that can be exploited, for example it is transitive:

P v Q ? Q v S ? P v S

and monotone: if C[.] is any process context, namely a process definition with a slot to put a
process in, then

P v Q ?C[P]vC[Q]

The traces model is the weakest of the three denotational models of CSP that we consider.
In fact, the traces of internal and external choice are indistinguishable. This indicates that
traces(P) does not give a complete description of P, since we would like to be able to distinguish
between PuQ and P 2 Q. For example, the process a?SKIP guarantees that if the environment
is prepared to engage in the event a and then terminate, then it can engage in the event a and
terminate successfully. However, a?SKIPua?ST OP does not guarantee that it can engage in
the event a and terminate successfully if the environment is ready to engage in the event a and
terminates. The traces model identifies both processes as they have the same traces. However,
one of them guarantees that it will terminate successfully, but the other does not guarantee.



3.3 CSP SEMANTIC MODELS 25

In terms of verification, the traces model can be deployed for the verification of safety
conditions. That is, a process Q which is a trace refinement of a process P, will perform
traces already defined in P and nothing more, i.e., traces(Q) ? traces(P). Safety conditions
are concerned with the exclusion of traces only.

3.3.2 Stable failure model

The stable failure model F gives a finer information about processes. For instance, it allows us
to distinguish between internal and external choice (and much more). In particular, it allows
us to detect deadlocked processes. A failure of a process is a pair (s,X), that describes a set
of events X which a process can fail to accept after executing the trace s. The set X is called
the refusal set; the process cannot perform any event in the set X no matter for how long it is
offered.

The ’stable’ in the model name means that the sequences represented by s are those that
reach a stable state where no transition is chosen nondeterministically. In other words, stable
states are those in which there are no choices between external and internal actions. As an
example, let us consider the following processes over the alphabet {a,b}:

P =a ? ST OP 2 b ? ST OP
Q =a ? STOP u b ? STOP

The stable failure set of P and Q, denoted by failures(P) and failures(Q), are given by:

failures(P) ={(??,{X}),(?a?,X),(?b?,X)|X ?{a,b,X}}
failures(Q) ={(??,Y ),(??,Z),(?a?,X),(?b?,X)|X ?{a,b,X},Y ?{a,X},Z ?{b,X}}

Here, P and Q have different failures, i.e., the stable failure model F can distinguish between
internal and external choice. The failures of P records that initially (after the trace s = ??)
the process cannot refuse either a or b. The process Q has two initial invisible actions ? to
choose from. After performing them, it reaches stable states, where it can perform either a or
b separately, and refuse b or a respectively. The failure of Q does not record any information
about the initial state, but only information about the stable states.

Observe that it is by no means inevitable that every trace of a process has failure: it may
never stop performing ? actions. So, as not all traces of a process are present in its failures,
a process in the F model is represented not only by its stable failures, but also by its traces.
Formally, in the stable failures model, each process P is modelled by a pair (T,F), denoting
T = traces(P) and F = failures(P), where T ? ??X and F ? ??X×P(??X), satisfying the following
healthiness conditions (where s, t range over ?? and X ,Y over P(?X)):

T1. T is non-empty and prefix closed.

T2. (s,X)?F ?s?T . This asserts that all traces performed by the failures should be recorded
in the traces component T . In other words it establishes consistency between the traces
component and the failures component.

T3. s ^?X?? T ? (s ^?X?,X) ? F . If a trace terminates successfully by producing X, then it
should refuse all events in ?X at the stable state after s ^?X?.



3.3 CSP SEMANTIC MODELS 26

F2. (s,X)? F ?Y ? X ? (s,Y )? F . This asserts that in a stable state if a set X is refused, then
any subset Y of X should also be refused.

F3. (s,X)? F ? (?a : Y • s ^?a? /? T )? (s,X ?Y )? F . This asserts that if a process P can refuse
the set X of events in some stable state, then the same state must also refuse any set of
events Y that the process can never reach.

F4. s ^?X?? T ? (s,?) ? F . This asserts that if we have any terminating trace s ^?X?, these
should refuse ? at the stable state after s.

Similar to the trace semantics, the clauses in Table 3.2 determine the failures of the various
processes in the stable failure model F; the clauses in Table 3.1 are still valid for the traces of
process in F model. Since the parallel operators can all be defined in terms of the interface par-
allel operator ?

X
, we only have a formal need to give the definition for that one. The semantics

for the interleave and the synchronised parallel operator are shown, as an example are given
due to their importance to the work.

A process C is a stable failures refinement of A if, and only if, it contains all traces within
A and presents less stable failures; it refuses less communications.

Definition 3.2 (Stable failure refinement). Let P, Q be CSP processes. P is a stable failure re-
finement of Q, written as Q vF P, if, and only if: traces(P)? traces(Q)? failures(P)? failures(Q).

In other words, if every trace s of Q is possible for P and every refusal after this trace is
possible for P, then Q can neither accept an event nor refuse unless P does. Two processes P
and Q are stable failure-equivalent, P ?F Q, if P vF Q and Q vF Q, i.e., traces(P) = traces(Q) and
failures(P) = failures(Q). The bottom element in vF is (??X,??X×P(??X)), while its top element
is (??, /0).

An important phenomenon captured by F is deadlock. Deadlock is a phenomenon pertain-
ing to networks of communicating processes which occur when two processes cannot agree
to communicate with each other, thus the whole system becomes permanently frozen. This
is potentially catastrophic in safety-critical computing applications. A network that can never
exhibit deadlock is said to be deadlock-free.

In CSP deadlock is represented by the process STOP, which can perform only the empty
trace, and after the empty trace the process STOP refuses to engage in any event. In CSP, a
process P is considered to be deadlock free, if the process P after performing a trace s never
becomes equivalent to the process STOP.

Definition 3.3 (Deadlock-free process). A process P is deadlock-free in CSP if, and only if:

?s : ?? • (s,?X) /? failures(P)

This definition is justified, as in the model F the set of stable failures is required to be closed
under the subset-relation: (s,X) ? failures(P) ? Y ? X ? (s,Y ) ? failures(P). In other words:
Before termination, the process P can never refuse all events; there is always some event that P
can perform. Moreover, the stable failure refinement notion preserves the deadlock-freedom of
a process. That is, if P is deadlock free and P vF Q, then Q is deadlock free.

From the definition of deadlock-free, an interesting lemma about deadlock-freedom in par-
allel synchronizations is described below.



3.3 CSP SEMANTIC MODELS 27

failures(STOP) ={(??,X)|X ? ?X}
failures(SKIP) ={(??,X)|X ? ?}?{(?X?,X)|X ? ?X}
failures(div) =/0
failures(a ? P) ={(??,X)|a /? X}?{(?a?^ s,X)|(s,X)? failures(P)}
failures(?x : A ? P) ={(??,X)|A?X = /0}?

{(?a?^ s,X)| ? a ? A ? (s,X)? failures(P[a/x])}
failures(P ; Q) ={(s,X)|s ? ?? ? (s,X ?{X})? failures(P)}?

{(s ^t,X)|s ^?X?? traces(P)? (t,X)? failures(Q)}
failures(P 2 Q) ={(??,X)|(??,X)? failures(P)?failures(Q)}?

{(t,X)|(t,X)? failures(P)?failures(Q)? t 6= ??}?
{(??,X)|X ? ? ??X?? traces(P)?traces(Q)}

failures(P u Q) =failures(P)?failures(Q)

failures(P?
X

Q) =
?
{(s?

X
t,Y ?Z)|Y 8(X ?{X}) = Z8(X ?{X})?

(s,Y )? failures(P)? (t,Z)? failures(Q)}

failures(P ? Q) =
?
{(s?

X
t,Y ?Z)|(s,Y )? failures(P)? (t,Z)? failures(Q)}

failures(P ||| Q) =
?
{(s ||| t,Y ?Z)|Y 8{X}= Z8{X}?

(s,Y )? failures(P)? (t,Z)? failures(Q)}
failures(P \ X) ={(t \ X,Y )|(t,Y ?X)? f ailures(P)}
failures(P[[R]]) ={(t,X)|(?t? |(t?,t)? R? ? (t?,R?1(X))? failures(P)}

Table 3.2 Semantic clauses for the failures model.

Lemma 3.1. Let P and Q be divergence-free CSP processes. Then P ? Q deadlocks if, and only
if:

?(t,X) : failures(P) • (t,?8X)? failures(Q)

Proof. The proof of this lemma is mainly based on the semantics of the synchronised parallel
operator.

P ? Q is deadlock-free
??s : ?? • (s,?X) /? failures(P ? Q)
?[Semantics of the synchronised parallel operator]
?s : ?? • (s,?X) /?{(t,X ?Y )|(t,X)? failures(P)? (t,Y )? failures(Q)}

?[set theory, X ?Y = ?X ? ?X8X ?Y ]
?(s,X) : failures(P)• (s,?X8X) /? failures(Q)



3.3 CSP SEMANTIC MODELS 28

From the lemma above, it is possible to formulate an important observation about how
process should communicate in order to preserve deadlock-freedom: one process can never
refuses all events that the other can perform. For instance, consider that X is a maximum
refusal of P, then P can perform events within ?X8X . From the lemma above, in order to avoid
deadlock, Q cannot refuse such events.

3.3.3 Failure/divergence model

The failures/divergence model gives us the most satisfactory representation for analysing live-
ness and safety properties of a CSP process; it allows us to detect not only deadlocked, but also
livelocked processes. Furthermore, it has long been taken as the ‘standard’ model for CSP.

A process diverges, if it reaches a state from which it may forever compute internally
through an infinite sequence of invisible actions. This is clearly a highly undesirable feature
of the process, described by as ‘even worse than deadlock’ [Hoa85]. Livelock may invalidate
certain analysis methodologies, and is often caused by a bug in the modelling. However the
possibility of writing down a divergent process arises from the presence of two crucial con-
structs: hiding and ill-formed recursive processes. For instance, consider the processes P = P
and Q = (a ? Q) \{a}. Q converts the external event a into an internal action ? . Therefore, Q
indefinitely performs internal actions, which leads to a divergence. As a consequence, Q and P
have the same behaviour in the failures-divergences model. The CSP process div (the same of
Q, in our example) represents the livelock phenomenon: immediately, it can refuse every event,
and it diverges after any trace.

In the failures/divergence model, the processes are represented by two sets of behaviours:
the failures and the divergences. The divergences of a process are the finite traces on which the
process can perform an infinite sequence of internal (invisible) actions. So, each process P is
modelled by the pair:

(failures?(P),divergences(P))

where:

• failures?(P) is the set of all stable failures (s,X) (where s is a trace and X is a set of actions
that the process can refuse in some stable state – unable to perform ? or X – after s, or
results from state after s which can perform X and X ? ?), together with all the pairs of
the form (s,X) for s ? divergences(P).

• divergences(P) is the (extension-closed) set of traces s on which a process can diverge.

In such model, if s is a trace that process P can perform then either P diverges after s or reaches
a stable state or one that can perform X.

Formally the failures/divergences model is defined to be the pairs (F?,D) satisfying the
following healthiness condition, where s, t range over ??X X ,Y over P(?X):

F.1. traces?(P) ={t |(t,X)? F} is non-empty and prefix closed.

F.2. (s,X)? F ?Y ? X ? (s,Y )? F .

F.3. (s,X)? F ? (?a ?Y • s ^?a? /? traces?(P))? (s,X ?Y )? F .



3.3 CSP SEMANTIC MODELS 29

F.4. s ^?X?? traces?(P)? (s,?)? F .

D.1. s ? D??? ? t ? ??X ? s ^ t ? D.

D.2. s ? D ? (s,X)? F . This adds all divergences-related failures of F.

D.3. s ^?X? ? D ? s ? D. This ensures that we do not distinguish between how processes
behave after successful termination.

Similar to the previous models, the clauses in Table 3.3 determine the divergences of the various
processes in the failure-divergence model. The clauses for the traces and failures in this model
are similar to those presented in tables 3.1 and 3.2, but consider the divergences:

traces?(P) = traces(P)?divergences(P)
failures?(P) = failures(P)?{(s,X)|s ? divergences(P)}

Refinement in the failures/divergence model is given by the following relation.

divergences(STOP) =/0

divergences(SKIP) =/0

divergences(div) =??X

divergences(a ? P) ={??}?{?a?^ s|s ? divergences(P)}
divergences(?x : X ? P) ={??}?{?a?^ s|s ? divergences(P)? a ? X}
divergences(P ; Q) =divergences(P)?

{s ^ t |s ^?X?? traces?(P)? t ? divergences(Q)}
divergences(P 2 Q) =divergences(P)?divergences(Q)
divergences(P u Q) =divergences(P)?divergences(Q)
divergences(P?

X
Q) ={u ^ v| (?s : traces?(P),t : traces?(Q)|u ? (s?

X
t)??? ?

(s ? divergences(P)? t ? divergences(Q))}
divergences(P \ X) ={(s \ X)^ t |s ? divergences(P)}

?{(u \ X)^t |u ? ?w ? (u \ X)is finite ? (?s &amp;lt;u|s ? traces?(P))}
divergences(P[[R]]) ={s?^t |(?s ? divergences(P)??? |sRs?)}

Table 3.3 Semantic clauses for the failures-divergence model.

Definition 3.4 (Failures/divergences refinement). Let P, Q be CSP processes. P is a failures-
divergences refinement of Q, written as Q vFD P, if, and only if: failures?(P) ? failures?(Q) ?
divergences(P)? divergences(Q).



3.3 CSP SEMANTIC MODELS 30

Two processes P and Q are failures-divergences equivalent, P?FD Q, if PvFD Q and QvFD P,
i.e., failures?(P) = failures?(Q) and divergences(P) = divergences(Q). The process div is the least
refined process in the failures/divergence model. Then, a process is said to be free of divergence
(or livelock free) if after carrying out a sequence of events, its denotation is different from div.

As said before, it is consensual that the failures-divergences model gives us the most satis-
factory representation for analysing liveness and safety properties of a CSP process. However,
when we look into the mathematical theory of how divergences are calculated, it turns out that
seeing accurately what a process can do after it has already been able to diverge is very difficult,
and not really worth the effort [Ros98]. By combining traces with stable failures (which is in
fact the failures part of the failures-divergences model), it is possible to see beyond any diver-
gence by ignoring divergences altogether. Moreover, it is sometimes advantageous to analyse
a divergence-free process P by placing it in a context in which it may diverge as the result of
hiding some set of actions; this only works when the traces and stable failures in this context
are not influenced by these divergences.

For instance, the process P = (a ? P 2 b ? P) \{b} diverges in its initial state. The hiding
operation converts the external choice (2) into an internal choice (u). Therefore, the process
internally chooses between the external event a and an internal action resulted from hiding b. As
a consequence, P may indefinitely perform internal actions, which in the failures-divergences
model leads to divergence.

As we will see in the next section, in our formalisation of some notions, it is not convenient
that certain hidden events result in divergence. For example, our intention is that the communi-
cation protocols of divergence-free components are also divergence-free processes, even after
hiding all events not in the protocol interface.

Therefore, we assume in this work that basic components are divergence-free and deadlock-
free, and use the semantic models presented here in verifications to ensure that such problems
are not introduced in the system formed by these components. The failures model is used in
local analysis, in which the involved processes are divergent-free and the applied operators are
known for not introducing such a problem. The failures/divergence model is used in verifi-
cations about the compositionality of strategy proposed in this work, checking theirs traces,
failures and divergences.



CHAPTER 4

I/O processes and communication protocols

Naturally, specifications of a component behaviour at different abstraction levels are desirable,
depending on the circumstances. Taking the component in isolation, two kinds of behaviours
are commonly found in literature: protocol and port-protocol. The former represents the whole
behaviour of the component. The latter is a more specific kind of specification that focuses
solely on the interaction of the component with others within the system, each one individu-
ally; such behaviour is called port-protocol, or communication protocol. It is observed as a
projection of the entire component behaviour over a specific interaction point of the component
with the rest of system.

The notion of protocols is intrinsically related to components, but deserves its own area
of study. Due to its characteristics, protocols play an important role in the study of compo-
nent communications. Furthermore, the study of protocols is performed in detail in this chap-
ter, and is used as a basis for the next chapters. In our rigorous strategy, both protocols and
port-protocols are used, for instance, in local analysis of component interactions prior to their
composition, in order to give reliability to the development.

In this chapter we present notions related to protocols. In particular, the first notion de-
fined in this chapter is of I/O processes, which encompass the protocols and port-protocols;
in particular, port-protocol is a specific kind of I/O process. I/O processes differ from regular
processes by distinguishing input and output events, and establishing specific constraints about
these events (see Section 4.1).

Besides the protocol definition, a central definition in this chapter is of protocol compati-
bility, which states whether two port-protocols are ready to continuously communicate without
being stuck. Moreover, we present means to verify such compatibility both on synchronous
and asynchronous mediums. The notions related to protocols, including compatibility, are first
presented with a synchronous semantics in Section 4.2. These are lift to asynchronous commu-
nications in 4.3. In particular, we present notions related to buffer tolerance, which allow us to
analyse systems with asynchronous communications, but considering a synchronous semantics
and the absence of the possible buffers in this communication.

Although protocols and port-protocols are used to represent the behaviour of components,
this chapter studies these processes in isolation; the relation of these notions with other con-
stituting parts of a component contract is presented in the next chapter. To emphasise this
isolation, we assume protocols are regular I/O processes, and we call port-protocols of com-
munication protocols. The notion of component contracts, interfaces and ports are presented in
the next chapter.

31



4.1 I/O PROCESSES 32

4.1 I/O processes

In the following definitions we present each of the notions that underlie our definition for I/O
processes, presented in the end of this section.

A first notion is related to the fact that any datum communicated by a process P through a
channel c is considered as either an input or an output of P. Considering this, we call c an I/O
channel if there is a clear distinction between inputs and outputs communicated on it.

Definition 4.1 (I/O channels). We say a channel c is an I/O channel if there exists two functions,
inputs(c,P) and outputs(c,P), for every process P, such that

inputs(c,P)?outputs(c,P)?{|c|} ? inputs(c,P)?outputs(c,P) = /0 (4.1)

Commonly, inputs and outputs of a process partition the events of a channel c in two.
However, the process is not obliged to perform all events of c. So, we state that inputs(c,P)?
outputs(c,P)?{|c|}, instead of stating an equation. The functions input(c,P) and out put(c,P) are
defined declaratively, and must be given for each pair of process and channel. Such an implicit
definition of these functions is later constrained by syntactical elements explicitly presented in
the component contracts (see the notion of interfaces in the next chapter).

Based on the definition above, we are able to define input and output events of a process as:

Definition 4.2 (Process input and output events). Let P be a process that only uses I/O channels.
The inputs and outputs of P are determined by the following, equally named, functions inputs(P)
and outputs(P):

inputs(P) ={c.e|c.e ? inputs(c,P)} ? outputs(P) ={c.e|c.e ? outputs(c,P)} (4.2)

Note that the directions of the events are not explicit in the channel definition, but implicit
in the processes definitions. They must be given in order to state if a channel is an I/O channel.

In the client-server example presented in Section 3.2, the inputs and outputs of CL are
represented by the functions:

inputs(csv,CL) ={|csv.ackW d,csv.resBal|}
outputs(csv,CL) ={|csv.wd,csv.reqBal|}

The decision to choose an input event from a set of events is performed by the environment,
and to choose an output is performed internally; observe the pattern matching (represented
by the marker ‘?’) before all input events in CL, it exposes to the environment a choice over
multiple events.

The second notion corresponds to the idea that when a process P offers any input commu-
nication on c then it offers a choice to the environment.

Definition 4.3 (Input determinism). We say a process P is input deterministic if

?s ^ ?c.a? : traces(P)| c.a ? inputs(c,P)• (s,{c.a}) /? failures(P) (4.3)



4.1 I/O PROCESSES 33

The above statement defines that if P may perform a trace s ^?c.a?, whose last event is
an input, then this input event is not refused by P, after performing s. Therefore, if a set of
input events are offered to the environment, none of them are refused; an (external) choice
among the input events is offered to the environment. This property is based on the failures
semantics, which guarantees that if (s,{c.a}) /? failures(P) then there is no set (s,X)? failures(P)
such that c.a ? X . In fact it is very similar to the definition of deterministic process [Ros98],
except that it focuses solely on input events. Although Definition 4.3 does not explicitly refer
to the behaviour related to outputs events, it allows choices among input and output events.
According to the definition, whenever there is a choice among a specific input event and other
events (inputs or outputs) this will be an external choice.

Input determinism is a property that is preserved under paralelism, as we show in the theo-
rem below.

Theorem 4.1 (Input determinism compositionality). Let P and Q be input determinist pro-
cesses, and C a set of channels, such that ? P?? Q ?{|C|} and P ?

{|C|}
Q is deadlock-free. Then

P ?
{|C|}

Q is input deterministic with respect to all inputs of P and Q, excepting those within C.

Proof. The proof of this theorem is performed by contradicting the statement that P ?
{|C|}

Q is

input deterministc. From Definition 4.3:

?u ^ ?a? : traces(P ?
{|C|}

Q)| a ? inputs(c,P ?
{|C|}

Q)? a /?{|C|}• (u,{a})? failures(P ?
{|C|}

Q)

?[Traces of P ?
{|C|}

Q]

?s : traces(P),t : traces(Q),a : (inputs(P)?inputs(Q))8{|C|}|
(s ^ ?a?? traces(P)? t ^ ?a?? traces(Q))? (s ?

{|C|}
t,{a})? failures(P ?

{|C|}
Q)

?[a /? ? P?? Q, P and Q are input deterministic]
?s : traces(P),t : traces(Q),a : (inputs(P)?inputs(Q))8{|C|}|
((s,{a}) /? failures(P)? (t,{a}) /? failures(Q))? (s ?

{|C|}
t,{a})? failures(P ?

{|C|}
Q)

?[Failures of P ?
{|C|}

Q]

?(s,Y ) : failures(P),(t,Z) : failures(Q),a : (inputs(P)?inputs(Q))8{|C|}|
((s,{a}) /? failures(P)? (t,{a}) /? failures(Q))?Y 8{|C|}= Z8{|C|}?{a}= Y ?Z

?[({a}= Y ?Z)? (Y 8{|C|}= Z8{|C|})? a /?{|C|}?Y ={|a|}? Z ={|a|}]
?s : traces(P),t : traces(Q),a : (inputs(P)?inputs(Q))8{|C|}|
((s,{a}) /? failures(P)? (t,{a}) /? failures(Q))? (s,{a})? failures(P)? (t,{a})? failures(Q)

?[Contradiction]
false



4.1 I/O PROCESSES 34

In the next definition, we state some constraints related to output events. It states that if a
process can make an output on c, then it can offer no choice of values for the input process (or
the environment) to select from.

Definition 4.4 (Strong output decisiveness). We say a process P is strong output decisive if:

?s ^ ?c.b? : traces(P)|c.b ? outputs(c,P)• (s,outputs(c,P)) /? failures(P)?
(s,outputs(c,P)8{c.b})? failures(P)

(4.4)

The statement in the definition above says that the process does not provide an (external)
choice among its output events to the environment (or other processes it communicates with).
All choices among output events are internal. Besides, in the definition above, we state output
decisiveness based only on maximum failures (all outputs within c except c.b – represented
by (s,out puts(c,P)8{c.b})), the other failures (whose refusals are subsets of these ones) are
implicit in the definition; according to the failures theory, ?X |X ? out puts(c,P)8{c.b}• (s,X)?
failures(P). The strong output decisiveness property presented here is equivalent to the equally
named property presented in [Ros05b], if we consider that channels communicate exclusively
either input or outputs.

Strong output decisiveness is a property that is preserved under paralelism, as we show in
the theorem below.

Theorem 4.2 (Output decisiveness compositionality). Let P and Q be output decisive pro-
cesses, and C a set of channels, such that ? P?? Q ?{|C|} and P ?

{|C|}
Q is deadlock-free. Then

P ?
{|C|}

Q is output decisive with respect to all outputs of P and Q, excepting those within C.

Proof. The proof of this theorem is performed by contradicting the statement that P ?
{|C|}

Q is

output decisive. From Definition 4.4, the proof can be divided in two parts:

1. ?s ^ ?c.b? : traces(P)|c.b ? outputs(c,P)• (s,outputs(c,P)) /? failures(P)

2. ?s ^ ?c.b? : traces(P)|c.b ? outputs(c,P)• (s,outputs(c,P)8{c.b})? failures(P)

The proof of the first part can be performed similarly to the proof of Theorem 4.1. Furthermore,
we focus on the proof of part 2, which starts by contradicting this statement for the process
P ?
{|C|}

Q.



4.1 I/O PROCESSES 35

?u ^ ?c.b? : traces(P ?
{|C|}

Q)| c.b ? outputs(c,P ?
{|C|}

Q)? c /?C •

(u,outputs(c,P ?
{|C|}

Q)8{c.b}) /? failures(P ?
{|C|}

Q)

?[Traces of P ?
{|C|}

Q]

?s : traces(P),t : traces(Q),c.b : (outputs(P)?outputs(Q))|c /?C ?
(s ^ ?c.b?? traces(P)? t ^ ?c.b?? traces(Q))? (u,outputs(c,P ?

{|C|}
Q)8{c.b}) /? failures(P ?

{|C|}
Q)

?[Failures of P ?
{|C|}

Q]

?s : traces(P),t : traces(Q),c.b : (outputs(P)?outputs(Q))|c /?C ?
(s ^ ?c.b?? traces(P)? t ^ ?c.b?? traces(Q))?
6?(s,Y ) : failures(P),(t,Z) : failures(Q)|Y 8{|C|}= Z8{|C|}?
(outputs(c,P)?outputs(c,Q)8{c.b}) = Y ?Z

?[c.b /? ? P?? Q, P and Q are output decisive]
?s : traces(P),t : traces(Q),c.b : (outputs(P)?outputs(Q))|c /?C ?
(({|c|}? ? P ? (s,outputs(c,P)8{c.b})? failures(P)?
6?(s,Y ) : failures(P),(t,Z) : failures(Q)|Y 8{|C|}= Z8{|C|}? (outputs(c,P)8{c.b}) = Y ?Z)?

({|c|}? ? Q ? (t,outputs(c,Q)8{c.b})? failures(Q)?
6?(s,Y ) : failures(P),(t,Z) : failures(Q)|Y 8{|C|}= Z8{|C|}? (outputs(c,Q)8{c.b}) = Y ?Z))

?[(Y ?Z)?{|c|}? (Y 8{|C|}= Z8{|C|})? c /?C ?Y = Z]
?s : traces(P),t : traces(Q),c.b : (outputs(P)?outputs(Q))|c /?C ?
(({|c|}? ? P ? (s,outputs(c,P)8{c.b})? failures(P)? (s,outputs(c,P)8{c.b}) /? failures(P))?
({|c|}? ? Q ? (t,outputs(c,Q)8{c.b})? failures(Q)? (t,outputs(c,Q)8{c.b}) /? failures(Q)))

?[Contradiction]
false

Altogether the input determinism and strong output decisiveness notions indicate how a
process offer outputs and accept input events. They are not simple behaviour properties,
however, it is relatively straightforward to formulate refinement checks for them in the style
of [Ros05a, Ros05b].

Theorem 4.3. A process P is input deterministic and output decisive with respect to all it
channels if, and only if:

• P[[Ro]] is deterministic

• ?c : chans(P)• P \ (? P8outputs(c,P))?F ((P ?
outputs(P)

RU NFU NC({|c|}C R))\ ? P)[[R?1]]



4.1 I/O PROCESSES 36

where Ro is a surjection that maps all outputs associated to a channel c of P into a distinct event
not used by P, R is a bijection from outputs of P into events not used in P, and RU NFU NC(R) =
2a : dom R • a ? R(a)? RU NFU NC(R).

Proof. The proof of the theorem above is straightforward, since the statements were written to
represent the input determinism and output decisiveness properties. We divide the proof in two
parts.
1) In the first part, we proof the equivalence between the first statement in the theorem above
and that the process P is input deterministic and at least one output is offered, when there is a
choice among outputs.

?s ^ ?c.a? : traces(P)| (c.a ? inputs(c,P)? (s,{c.a}) /? failures(P))?
(c.a ? outputs(c,P)? (s,outputs(c,P)) /? failures(P))

?[the outputs events of P are not distinguished in the statement]
?s ^ ?c.a? : traces(P[[Ro]])| (c.a ? inputs(c,P)? (s,{c.a}) /? failures(Pc))?

(c.a = oc ? (s,oc) /? failures(P[[Ro]]))
?[the definition of deterministic processes in [Ros98]]

P[[Ro]] is deterministic

2) The alphabet of the processes in the two sides of the refinement relation are within outputs(P),
since we hide the inputs of P in the process on the left and the alphabet of the process on the
right is the domain of the function R.

It is easy to see that for every communicated output c.o in P there is a subsequent commu-
nicated event in RU NFU NC(R) that is represented by the function R(c.o). Furthermore, the traces
of both processes in the refinement relation are equal.

traces(P \ (? P8outputs(c,P))) = traces(((P ?
outputs(P)

RU NFU NC({|c|}C R))\ ? P)[[R?1]])

Furthermore, we focus on the failures equivalence between these processes. For the sake of
brevity, we consider S = P ?

outputs(P)
RU NFU NC({|c|}C R). From the behaviour of the process S, we

observe that:

?s ^ ?c.b? : traces(S)|c.b ? ran R • (s,? P8{c.b})? failures(S)

So, hiding the alphabet of P, and applying the renaming R?1], we can state the following.

?s ^ ?c.b? : traces((S \ ? P)[[R?1]]) • (s,? P8{c.b})? failures((S \ ? P)[[R?1]])
?[P \ (? P8outputs(c,P))?F (S \ ? P)[[R?1]]]
?s ^ ?c.b? : traces(P \ (? P8outputs(c,P))) • (s,? P8{c.b})? failures(P \ (? P8outputs(c,P)))

?[semantics of hiding]
?s ^ ?c.b? : traces(P)|c.b ? outputs(c,P) • (s,outputs(c,P)8{c.b})? failures(P)

Based on the proof above, we show that if a process satisfies the conditions of the Theorem 4.3,
then it is input deterministic and output decisive, and vice-versa.



4.2 COMMUNICATION PROTOCOLS 37

Based on the definitions above, we are able to define I/O processes.

Definition 4.5 (I/O process). We say P is an I/O process if:

• whenever c.x ? ? P, then c is an I/O channel;

• P has infinite traces;

• P is divergent-free;

• P is input deterministic;

• P is strong output decisive.

In addition to the two properties already presented (input deterministic and output deci-
siveness), we assume that I/O processes are divergent-free and have infinite traces. Although
these processes have infinite traces, we consider, for practical purposes in model checking, that
these processes have finite state-spaces. Moreover, we require that the use of hiding, bijective
renaming and parallel operators on I/O processes that do not introduce divergence, automati-
cally result in I/O processes (that is, they are conservative with respect to the I/O definition).
These assumptions are related to the focus of this work on presenting a systematic strategy for
component construction. Moreover, as we shown in Theorem 4.3, it is easy the check whether
an arbitrary process is an I/O process in a model checker, such as FDR.

These processes represent a wide variety of computational systems. Only the process itself
can control its outputs; non-determinism exists only in the outputs of the process, which do not
offer any choice to the environment. The process CL presented earlier is an example of an I/O
process: all traces ended by input events are not refused, while decisions about which output is
performed are internal.

4.2 Communication protocols

Communication protocols are commonly associated to specifications of component behaviours
at a specific abstraction level, with an exclusive focus on a portion of the communicated events.
Despite its relation with components, these protocols are also studied apart to analyse the com-
munications through a channel. For homogeneity, we consider communication protocols as
regular I/O processes. However, we show the relationship between protocols and more com-
plex I/O processes, which encompass such communication protocols.

Definition 4.6 (Communication protocol). We say a CSP process P is a communication proto-
col if :

• ?c1,c2 • inputs(P)?{|c1|}? outputs(P)?{|c2|};

The definition above says that a communication protocol is an I/O process that inputs solely
by a unique channel (c1, for instance) and outputs solely by a unique channel (c2, for instance).
These channels can be the same, or be distinct channels (one channel for each direction). Note



4.2 COMMUNICATION PROTOCOLS 38

that any protocol that inputs and outputs via one channel has an isomorphic counterpart with
two distinct channels, and vice-versa. We use protocols with one channel in the examples of
this work, since we consider they might be associated to more complex analysis.

In the client-server example, we can identify two protocols in the communication between
the client and the server: one from the point of view of the client, and, the other, from the point
of view of the server. These are the processes ProtCL and ProtSV , respectively.

ProtCL = (uval : Int • csv!wd.val ? csv.ackW d?a ? ProtCL)
2 (csv!reqBal ? csv.resBal?x ? ProtCL)

ProtSV = (csv.wd?x ?ua : Bool • csv!ackW d.a ? ProtSV )
2 (csv.reqBal ?uy : Int • csv!resBal.y ? ProtSV )

The inputs and outputs of these processes are implicit in their specification. These are:

outputs(ProtCL) = inputs(ProtSV ) ={|csv.wd,csv.reqBal|}
inputs(ProtCL) = outputs(ProtSV ) ={|csv.ackW d,csv.resBal|}

These are the inputs and outputs that client and server use to interoperate. As observed above,
the outputs of one process is the same set of the inputs of the other. This syntactical requirement
is not enough to ensure compatibility (two processes interoperate without deadlock). It might
be necessary to verify the behaviour of the processes in the interaction. Moreover, two pro-
cesses can successfully interoperate with different sets of inputs and outputs (one can accepts
more input events then those output by the other). A detailed study on this topic is presented in
the next section.

As communication protocols are essentially used for the study of interactions within a sys-
tem, we assume that they do not have any traditional errors, such as deadlocks. Additionally,
as a communication protocol is an I/O process, it is also divergence free by definition. This,
however, does not forbid the study of communication over unreliable mediums. In this context,
for instance, IP (the Internet Protocol) would be a protocol that is used in an unreliable medium
(internet).

Note that communication protocols can be defined solely by their traces and their sets of
inputs and outputs. This means that there is only one communication protocol for a given set
of traces, input and output events.

For the sake of brevity, we use in this section the notion: IsP and O
s
P for the inputs and

outputs performed by a process P after a trace s, respectively.

IsP ={a : inputs(P)|s ^?a?? traces(P)} (4.5)
OsP ={a : outputs(P)|s ^?a?? traces(P)} (4.6)

Below, we present failures of a communication protocol, based on the input determinism and
output decisiveness properties. They say that all possible enabled inputs cannot be refused, at
most one output is enabled and, if it exists, is never refused.



4.2 COMMUNICATION PROTOCOLS 39

Theorem 4.4. Let P be a communication protocol. Then

failures(P) ={(s,X)|s ? traces(P)? X ? ?8IsP ? (O
s
P = /0 ? O

s
P * X)}

Proof. Based on Definition 4.6, there are, at most, two channels in a communication protocol
c1 and c2: one for inputing, and another for outputting. Based on the input determinism and the
output decisiveness properties, (s,X)? failures(P) if, and only if, s ? traces(P) and:

?s ^?c1.a? : traces(P)|c1.a ? inputs(c1,P)•{c1.a}* X ?
?s ^?c2.b? : traces(P)|c2.b ? outputs(c2,P)• outputs(c2,P) * X ? (outputs(c2,P)8{c2.b})? X

?[based on the IsP and O
s
P definitions, and considering outputs(c2,P) = outputs(P)]

?a : IsP • (s,{a}) /? X ??b : O
s
P • outputs(P) * X ? (out puts(P)8{b})? X

?[no event within IsP belongs to X ]
X ? ?8IsP ??b : O

s
P • outputs(P) * X ? (s,out puts(P)8{b})? X

?[if OsP is nonempty, then X does not contains all events within O
s
P]

X ? ?8IsP ? (O
s
P 6= /0 ? O

s
P * X)

?[rewriting]
X ? ?8IsP ? (O

s
P = /0 ? O

s
P * X)

The theorem above says that the behaviour of a communication protocol can be determined
by its traces, or, more specifically by the inputs and output offered after each trace. Based on
this, we could say, relaxing the restrictions of the CSP language, and for the sake of under-
standing, that the behaviour of a communication protocol P after a trace s is always an external
choice of its inputs and one of its outputs, if it exists, after s, as represented by the process TP(s)
below.

P =TP(??)

TP(s) =(2a : IsP ? TP(s ^?a?))

2

(ub : OsP ? TP(s ^?b?))
Naturally, it is desirable to relate communication protocols and more complex I/O processes,

with more than just one channel for input or output. For this, we use the basic notion of
projection.

Definition 4.7 (Projection). Let P be a process, and C a set of communication channels. The
projection of P over C (denoted by P |? C) is defined as:

P |? C = P \ (?8{|C|})



4.2 COMMUNICATION PROTOCOLS 40

Projections restrict the behaviour of a process to a set of events. It behaves as the hiding of
all events, except from those within C. For the sake of brevity, when C is singleton, we consider
an overloaded version of the operator |? to accept a channel name instead of the singleton set
containing such a channel name. This operator also overloads the filter operator |? for traces,
which has a similar semantics, but expects a trace instead of a process.

Obviously, communication protocols are very similar to projections over the events of a
unique channel (or two channels, considering that one performs solely inputs and the other
outputs). However, in this case, we should ignore possible divergences introduced by the re-
striction.

Based on the definition of communication protocols, we have two related and distinct con-
cepts: implementing a protocol (Protocol Implementation) and satisfying a protocol (Protocol
Satisfaction).

Definition 4.8 (Protocol implementation). Let P be an I/O process, and ch a communication
channel. The communication protocol, namely ProtIMP(P,ch), implemented by P over ch is a
protocol that satisfies the following property:

ProtIMP(P,ch)?F P |? ch

The protocol implemented by a component (represented solely by a process at this point)
is given by the abstraction of its behaviour projection over a specific channel. Moreover, the
protocol has the same traces and failures as the projection, but it is divergent-free. We use the
failures semantics here, since we ignore the possible divergences introduced by the restriction.

Communication protocols focus on their own events, and ignore other events which do not
pertain to the communication. Protocol implementations are usually associated to the commu-
nication of a single channel, and ignore events of other channels. Infinite sequences of internal
actions are ignored because of the inability of communication protocols to distinguish them
from events of other ports. Therefore, analyses of communication protocols are limited in this
work to divergent-free processes. The prevention of divergences is analysed in this work using
other techniques, presented in the end of this chapter.

Generalising the definition above, we now define whether a process satisfies a protocol.
Such a protocol is a given behaviour that satisfies its communication over a channel.

Definition 4.9 (Protocol satisfaction). Let P be an I/O process, ch a communication channel,
and Q a communication protocol. The communication of P over ch satisfies the protocol Q, if,
and only, if:

Q vF ProtIMP(P,ch)

Protocol satisfaction is an important notion in some architectures, since they may have a
restriction about the communication protocols a process must satisfy in order to communicate
with others.

Finally, we say two protocols are equivalent if they are isomorphic.

Definition 4.10 (Equivalent protocols). Let P and Q be protocols, and R a bijection of events in
the alphabet of P into events in the alphabet of Q. Then P is equivalent to Q if, and only if:

P[[R]]?F Q



4.2 COMMUNICATION PROTOCOLS 41

Protocol equivalence is an important notion in systems verification, where expected transla-
tions are performed by the medium. This happens for instance, marshalling and unmarshalling
data communications in a network.

4.2.1 Protocol compatibility

The idea of protocol compatibility is about checking the relation of two connected processes
in a network, verifying whether any communication problem (such as deadlock) is introduced
after their composition (considering, for instance, that they are deadlock-free). As the name
might suggest, the analysis is based on local verification, focusing solely on the communication
protocols. As communication protocols use a unique channel to communicate its inputs or
outputs, the analysis of communication protocol synchronisations is simpler than the analysis
of complex I/O processes. For this reason, the analysis of protocol compatibility is an effective
way of ensuring that the communication between two I/O processes is deadlock-free, as we
exploit in the next chapters.

Before presenting the compatibility notion for protocols, a relevant concept is required:
conjugate protocols. It is a syntactic property that states the outputs of a process are understood
as inputs of another. It is commonly used as a prior verification step in order to check if two
protocols are compatible.

Definition 4.11 (Conjugate protocols). Let P and Q be two communication protocols. P and Q
are conjugate if, and only if:

outputs(P)? inputs(Q) ? outputs(Q)? inputs(P)
outputs(P)?outputs(Q) = /0 ? inputs(P)?inputs(Q) = /0

The term conjugate is used in modelling notations, like UML-RT [SR98], to assume that
two interfaces have the same set of signal, but events with inverted directions (if an event is
defined as an input in an interface, it is an output in the other interface). Here, we generalise
this concept to a behavioural specification, protocols. Moreover, conjugate protocols may have
sets of events with different cardinalities.

Based on these concepts, we can define the important notion of compatible protocols: pro-
tocols whose communication (resulting from their synchronisation) is deadlock-free, based on
the syntactic concept of conjugate protocols.

Definition 4.12 (Protocol compatibility). Let P and Q be two deadlock-free communication
protocols, such that P and Q are conjugate. The protocols P and Q are compatible (denoted
P ? Q) if, and only if:

?s : traces(P)?traces(Q)• (OsP 6= /0 ? O
s
P ? I

s
Q)? (O

s
Q 6= /0 ? O

s
Q ? I

s
P)

The definition above relates the communication of the two communication protocols P and
Q, in order to avoid possible deadlocks in their communication. Definition 4.12 focuses on the
possible traces the two processes synchronise, saying that there must always be an output event



4.2 COMMUNICATION PROTOCOLS 42

to be performed, and at least one of the process must have all enabled outputs accepted by
the other process; the fact that protocols are conjugate just reinforce that they perform output
events within the vocabulary understood by the other process.

Besides the wide application of the definition above, sometimes it is useful to have a
stronger notion of compatibility that requires that the outputs of a process are always accepted
by the process it communicates with. In fact, systems that consider this stronger notion are
considered to have better designs. Using the stronger notion, no information generated (an
output) by a process is leaked; all of them are understood by its peer in the communication.

Definition 4.13 (Strong protocol compatibility). Let P and Q be two deadlock-free communi-
cation protocols, such that P and Q are conjugate. The protocols P and Q are strong compatible
(denoted P??Q) if, and only if:

?s : traces(P)?traces(Q)• (OsP 6= /0 ? O
s
Q 6= /0)? O

s
P ? I

s
Q ? O

s
Q ? I

s
P

The definition above is very similar to the one for protocol compatibility. However it subtly
additionally says that the outputs of each process must be accepted by the other, in all scenarios.
This stronger notion is more widely accepted, and demanded in practical systems.

In the example of the client-server communication, the protocols ProtCL and ProtSV are com-
patible. In every state, after performing an event, the outputs of one protocol are accepted by
the other. This is requirement for that client and server interoperate without deadlock.

The theorem below shows the inherent relation between protocol compatibility and dead-
lock-freedom in our component model.

Theorem 4.5. Let P and Q be two deadlock-free conjugate protocols. Then P ? Q is deadlock-
free if, and only if, they are compatible.

Proof. This theorem is a direct consequence of Lemma A.1 and the Deadlock Rule 1, presented
in [Ros98], which says that any tree topology system free of strong conflict is deadlock-free;
strong conflicts are states in which two components have no choice of communicating with rest
of the system, and they cannot establish a communication between them.

The system structure P ? Q has a tree form; no cycle is presented. Moreover, according to
the Lemma A.1, compatible protocols are free of strong conflicts. As a result, according to
Deadlock Rule 1, the pair of processes is deadlock-free.

Details about the relations of compatible protocols and the work of [Ros98] are presented
in Appendix A.

Despite the relationship between deadlock-freedom and protocol compatibility in our com-
ponent model, we need a test characterisation to perform simpler verifications on regular model
checkers, such as FDR; a candidate strategy for this test characterisation is through refinement
checking, which is supported by some model checkers, including FDR. Because of its prac-
tical appeal, we focus the definition of the test characterisation of protocols that are strong
compatible.



4.2 COMMUNICATION PROTOCOLS 43

4.2.1.1 Verifying compatibility via process refinement

A testing characterisation of this notion via refinement can be defined upon a special process,
called dual protocol [VVR06]. We define the dual of a protocol Q as a process whose sets of
inputs and outputs are equal to outputs(Q) and inputs(Q), respectively, and which has the same
set of traces.

Definition 4.14 (Dual protocol). Let P be a deadlock-free communication protocol. The dual
protocol of P is defined as a deadlock-free communication protocol DP, such that:

inputs(P) = outputs(DP)? outputs(P) = inputs(DP)? traces(DP) = traces(P)

Based on this, we could say, relaxing the restrictions of the CSP language, and for the sake
of understanding, that the behaviour of the dual protocol DP of P after a trace s is always an
external choice of the outputs and one of the inputs of P, if it exists, after s, as represented by
the process T DP(s) below.

Q =T DP(??)

T DP(s) =(ua : IsP ? T DP(s ^?a?))
2

(2b : OsP ? T DP(s ^?b?))

In the client-server example, the dual protocol of ProtCL is represented by the process DProtCL
below. Observe that it is equivalent to ProtSV , in the example.

DProtCL = (2val : Int • csv.wd.val ? (ua : Bool • csv.ackW d?a ? DProtCL))
2 (csv.reqBal ? (2x : Int • csv.resBal?x ? DProtCL))

Similarly to the definition of protocol implementation, we can define the dual protocol associ-
ated to a specific channel.

Definition 4.15 (Dual protocol implementation). Let P be a communication protocol. The dual
communication protocol of P is named ProtDUAL(P).

Based on the Definition 4.14, an interesting observation can be made. Communication pro-
tocols are compatible to their dual protocols. Having the same traces of P, the dual protocol is
the compatible process with most similar structure. In fact, it can be used to guide implemen-
tations that wish to communicate with P. Observing the definition above, a systematic way to
obtain the dual protocol of a protocol P is by replacing internal choices by external choices, and
vice-versa, within P. This strategy allows implementations that communicate with the protocol
to decide how they provide these inputs.

Lemma 4.1. Let P be a deadlock-free communication protocol, and DP its dual protocol. Then
P and DP are strong compatible.



4.2 COMMUNICATION PROTOCOLS 44

Proof. This proof follows directly from definitions 4.14 and 4.13. We start the proof by a true
statement.

?t : traces(P)• IsP ? I
s
P ? O

s
P ? O

s
P

?[P is deadlock-free]
?t : traces(P)• (OsP 6= /0 ? I

s
P 6= /0)? I

s
P ? I

s
P ? O

s
P ? O

s
P

?[Definition 4.14, OsP = I
s
DP, I

s
P = O

s
DP]

?t : traces(P)?traces(DP)• (OsP 6= /0 ? O
s
DP 6= /0)? O

s
DP ? I

s
P ? O

s
P ? I

s
DP

?[Definition 4.13]
P and DP are strong compatible

From the notion of dual protocol, we are able to state that, for a given process P: any
process Q more deterministic than the dual protocol of P is also compatible with P.

Lemma 4.2. Let P and Q be deadlock-free communication protocols, and DP the dual protocol
of P, such that DP vF Q. Then P and Q are strong compatible.

Proof. The lemma above follows directly from Lemma 4.1, since if Q refines the dual protocol,
then Q can substitute it in all possible scenarios. Based on Lemma 4.1:

?s : traces(P)?traces(DP)• (OsP 6= /0 ? O
s
DP 6= /0)? O

s
P ? I

s
DP ? O

s
DP ? I

s
P

?[traces(Q)? traces(DP)]
?s : traces(P)?traces(Q)• (OsP 6= /0 ? O

s
DP 6= /0)? O

s
P ? I

s
DP ? O

s
DP ? I

s
P

?[failures(Q)? failures(DP) and protocols are input deterministic, IsDP = IsQ ? OsP]
?s : traces(P)?traces(Q)• (OsP 6= /0 ? O

s
DP 6= /0)? O

s
P ? I

s
Q ? O

s
DP ? I

s
P

?[failures(Q)? failures(DP) and protocols are output decisive,
OsQ ? O

s
DP, O

s
DP 6= /0 ? O

s
Q 6= /0]

?s : traces(P)?traces(Q)• (OsP 6= /0 ? O
s
Q 6= /0)? O

s
P ? I

s
Q ? O

s
Q ? I

s
P

?[Definition 4.13]
P and Q are strong compatible

Analysing the lemma above, we observe that in any state, determined by trace s, Q must
accept the same number of inputs and a number of outputs less or equal to the dual protocol of
P. Any process that satisfies this property can substitute the dual protocol, which is the default
implementation compatible to P. This notion reminds the covariance of operation results in
programming languages.

As previously mentioned, the protocols ProtCL and ProtSV are compatible. In this example,
they satisfy the refinement ProtSV v DProtCL.

This test characterisation, defined in terms of refinement, can be mechanically carried out by
the FDR model checker. However, the refinement checking captured by Theorem 4.1 cannot be



4.2 COMMUNICATION PROTOCOLS 45

directly applied to verify all possible compatible protocols. The reason is that some protocols
may accept more inputs than necessary in a communication, and despite being compatible
with a protocol P, they do not refine its dual protocol. In other words, we need a notion that
comprises both the contravariance of inputs and covariance of outputs. This can be done using
a mechanism that restricts the events communicated to the ones used by the communication
protocol, similar to what happens when the protocols communicate in practice.

A useful process to help in verification would be a deadlock-free process that represents
all possible communications between a protocol P and another process compatible with it. We
call this process communication context of P. To define this process we need to consider the
protocol P, and another that represents a protocol compatible with it. By Theorem 4.1 the
natural candidate is a dual protocol DP. As the input events of P are outputs of DPP, we need
only to specify the communication context process with respect to P.

Definition 4.16 (Communication context process). Let P be a deadlock-free communication
protocol. The communication context process of P (denoted by CTXP) is defined as a deadlock-
free deterministic process, such that traces(CTXP) = traces(P).

Similarly to the definition of protocol implementation, we can define the communication
context process associated to a specific channel.

Definition 4.17 (Communication context process implementation). Let P be a communication
protocol. The communication context process of P is named CTX(P).

A systematic way to define the communication context process of P is by using external
choice for all outgoing transitions in states of P. All events must be written in the form ch?data,
where ch is the name of a channel in the interface and data is an identifier to hold possible data
values associated with the interface.

Based on this, we could say, relaxing the restrictions of the CSP language, and for the sake
of understanding, that the behaviour of the context process CT XP of P after a trace s is always
an external choice of the outputs and inputs of P after s, as represented by the process T CP(s)
below.

CT XP =T CP(??)

T CP(s) =(2a : IsP ? T DP(s ^?a?))

2

(2b : OsP ? T DP(s ^?b?))

The definition of a communication context process allows us to restrict proofs concerning
communication via a specific protocol. Based on it, we are able to state the following lemma.
Its proof follows directly from the fact that the context process of a process P is a deterministic
process with the same trace as P; as a consequence, no event performed by P is refused by its
context process.



4.2 COMMUNICATION PROTOCOLS 46

Lemma 4.3. Let P be deadlock-free a communication protocol, DPP its dual protocol, and CTXP
the context process of P. Then CTXP satisfies:

P ?F P ? CTXP ?
DPP ?F DPP ? CTXP

Proof. This lemma follows directly from the semantics of parallel operators, see Section 3.3.2.
We focus on the first equivalence; the proof of the second follows a similar strategy.

traces(P ? CTXP) = traces(P)?traces(CTXP)?
failures(P ? CTXP) ={(t,X ?Y )|(t,X)? failures(P)? (t,Y )? failures(CTXP)}
?[traces(P) = traces(CTXP), failures(CTXP)? failures(P)]

traces(P ? CTXP) = traces(P)?traces(P)?
failures(P ? CTXP) ={(t,X ?Y )|(t,X)? failures(P)? (t,Y )? failures(P)}

?[failures theory]
traces(P ? CTXP) = traces(P)?
failures(P ? CTXP) = failures(P)}

?[equivalence in the failure model]
P ?F P ? CTXP

From Theorem 4.5, for protocol compatibility, and from Lemma 4.3, for communication
context process, we are now able to construct a stronger test characterisation for protocol com-
patibility based on refinement, which can be verified in the model checker FDR.

Theorem 4.6. Let P and Q be two deadlock-free conjugate protocols. Then, P and Q are strong
compatible if, and only if:

ProtDUAL(P)vF Q ? CTX(P)

Proof. The proof has two parts, each corresponding to one implication direction in the theorem.
1) We start by proving that ProtDUAL(P)vF Q ? CTX(P) implies in P??Q.

The first statement of the proof comes directly from the definition of dual protocols. For
the sake of brevity, consider in the proof DP = ProtDUAL(P).

?s : traces(P)?traces(DP)• (OsP 6= /0 ? O
s
DP 6= /0)? O

s
P ? I

s
DP ? O

s
DP ? I

s
P

?[traces(Q ? CTX(P))? traces(DP), traces(Q ? CTX(P)) = traces(Q)?traces(CTX(P)),
traces(CTX(P)) = traces(P)]

?s : traces(P)?traces(Q)• (OsP 6= /0 ? O
s
DP 6= /0)? O

s
P ? I

s
DP ? O

s
DP ? I

s
P

?[failures(Q ? CTX(P))? failures(DP) and protocols are input deterministic, IsDP = I
s
Q ? O

s
P]

?s : traces(P)?traces(Q)• (OsP 6= /0 ? O
s
DP 6= /0)? O

s
P ? I

s
Q ? O

s
DP ? I

s
P

?[failures(Q ? CTX(P))? failures(DP), OsQ ? O
s
DP, O

s
DP 6= /0 ? O

s
Q 6= /0]

?s : traces(P)?traces(Q)• (OsP 6= /0 ? O
s
Q 6= /0)? O

s
P ? I

s
Q ? O

s
Q ? I

s
P

?[Definition 4.13]
P and Q are strong compatible



4.3 BUFFERING 47

2) The second part concerns the proof that P??Q implies that ProtDUAL(P)vF (Q ? CTX(P)).

?(s,X) : failures(CTX(P)? Q)• true
?[Failures semantics, P ? Q is deadlock-free ? CTX(P)? Q is deadlock-free]
?(s,X) : failures(CTX(P)? Q)•

s ? traces(Q)?traces(CTX(P))? X ? ?8(IsQ ? O
s
P)? (O

s
Q 6= /0 ? O

s
Q * X)

?[P??Q, OsP ? I
s
Q]

?(s,X) : failures(CTX(P)? Q)•
s ? traces(Q)?traces(CTX(P))? X ? ?8OsP ? (I

s
Q 6= /0 ? I

s
Q * X)

?[Definition 4.16]
?(s,X) : failures(CTX(P)? Q)•

s ? traces(CTX(P))?traces(P)? X ? ?8OsP ? (I
s
Q 6= /0 ? I

s
Q * X)

?[Lemma 4.4]
?(s,X) : failures(CTX(P)? Q)• (s,X)? failures(ProtDUAL(P))

Considering the two results above, we conclude the proof of the theorem.

The theorem is informally explained by the observation of the two processes: ProtDUAL(P)
and Q ? CTX(P). As ProtDUAL(P) is a protocol, it is deadlock-free and an I/O process. And so
is the process Q ? CTX(P). From Lemma 4.4, in order to satisfy the refinement, Q ? CTX(P)
must have the same inputs and less or equal outputs than ProtDUAL(P). The role of CTX(P) in
the synchronism is to restrict the events performed by Q, as a consequence Q has more or the
same number of inputs than ProtDUAL(P). Moreover, Q must have less or equals outputs than
the dual protocol, in order to Q ? CTX(P) be output decisive. As a consequence, considering
the complementary directions of the events in P and in its dual protocol, the processes Q and P
have the requirements to the strong compatible.

Theorem 4.6 presents an important test characterisation for protocol compatibility, which
plays an important role in the verification of component compositions. All elements in the test
(protocols, dual protocols and context processes) are usually provided at integration time, or
can be easily derived from the protocols, as previously shown.

This concludes our compatibility notions for individual communication protocols. A dis-
cussion about networks of I/O is performed in the next sessions.

4.3 Buffering

In this work we focus on the interoperation of asynchronous systems, which is an important
issue on real concurrent systems. This brings a new concern in analysis of deadlock freedom:
how we can check if two processes can interoperate in asynchronous systems. Moreover, we
are concerned how this can scale this verification, and if we bring our previous notions about
protocol compatibility in synchronous systems (which is the communication semantics of CSP
processes) to this context.



4.3 BUFFERING 48

In the next section, we present how asynchronous communication of I/O processes is spec-
ified via buffers. In Section 4.3.2, we study the analysis of systems with asynchronous com-
munications, as if their communication were synchronous. Moreover, we link our notion of
protocol compatibility with the idea of buffer tolerance, and we introduce a new notion of
buffering self-injection compatibility, which allows us to assembly two channels of a process
via a buffer, without introducing deadlocks.

4.3.1 I/O buffers

A classical definition of an (one place) buffer in CSP (as presented in [Ros98]) is of a process
with one input channel and one output channel (left and right, say) both of which have the same
type. The buffer copies information from its input channel to its output channel, preserving
order and without loss, and such that it never refuses to output an item it contains and will not
refuse to input when empty.

More formally, any buffer satisfies the following specification [Ros98]:

(i) All a buffer does is input on left and output on right. It correctly copies all its inputs to its output
channel, without loss or reordering.

(ii) Whenever it is empty (i.e., it has output everything it has input) then it must accept any input.

(iii) Whenever it is non-empty, then it cannot refuse to output.

Here, we make a slightly change to generalise the notion of buffers, and ease the mapping
of events in the two sides of the buffer. Instead of left and right channels, we assume they
are distinct sets of events; more precisely, the domain and the range of a bijection called LR.
For instance, the simplest example of a buffer process, the process COPY , could be written as
follows:

COPY (LR) =?x : dom LR ? LR(x)? COPY(LR)

where LR ={le f t.x 7? right.x|x ? T}
This can be easily translated into a specification in terms of failures and divergences. For

any buffer B:

1. divergences(B) = /0

2. s ? traces(B)? s ? (dom LR?ran LR)? ? s ? ran LR ? s ? dom LR

3. (s,X)? failures(B)? s ? ran LR = s ? dom LR ? X ?dom LR = /0 ? (s,ran LR)? failures(B)

4. (s,X)? failures(B)? s ? ran LR &amp;lt;s ? dom LR ? ran LR * X

Note that the specification above translates the general specification of buffers presented
earlier (items i, ii and iii) in terms of failures and divergences; it is also similar to the specifica-
tion of buffers with left and right channels presented in [Ros98]. The operator s ? X returns the
cardinality of events within X in the trace s, and it is used to specify states of the buffer (like
empty and non-empty).



4.3 BUFFERING 49

Another example is a buffer process which, unlike COPY , does not insist upon outputting
one thing before inputting the next. It represents an infinity buffer B?.

B?(LR) = B???(LR) =?x : dom LR ? B
?

?x?

B?
s ^?y?(LR) = (?x : dom LR ? B

?

?x?^ s ^?y?(LR))

2(LR(y)? B?s (LR))

We can also imagine a buffer of arbitrary Bn(LR) size as the pipeline of several one-place
buffers COPY (LR).

Bn(LR) = COPY (LR)?LR COPY (LR)?LR ···?LR COPY (LR)

The operator ?LR is a new chain operator that instead of using left and right, takes LR into
consideration:

P ?LR Q = (P[[RM]] ?
mid

Q[[LM]])\ mid

where LR, RM and LM are bijections and mid is a set of events, such that (? P?? Q)? (dom LR?
ran LR), (dom LR?ran LR) = /0, (dom LR?ran LR)?mid = /0, ran RM = mid, ran ML = mid, dom RM =
ran LR, and dom LM = dom LR.

The new chain operation is as simple as the original one [Ros98]; it renames events of both
processes to an intermediary set of events (mid) and synchronise them on this set. For the sake
of brevity, we consider that mid is an arbitrary set of events unused by the processes. LR is used
as a reference to all other arbitrary bijections, used for the renames.

In all buffer specifications, events within left and right are associated to a definite direction:
input and output, respectively. However, it is possible to define similar constructions which
convey information in both directions. Instead of the traditional definition of buffer with left and
right, we specify a bidirectional buffer parametrised by an ordinary buffer and two bijections.

BUFFIO(BF,LR1,LR2) = (BF(LR1) ||| BF(LR2))

For the sake of brevity, we consider BUFF1IO and BUFF
?
IO as the following process:

BUFF1IO(LR1,LR2) =BUFFIO(COPY,LR1,LR2)

BUFFnIO(LR1,LR2) =BUFFIO(B
n,LR1,LR2)

BUFF?IO(LR1,LR2) =BUFFIO(B
?

??,LR1,LR2)

4.3.2 Buffer tolerance

An important issue on real concurrent systems is the ability of verifying them without buffers.
The main reason is the reduction in state-space that this brings in the verification of asyn-
chronous communications, usually modelled by buffers. Related to this is the term buffer tol-
erance [Ros05b], which refers to systems into which buffers may be introduced onto their
channels without introducing any extra error. So, certain properties of buffer tolerant systems



4.3 BUFFERING 50

can be analysed in the absence of buffers, considering a synchronous semantics. And, later on,
these properties are still valid in analogue systems (with buffers introduced onto their channels)
with asynchronous semantics.

We use in this work the notions of buffer tolerance as a strategy to analyse systems with
asynchronous communications, as if their communication were synchronous (which is the com-
munication semantics of CSP processes). In addition to the work [Ros05b], we present here
compatibility notions for systems interoperate in mediums with asynchronous communication.
Furthermore, we link our notion of protocol compatibility with the idea of buffer tolerance, and
we introduce a new notion of buffering self-injection compatibility, which allows us to assem-
bly two channels of a process via a buffer, without introducing deadlocks. Other notions that
support this strategy are also presented by demand.

As established in [Ros05b], the idea of confluent processes [Mil89, Ros06] is a useful tool in
the area of buffer tolerance. Using them, we are able to establish properties of buffered systems
by checking their buffer-less analogues. A process or computation is said to be confluent if,
whenever a state has two alternative actions ? and ? , then performing either of them does not
preclude the other and furthermore performing them in either order leads to equivalent states.

Formally, a process P is confluent if P s=? Q1 and P
t

=? Q2 then there exists R with Q1
t?s
=? R

and Q2
s?t
=? R where s?t is the trace consisting of s with the events of t deleted according to

multiplicity from the beginning. For example:

?a,b,c,c,b,a???d,c,b,a,c?= ?b,a?

Consider a bag BAG2 = {d 7? 1,c 7? 2,b 7? 1,a 7? 1} from the multiplicity of the events in
the sequence SEQ2 = ?d,c,b,a,c?. Delete events of SEQ1 = ?a,b,c,c,b,a? from events of SEQ2,
according to multiplicity from the beginning, is the same of, for each pair (ev 7? n) in BAG2,
delete the first n events ev of SEQ1, as shown in the statement above.

Moreover, a set of traces is said to be confluent if it satisfies the following (apparently
weaker) property [Ros05b]:

• Consider T as the set of traces of a process P. P is confluent if whenever s ^?a?^ t and
s ^?b? (with a 6= b) are both in T , so is s ^?b,a?^(t ??b?).

To help the use of the notion of confluence in a broader range of systems, we relax its
definition a little, distinguishing only choices among input or output events. We call such a
loose confluence an I/O confluence.

Definition 4.18 (I/O confluence). Let P be an I/O process. Then P is I/O confluent if and only
if :

?s ^?c1.a?^ t,s ^?c2.b? : traces(P)|c1.a 6= c2.b •
(c1.a ? inputs(P)??i : inputs(P,c1)|s ^?c2.b,i?^(t ??c2.b?)? traces(P))?
(c1.a ? outputs(P)??o : outputs(P,c1)|s ^?c2.b,o?^(t ??c2.b?)? traces(P))?
(c1 = c2 ? ({c1.a,c2.b}? outputs(P)?{c1.a,c2.b}? inputs(P)))

The notion above retains most of the useful properties of confluent process. However, it
considers the specificities of I/O processes. It also does not consider if the event performed



4.3 BUFFERING 51

is an input or an output. In other words, a process is said to be I/O confluent if, whenever a
state has two alternative actions ? and ? , then performing either of them does not preclude
the other, unless it is a choice among inputs or outputs of the same channel. If ? is an input,
then performing ? does not preclude the process offering all inputs offered together with ? . If
? is an output, then performing ? does not preclude the process offering at least one output
offered together with ? . Outputs are treated differently because their decisions are internal to
the process, and, furthermore, performing an event may preclude outputs of happening in the
future. As a result, instead of alternative actions leading to equivalent states in I/O confluent
processes, they lead to ‘less-deterministic states’, where fewer outputs can be offered.

In the example of the client-server communication, the processes CL and SV are two exam-
ples of I/O confluent processes. They are categorised in the simplest case, in which there is no
choice among events of different channels, neither choices among inputs and outputs.

Observe that I/O confluent processes are similar to channel-confluent processes [Ros05b],
which are processes whose data component abstractions is also confluent; this result also ap-
plies to the case where there are specific channels for inputs and outputs. This relates this loose
notion of confluence to the study performed by [Ros05b]. Moreover, I/O confluence states that
the communication of pending outputs is not interfered by input provisions, and vice-versa. In
such aspect, they remind function agents [Ros05b]. This ensures, for instance, that when an
input and an output are simultaneously offered in a channel, whenever the decision is made,
these events are eventually performed by the process. In other words, pending outputs or a
choice among inputs are not denied; they are just postponed.

Theorem 4.7. Let P be a process, {c1,...cn} the set of channels used in P, {ai1,ao1,...ain,aon}
a set of events, and R a bijection, such that R = { j, b| j ? 1...n ? b ? inputs(P,c j) • (b 7? ai j)}?
{ j, b| j ? 1...n ? b ? outputs(P,c j)• (b 7? ao j)}. Then the process P is I/O confluent if the process
P[[R]] is confluent.

Proof. The Lemma above is a direct consequence of the definition of confluent and of I/O
confluent processes..

?s ^?c1.a?^t, s ^?c2.b? : traces(P)|c1.a 6= c2.b •
c1.a ? input(P)? c1.a ? outputs(P)

? [P[[R]] is confluent]
?s ^?c1.a?^ t, s ^?c2.b? : traces(P)|c1.a 6= c2.b •

(c1.a ? inputs(P)? ((?i : inputs(P,c1)|s ^?c2.b,i?^(t ??c2.b?)? traces(P))?
c2.b ? inputs(P,c1)))?

(c1.a ? outputs(P)? ((?o : outputs(P,c1)|s ^?c2.b,o?^(t ??c2.b?)? traces(P))?
c2.b ? outputs(P,c1)))

? [rewriting]
?s ^?c1.a?^ t, s ^?c2.b? : traces(P)|c1.a 6= c2.b •

(c1.a ? inputs(P)??i : inputs(P,c1)|s ^?c2.b,i?^(t ??c2.b?)? traces(P))?
(c1.a ? outputs(P)??o : outputs(P,c1)|s ^?c2.b,o?^(t ??c2.b?)? traces(P))?
(c1 = c2 ? ({c1.a,c2.b}? outputs(P)?{c1.a,c2.b}? inputs(P)))



4.3 BUFFERING 52

The work presented in [Ros05b, Ros06], presents a test characterisation of confluence,
by checking if placing inwards buffers of size one from the environment to a process P, the
resulting process is deterministic.

Theorem 4.8. The process P is confluent if, and only if, the process C?[P], in which a one-place
inwards-pointing buffer is placed on every individual event of P, is deterministic.

Proof. Details about the proof of this theorem can be obtained in [Ros05b].

This is a consequence of confluence processes being deterministic that , by combining them
using restrict constructors, result in confluent processes [Ros06]. The relation of confluent
processes and their synchronisation with inwards buffers makes quite a subtle observation about
the nature of communication by confluent processes, and their relation with the buffer tolerant
notion.

The theorem above shows a test characterisation that is completely characterised by deter-
minism under a particular sort of transformation; as a consequence, checking whether a process
is confluent is feasible in FDR. Details about the C?[P] process are explained in [Ros05b].

Another important notion, required in communication through infinite buffers, is the finite
output property (FOP). It states that a process P cannot perform an infinite number of outputs
without an input.

Definition 4.19 (Finite output property). Let P be an I/O process, and C the set of channels
used in P. P satisfies the finite output property (FOP) if, and only if, for all c ? C the process
P \ outputs(P,c) is divergence-free.

As an I/O process is divergence-free, the absence of divergences after hiding the outputs
of a certain channel guarantees that the process always communicate a finite number of out-
puts. Based on this property, we are able to introduce buffers in a system without blocking the
communication; processes that do not satisfy FOP may infinitely produce events to the buffers
without being able to consume them.

Below, we show the relevance of such properties on the communication of protocols.

Theorem 4.9. Let P and Q be two deadlock-free I/O confluent communication protocols with
distinct alphabets, BF a deterministic buffer, and LR1 and LR2 two bijections, such that:

1. P and Q satisfy FOP;

2. LR1 : outputs(P)? inputs(Q) and LR2 : outputs(Q)? inputs(P);

3. P[[LR1]]??Q[[LR2]].

Then the synchronization of P and Q via a buffer BF is deadlock-free.

P ?
? P

BUFFIO(BF,LR1,LR2) ?
? Q

Q



4.3 BUFFERING 53

Proof. The proof of this theorem is based on the theory of confluent processes, and their abil-
ity to be buffer tolerant [Ros05b]. Besides confluence, another weaker notion, called channel
confluence has this property. Channel confluent processes are processes whose pattern of com-
munication is independent of which data is sent, and abstracting such data this pattern obeys the
confluence property. Buffer tolerant systems have the property of preserving deadlock freedom
after buffers are introduced into its internal channels.

Similarly to channel confluent processes, I/O confluent processes are buffer tolerant. The
reason is that any communication protocol P has an equivalent protocol P? with two channels,
one for communicating inputs and the other for outputs; this is obtained from a simple bijective
renaming. If P is I/O confluent, then P? is channel confluent. Similarly, the process Q has an
analogue protocol Q? that is channel confluent. A synchronisation of P? and Q? is buffer tolerant,
and having an equivalent behaviour, so is the synchronisation of P and Q.

Given these considerations, we start our proof by the following statement, based on the
Theorem 4.5. Consider, for a given process S, INS = inputs(S) and OU TS = outputs(S).

P[[LR1]]? Q[[LR2]] is Deadlock-free
?[P and Q are equivalent to channel confluent processes]
(P ?

OU TP
BF(LR1)) ?

INP?INQ
(Q ?

OU TQ
BF(LR2)) is Deadlock-free

?[? BF(LR1)?? BF(LR2) = /0]
P ?

INP?OU TP
(BF(LR1)) ||| BF(LR2)) ?

INQ?OU TQ
Q is Deadlock-free

?[according to definition of BUFFIO, P and Q are I/O processes ]
P ?

? P
BUFFIO(BF,LR1,LR2) ?

? Q
Q is Deadlock-free

The theorem above shows that two confluent and compatible protocols that satisfy FOP can
communicate in an asynchronous medium, represented by infinite buffers, without deadlock.
More important, all these properties can be verified without taking infinite buffer into account,
and, furthermore, avoiding the state explosion on model checkers usually related to it.

Note that this theorem can be applied to establish an asynchronous communication between
the client and the server, in our example. As previously mentioned the protocols CL and SV are
strong compatible. They also satisfy FOP and allow a bijection between their alphabets.

4.3.3 Buffering self-injection

The protocol compatibility notion (Definition 4.12) is usually used to check the communica-
tion between two distinct processes. However, sometimes, we have to understand the relation
among distinct channels of the same component, probably one that contains other inner compo-
nents. For this reason, we introduce another notion of compatibility, which is very similar to the
previously presented, except for the fact that we do not compare the communication between
two simple processes (protocols) but the communication between events of the same process.



4.3 BUFFERING 54

Definition 4.20 (Buffering self-injection compatibility). Let P be a deadlock-free I/O process,
and c and z channels. Then P j = P |? {|c,z|} is buffering self-injection compatible if, and only if:

1. ?(s,X) : failures(P j)|(s ? Oc = s ? Iz)? (s ? Oz = s ? Ic)• X ?(Oc ?Oz) = /0

2. ?(s,X) : failures(P j)|s ? Oc &gt; s ? Iz • (s |? z,X ?{|c|})? failures(P j |? z)

3. ?(s,X) : failures(P j)|s ? Oz &gt; s ? Ic • (s |? c,X ?{|z|})? failures(P j |? c)

where Oc = outputs(P,c), Oz = outputs(P,z), Ic = inputs(P,c) and Iz = inputs(P,z)

The lemma below shows that a buffering self injection compatible process can establish a
communication between its channels via a one-place buffer without deadlock.

Lemma 4.4. Let P be an deadlock-free I/O process, c and z communication channels, and LR1
and LR2 bijections, such that:

1. LR1 : outputs(P,c)? inputs(P,z) and LR2 : outputs(P,z)? inputs(P,c)

2. ProtIMP(P,c)[[LR1]]??ProtIMP(Q,z)[[LR2]]

3. ProtIMP(P,c) an ProtIMP(Q,z) satisfy FOP

Then, P |? {|c,z|} is buffering self-injection compatible if, and only if, the following process is
deadlock-free:

P |? {|c,z|} ?
{|c,z|}

BUFF1IO(LR1,LR2)

Proof. The proof of this lemma is carried by case analysis. We contradict the theorem above,
showing that for each possible case where the process deadlocks there is a possible communi-
cation to perform.

The process deadlocks when P and the two buffers within BUFF1IO are stuck. Therefore, in
this proof, we analyse each case where BUFF1IO may deadlock. These are: when the buffers are
empty, and no output of P comes out; and when at least one buffer is full.
1) In the first case, every time both buffers are empty, the process P has communicated the
same number of events through c and z. In this case, the last event communicated by P cannot
be an output; if so, the buffer would not be empty. Therefore, since P is buffering self-inject
compatible, P may output something in this case. These processes do not deadlocks.

Below, we present the formal proof for this case, showing that if it deadlocks, then we have a
contradiction. Assume that Oc = outputs(P,c), Oz = outputs(P,z), Ic = inputs(P,c), Iz = inputs(P,z),
PJ = P |? {|c,z|} and BF = BUFF1IO(LR1,LR2)

P |? {|c,z|} ?
{|c,z|}

BF deadlocks

?[Lemma 3.1]
?(s,X) : failures(PJ)• (s,?8X)? failures(BF )



4.3 BUFFERING 55

?[buffers are empty]
?(s,X) : failures(PJ)| (s ? Oc = s ? Iz)? (s ? Oz = s ? Ic)?

(s,?8X)? failures(BF )? (?8X)?(Oc ?Oz) = /0
?[P is buffering self-injection compatible, X ?outputs(PJ) = /0]
?(s,X) : failures(PJ)| (s ? Oc = s ? Iz)? (s ? Oz = s ? Ic)?

((?8X)?(Oc ?Oz) = /0)? (X ?(Oc ?Oz) = /0)
?[contradiction]

false

2) In the second case, at least one buffer is full. Below, we present the formal proof for
this case, showing that if it deadlocks, then we have a contradiction. Here, we also assume
that Oc = outputs(P,c), Oz = outputs(P,z), Ic = inputs(P,c), Iz = inputs(P,z), PJ = P |? {|c,z|}, BF =
BUFF1IO(LR1,LR2), Pc = ProtIMP(P,c) and Pz = ProtIMP(P,z). We start the proof by a consequence
of the compatibility of the protocol implementation, and Lemma 3.1.

?(s,X) : failures(BF )• (s,?8X) /? f ailures(Pc ||| Pz)
?[Lemma 3.1, Proj ? BF deadlocks]
?(s,X) : failures(BF )• (s,?8X) /? failures(Pc ||| Pz)?

(s,?8X)? failures(Pro j)
?[The failures semantics of the interleave operator, see Section 3.3.2]
?(s,X) : failures(BF )• (s |? c,?8X) /? f ailures(Pc)? (s |? z,?8X) /? f ailures(Pz)?

(s,?8X)? failures(Pro j)
?[at least one buffer is full, P is buffering self-injection compatible]
?(s,X) : failures(BF )• (s |? c,?8X) /? f ailures(Pc)? (s |? z,?8X) /? f ailures(Pz)?

((s |? z,(?8X)?{|c|})? failures(Pro j |? z)?
(s |? c,(?8X)?{|z|})? failures(Pro j |? c))

?[Definition 4.8, failures(Pro j |? c) = failures(Pc)? failures(Pro j |? z) = failures(Pz)]
?(s,X) : failures(BF )• (s |? c,?8X) /? f ailures(Pc)? (s |? z,?8X) /? f ailures(Pz)?

((s |? z,?8X)? failures(Pz)? (s |? c,?8X)? failures(Pc))
?[contradiction]

false

This theorem could be used, for instance, in the development of the client-server example.
Suppose that, due to a design decision, one achieves a process S = CL ||| SV , and then wishes to
communicate the client and the server enclosed in S. This is a classical case that requires a self-
injection assembly. In this case, the client and the server fulfil the requirements of buffering
self-injection.

We observe that this result can be easily expanded from communications with an one-place
buffer to an infinite buffer, if the process is also confluent.



4.3 BUFFERING 56

Theorem 4.10. Let P be an deadlock-free I/O confluent process, c and z communication chan-
nels, BF a deterministic and infinite buffer and LR1 and LR2 bijections, such that:

1. LR1 : outputs(P,c)? inputs(P,z) and LR2 : outputs(P,z)? inputs(P,c)

2. ProtIMP(P,c)[[LR1]]??ProtIMP(Q,z)[[LR2]]

3. P |? {|c,z|} is buffering self-injection compatible and satisfy the FOP

Then, the following process is deadlock-free:

P ?
{|c,z|}

BUFFIO(BF,LR1,LR2)

Proof. This theorem is a direct result of Lemma 4.4 and the fact of the process is I/O confluent.
Since I/O confluent processes are channel confluent, then it is buffer tolerant, which means that
an arbitrary number of buffers can be introduced without introduce new errors. A system that
is deadlock-free will be also deadlock-free after introducing such buffers. So BF represents
a pipeline of an arbitrary number of one-place buffers. We start the proof from the result of
Lemma 4.4.

P ?
{|c,z|}

BUFF1IO(LR1,LR2) is deadlock-free

?[I/O buffer definition]
P ?
{|c,z|}

(COPY (LR1) |||COPY (LR2)) is deadlock-free

?[P and COPY are channel confluent]

P ?
{|c,z|}

(
(COPY (LR1)?LR1 ···?LR1 COPY (LR1)) |||
(COPY (LR2)?LR2 ···?LR2 COPY (LR2))

)
is deadlock-free

?[BF represents a buffer of arbitrary size]
P ?
{|c,z|}

(BF(LR1) ||| BF(LR2)) is deadlock-free

?[I/O buffer definition]
P ?
{|c,z|}

BUFFIO(BF,LR1,LR2) is deadlock-free

An interesting subclass of I/O processes is the one with decoupled channels. In this class
of processes, the communication through two channels of a same process behaves as commu-
nications between channels of distinct processes.

Definition 4.21 (Decoupled channels). Let P be an I/O process and Ch a set of channels. Then,
the channels within Ch are decoupled in P (denoted by Ch DecoupledIn P) if, and only, if:

P |? Ch ?F |||
z?Ch

ProtIMP(P,z)

Below, we present the expected relation between the two notions of compatibility in pro-
cesses with decoupled channels.



4.4 SAFE HIDING 57

Theorem 4.11. Let P be an deadlock-free I/O process, c and z communication channels, and
LR1 and LR2 bijections, such that:

1. LR1 : outputs(P,c)? inputs(P,z) and LR2 : outputs(P,z)? inputs(P,c)

2. ProtIMP(P,c)[[LR1]]? ProtIMP(Q,z)[[LR2]]

3. {c,z} DecoupledIn P

Then, P |? {|c,z|} is buffering self-injection compatible.

Proof. The proof of this theorem is underpinned by the notion of protocol compatibility and by
Lemma 4.4. We start by the fact that the synchronisation of compatible protocols is deadlock-
free (Theorem 4.9).

(ProtIMP(P,c) ||| ProtIMP(P,z)) ?
{|c,z|}

BUFF1IO(LR1,LR2) is deadlock-free

?[Definition 4.5, ProtIMP(P,z)vF Pz?, ProtIMP(P,c)vF Pc? ]
(Pc? ||| Pz?) ?

{|c,z|}
BUFF1IO(LR1,LR2) is deadlock-free

?[{c,z}DecoupledIn P, P |? {c,z}?F Pz? ||| Pc?]
P |? {|c,z|} ?

{|c,z|}
BUFF1IO(LR1,LR2) is deadlock-free

?[Lemma 4.4]
P |? {|c,z|} is self-injection compatible

4.4 Safe hiding

A notion related to projection is safe-hiding. Instead of focusing on the behaviour that remains
after hiding some events, this notion focuses on the preservation of a certain property after the
hiding operation has been applied. More specifically, safe-hiding states that hiding does not
introduce divergences.

Definition 4.22 (Safe hiding). Lets P be a process, and C a set of channels. The process P\{|C|}
is safe-hide if, and only, if:

?s ^ t ^ u : traces(P)|t is infinite • chans(t) * C

Lemma 4.5. Let P be a divergence-free process, and X a set of events. Then:

?s : traces(P) | s is infinite ? s \ X is finite
•?x,y,z|(x ^ y ^ z = s)? ((x ^ z)\ X = s \ X ? y is infinite)



4.4 SAFE HIDING 58

Proof. As s is infinite, and after hiding events within X it becomes finite, then an infinite part
of s is hidden. This is the fundamental fact that sustains the lemma above. y represents this
infinite hidden part. x and z are used to relate y to s.

As s \ X is finite, and y is hidden, then the unhidden part is equals to (x ^ z) \ X . Note that
except from the fact that y is infinite, x and z can assume any size, even zero, depending on the
location of y in the trace s.

The definition states that no infinite trace has an infinite part formed only of hidden events;
the part is identified as an infinite sequence of events that are communicated via the hidden
set of channels. Basically, the definition states a condition to where hiding does not introduce
divergences. It focuses on the verification of the channels of the possible problematic infinite
traces. Despite its calculation is as hard as traditional calculations of divergences, its conclusion
can be useful to scenarios where traces obey specific patterns, and, furthermore, where the
channels used within these patterns can be easily figured out.

Next, we show the theorem that proves the application of safe-hiding to the preservation of
divergence freedom.

Theorem 4.12. Let P be a divergent-free process, and C a set of channels, such that P \{|C|} is
a safe-hide. Then P \{|C|} is divergent-free.

Proof. As there is no infinite trace hidden, no divergence is introduced. Furthermore, P \{|C|}
is divergence-free. Below, we calculate the divergences of the hidden process P \{|C|}, based
on the denotational semantics of infinite traces, presented in Sec. 10.1 in [Ros98].

divergences(P \{|C|})
=[hiding semantics ]

{(u \{|C|}) ^ t |u ? infinites(P)? t ? ??X ? u \{|C|} is finite}?
{(s \{|C|}) ^ t |s ? divergences(P)??? ? t ? ??X}

=[P is divergence-free]

{(u \{|C|}) ^ t |u ? infinites(P)? t ? ??X ? u \{|C|} is finite
=[substituting y ^ x ^ z = u, Lemma 4.5]

{((x ^ y ^ z)\{|C|}) ^ t |x ^ y ^ z ? infinites(P)? t ? ??X ? (x ^ y ^ z)\{|C|}= (x ^ z)\{|C|}?
x ^ z is finite ? y is infinite

=[x ^ y ^ z \ X = x ^ z \ X ? y \ X = ??]
{((x ^ y ^ z)\{|C|}) ^ t |x ^ y ^ z ? infinites(P)? t ? ??X ? (x ^ y ^ z)\{|C|}= (x ^ z)\{|C|}?
x ^ z is finite ? y is infinite ? chans(y)?C

=[P \{|C|} is safe-hide]
/0

This concludes our characterisation of the I/O processes, and related concepts. This is used
as a basis for our component model and its constructive constraints.



CHAPTER 5

The BRIC component model

The aim of this chapter is to define the component model used in this work. This model delim-
its the broad outline of what constitutes a component in our approach, exposing its necessary
related technical concepts and constraints. This component model, which we informally call
BRIC, characterises not only components, but connectors as well as their interaction seman-
tics. As a consequence, the BRIC component model defines the building blocks of our sys-
tematic development approach, which is aligned with an overall engineering discipline based
on component, and considers important desirable issues on this area, previously pointed out in
Section 2.4.

The BRIC component model characterises (re)active components in this work and how
they interact. The behaviour of these components are represented by I/O processes (pre-
sented in Section 4.1). Moreover, they can interact either synchronously or asynchronously,
as presented further in this chapter. These concepts are compatible with other component mod-
els [HLL06b, ADG98, BCD02, BHP06]. In fact, other Architectural Description Languages
(ADL) [MT00], or even the UML 2.0 [Obj07] might be used as a concrete syntax for the
concepts presented here; an example of similar mapping is presented in [RSM05]. The BRIC
component model presents connectors as first class design entities, which are aimed not only
for composition but also for reuse. The separation of concerns between components and con-
nectors, as well the composition of the latter elements, allows the exogenous coordination of
components. Although coordination is allowed, it is not the focus of this thesis. We focus
the discussion on this chapter in the compositions of components, which is the basis for our
systematic strategy for components in the next chapter.

The rest of this chapter formalises several concepts in CBSE, such as interfaces, com-
ponents, port-protocols, component composition and connectors, as part of our architectural
component model. They are defined independently of any quality attribute, or without know-
ing further information about any target component technology. In the end of this chapter
(Section 5.3), we introduce some architectural styles that do assume some constraints to fa-
cilitate reasoning and analysis. In special, we present the BRICK component model, which
enriches arbitrary BRIC components with metadata. As we show, such metadata store partial
information used in verifications of compositions. Furthermore, they are rich tools to alleviate
verifications. Constructive constraints for this architectural component model are presented in
the next chapters, embodied in a rigorous development process that provide assistance in wiring
components together, or updating them in a predictable way.

59



5.1 A COMPONENT-BASED SYSTEM EXAMPLE 60

5.1 A component-based system example

In our approach, components and connectors are basically represented by black-box design ele-
ments, with defined interaction points (or ports) and a dynamic (external) behaviour, which are
formally expressed by channels and a process in CSP, respectively. To illustrate the proposed
notions, we use an example: the communication between a CLIENT and a SERVER component
in a simple ATM system (see Figure 5.1). When necessary, we assume the runtime environment
as another, possibly a set of, components. However, in this example, no additional service is
required from the environment, and, furthermore, its representation is immaterial.

Figure 5.1 An example of a simple ATM System.

The architectural configuration of the system in Figure 5.1 shows all design entities and their
respective ports. Each component has an observational dynamic behaviour, which describes
how it reaches different states during its execution, based on external events. This is the same
example presented in Chapter 3, but we lift the definition of processes to components in this
chapter.

In the example, the entire system is represented by a component, which is hierarchically
composed of other components and connectors. After identification (through a card and pin),
the CLIENT component offers to the user a choice between withdrawing money and checking
its account balance. Both withdraw and balance operations are expected to be performed by
another component. In our example, the SERVER component is responsible for these operations.
The connector CON helps to sort out communication issues between these components, such
as heterogeneity. Further details are shown in the next sections.

5.2 BRIC component model

5.2.1 Interfaces

Component capabilities are usually described by means of interfaces, which define the provided
and the required services of a component. In this work, we assume that interfaces simply consist
of input and output events in CSP, which may express pairs of request-response or individual
synchronisation events of a service. At this level of abstraction, a pair with an input and an
output event might be understood as representing, for instance, the invocation of a method.

Before we define interfaces, we present the definition of I/O types that represent communi-
cations with distinct events for input and output.



5.2 BRIC COMPONENT MODEL 61

Definition 5.1 (I/O type). Let T and U be two disjoint sets of values. Then, we define an I/O
type as a set parameterised by these two sets, as follows:

IOTT,U = in.T|out.U

I/O types are associated at a fundamental level with the set of elements communicated by
a component. In fact, we observe them as sets of elements, whose values within T and U are
associated with the tags in and out. In a communication between a pair of components, typically
T and U will be the sets of input and output values for one component and, conversely, the set
of output and input values for the other component. Therefore, IOTT,U would be the I/O type of
one component and IOTU,T the I/O type of the other component.

In order to illustrate our notions, we revisit the example of the client-server communication
presented in Section 3.2. We present here a new specification for the same problem. The run-
ning example is slightly modified to make explicit the direction of the events in communication.
In our example (see Figure 5.1), the interfaces IUS, ICL and ISV have the following I/O types.

IUS = IOTUSIN ,USOU T
ICL = IOTCLIN ,CLOU T
ISV = IOTCLOU T ,CLIN

where CLOU T , CLIN , USIN and USOU T are defined by the datatypes below.

CLOU T = wd.Int|reqBal
CLIN = ackW d.Bool|resBal.Int
USIN = insertCard.Int|enterPin.Int|withdraw.Int|balance

USOU T = takeCard|takeCash|takeSlip.Int

Note that the I/O types of ICL and ISV are parametrised by the same set of values. In order to
allow communication, the parameters of one I/O type have the reverse order of the other; this
means that outputs of one are observed as inputs of another, and vice-versa. To ease readability,
we avoid such explicit parametrisation using the following abbreviations.

Definition 5.2 (Interface). Let TIN and TOU T be sets of values for input and output communica-
tion of a given component. We call the types that represent the interface of such a component a
regular interface and a conjugate interface (namely I and ?I, respectively), and define them as
follows:

I = IOTTIN ,TOU T ?I = IOTTOU T ,TIN

We also define the projection functions inputs and out puts as follows:

inputs(I) = ran(in)?I outputs(I) = ran(out)?I

As a result of Definition 5.2, a regular interface is a type whose input and output events are
tagged by in and out, respectively, whereas a conjugated interface has input and output tagged
by out and in, respectively. In our example, ICL =?ISV . The modifiers in and out also behave
as functions that take an arbitrary value and yields the same value prefixed by those modifiers.



5.2 BRIC COMPONENT MODEL 62

As a consequence of Definition 5.1, the ranges of in and out represent all inputs and outputs of
the system. For this reason, these modifiers are elegant candidates for defining the projection
functions inputs and out puts; the intersection with the whole interface restricts the range of in
and out (ran(in) and ran(out), respectively) to those values within the interface. For instance,
for TIN ={a,b} and TOU T ={w,z}, inputs(I) = outputs(?I) ={in.a,in.b} and outputs(I) = inputs(?
I) ={out.w,out.z}. For the sake of brevity, we use ? as an operator that takes a regular interface
and yields a conjugate interface, and vice-versa. So that ??I = I.

Despite interfaces being an important concept to capture component interaction, it is not
sufficient for ensuring the correct development of component based applications [RM04]. A-
part from a static representation provided by interfaces, design entities are also expressed by
their dynamic behaviour. Interfaces define the type of a component port. In other words, an
interface defines a set of possible events communicated by components via its ports. Thus, each
port is associated to one interface. For instance, in our example, CLIENT uses the ports cl and
us, and SERVER uses the port sv. In CSP, the association of a port with its type is syntactically
expressed in the channel definition, as follows.

channel cl : ICL
channel us : IUS
channel sv : ISV

5.2.2 Regular components

In the definition below, we define a component contract in terms of its behaviour (represented
as a CSP process), ports (represented as channels) and respective interfaces (types).

Definition 5.3 (Component contract). A component contract Ctr comprises an observational
behaviour B, a set of communication channels C, a set of interfaces I, and a total function
R : C? I between channels and interfaces:

Ctr : ?B,R,I,C?

such that

• B is an I/O process

• dom R = C ? ranR = I

• Let c ?C, outputs(c,B) ={out.x : R(c)• c.out.x} and inputs(c,B) ={in.x : R(c)• c.in.x}

A component is defined as an autonomous entity that deterministically offers its inputs, but
nondeterministically decides which outputs it performs. These behaviours are represented by
the input deterministic and output decisive properties, satisfied by the component (see the Def-
inition 4.5 of I/O process). Determinism is important to improve the reuse of the component:
i) it always accepts to communicate the input services previously offered to the environment
(other components); ii) the input events offered to the environment depends only on things it



5.2 BRIC COMPONENT MODEL 63

has seen (i.e., the sequence of communications so far). The nondeterminism on outputs pro-
vides the component with the ability to take internal decisions based on its inputs (autonomous
entity).

In our component model, we do not distinguish between required and provided interfaces.
These, however, are immaterial in our strategy, since we concentrate our effort on composition.
The associated verification is not limited to syntactical checking, but also cope with verifica-
tions in elaborated systems.

Observing I/O processes, it is easy sometimes to classify an event as output or input, ac-
cording to the process that enables it. However, this is not a reliable procedure. For this reason,
we rely on the interfaces to identify the type and the direction of the events. The syntactic
elements of a component contract complement the behavioural ones. Among the four elements
that constitutes the contract definition, R is the only one that does not have an explicit counter-
part in behavioural specification languages, like CSP; it represents the link between the channel
names and their types. The third statement in the definition above links the abstract functions
inputs and out puts related to I/O channels (see Definion 4.1) to the in and out tags defined by
the interfaces; these functions are overloaded here in many scenarios, returning inputs and out-
puts of interfaces, channels and components. This component contract definition observes the
component in isolation; other constructive constraints are defined in the next chapter to forbid
undesirable synchronism with the environment.

For verification purposes (or further observations), we do not restrict the component dy-
namic behaviour B to communicate only events within {|C|}. Channels within C are those
externally observed, and used in direct compositions with other components (see next section).
Other channels, which do not belong to C, represent communication among subparts (or con-
stituting components) of the component. This distinction provides a certain kind of white-box
component that is especially useful in testing, verification or observation about the system and
its constituting parts. Of course, we also provide means to hide such internal channels, in case
someone wants to ship a black-box component (presented later in Section 5.2.5).

The notation {|ch|} is very useful; it allows us to turn any set of channels and partially
defined events into the corresponding events. For instance, if ch communicates values of the
set {1,2}, {|ch|}={ch.1,ch.2}.

Equally, the notation {|C|} =
?

c:C{|c|} represents the set of all events represented by chan-
nels or partially defined events within C. As a consequence, the alphabet of events of a compo-
nent Ctr externally observed by other components is given by {|CCtr|}. Similarly, the observed
traces of this component are defined within the transitive closure set of this alphabet ({|CCtr|}?).

To exemplify a component contract, we show it in CSP syntax. In our example, the CLIENT
component (see Section 5.1) has its contract defined by CtrCLIENT . It has two ports: us and cl,
which are typed by IUS and ICL, respectively. The former port provides services to the user, and
the latter delegates these services to another component (SERVER).

CtrCLIENT = ?CLIENT,{us 7? IUS,cl 7? ICL},{IUS,ICL},{us,cl}?

The component and its interfaces are illustrated in the CLIENT structure in Figure 5.1. Syntac-
tically, channels and interfaces of this contract are written in CSP as previously presented. The
dynamic behaviour is presented next.



5.2 BRIC COMPONENT MODEL 64

Figure 5.2 The Client behaviour.

As we focus on the interaction of CLIENT and SERVER, we explain only the events used in
their communication. In the example, the events in ICL are those used by CLIENT to interact with
SERVER. ICL contains the events for withdrawing money (tagged with wd) and for requiring and
receiving an account balance (tagged with reqBal and resBal, respectively). These events use the
(assumed) built-in data types Bool and Int to represent boolean and integer values, respectively.
The CLIENT behaviour is illustrated by the statechart in Figure 5.2. Formally, its behaviour is
written in CSP as follows.

CLIENT =us.in.insertCard?num ? us.in.enterPin? pin ?
(W DRAW 2 BAL) ; us.out!takeCard ? CLIENT

W DRAW =us.in.withdraw?val ? cl.out!wd.val ? cl.in.ackW d?a ?
us.out!takeCash ? SKIP

BAL =us.in.balance ? cl.out!reqBal ? cl.in.resBal?x ?
us.out!takeSlip.x ? SKIP

The process CLIENT is the specification of the component dynamic behaviour in CSP. All
input and output events are defined by the component interfaces. To help readability in our
specification, we assume that a request event with an input parameter takes the form ch.in.tag?x,
where ch is the name of a channel and x acts as an input pattern, which can be empty (as
in the event balance) or with a variable (as in insertCard?num). The notation ch.out!v is used
for response events, where v is an expression. The data processing starts by acquiring the card
number from the environment using the channel us. Next, the prefix operator (?) states that the
event us.in.enterPin? pin takes place, representing the validation of the user token and password.
Then, CLIENT offers two choices deterministically (2): it engages either on the events withdraw
or balance, to withdraw money or to check the account balance, respectively. Each of the
alternative operations is started by the occurrence of the cl.out!wd or the cl.out!reqBal event,
and can be completed by the cl.in.ackW d?a or the cl.in.resBal?x event, respectively. The events
us.out!takeCash, us.out!takeCard and us.out!takeSlip inform the user about the operation result
and finalisation.



5.2 BRIC COMPONENT MODEL 65

Now we present the SERVER component contract, which provides bank services to the
CLIENT component.

CtrSERVER = ?SERVER,{sv 7? ISV},{ISV},{sv}?

Syntactically, the dynamic behaviour of this contract is written in CSP as follows.

SERVER = sv.in.wd?x ? (ua : Bool • sv.out!ackW d.a)? SERVER
2 sv.in.reqBal ? (uy : Int • sv.out!resBal.y)? SERVER

The SERVER component has a provided interface ISV whose values for input and output com-
munication are defined in the opposite direction of those in ICL. We have defined ISV as a regular
interface in order to ease the understanding of the communication direction in the SERVER be-
haviour. The way the communication between CLIENT and SERVER is bridged is presented in
Section 5.2.3.

The process SERVER offers a deterministic choice (2) between a withdraw and a balance re-
quest, which is represented by the occurrence of the communications sv.in.wd?x and sv.in.reqBal.
After receiving a withdraw or balance request, it internally decides (nondeterministic choice
u) the value of the withdraw acknowledgement (ackW d!a) and that of the balance response
(resBal.y); the nondeterministic choice is usually associated to abstract internal actions of the
component that decides the value that is output.

Observe that a component contract does not define the port-protocol that it satisfies. It is
usually an information given at deployment, used before component integration. In case a port-
protocol is not provided at the integration phase, we automatically derive it from the component
behaviour (see Definition 4.8), since a port-protocol is in fact a specification that a component
realises during the communication with other components. As presented in Definition 4.8,
the function ProtIMP(.,.) takes an I/O process (in our case the component behaviour) and a
channel, and returns the port-protocol associated to them. For the sake of brevity, we consider
an overloaded version of the function to accept a component contract instead of an I/O process;
i.e. it takes a component contract Ctr and a channel c. We call port-protocol, or communication
protocol, the protocol associated with the port of a component. For the sake of clarity, when
the context explicitly associates behaviour to a port, we might call the port-protocol as just
protocol.

ProtIMP(Ctr,c) = ProtIMP(BCtr,c)

For instance, in our example, the projection of CLIENT over the channel cl is expressed as
follows.

ProtIMP(CtrCLIENT,cl) = µ X • cl.out!wd.val ? cl.in.ackW d ? X
2 cl.out!reqBal ? cl.in.resBal?x ? X

Observe that the port-protocol is equivalent to the projection of the entire dynamic behaviour
of CLIENT over the corresponding port (cl).

Usually, a component is defined once and reused multiple times, and in multiple different
contexts. In this work, we represent these contexts as a set of channels, since channels represent
interaction points of the component, and each channel is used to communicate with a single
component in the environment. So, replacing the channels of a component contract by another



5.2 BRIC COMPONENT MODEL 66

set means that it supposedly interacts with another environment. In this work, this replacement
is represented by a bijection of the set of channels of the component contract into a set with
new channels. To avoid performing indefinitely replacements, every time we want to reuse the
specification, this bijection assumes that the target interaction points have an index. So, reuse
from now on is made by adopting a new identification for the component we wish to use.

Definition 5.4 (Component contract instantiation). Let Ctr be a component contract, and F a
bijection between name prefixes, such that dom F = CCtr and F(c) has the form c..x...y, where
x...y is a sequence of one or more integers combined by dots. Then the instance of Ctr according
to F , denoted by CompINST (Ctr,F), is represented by the contract CtrF .

CtrF = ?B[[F]],F?1 ; R,I,ran F?

In the definition above, all elements of the new component are derived from the bijection
and from the older component contract. The behaviour of the new component contract (B[[F]])
is equivalent to the older one, except that it uses a new set of interaction points (the range of
the bijection, ran F ). The interfaces are still the same, and mapping from interaction points into
interfaces are represented by a composition of the bijection (in inverse function F?1) with the
relation R. Note that all port-protocols of the new component are equivalent with the protocols
of the older one, see Definition 4.10. The interaction point takes the form c.x...y, in which c is
a channel and x..y are identifiers of components; usually one of these identifiers is assigned to
the component itself and the other to components that it interacts with.

5.2.3 Connectors

Connectors establish coordination rules that govern component interaction and specify any aux-
iliary mechanisms required [SG96], such as mapping between heterogeneous communication
interfaces. They are regarded more broadly as exogenous coordinators [PA98, Arb06], intended
to mean ‘coordination from outside’ the components.

To increase the range of components they integrate, connectors are abstractly defined at
the design level to serve the needs of unspecified components. They become components only
later in the life-cycle, on the assembly with the components, by relying on the component
contracts [MB05].

We represent the dynamic behaviour of abstract connectors as parametrised CSP processes,
whose parameters represent component ports and their respective roles in the composition
(channels and port-protocols, respectively). When all parameters are instantiated, connectors
are ready to be composed with other components, or to form more elaborate connectors. The
first issue of connectors is that they allow reuse.

Definition 5.5 (Abstract connector). An abstract connector AC(SC,SI,SP) is described by a be-
haviour parameterised by a sequence of distinct channels SC, a sequence of arbitrary interfaces
SI and a sequence of processes SP, such that #SC = #SP = #SI ? ?i : 1..#SI • ? SP(i) ={SI(i)}.

A connector is formed by elements similar to a component, but its behaviour is parame-
terised. Instead of sets of channels and interfaces, we use sequences, which are more suitable
to parametrise the connector specification. We consider the sequence of processes as protocols



5.2 BRIC COMPONENT MODEL 67

over the channels that parametrise the connector. For consistency among these parameter se-
quences, we establish that they have the same size, and that all processes only communicate
values on their associated interfaces. When the connector parameters are instantiated, it be-
comes a component that behaves according to the connector behaviour. Sequences are used in
the definition of connector to help the parametrisation of the connectors.

Definition 5.6 (Connector instantiation). Let AC be an abstract connector, SC a sequence of
channels, SP a sequence of processes, and SI a sequence of interfaces, such that SC, SP and SI
satisfy the constraints to be parameters of AC. Then F(AC,SC,SI,SP) is a component contract
defined by:

F(AC,SC,SI,SP) = ?AC(SC,SI,SP),{i : 1..#SC • (SC(i) 7? SI(i))},ran SI,ran SC?

The definition above bridges the gap between two abstraction levels: an abstract connector
at design stage and its instantiation at component integration and deployment level. We say
that the function F has an instantiation role. It takes an abstract connector AC and its list of
parameters (SC, SI and SP) and constructs a component, which is a concrete version of AC.

One of the simplest and most common abstract connectors is the one whose behaviour is
presented below. It is parametrised by two channels, and its purpose is to copy any value
communicated by one channel to the other. It does not perform any verification concerning
protocols, so the protocol parameters are not referenced in the definition.

Concopy(?c1,c2?,?I1,?I1?,SEQP) = µ X •
c1?x : inputs(I1)? c2.reverse(x)? X
2 c2?y : inputs(I2)? c1.reverse(y)? X

where reverse(in.x) = out.x,reverse(out.x) = in.x
Observe that input values of c1 and c2 are tagged by out, and outputs by in. The reason is

that this connector aims at mediating the communication between two components with regular
interfaces. So, an output of a component is transmitted to the other component, and vice-versa.

5.2.4 Composition

The traditional composition idea about assembling two components is to perform parallel syn-
chronisation among the channels they share in common, so that, an output is only transmitted
when the other component is enabled to input it, and vice-versa.

However, this brings a major barrier to our approach: sometimes, we wish to connect two
channels of a same component. This is especially important when we have a larger component
formed of an interleaving of other inner components. In this case, the composition of the inner
components is postponed as a design decision.

The answer to this problem is to observe what happens with real applications, as hardware,
distributed and agent oriented systems, which are naturally asynchronous, or, at most, what is
called, globally asynchronous locally synchronous (GALS) [Cha85]. Synchronism is achieved
by direct (local) assemblies of components or by specific communication protocols or orches-
tration in networks of components, which communicate asynchronously.

To represent asynchronous communication, we introduce buffers as intermediary elements
of the composition. They copy information from one component channel to another, ignoring



5.2 BRIC COMPONENT MODEL 68

if the other component is enabled to input. Components may still be assembled directly using
parallel operators in order to build more complex components, but certain compositions would
be allowed only through buffers, as shown in Fig. 5.3. Buffers could be considered as regular
connectors, but, due to their importance, we consider them as integral part of our strategy; other
connectors can be introduced later, if desired.

These buffers have the same structure as those presented in Section 4.3.1. However, compo-
nent interfaces provide the syntactic support for the abstraction presented there. The mapping
between outputs and inputs is translated as a renaming between the tags in and out (see I/O
types). Considering this, we overload the function BUFFIO to receive a pair of channels, in-
stead of bijections. The renaming used on this buffer is:

R a?bIO ={a.out.x 7? b.in.x}

the elements a and b are placeholders for two channels. R a?bIO replaces outputs of a by inputs of
b.

For the sake of brevity, we consider BUFF1IO, BUFF
n
IO and BUFF

?
IO as the following pro-

cesses:

BUFF1IO(c,z) =BUFFIO(COPY,R
c?z
IO ,R

z?c
IO )

BUFFnIO(c,z) =BUFFIO(B
n,R c?zIO ,R

z?c
IO )

BUFF?IO(c,z) =BUFFIO(B
?

??,R
c?z
IO ,R

z?c
IO )

For instance, consider the communication between the processes P and Q below via the chan-
nels c and z. Consider that P and Q has no channels in common, and that BUFF?IO(c,z) is an
infinite buffer that copies information from c to z, and vice-versa.

P ?
{|c|}

BUFF?IO(c,z) ?
{|z|}

Q

or, using the interleave operator.

(P ||| Q) ?
{|c,z|}

BUFF?IO(c,z)

Observing the form of the statement above, we are able to define a composition of an
arbitrary number of processes, assembling an arbitrary even number of channels.

Figure 5.3 Composition using a buffer



5.2 BRIC COMPONENT MODEL 69

To help us in this definition, we first specify an auxiliary function AsyncComp. The function
AsyncComp takes a set of processes S and a bijective function F among distinct sets of channels
used by processes within S and yields the assembly of the processes within S, connecting each
channel c to its respective channel represented by F(c).

AsyncComp(S,F) =
(
|||

P?S
P
)
?dom F

(
|||

c?dom F
BUFF?IO(c,F(c))

)
or, considering PS = |||

P?S
P

AsyncComp(S,F) = PS?dom F
(
|||

c?dom F
BUFF?IO(c,F(c))

)
Observe that the compositions can be constructed based on the function AsyncComp, indepen-

dently of the form of PS or the number of channels mapped by F .
For the sake of brevity, we define component composition in two modes: a binary operation

on two components, and a unary operation over a component. Both are variations of the notions
introduced above. These variations are distinguished in order to explicit the common uses the
function AsyncComp(.,.) and the properties related to each kind of use. First, we define the
composition between two distinct components.

Definition 5.7 (Asynchronous binary composition). Let P and Q be two distinct component
contracts, and ?c1,..,cn? and ?z1,..,zn? sequences of distinct channels within CP and CQ, respec-
tively, such that CP ?CQ = /0. Then, the asynchronous binary composition of P and Q (namely
P?c1,..,cn? ??z1,..,zn? Q) is given by:

P?c1,..,cn? ??z1,..,zn? Q = ?(AsyncComp({BP,BQ},{ci 7? zi|i ? 1..n}),RPQ,IPQ,CPQ?

where CPQ = (CP ?CQ)8{c1,..,cn,z1,..,zn}, RPQ = CPQ C (RP ?RQ), and IPQ = ranRPQ
In this definition, we assume each component has a distinct set of interaction points (CP ?

CQ = /0), and that their communication is asynchronous, mediated by buffers. The behaviour
of the composition is defined by the synchronisation of the components (P or Q) with an in-
finite buffer in all interactions of the channels mapped by F (this is expressed by the process
AsyncComp); we consider infinity buffer here, as they represent the worst case we can found.
Any communication related to a channel mapped by F is not offered to the environment in fur-
ther compositions (CPQ). The operator C stands for domain restriction; it is used to restrict the
mapping from channels into interfaces (RPQ) and, furthermore, to restrict the set of interfaces
in the composition contract (IPQ). It is important to observe that the sequences ?c1,..,cn? and
?z1,..,zn? have distinct channels, this helps to avoid that components share the same interaction
points (channels); the communication have to be intermediate via a buffer.

The binary composition behaves similarly to the piping (or chaining) CSP operator [Ros98].
However, it does not oblige pipelines of assembled processes to have the same interface type;
the channels used in the composition are explicitly defined. Moreover, the buffer explicitly
represents the bindings of different interface types, rather than the implicit renaming performed
by such CSP operator.

Below we show how the composition can be used to construct well-formed component
contracts (elements that satisfy the conditions to be a component contract in our component
model).



5.2 BRIC COMPONENT MODEL 70

Theorem 5.1 (Binary Composition Monotonicity). Let P and Q be component contracts, and
?c1,..,cn? and ?z1,..,zn? sequences of distinct channels within CP and CQ, respectively, such that
the behaviour (B) in P?c1,..,cn? ??z1,..,zn? Q is deadlock-free. Then P?c1,..,cn? ??z1,..,zn? Q is a compo-
nent contract.

Proof. In order to proof that the resulting tuple is a component contract, we have to show that
its structure is compatible with Definition 5.3. This is provided by the use of the direct com-
position, P[|||]Q = P?? ? ??Q (see Definition 5.7). Moreover, the behaviour of the component is
also an I/O process, since the composition does not introduce divergences (no hiding operation
or undesired renaming is performed), the infinite behaviours of the original components result
in a new infinite process, and the resulting process is input deterministic and output decisive
with respect to the channels that remain in contract, C (see theorems 4.1 and 4.2).

The other composition mode concerns the assembling among channels of the same compo-
nent.

Definition 5.8 (Asynchronous unary composition). Let P be a component contract, and ?c1,..,
cn? and ?z1,..,zn? sequences of distinct channels within CP, such that {c1,..,cn}?{z1,..,zn} = /0.
Then, the asynchronous unary composition of P (namely P ?|?c1,..,cn??z1,..,zn?) is given by:

P ?
???c1,..,cn?
?z1,..,zn?

= ?(AsyncComp({BP},{ci 7? zi|i ? 1..n}),RPQ,IPQ,CPQ?

where CPQ = CP8{c1,..,cn,z1,..,zn}, RPQ = CPQ C RP, and IPQ = ranRPQ

The definition above is similar to the one for binary composition. It differs on the number
of processes passed to AsyncComp. This allows us to assembly channels of a same component,
instead of two distinct components.

Below we show how the composition can be used to construct well-formed component
contracts (elements that satisfy the conditions to be a component contract in our component
model).

Theorem 5.2 (Unary Composition Monotonicity). Let P be a component contract, and ?c1,..,cn?
and ?z1,..,zn? sequences of distinct channels within CP, such that the behaviour (B) in P?|

?c1,..,cn?
?z1,..,zn?

is deadlock-free. Then P ?|?c1,..,cn??z1,..,zn? is a component contract.

Proof. In order to proof that the resulting tuple is a component contract, we have to show that
its structure is compatible with Definition 5.3. This is provided by the use of the unary compo-
sition, P[ic ¯??oc] = P ?

???ic?
?oc? (see Definition 5.8). Moreover, the behaviour of the component is

also an I/O process, since the composition does not introduce divergences (no hiding operation
or undesired renaming is performed), the infinite behaviours of the original components result
in a new infinite process, and the resulting process is input deterministic and output decisive
with respect to the channels that remain in contract, C (see tTheorems 4.1 and 4.2).

The composition operators presented in both definitions follow some commutative, dis-
tributive and identity properties.



5.2 BRIC COMPONENT MODEL 71

Rule 5.1. Let P and Q be two component contracts, and cs1, zs1, cs2, zs2, cs3 and zs3 sequences
of channels. Then:

Pcs1 ?zs1 Q = Qzs1 ?cs1 P (5.1)

P = P ?|???? (5.2)

P ?|cs1zs1 = P ?|
zs1
cs1 (5.3)

P ?|cs1 ^ cs2
zs1 ^ zs2

=
(
P ?|cs1zs1

)
?|cs2?zs2 (5.4)(

P ?|cs1zs1
)

cs2 ^ cs3 ?zs2 ^ zs3 Q = (Pcs2 ?zs2 Q)?|
cs1 ^ cs3
zs1 ^ zs3

(5.5)

Proof. These set of rules are a direct consequence of commutative and associative properties
of the parallel operator and the function BUFF?IO.

By definition, components are regarded as reusable units of composition. However, the
direct composition of components requires that the connected points of composition have the
same type (conjugated interfaces). This excludes a wide variety of components, which would
be eligible for composition and, furthermore, restricts their reuse. An alternative approach to
direct composition of components is to use connectors to mediate their interactions. In fact, we
show in Section 6.1 that this is explained by successive direct compositions.

The composition of two components using a connector can be performed through two direct
composition steps. We first assemble a component (CLIENT or SERVER, in our example) to
the connector (CON). Then, the second step is to assemble the resulting composition to the
other component (SERVER or CLIENT, respectively). Substituting CON by a concrete connector
that uses Concopy in our example, the resulting component is obtained from the (two-steps)
composition of CLIENT and SERVER:

AT Msystem = CLIENT ?cl? ? ?ccl? CON ?csv? ? ?sv? SERVER

where

channel ccl : ICL
channel csv : ISV

CON =F(Concopy,?ccl,csv?,?RCtrCLIENT (cl),RCtrSERVER(sv)?,

?ProtIMP(CtrCLIENT,cl)[[ccl/cl]],ProtIMP(CtrSERVER,sv)[[csv/sv]]?)

The naive use of (a sequence of) direct composition of components (even through a connec-
tor), without checking their compatibilities, can easily introduce deadlocks in the composition.
In order to safely compose components, some provisos must be checked. As a matter of fact,
this is the problem statement that originates the composition rules, proposed in Chapter 6.

5.2.5 Wrapping

The composition operators presented in both definitions take components as parameters and
return a compound component back, hiding the assembled channels from the resulting com-
ponent contract. These compositions construct a sort of grey-box components, in which some



5.3 ARCHITECTURAL STYLES 72

channels used in B do not belong to C. These channels are not in the contract. For instance, the
channels mapped by F used in the synchronisation are restricted from the composition contract.
They can be observed, in this way, in tests and verifications about the constituting components
of the composition. At any moment, it is possible to transform such grey-box into a black-box
component using the following hiding operator.

Definition 5.9 (Wrapping). Let P be a component contract, and CC a set of channels. Then, a
wrapping of P with respect to CC is given by:

P \CC = ?(BP \{|CC 8CP|},RP,IP,CP?

Definition 5.9 defines a new component contract from another that has the same provided
and required services, but which hides some internal events used to process such services. This
clearly does not restrict any further composition with the component P. In fact, it creates a
component version that is better aligned to the component-based philosophy, in which imple-
mentation details are hidden to outside. For this reason, it is common to perform a direct
composition, and a wrapping of its synchronised events afterwards. We call this operation of
wrapped composition. For instance, the wrapping asynchronous binary composition of P and
Q (namely P?c1,..,cn????z1,..,zn?Q) would be given by:

P?c1,..,cn????z1,..,zn?Q = (P?c1,..,cn? ??z1,..,zn? Q)\{|c1,..,cn,z1,..,zn|}

Although compositions with wrapping play an important role at development of commer-
cial off-the-shelf (COTS) components, sometimes developing in-house systems using grey-box
components are easier, since we can explicitly observe and analyse the communication of the
constituting parts of the system, before packing it in a black-box component using the wrap-
ping operator. This method does not invalidate COTS components, rather it just postpones such
status to when the development is finished and it is delivered to third parties.

5.3 Architectural styles

In the previous sections, we have formally defined a general architectural model concerned
with responsibilities assigned to components, and with initial assumptions about their interac-
tion. However, additional constraints can be considered to capture more detailed integration
concerns. These concerns may determine whether pre-existing parts can be used together, or
affect some quality attributes, or even enable a specific target technology (to construct or to
reason about the system).

Developers recognise a number of distinct architectural styles [SC97]. Many of these are
defined informally and idiosyncratically. Here, we formally present some styles found in com-
municating processes: interaction, naive client-server, and protocol oriented components. Ob-
viously, the small number of styles presented here is not intended to be complete, but they seem
to represent the diversity found in practice.

Interaction components, for instance, focus on components with a cyclic behaviour, which
are found in several technologies such as, for instance, Session Enterprise JavaBeansT M and



5.3 ARCHITECTURAL STYLES 73

transactional conversational Web Services. Moreover, it is aligned with a common partial-order
reduction practice, transaction-based reduction, to alleviate state space explosion in the static
analysis of concurrent programs [BLL09]. The other architectural style, naive client-server1,
focuses on components with synchronous communication in which any communicated message
can be interpreted as either a requisition or an acknowledgement of a previous requisition.
This is similar to the style call-and-return [SC97], typically found in classical object-oriented
systems or applications with (remote) procedures calls, except from the fact that we include
concurrent processes in our style. Furthermore, the naive client-server style can be used to
design synchronous communication protocols over asynchronous mediums. Another important
architecture style is called protocol oriented component. It defines components that preserve
their communication protocol on all their channels, after composition. This is an important
property in the development of component-based systems in where protocol plays a central
role, such as the strategy presented later in this work.

5.3.1 Interaction components

This architectural style focuses on components that repeatedly present the same behaviour to
the environment. Such a recurring behaviour is called here an interaction process, which is
itself defined in terms of interaction patterns [BBT01]. Each interaction pattern consists of a
finite sequence of events (representing component services) that, when performed, leads the
component (interaction process) back to its initial state. For instance, in our example, the
CLIENT component presents such a recurring behaviour (see Figure 5.2). In this manner, the
component repeatedly offers these sequences of events, similar to possible transactions (includ-
ing compensating actions) performed against a database management system. These patterns
cover a wide range of applications, like transactional stateful components found in several
technologies such as, for instance, Session Enterprise JavaBeansT M and transactional conver-
sational Web Services.

To present the interaction patterns of a process P, InteractionPatterns(P), we use the CSP
operator P/s. If s ? traces(P) then P/s (pronounced ‘P after s’) represents the behaviour of P
after the trace s is performed. So, InteractionPatterns(P) is the set of traces that leads the process
to its initial state.

Definition 5.10 (Interaction patterns). Let P be a CSP process.

InteractionPatterns(P) ={s : traces(P)|P vF D (P/s)? s is finite}

Definition 5.10 is characterised in terms of the CSP failures/divergence semantic model.
It defines the set of traces after which the process presents the same failures and divergences;
these are precisely the interaction patterns of P. From Definition 5.10, we say that a process is
an interaction process, if it can be defined in terms of interaction patterns. Its traces must be
a prefix (?) of an interaction pattern or a combination of them. Note that in either case they
belong to InteractionPatterns(P).

1True client/server systems maintain a context that captures the current state of an ongoing series of actions.
“Client/server” is sometimes used to describe systems that ignore this requirement and simply use components
that call/define procedures or send request/reply messages. We call the latter “naive client/server systems.”



5.3 ARCHITECTURAL STYLES 74

Definition 5.11 (Interaction process). A divergence-free CSP process P is an interaction pro-
cess if, and only if:

?s ? traces(P)•?p : InteractionPatterns(P)• s ? p

We consider that an interaction process represents a complete pattern of services (including
compensating actions). After starting to communicate, the process always perform at least
one pattern completely, and eventually returns to a state where it can initiate other interaction
patterns; only one interaction pattern can be performed at a time. These properties help us in
further verifications in this work.

Based on the above definition, we are able to define components that behave as interaction
processes.

Definition 5.12 (Interaction component). Let C be a component with contract Ctr. Then C is
an interaction component if, and only if, BCtr is an interaction process.

The definition of interaction components explicit how infinite traces can be represented by
processes with a finite number of states, which is one of the requirements of an I/O process.
As said before, it also helps in the verification of process with infinite traces. Although there
may be other strategies for representing infinite traces with a finite number of states, we use
interaction components as our default strategy in the examples used in this work.

Overall, in practice, we can specialise this architectural style in order to represent interac-
tion processes solely in terms of the set of their interaction patterns. In order to achieve this,
we may assume that all choices between events of different channels are external. As a result,
any interaction process P can be defined as a recursive process of the form P = Q ; P, where the
traces of the finite process Q represent interaction patterns of P. A default implementation for
a set of interaction patterns T of an interaction component is PDEF IMP(T), defined as follows.

Definition 5.13 (Default interaction component implementation). Let C be a set of channels,
I a set of interfaces, R a mapping from C to I, and T a set of interaction patterns, such that
T ?{|C|}?. Then the default implementation of T (namely PDEF IMP(T)) is an interaction process.

PDEF IMP(T) = PINT (??,T) ; PDEF IMP(T)

PINT (s,T ) =(2ai : enabled(s,in,T )• ai ? PINT (s_?ai?,T ))

2

(uao : enabled(s,out,T )• ao ? PINT (s_?ao?,T ))
2 s ? (T ?{??})&amp;amp; SKIP

enabled(s,tag,T ) = {t,c,a|t ? T ? c ?C ? tag.a ?R(c) ? s_?c.tag.a?? t • c.tag.a}

The default implementation of an interaction component has a similar behaviour to one
defined for I/O processes in Chapter 4. It is defined as the external choice of its inputs and



5.3 ARCHITECTURAL STYLES 75

the internal choice of its outputs, after a trace s. The set of inputs and outputs is given by
enabled(s,in,T ) and enabled(s,out,T ), which returns the events with the tag in and out after the
trace s in the set of traces T respectively.

Then Ctr = ?PDEF IMP(T),R,I,C? can be accepted as a contract for an interaction component,
and easily transformed into a regular component contract (see Definition 5.3)

5.3.2 Naive client-servers

The requirement for a component in a naive client-server style [SC97] is that it communicates
on each of its ports either as a client or as a server, according to a strict protocol. This protocol
requires that after a client sends a request, it must wait for a reply on that port before communi-
cating again through it. Similarly, a server sends a response, after being requested. We define
a naive client-server component as a component that satisfies this requirement.

Based on the requirement of this style, all protocols of this component satisfy strict con-
ditions: a) requests are followed by replies, and the former never comes before the latter; b)
a response is communicated on the opposite direction of its request; c) the component never
communicates two consecutive requests, or replies, on a same port.

Definition 5.14 (Naive client-server component). Let Ctr be a component contract. Then Ctr
is a naive client-server component if, and only if:

?c,P|c ?CCtr ? P = ProtIMP(Ctr,c)• StrictProt(P,c,in,out)? StrictProt(P,c,out,in)

where StrictProt(P,c,d1,d2) =?s : traces(P)• (s ?{|c.d1|}? s ?{|c.d2|}) ?
(s ?{|c.d1|}? s ?{|c.d2|}+ 1)

The Definition 5.14 says that any protocol of a component satisfies the conditions of being
a server or a client. Their traces have the form: request, response, request, response...; the
number of request is bigger than the number of responses (s ? {|c.d1|}? s ? {|c.d2|}), but their
difference is not bigger than one. The only difference is that a server request is an output, and
a client request is an input. Similarly, the responses have opposite directions. The property
StrictProt represents the strict conditions for being a client or a server.

5.3.3 Protocol oriented components

This style is related to the need of specifying components with respect to their port-protocol be-
haviours. In such a style, any composition preserves the port-protocol behaviour of the original
components in all channels that are still available after they are assembled. There are several
ways to achieve this; most of them restricted to specific applications. In this work, however,
we present this style in a generic form as follows.

Definition 5.15 (Protocol oriented component). We say that a component S is protocol oriented
if, and only if, for any process R, channel c, and set of events Z, such that c ?CS, ? R?{|c|}= /0,
?z? : Z • z? ?CS8{c} ? ProtIMP(R,z?)??ProtIMP(BS,z?), and BS ?

{|Z|}
R is deadlock-free, the following

holds:
BS |? {|c|}vF (BS ?

{|Z|}
R) |? {|c|}



5.4 BRICK COMPONENTS 76

The proviso in the previous definition is hard to verify because we have to consider a wide
range of processes R for a same component S. This is intentionally defined in this way to
cover several other more specific styles that naturally satisfy the conditions of protocol orient-
edness. However, for specific styles, the verification of this proviso can be very easy using
more specific patterns of communication. For instance, classical styles whose components
are also protocol oriented are components with cyclic processes or resource allocation proto-
cols [MW97, Ros98]; classical examples of these are systolic arrays and the dining philoso-
phers, respectively.

An example of a component that is not protocol oriented is one that behaves as follows.
Consider that c and z are channels within the component contract.

Q = c.in.a1 ? c.in.b ? Q
2 c.in.a2 ? z.in.d ? Q

In the process above, the choice between the events c.in.a1 and c.in.a2 determines that the
environment keeps communicating via the channel c or performs the event z.in.d. A valid com-
position might allow only the event c.in.a1 to be performed, precluding communications in z.
Furthermore, compositions with this component may not preserve the protocol on z. This hap-
pens because I/O processes are output decisive, and a refinement of a given I/O processes might
have a more restricted set of outputs to choose from (see the notion of protocol compatibility
in the last chapter). In most examples in this work, we use protocol oriented components. For
instance, the client and server components in our running example are protocol oriented.

5.4 BRICK components

In addition to the contract elements presented in Definition 5.3, there might be other elements
intended to ease and potentialise the use of a component during the development of a sys-
tem. In this section, we define a component contract that specialises the notion of protocol
oriented component and enriches its contract with metadata. These components are called
BRICK-components. The metadata elements record information that aims at alleviating several
verifications in our rigorous strategy for component composition, which is presented in the next
chapter.

By analysing the material about I/O processes in Chapter 4, it is worth observing that some
properties play an important role in the assembly of I/O processes. Moreover, some of these
properties can be predicted from properties of the original components in the composition.

Furthermore, to ease the incremental development of component-based systems, we con-
sider that the previous calculation of these properties is as relevant in a component contract as
the other elements presented in Definition 5.3. In fact, we include these properties in an en-
riched definition of component contracts, so that compositions have to solely consider such en-
riched component contracts. In particular, we focus on the properties related to port-protocols
and decoupled channels (see Definitions 4.6 and 4.21), which are used to verify protocol com-
patibilities and the safe introduction of buffers in a system. These are important properties, as
shown in the next chapter, in the composition of components in systems with tree topologies
(without cycles of dependencies between components). We propose a new component contract



5.4 BRICK COMPONENTS 77

definition, in which these properties are captured as relations that form a component metadata
(representd by K in following definition).

Definition 5.16 (Enriched component contract). Let Ctr be a protocol oriented component
contract, and K a metadata derived from its elements. An enriched component contract that
includes Ctr is represented by:

?BCtr,RCtr,ICtr,CCtr,K?

where K comprises the following information:

K : ?ProtK, CTXK, DProtK, DecK?

such that:

• dom ProtK ?CCtr ? ?c : dom ProtK • ProtK(c)vF ProtIMP(Ctr,c)

• dom DProtK ?CCtr ? ?c : dom DProtK • DProtK(c) is the dual protocol of ProtK(c)

• dom CTXK ?CCtr ? ?c : dom CTXK • CTXK(c) is the context process of ProtK(c)

• dom DecK ?CCtr ? ran DecK ?CCtr ?
?c1,c2 : CCtr • c1 DecK c2 ?{c1,c2}DecoupledInCtr ? c2 DecK c1

The element ProtK is a relation from channels to protocols, which represent the actual port-
protocol of the component on that channel. If a protocol within ProtK satisfies a property, then,
by refinement, it also holds for the protocol of the component. Similarly, the elements DProtK

and CTXK map channels into context processes and dual protocols, respectively. They are
used to support the use of the protocols within ProtK; these are used, for instance, in protocol
compatibility verifications (see Theorem 4.6). Finally the element DecK is a relation among
decoupled channels of the component. Observe that Dec is a symmetric relation, since this
property is inherited from the interleaving operator (see Definition 4.21). Altogether these
elements help to alleviate the verifications of component compositions. Moreover, they can
be easily calculated for compositions using metadata of the original components present in the
assembly.

To briefly illustrate the idea of metadata, let us define a protocol ProtSV 10 for a server, in a
bank where basic accounts are limited to have more than 5 dollars and less than 1000 dollars.
The processes DProtSV 10 and PCTXSV 10 below are the dual protocol and the context process of
ProtSV 10, respectively.

ProtSV 10 = µ X • sv.in.wd?x ? (ua : Bool • sv.out!ackW d.a)? X
2 sv.in.reqBal ? (uy : 5..1000 • sv.out!resBal.y)? X

DProtSV 10 = µ X • (ux : Int • sv.in.wd!x ? sv.out.ackW d?a)? X
2 sv.in.reqBal ? (2y : 5..1000 • sv.out.resBal.y)? X



5.4 BRICK COMPONENTS 78

PCTXSV 10 = µ X • sv.in.wd?x ? sv.out.ackW d?a ? X

2 sv.in.reqBal ? (2y : 5..1000 • sv.out.resBal.y)? X

Let us also suppose that we have a server that can communicate with two clients concur-
rently. For the sake of brevity, we define this server as the interleave of two simple servers; one
communicating on the channel sv and the other on sv? – both channels typed by the interface
ISV . The enriched component contract of this server is defined as CtrSERVER2.

CtrSERVER2 = ?SERVER ||| SERVER[[sv
?
/sv]],{sv 7? ISV ,sv? 7? ISV},{ISV},{sv,sv?},KSERVER2?

where

KSERVER2 = ?{sv 7? ProtSV 10,sv? 7? ProtSV 10[[sv
?
/sv]]},{sv 7? PCTXSV 10,sv? 7? PCTXSV 10[[sv

?
/sv]]},

{sv 7? DProtSV 10,sv? 7? DProtSV 10[[sv
?
/sv]]},{(sv,sv?)}?

The metadata is formed by protocols that limit the account balance, their dual protocols and
context processes, as well as a relation that indicates that sv and sv? are not dependent on each
other (they belong to two distinct processes in an interleave). We over restrict the protocols in
the metadata (they limit the account balance) to illustrate the ideas behind this notion.

Note that CtrSERVER2 is a protocol oriented component, in which whenever a client is assem-
bled to the channel sv?, the protocol implementation associated to sv is preserved, and vice versa;
therefore, the protocol ProtSV 10 within the metadata still refines ProtIMP(CtrSERVER2,sv) (the same
occurs for ProtSV 10[[sv

?
/sv]] and the protocol implementation of sv?). These protocols are ready to

be used in protocols compatibility verifications of compositions. As they are preserved in com-
positions, verifications in subsequent compositions do not have the onus of deriving protocols,
and, furthermore, understanding the new behaviour defined by the composition.

Decoupled channels are also useful to simplify assemblies of channels of the same compo-
nent, identifying inner interleaves inside the component. This is a relation that can be easily
observed in white box components, but that requires additional verifications in gray or black-
box components; for this reason it was elected to be an element of the component contract
metadata. Due to the compositionality of interleaves, decoupled channels relations are not dif-
ficult to be predicted in compositions: if a client is assembled to the server via the channel sv,
the communication in the channels of the client are independent of communications in sv? (and
vice versa), so, by induction, new decoupled channels relations are defined.

Observe that the metadata elements (K) have a loose definition. They are intentionally
defined in this way to avoid including all protocols or relations between decoupled channels.
When not provided by the developer of the component, such properties must be calculated
by whom is interested on them (see definitions 4.8, 4.15, 4.17, and 4.21). In any case, these
properties can be derived from the other component contract elements (B, R, I, or C). When



5.4 BRICK COMPONENTS 79

present, metadata ease the verification of important constraints in the development. As compo-
nents are possibly reusable in many scenarios, the cost to define such metadata is proportionally
distributed by the degree of reuse employed.

In order to link the definition of enriched component contracts with the one for regular
components (Definition. 5.3), we define the function Enrich as follows.

Definition 5.17 (Enrich Component Contract). Let Ctr be a protocol oriented component con-
tract, and K a metadata derived from its elements. Then:

Enrich(Ctr,K) = ?BCtr,RCtr,ICtr,CCtr,K?

This is a very simple function used to construct enriched component contracts from regular
component contracts and already known metadata of these component contracts.

In the next chapters we explore relevant properties of the component model and architec-
tural styles presented here.



CHAPTER 6

A rigorous strategy for component compositions

The constructive constraints for the BRIC component architectural model are based on compo-
sition rules for components. These rules present a systematic strategy to build systems when-
ever every two components are compatible to interoperate. They aim at guiding the developer
in the composition of regular components in the BRIC component model, guaranteeing, by
construction, preservation of some quality attributes amenable for verification by construction.
Together with the characterisation constraints in the component model, the rules impose side
conditions to compositions in order to ensure they are correct.

The composition rules are defined on the top of the notion of service conformance. Service
conformance can be understood as a design principle to be followed, when permitted: unused
services of a component should be still available after composition. The degree of satisfaction
of this notion may vary from preserving all services (strong conformance) to at least one (weak
conformance). The set of composition rules for the BRIC component model satisfy the weak
service conformance, and the set of composition rules for the BRICK component model satisfy
the strong service conformance.

The rest of this chapter is organised in three parts. The first one presents a prelude of our
strategy. It discusses the benefits and limitations of local analysis, and the quality attributes
we focus on this work. In special, we present our notions of service conformance, from which
our compositions are lifted up. The second part sets out general rules for component based
systems. Based on them, we guarantee that properties about individual components (P(A) and
P(B)) are preserved by their composition (P(A?B)). The third part considers basic assumptions
about the architectural styles presented in the previous chapter in order to understand scenarios
that are still amenable for compositional preservation of quality attributes. Based on these
assumptions, we are able to construct some elaborate rules for these architectural styles that
require less complex verifications and, furthermore, alleviate the verification of other quality
attributes by construction.

6.1 Local analysis

A first (and widely used) attempt to prove behavioural properties in a composition would be
directly checking such properties in the compound system, without any assumption about its
components. However, this significantly decreases the value of a component-based approach,
since to determine an attribute (or property) in a system after integration or deployment to a
target system is often costly. In this section, we present composition rules that guarantee com-

80



6.1 LOCAL ANALYSIS 81

position properties of a system by construction, based on the same properties of its constituting
components, so that problems are anticipated before all parts are integrated.

These rules form a restricted model for component integration that shows whether a com-
position preserves a behavioural property or not. By not satisfying a property, it does not mean
that the composition is in fact problematic, but that this system does not attend to a pre-existing
(or proposed) set of conditions that guarantee such a property.

It is true that some properties are global phenomenon over the whole system (emergent
properties) and sometimes arise, or fail to arise, for extremely subtle reasons. For most of
them, there is probably no complete method for deciding whether or not a property is satisfied
other than brute-force state exploration. And yet all the rules described in this section rely
entirely on local analyses. With such rules, one cannot hope to decide all cases, although they
do seem to work for a significant class of applications, as illustrated by our examples.

General rules based on local analyses are sometimes limited. For instance, a system might
be carefully designed to guarantee a certain property, but presents an elaborate design or in-
teraction with other components that prevents any automatic verification using general rules.
Nevertheless, systems that are carefully designed also tend to follow specific rules, and these
rules usually conform to an architectural style. As a consequence, new specific composition
rules can be proposed for specific architectural styles, as we exemplify in this chapter.

6.1.1 Desirable quality attributes

Before presenting composition rules that ensure the preservation of design properties by con-
struction, it is essential to discuss the kind of quality attributes we are concerned with. We are
interested in preserving behavioural properties. In particular, we support the argument that the
preservation of basic properties helps in the preservation of more complex ones.

For instance, let’s have a look on notions of service conformance (originally presented
in [RSM10], but revisited here for introducing two levels of conformance). Satisfying this
property means that the composition conforms to the services of the original components, or,
in other words, that services not directly involved in the composition are preserved. The reason
we do not consider the services involved in the composition is because they are not available
afterwards for new assemblies. With this in mind, we consider that these services assist in the
implementation of the other external visible services. We capture this notion with a refinement
expression which requires that the observed behaviour of the composed components refines the
behaviour of the original components, hiding all ports involved in the composition.

There are two levels of conformance agreement. In the strongest one, services provided in
all external visible channels are preserved. In the weakest notion, services provided in part of
the channels are preserved. Below, we formally present them.

Definition 6.1 (Service conformance). Let {Ctr1,Ctr2,...,Ctrn} be a set of components, and
CCtr be a component contract, such that CCtr = (Ctr1 s11 ? s12 Ctr2)s21 ? s22 ... sm1 ? sm2 Ctrn. Then
the composition CCtr

• weakly conforms to the services of the components Ctr1...Ctrn if, and only if:

?i,c|c ?CCCtr ?CCtri • (BCtri |? {|c|})vF (BCCtr |? {|c|})



6.1 LOCAL ANALYSIS 82

• strongly conforms to the services of the components Ctr1...Ctrn if, and only if:

?i,c|c ?CCCtr ?CCtri • (BCtri |? {|c|})vF (BCCtr |? {|c|})

As in any composition the channels involved in the integration are removed from the set
CCCtr. As a result, channels within CCCtr ?CCtri exactly represent the channels of Ctri that re-
mains externally observable after the composition. The behaviour restricted to these channels
constitute the services we look for. The conformance is then expressed by the refinement of
services in the components (the original one and the composition).

Strong conformance may not be always desired. It is easy to think in scenarios that part
of the component is put aside in order to other components achieve a global goal as part of
a coordination strategy of the components of the system. So, strong conformance depends as
much of the careful design of its components as of their correct composition. As its name says,
the weak conformance notion is more flexible to such condition.

The concern on design can be replaced by the use of architectural styles. Systems with
protocol oriented components (see Section 5.3.3) satisfy the conditions for weak conformance
notion. Observing Definition 5.15, it is easy to see how a style with stronger conditions could
achieve strong conformance notion. The advantages of architectural styles to preserve proper-
ties are discussed later in this chapter.

It is interesting to observe that not all quality properties are independent. In fact, the service
conformance notion depends on more basic properties. Analysing the refinement expression,
we observe that it is based on the semantics of hiding. Any event outside the alphabet used for
comparison is assumed to be always enabled. However, we know that this might not be true
after component integration. Problems might arise during integration, and stuck the communi-
cation of those events.

According to the CSP semantics, the reasons for a system to get stuck are the two classical
quality attributes, commonly cited as emergent properties: deadlock- and livelock-freedom
[Lev95]. They are cited as emergent properties because in order to verify them it is necessary to
check the interaction of several components in the system. Deadlock arises when components
in a composition might be waiting for each other to proceed, so that no external communication
is visible. Livelock arises when components infinitely communicate on internal channels (those
not externally observable). Looking at sections 5.2.4 and 5.2.5, we note that deadlock and
livelock problems are introduced by different CSP operators. In this context, deadlocks might
arise from the synchronisation between components, while livelocks are possible introduced
after applying the hiding operator. For the sake of brevity, we say that a component contract
Ctr is livelock or deadlock-free, if its behaviour (BCtr) is.

The analyses of those quality attributes give us some insights about how to restrict the sce-
narios in which undesirable problems do not arise in the component integrations. Based on this
analysis we present the composition rules in the next sections, mainly focusing on deadlock and
livelock freedom. As observed for the service conformance notion, the preservation of these
classical properties is important in the analysis of general integration problems. Other confor-
mance notions might be interesting for more specific coordination purposes. Some examples
of conformance notions are presented in Chapter 7.



6.2 COMPOSITION RULES 83

6.2 Composition rules

In this section, we present four composition rules; each one focuses on a specific problem
at development. They specialise the asynchronous compositions shown in Section 5.2.4, and
focus on the preservation of deadlock-freedom. The reason for not coping with livelocks is that
they are only introduced after wrappings.

A way to guarantee livelock-freedom is to provide that wrappings perform safe hidings (see
Definition 4.22). So, to preserve both properties, one has just to lift our rules to comprise such
property. In any case, the verification by construction of livelock-freedom is still costly, since
it must be verified on the whole system (or composition). Means to alleviate the verification of
such problem, in specific architectural styles, are presented in Section 6.3.2.

The next section presents our four composition rules, how they can be combined, and,
furthermore, how they preserve deadlock-freedom in the entire system by construction.

6.2.1 General composition rules

In this work we propose a comprehensive set of compositions that ensure correct systems by
construction. For instance, applying these rules, one can predict the absence of deadlocks in
the system, or even early identify this problem.

In order to cope with the complexity of deadlock analysis, each of our composition rules
is related to a scenario at composition. Instead of focusing on assembling different compo-
nents (as it traditionally conceived), our composition rules focus on synchronising two chan-
nels of two components, or even the same component. Mainly, the pairwise verification of
port-protocols on these channels guarantees deadlock-freedom in the entire system.

The four rules are presented in this section in an increasing order of complexity. They
are named interleave, communication, feedback and reflexive compositions. Each of these
compositions constructs a new component, which includes the original ones. In other words,
each composition results in a unique, and elaborate, component.

The structures of three of these composition rules are illustrated in Figure 6.1. The inter-
leave and communication composition rules are binary compositions (they assemble channels
of two distinct components). The feedback and reflexive composition rules are unary composi-
tions (they assemble distinct channels of a component). These unary compositions rules have
the same structure; they are distinguished by the conditions they impose.

The interleave composition rule concerns the case where no channel is synchronised, or, in
other words, no communication is established. The communication one represents the tradi-

Figure 6.1 Three composition rules proposed in this work.



6.2 COMPOSITION RULES 84

tional case, when the composition involves two components. As these rules always take distinct
components, they always results in systems that follows a tree topology; systems that, when its
structure is flattened, results in a graph of communicating components with no cycle. The vi-
sualisation of the topology, however, is sometimes hidden, since compositions generate new
components that enclose the original ones.

In addition to our binary compositions rules, we present unary composition rules that as-
semble two channels of the same component. Unary rules complement the binary rules by
linking component in an existing structure. In this way, we can connect unassembled channels
in existing components of a tree topology system, or even create proper graphs of components
(when we visualize a flattened structure of the system).

The third rule corresponds to the simpler unary composition case, where two channels of
the same component are assembled, but do not introduce a new cycle. The rule imposes that the
original component presents a partition in its behaviour (there is a low cohesion). These first
tree compositions are the rules used more often, and that luckily requires less complex verifica-
tions. As this partition is not always explicitly visible in the system structure, this system can
be observed some times as a graph with cycles, however, behaviourally to an equivalent tree-
topology system. To avoid misunderstanding, we call these systems of pseudo cyclic systems.

The last composition rule, reflexive, deals with cycle-topologies. In particular, it is one
that intentionally introduces a cycle whenever this does not introduce problematic dependen-
cies among the communication of events in the system. Similar to the feedback composition,
it also assemblies two channels of the same component. In fact, it generalises the feedback
composition rule, imposing more complex verifications

These are the composition rules that can be used in sequence to design a wide variety
of systems, with different topologies. Elaborate rules for regular components can be derived
from these basic ones, as we show in Section 6.2.3. As connectors have the same structure
of components, these can be similarly used in our composition strategy. For instance, we can
assemble two connectors, or a connector to a component, using a communication composition
rule. In this way, we give a uniform treatment for both design elements.

As said before, the simplest form of composition is to aggregate two independent entities
such that, after composition, these entities still do not communicate between themselves. They
directly communicate with the environment as before, with no interference from each other. To
perform this composition form, there is a proviso that they do not share any communication
channel.

Definition 6.2 (Interleave composition). Let P and Q be two component contracts, such that P
and Q have disjoint channels, CP?CQ = /0. Then, the interleave composition of P and Q (namely
P[|||]Q) is given by:

P[|||]Q = P?? ? ??Q

The above composition form is, by definition, a particular kind of direct composition that
involves no communication, resulting in a weakly cohesive entity, which performs all events
defined in the original entities without any interference from each other.

Theorem 6.1. Deadlock-free Interleave Composition
The interleave composition of two deadlock-free component contracts is also a deadlock-free
component contract.



6.2 COMPOSITION RULES 85

Proof. The statement that the resulting process is deadlock-free follows directly from the
condition that the components do not share any channel. Furthermore, as showed below,
BP[|||]Q = BP |||BQ. As BP and BQ are deadlock-free, so is, from the semantics of the interleave
operator, BP[|||]Q. We start by expanding the direct composition of P and Q (Definition 5.7).

BP[|||]Q ?F (BP |||BQ) ?
{}

(
|||

c?{}
BU F F ?IO(c,F(c))

)
no buffer is used, c ?{}

?F (BP |||BQ) ?
{}

SKIP rewriting

?F BP |||BQ

The proof that the composition rule is component contract results directly from Theo-
rem 5.1.

The second form of composition states the most common way for assembling complemen-
tary channels of two entities. It links a channel of one entity to a channel of the other entity, as
in a direct composition (Definition 5.7).

Definition 6.3 (Communication composition). Let P and Q be two component contracts, and
ic and oc two communication channels, such that ic ? CP ? oc ? CQ, CP ? CQ = /0, and the port-
protocols ProtIMP(P,ic)[[R ic?ocIO ]] and ProtIMP(Q,oc)[[R

oc?ic
IO ]] are I/O confluent strong compatible

and satisfy the finite output property. Then, the communication composition of P and Q (namely
P[ic ? oc]Q) via ic and oc is defined as follows:

P[ic ? oc]Q = P?ic? ? ?oc?Q

In our composition rules, we assume each component has a distinct set of interaction points
(CP ? CQ = /0), and that their communication is asynchronous, mediated by buffers. In the com-
position P[ic ? oc]Q, values of P are asynchronously forwarded to Q through an internal buffer,
which is confined in the composition (see Definition 5.7). In order for the two components be
compatible in an asynchronous medium, we require that they satisfy the finite output property
(FOP) and that their protocols are I/O confluent(see definitions 4.19 and 4.18). Observe that
composition operator (? ) consider the existence of infinite buffers in the medium. In case, we
know the medium can be specified as a buffer of finite size, satisfying the finite output property
is immaterial.

Theorem 6.2. Deadlock-free Communication Composition
The communication composition of two deadlock-free component contracts is also a deadlock-
free component contract.

Proof. The communication composition of two components P and Q is formed, in fact, of
two parallel synchronisations. The composition operator ? implicitly introduces a buffer that
always accepts any communication from P, and forwards to Q, and vice-versa. As these com-
ponents have strong compatible port-protocols, they always accept communications from each
other. This theorem results direct from Theorem. 4.9.



6.2 COMPOSITION RULES 86

To prove that a divergent-free component R is deadlock-free, we have to prove that BR \ ?
diverges [Ros98]. In the statements below we rewrite the behaviour of a composition of two
component contracts P and Q using the channels ic and oc.

BP[ic?oc]Q \ ? =

(
(BP |||BQ) ?

{|ic,oc|}

(
|||

c?{ic}
BU F F ?IO(c,F(c))

))
\ ?

=

(
(BP |||BQ) ?

{|ic,oc|}
BU F F ?IO(ic,oc)

)
\ ?

=

(
BP ?
{|ic|}

BU F F ?IO(ic,oc) ?
{|oc|}

BQ

)
\ ?

=

(
BP ?
{|ic|}

BU F F ?IO(ic,oc) ?
{|oc|}

BQ

)
\ (?8{ic,oc})\ ?

=

(
BP |? {|ic,oc|} ?

{|ic|}
BU F F ?IO(ic,oc) |? {|ic,oc|} ?

{|oc|}
BQ |? {|ic,oc|}

)
\ ?

=

(
P |? ic ?

{|ic|}
BU F F ?IO(ic,oc) ?

{|oc|}
Q |? oc

)
\ ?

If either P |? ic or Q |? oc diverges, them the synchronisation above diverges, proving that the
composition is deadlock-free. So,in order to continue the proof, we assume that these projec-
tions are divergence-free.

BP[ic?oc]Q \ ? =

(
P |? ic ?

{|ic|}
BU F F ?IO(ic,oc) ?

{|oc|}
Q |? oc

)
\ ?

=[P |? ic and Q |? oc are divergence-free](
ProtIMP(P,ic) ?

{|ic|}
BU F F ?IO(ic,oc) ?

{|oc|}
ProtIMP(Q,oc)

)
\ ?

=[Theorem 4.9]

div

The proof that the composition rule is component contract results directly from Theorem 5.1.

The next two composition rules show how we can build systems with cyclic topologies.
In particular, we focus on assembling two channels of the same component. Since we build
systems by composing components pairwisely, a set of assembled components can always be
taken as a single large grain entity. In doing so, composing outputs and inputs of this large
grain component allows introducing cycles in the flattened structure.

Due to the existence of cycles, new conditions have to be taken into account to preserve
behavioural properties in the composition. This topic is closely related to the study of more
general approaches to ensure deadlock freedom [MW97, Ros98]. They identify that deadlocks



6.2 COMPOSITION RULES 87

arise in complex (graph) topologies by the presence of undesirable cycles, called cycles of
ungranted requests [Ros98].

The third composition rule deals with pseudo cyclic topology, which are behavioural equiv-
alent to systems with tree-topologies. It does have some cycles, but none of them introduces
deadlocks. However, it cannot express all possible topologies. For this reason, verification
on this topology is simpler than in arbitrary complex topologies. The feedback composition is
aligned with the incremental nature of our strategy, dealing with a one problem at a time. A
rule for more complex topologies is presented in Definition 6.5.

In order to avoid undesirable cycles, we base our approach on the notion of decoupled
channels (see Definition 4.21 ). According to this notion, communication on one channel does
not interfere on communications through the other (their communications are interleaved). This
is a simple way to avoid undesirable cycles. The intuition here is in accordance with the notion
of independency between parallel I/O processes proposed in [MW97] to avoid deadlocks in
cyclic networks in CSP.

Definition 6.4 (Feedback composition). Let P be a component contract, and ic and oc two com-
munication channels, such that ProtIMP(P,ic)[[R ic?ocIO ]] and the protocols ProtIMP(P,oc)[[R

oc?ic
IO ]] are

I/O confluent strong compatible and satisfy the finite output property, {ic,oc}? CP and decou-
pled in P. Then, the feedback composition P (namely P[oc ?? ic]) hooking oc to ic is defined as
follows:

P[oc ?? ic] = P ?
???ic?
?oc?

In the resulting composition, P[oc ?? ic], values of P through oc are communicated to the
feedback channel ic. Both channels oc and ic are then confined in the composition (see Def-
inition 5.8) and are not available to the environment. This composition rule imposes some
conditions that are similar those in the communication composition rule (relative to protocol
compatibility and buffer tolerance), except that it additionally imposes that channels are de-
coupled. As mentioned before, this last condition imposes that the protocols associated to the
assembled channels behave independently of each other, and furthermore, the new communi-
cation does not introduce deadlocks.

Before presenting a theorem related to this kind of composition, we present the reflexive
composition rule, which is more general. The proof of these two rules are related; in fact, as
we show later, the feedback composition is a subcase of the reflexive composition.

The composition rules presented so far deal with systems with a tree. In practice, there
are more complex systems that indeed present cycles of dependencies in the topology of the
system structure. In fact, not all cycles are undesirable. It has being pointed out [Ros98] that
the unique undesirable cycles are those that present a cycle of ungranted requests. These are
cycles in which all components simultaneously realise a request that is prevented by the next
component, so all of them deadlock.

To deal with such cycles, we note that in order to avoid deadlock, we only need to know
what kind of dependency exists between channels used in a cycle. In general it is difficult
to classify all possible dependency kinds. So, in order to cover the general case, we use in
addition projections with two channels, instead of solely port-protocols. Only the order among
communication in these channels matters. They have to allow the injection of information from



6.2 COMPOSITION RULES 88

one channel to the other via the implicit buffers of the composition. We call this rule reflexive
composition.

Definition 6.5 (Reflexive composition). Let P be a component contract, and ic and oc two com-
munication channels, such that {ic,oc}? CP, and P |? {|c,z|} buffering self-injection compatible
and satisfies the finite output property. Then, the reflexive composition P (namely P[oc ¯??ic])
hooking oc to ic is defined as follows:

P[ic ¯??oc] = P ?
???ic?
?oc?

A reflexive composition is similar to the feedback composition. Both assemble channels
of the same component contract. They differ in the relationship between these channels. The
feedback composition assembles independent channels, and the reflexive composition deals
with dependent ones, thanks to the buffering self-injection compatible property (see Defini-
tion 4.20). Provided that the behaviour is buffering self-injection compatible, then it is possible
to introduce a buffer to assembly the channels ic and oc without the composition deadlocks. In
fact, the reflexive one is more general than the feedback one. However, it is also more costly.
For this reason, we have distinguished them. This cost is directly associated to the cost of de-
termining if the projection is self-injection compatible. We observe later that in several cases,
in which components follow specific communication patterns (or architectural styles), it is eas-
ier to categorise all possible dependency relationships existing in a system, and performing
verifications about them. We show one of these cases in Section 6.3.

Similar to our other composition rules, a reflexive composition preserves deadlock-freedom.

Theorem 6.3. Deadlock-free Reflexive Composition
The reflexive composition of two deadlock-free component contracts is also a deadlock-free
component contract.

Proof. This proof is similar to the one for Theorem 6.2. Buffers are also implicitly introduced
in the communication. As for communication composition, we provide a theorem that supports
our proof, Theorem 4.10.

To prove a divergent-free component R is deadlock-free, we have to prove that BR \ ? di-
verges [Ros98]. In the statements below we rewrite the behaviour of a composition of a com-
ponents contracts P using the channels ic and oc.

P[ic ¯??oc]\ ? =

(
BP ?
{|ic,oc|}

(
|||

c?{ic}
BU F F ?IO(c,F(c))

))
\ ?

=

(
BP ?
{|ic,oc|}

BU F F ?IO(ic,oc)

)
\ ?

=

(
BP ?
{|ic,oc|}

BU F F ?IO(ic,oc)

)
\ (?8{|ic,oc|})\ ?

=

(
BP |? {|ic,oc|} ?

{|ic,oc|}
BU F F ?IO(ic,oc)

)
\ ?

=

(
P |? {ic,oc} ?

{|ic,oc|}
BU F F ?IO(ic,oc)

)
\ ?



6.2 COMPOSITION RULES 89

According to Theorem 4.10 the process in parentheses is deadlock-free, so hiding the whole
alphabet results in divergence.

P[ic ¯??oc]\ ? = div

The proof that the composition rule is component contract results directly from Theorem 5.2.

A similar theorem is related to the feedback composition.

Theorem 6.4. Deadlock-free Feedback Composition
The feedback composition of a deadlock-free component contract is also deadlock-free.

Proof. This theorem results direct from Theorem 4.11. The decoupled property in the feedback
composition implies in self-injection compatibility. As a result, according to Theorem 6.3, the
feedback composition is also deadlock-free.

6.2.2 Trustworthy component systems

From our proposed building block constructors (composition rules), any system S can be struc-
tured as follows.

S ::=P

| S [|||]S
| S[c1 ? c2]S
| S[c1 ?? c2]
| S[c1 ¯??c2]

where P is a component contract whose behaviour is deadlock free. We say that any component
system that follows this grammar is in normal form.

Theorem 6.5. Deadlock-free Component Systems
Any system S in normal form, built from deadlock-free components, is deadlock-free.

Proof. Direct from theorems 6.1, 6.2, 6.4, and 6.3.

Theorem 6.5 is an important theorem in this work. It says that any system that follows
our rules preserves the deadlock-free quality property, and emphasises the relevance of our
composition rules in a rigorous strategy. Observe that livelock-free could easily be added in
our theorem, since all operators used within our normal form does not introduce livelocks. As
we said before, livelocks are introduced by the wrapping operator and, unfortunately, demands
heavy verification in the whole composition, after wrapping is performed. In Section 6.3,
we discuss how verification on compositions with arbitrary components can be alleviated by
following an architectural style. In Chapter 7 we present practical examples were these rules
are applied in order to ensure that the final system is deadlock-free.



6.2 COMPOSITION RULES 90

6.2.3 Rule compositionality

Sound composition rules can also be elaborated based on the general composition rules pre-
sented so far. Similar to them, elaborate rules should underlie common practices in develop-
ment. For instance, to assist developer activities, a desirable issue is to connect several ports
(channels) in one step. To perform such a task, we would have to use the feedback or the com-
munication composition rules several times, assembling channels pairwise. In order to perform
such compositions in one step, we have defined two new composition rules, which extend the
previously defined feedback and communication composition rules.

Definition 6.6 (Extended feedback composition). Let P be a component contract, and chseq1
and chseq2 two nonempty sequences of distinct communication channels, such that:

• (ran chseq1 ? ran chseq2)?CP ? (ran chseq1 ? ran chseq2) = /0;

• (ran chseq1 ?ran chseq2) DecoupledIn P ? #chseq1 = #chseq2

• ?i,z,c|c = chseq1(i) ? z = chseq2(i) • ProtIMP(P,c)[[R c?zIO ]] and ProtIMP(P,z)[[R
z?c
IO ]] are I/O

confluent strong compatible port-protocols and satisfy the finite output property;

Then, the extended feedback composition of P (namely P[chseq1 ?? chseq2]) via the channels
within chseqP and chseqQ is defined as follows:

P[chseq1 ?? chseq2] = P ?
??chseq1
chseq2

The composition rule above is very similar to feedback composition, except for the fact that
it assembles several channels at once. In fact, the result of this composition rule is equal to the
application of several consecutive feedback compositions. Instead of taking a pair of channels,
the extended composition rule takes two sequences of channels to assemble. The channels are
assembled pairwisely according to their order; the first channel in one sequence is assembled
to the first one the other sequence, and so on. Similarly to feedback composition rule, the
extended feedback composition also guarantees deadlock-freedom.

Theorem 6.6. Deadlock-free Extended Feedback Composition
The extended feedback composition of a deadlock-free component contract is also deadlock-
free.

Proof. The extended feedback composition has exactly the same conditions of a regular feed-
back composition, except it is more restrictive; it has a bigger set of decoupled channels. Then,
we observe that, assuming c and z the head of chseq1 and chseq2, the composition P[c ?? z] is
allowed. Such resulting process satisfies the provisos of Definition 6.6, similarly to P, except
that the new sequences are the tail of chseq1 and chseq2. Consider that the channels within the
tail of chseq1 and chseq2 are represented by CT1 and CT2, respectively. The following statements
shows that the channels within these sequences are decoupled in P[c ?? z].



6.2 COMPOSITION RULES 91

P[c ?? z] |? CT1 ?CT2
?F [Definition 6.4]

P ?
{|c,z|}

BU F F ?IO(c,z) |? CT1 ?CT2

?F [Definition 4.7 ]
(P ?
{|c,z|}

BU F F ?IO(c,z)) |? {|CT1 ?CT2|}

?F [{|CT1 ?CT2|}?{|ran chseq1 ?ran chseq2|}]
(P ?
{|c,z|}

BU F F ?IO(c,z)) |? {|ran chseq1 ?ran chseq2|} |? {|CT1 ?CT2|}

?F [hide-?
X

-dist]

(P |? ran chseq1 ?ran chseq2 ?
{|c,z|}

BU F F ?IO(c,z)) |? {|CT1 ?CT2|}

?F [Definition 4.21, assuming Pi? is a process such that ProtIMP(P,i)v Pi?]

(((|||
i?CT1?CT2

Pi?) ||| (Pc? ||| Pz?)) ?
{|c,z|}

BU F F ?IO(c,z)) |? {|CT1 ?CT2|}

?F [applying the restricting operator]

|||
i?CT1?CT2

Pi?

Using a similar strategy, but hiding a unique channel per time, it is easy to see that

? j ?CT1 ?CT2 • ProtIMP(P, j)vF ProtIMP(P[c ?? z], j)

This concludes that the feedback compositions P[c ?? z] satisfies the provisos of Definition 6.6.
By induction, we prove that the Definition 6.6 can be represented by a consecutive application
of feedback compositions. Moreover, P[chseq1 ?? chseq2] is deadlock-free.

Similarly, we also define a composition rule for distinct components using several channels.

Definition 6.7 (Extended communication composition). Let P and Q be two component con-
tracts, and chseqP and chseqQ two nonempty sequences of distinct communication channels,
such that:

• CP ? CQ = /0 ? ran chseqP ?CP ? ran chseqQ ?CQ;

• ran chseqP DecoupledIn P ? ran chseqQ DecoupledIn Q ? #chseqP = #chseqQ

• ?i,z,c|c = chseqP(i) ? z = chseqQ(i) • ProtIMP(P,c)[[R c?zIO ]] and ProtIMP(Q,z)[[R
z?c
IO ]] are I/O

confluent strong compatible port-protocols and satisfy the finite output property;



6.2 COMPOSITION RULES 92

Then, the extended communication composition of P and Q (namely P[chseqP ? chseqQ]Q) via
the channels within chseqP and chseqQ is defined as follows:

P[chseqP ? chseqQ]Q = PchseqP ? chseqQ Q

The composition rule above is very similar to a communication composition, except for the
fact that it assembles several channels at once. The additional provisos state that each pair of
assembled channels (chseqP(i) and chseqQ(i)) are independent of the other channels involved in
the composition. This proviso guarantees that no cycle of dependencies is introduced. A sim-
ilar composition could be obtained from the application of a communication composition and
several subsequent feedback compositions. Similarly to these composition rules, the extended
communication composition also guarantees deadlock-freedom.

Theorem 6.7. Deadlock-free Extended Communication Composition
The extended communication composition of deadlock-free component contracts is also dead-
lock-free.

Proof. This theorem results from Theorem 6.6, since definitions 6.7 and 6.6 carry several pro-
visos in common. To use our previous findings, we apply an interleave composition between
two components P and Q. If P and Q satisfy the provisos of Definition 6.6, then P[|||]Q satis-
fies the provisos of Def 6.6. First, based on the interleave of the components, we observe that
following relation between port-protocols of P and Q and of the composition.

ProtIMP(P[|||]Q, j) =

{
ProtIMP(P, j) j ?CP
ProtIMP(Q, j) j ?CQ

Based on this, and considering CT1 = ran chseqP ?CT2 = ran chseqQ, we observe that:

P[|||]Q |? CT1 ?CT2

?F [Definition 6.2 and hide-?-dist]

(P |? CT1 ?CT2) ||| (Q |? CT1 ?CT2)

?F [{|CT2|} /? ? P and {|CT1|} /? ? Q]

(P |? CT1) ||| (Q |? CT2)

?F [relation between port-protocols of P and Q and of the composition]

|||
j?CT1?CT2

ProtIMP(P[|||]Q, j)

Considering the above, we are allowed to perform the extended feedback composition on
P[|||]Q assembling channels of chseqP with chseqQ. Based on Theorem 6.6, such composition is
deadlock-free.



6.3 VERIFICATION IMPROVEMENTS USING ARCHITECTURAL STYLES 93

6.3 Verification improvements using architectural styles

As mentioned earlier, the use of architectural styles may help in the verification of component-
based systems, and, in special, in verifications related to their compositions. Particularly, we
use the styles: interaction, protocol oriented, and BRICK components. The first two styles help
to guarantee livelock freedom and local progress, respectively. In addition, BRICK components
help to scale our strategy to the development of large systems.

Protocol oriented components deals with a set of concerns related to port-protocols, which
play a vital role in our strategy. In particular, we observe that sometimes a channel of a compo-
nent does not have an associated port-protocol. The reason is that there are several conditions
that must be satisfied in order to have a well-formed port-protocol (see definitions 4.6 and 4.5),
and these are not always achieved after we design the behaviour of a component in terms of
a specific channel. Another concern is that port-protocols associated to a specific channel are
preserved after successive compositions. These concerns are accomplished by using protocol
oriented components, since it forces all channels to have an associated port-protocol and guar-
antees that their projections are preserved after synchronisations with other components. As all
port-protocols in a system are always preserved (even those not observed in a composition), we
guarantee, by consequence, that all components in a system progress (see Section 5.3.3).

In the next section, we show how interaction components can be used to help in the treat-
ment of divergences. We show a variant of the wrapping operator, which can be easily used
together with our composition rules to verify by construction the absent of deadlocks and live-
locks in a system.

In Section 6.3.2, we show a set of composition rules for the BRICK components. These
rules are improved by the use of metadata, which help to alleviate verifications and, further-
more, scale in strategy to larger systems. As BRICK components are also protocol oriented
components, these rules guarantee by construction the local progress, in addition to the ab-
sence of deadlocks.

6.3.1 Wrapping interactions

A desirable quality attribute not addressed by the general composition rules presented in Sec-
tion 6.2 is livelock-freedom. The reason livelocks are only dealt with now is because diver-
gences are only introduced in a composition by performing wrapping (see Definition 5.9).
Furthermore to our knowledge, no compositional verification strategy detects divergence in ar-
bitrary systems. In order to solve such a problem, we analyse some properties that explain how
livelocks are introduced in the interaction component style (see Section 5.3.1).

Lemma 6.1. Let Ctr be an interaction component contract with behaviour P, and C a set of
communication channels. Then

P is livelock-free ? (P \C) diverges ??t ? InteractionPatterns(BCtr)• chans(t)?C

Proof. This lemma follows directly from the interaction component definition. In an interaction
component, an infinite trace is formed of the concatenation of several interaction patterns. If
an interaction component only diverges after hiding certain events, then these events are those



6.3 VERIFICATION IMPROVEMENTS USING ARCHITECTURAL STYLES 94

used by the infinite traces of the livelock.

P is livelock-free ? (P \C) diverges
?[Definition 5.11]
?t : InteractionPatterns(P)|chans(t)?C

The previous property says that if livelock-freedom is not preserved after wrapping an in-
teraction component (or composition), then there is an interaction pattern that performs only
events on hidden channels. This property gives us some insights about how to guarantee this
quality attribute. Since interaction patterns are usually known, we can keep all possible sets of
channels used by each interaction pattern of an interaction component, and predict possible sets
used after the component being composed with others. We call these sets interaction channels.

Definition 6.8 (Interaction channels). Let Ctr be an interaction component contract. Then its
interaction channels are:

IntChCtr ={chans(t)|t ? InteractionPatterns(BCtr)}

Observing the evolution of interaction channels through compositions, we can predict
whether a system is livelock-free or not. So, similar to our composition rules, we propose
a safe version of wrapping, which does not introduce livelocks.

Definition 6.9 (Wrapping interaction). Let Ctr be an interaction component contract, and CC a
set of communication channels, such that CC /? IntChCtr. Then the wrapping interaction version
of Ctr (denoted by CtrddCC) is given by:

CtrddCC = Ctr \CC

The wrapping interaction behaves exactly the same way as wrapping, except for its proviso.
In order to apply wrapping interaction, we guarantee that no set of channels within interaction
channels are hidden. From Definition 6.9 and Lemma 6.1, we are able to state the following
theorem.

Theorem 6.8. The wrapping interaction of a livelock-free interaction component contract is
also livelock-free.

Proof. This proof is straightforwardly obtained from Lemma 6.1 and Definition 6.9. The for-
mer tells us which channels, after being hidden, would introduce livelocks. The latter prevents
hiding such channels.

This theorem can help us to construct another normal form, specialised to our target archi-
tectural style. The advantage is that if all constituting components are livelock and deadlock-
free, so is their composition. We do not explicitly define it here, but it is clear that this normal
form would include all general rules, and those specific for the architectural style.



6.3 VERIFICATION IMPROVEMENTS USING ARCHITECTURAL STYLES 95

6.3.2 Improving composition support using component metadata

During development, it is sometimes desirable to keep additional information, called metadata,
with the component. Such metadata enrich component contracts with static information that
assist the runtime environment with additional (validation) properties. In our approach, meta-
data comprise information that can (at any moment) be derived from other component contract
elements (B, R, I, or C). In particular, we use metadata to optimise component composition
verifications. The formal definition of components with metadata used in this work is presented
in Section 5.4; other styles enriched with metadata can be defined in a similar way.

Since these metadata comprise derived information, it can be ignored by a composition
environment, and, furthermore, the component can still be used in environments unaware of
them. As a consequence, despite the use of metadata can be considered a powerful tool during
the integration phase, its use is optional.

To increase the value of our compositional approach, we derive composition metadata from
the metadata of the original components, without always building them from scratch. After
each composition rule is applied, the metadata is updated using simple formulae that consider
the semantics of such composition rule.

In order to perform lightweight analysis, certain metadata might be informed once for a
specific component, and can be left out-of-date, or can be updated with an approximated value,
after composition. As a consequence, important composition scenarios are still represented in
the metadata, but not all of them. This introduces some approximation to our strategy, and
restricts the systems we can construct. However, this does not classify any deadlock system,
as deadlock-free, neither states as ‘true’ a property that should be evaluated to ‘false’. We only
tag more systems as problematic, requiring further analysis. At any moment, however, one can
derive metadata from scratch, and give more precision to the approach.

Similarly to the composition rules presented before, we present four composition rules for
enriched component contracts. The simpler composition of enriched component contracts is
the one formed by the interleaving of its components.

Definition 6.10 (Enriched interleaving composition). Let P and Q be two enriched component
contracts, such that P and Q have disjoint channels, CP?CQ = /0. Then, the enriched interleaving
composition of P and Q (namely P[|||]Q) is given by:

P[|||]Q = Enrich(?BP,RP,IP,CP??? ? ???BQ,RQ,IQ,CQ?,?ProtKPQ,CT X
K
PQ,DProt

K
PQ,Dec

K
PQ?)

where

(i) ProtKPQ = Prot
K
P ?Prot

K
Q

(ii) CT X KPQ = CT X
K
P ?CT X

K
Q (c)

(iii) DProtKPQ = DProt
K
P ?DProt

K
Q

(iv) DecKPQ = Dec
K
P ?Dec

K
Q ?{(c1,c2)|(c1 ?CQ ? c2 ?CP)? (c1 ?CP ? c2 ?CQ)}

The result of this composition is similar to the one from Definition 6.2. In addition, we show
here the metadata associated to the interleaving. At this moment, no benefit is obtained from



6.3 VERIFICATION IMPROVEMENTS USING ARCHITECTURAL STYLES 96

the metadata; they are maintained for more complex compositions. However, the calculation
of metadata is very simple. It basically includes all information of the metadata of P and Q,
except that it also states that all channels of one component are decoupled from the other; this
is a direct result of the interleaved behaviour of the composition.

Intuitively, we note that the resulting tuple of an enriched interleaving composition is also
an enriched component contract. However, unlike the interleaving composition, we have to
prove that their metadata are well-formed, according to Definition 5.16.

Theorem 6.9 (Enriched Interleaving Composition Compatibility). An enriched interleaving
composition is an enriched component contract.

Proof. The proof of this theorem is presented in Appendix B.

Similarly, we define communication compositions of enriched component contracts in the
following way.

Definition 6.11 (Enriched communication composition). Let P and Q be two enriched com-
ponent contracts, and ic and oc two communication channels, such that ic ? CP ? oc ? CQ,
CP ? CQ = /0, and ProtKP (ic)[[R

ic?oc
IO ]] and the port-protocols Prot

K
Q (oc)[[R

oc?ic
IO ]] are I/O confluent

strong compatible and satisfies the finite output property. Then, the communication composi-
tion of P and Q (namely P[ic ? oc]Q) via ic and oc is defined as follows:

P[ic ? oc]Q = Enrich(?BP,RP,IP,CP??ic? ? ?oc??BQ,RQ,IQ,CQ?,?ProtKPQ,CT X
K
PQ,Dec

K
PQ?)

where

(i) ProtKPQ ={(c 7? Prot
K
P (c))|c ? dom Prot

K
P 8{ic}}?{(c,Prot

K
Q (c)|c ? dom Prot

K
Q 8{oc}}

(ii) DProtKPQ ={(c 7? DProt
K
P (c))|c ? dom DProt

K
P 8{ic}}?{(c,DProt

K
Q (c)|c ? dom DProt

K
Q 8{oc}}

(iii) CT X KPQ ={(c 7?CT X
K
P (c))|c ? domCT X

K
P 8{ic}}?{(c,CT X

K
Q (c)|c ? domCT X

K
Q 8{oc}}

(iv) DecKPQ ={(c1,c2)|({c1,c2}?{ic,oc}= /0)? (
((c1 Dec

K
P ic ? ic Dec

K
P c1)? (c2 ?CQ ? c1Dec

K
P c2))?

((oc DecKQ c2 ? c2 Dec
K
Q oc)? (c1 ?CP ? c1Dec

K
Q c2)))}?

The result of this composition is similar to the one from Definition 6.3, except for: instead
of checking compatibility among port-protocols of the original components, we check it on
port-protocols within their metadata. Furthermore, the composition does not have to take into
account the complexity of its components, since no port-protocol has to be derived from the
component behaviours. In addition, we show here the metadata associated to the composition,
which can be used in further compositions. Again, the calculation of metadata is very simple.
They include all information of the metadata of P and Q, excluding information about ic and oc,
which does not belong to the new composition contract. There are also new relations identified
among channels of one component and channels of the other, requiring that these channels
are decoupled with the channels involved in the composition (ic and oc). This results from
the semantics of the parallel operator being used in the composition. Observe that DecK is a
symmetric relation, and, furthermore, this has to be handled in its calculation.

As for the interleaving composition, the communication composition of enriched compo-
nents is also an enriched component.



6.3 VERIFICATION IMPROVEMENTS USING ARCHITECTURAL STYLES 97

Theorem 6.10 (Enriched Communication Composition Compatibility). An enriched commu-
nication composition is an enriched component contract.

Proof. The proof of this theorem is presented in Appendix B.

Now we define the feedback composition of an enriched component contract.

Definition 6.12 (Enriched feedback composition). Let P be an enriched component contract,
and ic and oc two communication channels, such that {ic,oc}? CP, ProtKP (ic)[[R

ic?oc
IO ]] and the

port-protocols ProtKP (oc)[[R
oc?ic
IO ]] are I/O confluent strong compatible and satisfies the finite

output property, and ic DecKP oc. Then, the feedback composition P (namely P[oc ?? ic]) hooking
oc to ic is defined as follows:

P[oc ?? ic] = Enrich(?BP,RP,IP,CP??
???ic?
?oc?,?Prot

K
S ,CT X

K
S ,DProt

K
S ,Dec

K
S ?)

where

(i) ProtKPQ ={(c 7? Prot
K
P (c))|c ? dom Prot

K
P 8{ic,oc}}

(ii) DProtKPQ ={(c 7? DProt
K
P (c))|c ? dom DProt

K
P 8{ic,oc}}

(iii) CT X KPQ ={(c 7?CT X
K
P (c))|c ? domCT X

K
P 8{ic,oc}}

(iv) DecKS ={(c1,c2)|({c1,c2}?{ic,oc}= /0)? c1Dec
K
P c2 ?

((c1 Dec
K
P ic ? c1 Dec

K
P oc)? (ic Dec

K
P c2 ? oc Dec

K
P c2))}

The result of this composition is similar to the one from Definition 6.4, except that most
provisos use the metadata of its original components directly. Instead of having to check com-
patibility among port-protocols of P, we check this on port-protocols within the metadata. In-
stead of verifying that two channels are decoupled in P, we verify it directly on relations within
the metadata. In this way, we perform lightweight verifications. Moreover, the composition
does not have to take into account the complexity of P. In addition, we show here the metadata
associated to the composition, which can be used in further compositions. Again, the calcu-
lation of metadata is very simple. The new metadata include all information of the metadata
of P, excluding information about ic and oc, which does not belong to the composition con-
tract. Some other channels are also removed from the decoupled relation DecKS , since after the
composition new communications are established. This composition of enriched components
is also an enriched component.

Theorem 6.11 (Enriched Feedback Composition Compatibility). An enriched feedback com-
position is an enriched component contract.

Proof. The proof of this theorem is presented in Appendix B.

The last rule is the reflexive composition of enriched compositions.



6.3 VERIFICATION IMPROVEMENTS USING ARCHITECTURAL STYLES 98

Definition 6.13 (Enriched reflexive composition). Let P be a component contract, and ic and
oc two communication channels, such that {ic,oc}?CP, and P |? {|c,z|} is buffering self-injection
compatible and satisfies the finite output property. Then, the reflexive composition P (namely
P[oc ¯??ic]) hooking oc to ic is defined as follows:

P[ic ¯??oc] = Enrich(?BP,RP,IP,CP??
???ic?
?oc?,?Prot

K
S ,CT X

K
S ,DProt

K
S ,Dec

K
S ?)

where

(i) ProtKPQ ={(c 7? Prot
K
P (c))|c ? dom Prot

K
P 8{ic,oc}}

(ii) DProtKPQ ={(c 7? DProt
K
P (c))|c ? dom DProt

K
P 8{ic,oc}}

(iii) CT X KPQ ={(c 7?CT X
K
P (c))|c ? domCT X

K
P 8{ic,oc}}

(iv) DecKS ={(c1,c2)|({c1,c2}?{ic,oc}= /0)? c1Dec
K
P c2 ?

((c1 Dec
K
P ic ? c1 Dec

K
P oc)? (ic Dec

K
P c2 ? oc Dec

K
P c2))}

The result of this composition is similar to the one from Definition 6.5. It does not ben-
efit from the metadata of its original components. This is because to check buffering self-
injection compatibility we cannot solely use port-protocols, but the entire component behav-
iour; it checks the behaviour concerning two communication channels. In addition, we show
here the metadata associated to the composition, which can be used in further compositions.
The structure of the metadata is identical to the one of a feedback composition of enriched com-
ponents, since both are unary compositions. So, similarly to Definition 6.12, this composition
of enriched components is also an enriched component.

Theorem 6.12. An enriched feedback composition is an enriched component contract.

Proof. The proof of this theorem is presented in Appendix B.

Despite the reflexive composition of enriched components does not obtain further benefits
from the use of metadata, we can construct more specific styles and define other metadata to
alleviate this kind of composition.

Observe that all rules presented here also guarantee deadlock-freedom because the behav-
iour of their compositions is equivalent to the behaviour of the general rules used to create them,
presented in Section 6.2. Similarly, we could also define a normal form for them, specialised
to our target architectural style, so that if all constituting components are deadlock-free, so is
the composition. As the focus of this section is the preservation of metadata, we did not define
this new normal form here.



CHAPTER 7

Case studies

This chapter aims to exemplify different scenarios in which our composition rules are appli-
cable. They show the expressiveness of our rules to construct trustworthy systems. The case
studies in this chapter are: the dining philosophers example and a routing coordinator example

Each case study has a different proposal. The first case study shows how our composition
rules can be applied to construct the seminal dining philosophers example, which includes a
recurring problem on resource sharing. The proposal of this case study is to place our strategy
in the context of others, including non component-based ones, concerning the guaranteeing
of quality attributes. Contracts with metamodels are used here to improve the verifications of
compositions.

We show that by predicting the behaviour of compositions based on the constituting parts
(components), we are able to identify the exact moment at development when errors may be
introduced. This is not the case when we use the traditional strategy to verify systems. In
the example of the dining philosophers, traditionally the verification is performed after the
system is built, and then the developer starts to analyse why the system deadlocks. So, besides
postponing the detection of the error, much more effort is made to identify its causes.

The second case study explores the application of our composition rules to construct a
coordination system. This study focuses on connectors and not on standard components; con-
nectors are used to coordinate other components. Our proposal here is to show the diversity of
the design elements covered by our composition rules.

As we present in Appendix C, most necessary verifications in our strategy can be performed
in the model checker FDR; these concern the verifications that a specification satisfies the
conditions of our component model, and side conditions of the interleave, communication and
feedback composition rules.

7.1 The dining philosophers example

This is perhaps the most famous example of a deadlock system. As shown in Figure 7.1, five
philosophers are seated at a round table with five forks; each fork placed between each pair
of philosophers. In order to eat, a philosopher must pick up the forks on either side of him or
her. A philosopher who cannot pick up one or the other fork has to wait. But, since there are a
limited number of forks, it is necessary to control the access to such resources. Otherwise, for
instance, all philosophers might get hungry simultaneously and pick up a fork, then deadlock
and starve to death.

99



7.1 THE DINING PHILOSOPHERS EXAMPLE 100

Figure 7.1 The Dining Philosophers Problem

Even though this example is anthropomorphic, it actually captures one of the major causes
of real deadlocks, namely competition for resources. We can model this story in various ways
in CSP by choosing different ‘episodes of philosophers lives’ as events, but the essential things
from the point of view of interaction are when they pick up or put down their forks.

Before presenting the actual components (forks and philosophers) that form the system,
we explain the behaviour of a fork and a philosopher as simple CSP processes. The dining
philosophers example here has a behaviour equivalent to the one presented in [Ros98], and
its specification in CSP is a basis for its specification in our component model. As we show
later in this section, one of the benefits of using a component model is that we can store in
components contracts derived information about the system that is useful at verification and
helps the developer in his task of evolve the system.

IFORK =IOTFKIN ,FKOUT
FKIN =picksup|putsdown
FKOU T =picksack|putsack
channel fk1,fk2 : IF ORK
FORK =(COMPFK(fk1) 2 COMPFK(fk2)) ; FORK

COMPFK( f ) =PICKUPFK( f ) ; PUTDOWNFK( f )

PICKUPFK( f ) = f .in.picksup ? f .out.picksack ? SKIP
PUTDOWNFK( f ) = f .in.putdown ? f .out.putsack ? SKIP

The process FORK ensures that no two philosophers can hold a fork simultaneously. All
events associated to fork on the table are represented by the channels fk1 and fk2, each one
specific for the interactions with each philosopher. The processes PICKUPFK and PUTDOWNFK
represent the elementary actions associated with a fork FORK. PICKUPFK represents picking
up a fork, and PUTDOWNFK putting it down; picking up the fork always precedes putting it



7.1 THE DINING PHILOSOPHERS EXAMPLE 101

down (the process COMPFK represents this restriction). The external choice means that the
first philosopher to interact with the fork and pick it up, holds it until put it down. All events
performed by these processes are defined by the interface IFORK . To pick up a fork, we use two
events picksup and picksack. The former represents the intention to pick the fork, and the latter
indicates that it has been performed. PUTDOWNFK similarly uses putsdown and putsack.

The events of a fork are a subset of those communicated by the philosopher, since the latter
has a more complex life cycle. Besides picking up or putting down a fork, the philosopher
can also think, eat, sit or get up on his chair. It is assumed that a philosopher thinks all the
time, except when he gets hungry. When he gets hungry, he sits on its chair and picks up the
necessary forks, eats, and then releases the forks, gets up and starts to think again. Of course,
different philosophers might have different preferences about which order they keep or release
such forks. We assume that each philosopher picks up the left fork first, and puts it down last.

ILIF E =IOT/0,LFOU T
LFOU T =thinks|sits|eats|getsup
IPHFK =IOTFKOU T ,FKIN
channel pf 1,pf 2 :IPHFK
channel lf :ILIF E
PHIL =PREEAT ; (lf .out.eats ? POSTEAT) ; PHIL
PREEAT =lf .out.thinks ? lf .out.sits ? PICKFORKSUP
POSTEAT =PUTFORKSDOWN ; (lf .out.getsup ? SKIP)
PICKFORKSUP =PICKUPPH(pf 1) ; PICKUPPH(pf 2)

PUTFORKSDOWN =PUTDOWNPH(pf 2) ; PUTDOWNPH(pf 1)

PICKUPPH(c) =c.out.picksup ? c.in.picksack ? SKIP
PUTDOWNPH(c) =c.out.putsdown ? c.in.putsack ? SKIP

The process PHIL represents the life cycle of a philosopher. It uses the channels pf 1, pf 2 and
li f e, which represent events associated to fork manipulations and other philosophers activi-
ties. The datatype of pf 1 and pf 2 are similar to fk1 and fk2, and are used to pick up and put
down forks. The central activity in the life cycle of a philosopher is eating. Before eat, the
philosopher thinks, sits and pick the forks up (the process PREEAT). After eating, the philoso-
pher puts the forks down and gets up (the process POSTEAT). Philosophers actions on his
left and right forks are represented by fk1 and fk2, respectively. The processes PICKFORKSUP
and PUTFORKSDOWN represent the elementary actions associated to fork manipulations; the
former represents acquiring the two forks, and the latter represents releasing them.

Based on these CSP processes, the contract of a fork and a philosopher are represented by
CtrFORK and CtrPHIL, respectively.

CtrFORK =?FORK,{fk1 7? IFORK,fk2 7? IFORK},{IFORK},{fk1, fk2}?
CtrPHIL =?PHIL,{l f 7? ILIF E,pf 1 7? IPHFK,pf 2 7? IPHFK},{IPHFK,ILIF E},{l f ,pf 1,pf 2}?

In order to ensure no fork can be held by two philosophers at once, we represent each fork
and philosopher on the table behaviour by a CSP process F ORKi or PHILi; where the identifier



7.1 THE DINING PHILOSOPHERS EXAMPLE 102

i ?{0..4}. The channels used by the component are:

channel fk : Int.Int.IFORK
channel pfk : Int.Int.IPHFK
channel life : Int.ILIF E

In order to distinguish actions from each philosopher on each fork, there are two integers on
the channel fk definition. fk contains two integers standing for the fork and for the philosopher
identifier. Similarly, pfk contains also two integers to identify the fork and the philosopher. The
channel li f e contains an integer representing the philosopher identifier.

The contract of the five forks and a philosophers on the table are:

F ORK1 = CompINST (CtrFORK,{fk1 7? fk.1.1,fk2 7? fk.1.5})
F ORK2 = CompINST (CtrFORK,{fk1 7? fk.2.2,fk2 7? fk.2.1})
F ORK3 = CompINST (CtrFORK,{fk1 7? fk.3.3,fk2 7? fk.3.2})
F ORK4 = CompINST (CtrFORK,{fk1 7? fk.4.4,fk2 7? fk.4.3})
F ORK5 = CompINST (CtrFORK,{fk1 7? fk.5.5,fk2 7? fk.5.4})
PHIL1 = CompINST (CtrPHIL,{pf 1 7? pfk.1.1,fk2 7? pfk.2.1})
PHIL2 = CompINST (CtrPHIL,{pf 1 7? pfk.2.2,fk2 7? pfk.3.2})
PHIL3 = CompINST (CtrPHIL,{pf 1 7? pfk.3.3,fk2 7? pfk.4.3})
PHIL4 = CompINST (CtrPHIL,{pf 1 7? pfk.4.4,fk2 7? pfk.5.4})
PHIL5 = CompINST (CtrPHIL,{pf 1 7? pfk.5.5,fk2 7? pfk.1.5})

Although all forks are represented by a unique process with indexes on its channels, the
definition of their component contracts are made separately. This helps to understand the inter-
action of each of them with the environment. The same happens for the philosophers.

To easy the integration of these components, we use in this case study the metadata of the
component forks and philosophers. Their metadata is very simple, and only consider informa-
tion about their protocols. There are no decoupled channels in these components.

All verifications about the protocols of the fork on the table can be performed on the same
protocol PROTFK , which is equivalent for all of them. Similarly, the behaviour (protocols) that
philosophers use to communicate with the forks can be represented by PROTPH .

PROTFK = PICKUPFK(fk1) ; PUTDOWNFK(fk1) ; PROTFK
PROTPH = PICKUPPH(pf 1) ; PUTDOWNPH(pf 1) ; PROTFK

These protocols are deterministic, and furthermore they have behavioural equivalent context
processes and dual protocols. Observe that due to the fact that all forks and all philosophers
have a similar structure and behaviour, any pair of protocols, one of a fork and another of a
philosopher, that are equivalent to PROTFK and PROTPH satisfy the same properties of the pair
PROTFK and PROTPH (see Definition 4.10). Furthermore, enriched versions of these components



7.1 THE DINING PHILOSOPHERS EXAMPLE 103

repeat these protocols on the elements of protocols, context processes and dual protocols, as
presented below.

EF ORK1 = Enrich(F ORK1,MetaProt(PROTFK,fk1,fk.1.1,fk.1.5))

EF ORK2 = Enrich(F ORK2,MetaProt(PROTFK,fk1,fk.2.2,fk.2.1))

EF ORK3 = Enrich(F ORK3,MetaProt(PROTFK,fk1,fk.3.3,fk.3.2))

EF ORK4 = Enrich(F ORK4,MetaProt(PROTFK,fk1,fk.4.4,fk.4.3))

EF ORK5 = Enrich(F ORK5,MetaProt(PROTFK,fk1,fk.5.5,fk.5.4))

EPHIL1 = Enrich(PHIL1,MetaProt(PROTPH,pf 1,pfk.1.1,pfk.2.1))

EPHIL2 = Enrich(PHIL2,MetaProt(PROTPH,pf 1,pfk.2.2,pfk.3.2))

EPHIL3 = Enrich(PHIL3,MetaProt(PROTPH,pf 1,pfk.3.3,pfk.4.3))

EPHIL4 = Enrich(PHIL4,MetaProt(PROTPH,pf 1,pfk.4.4,pfk.5.4))

EPHIL5 = Enrich(PHIL5,MetaProt(PROTPH,pf 1,pfk.5.5,pfk.1.5))

where MetaProt(P,c,a,b) is a function that builds a metadata with protocols equivalent to P substituting
the channel c by the channels a and b, and with an empty set of decoupled channels. The function
MetaProt(.,.,.,.) is defined as follows:

MetaProt(P,c,a,b) =?MProts(P,c,a,b),MProts(P,c,a,b),MProts(P,c,a,b), /0?
MProts(P,c,a,b) ={a 7? P[[c/a]],b 7? P[[c/b]]}

The complete system is then formed by putting all the components in parallel. We can build this system
in several steps, using our composition rules. We can also apply the rules in different orders, and we still
obtain the same system. For the sake of brevity, we present just one way, which we follow to show the
application of different composition rules.

To accomplish our goal, we first put all forks in interleave to form the composition FORKS, as
presented below. We do the same with the philosophers to form PHILS, except for the fact that we do
not include the fifth philosopher.

FORKS =EF ORK1[|||](EF ORK2[|||](EF ORK3[|||](EF ORK4[|||]EF ORK5)))
PHILS =EPHIL1[|||](EPHIL2[|||](EPHIL3[|||]EPHIL4))

Figure 7.2 shows the interleave of philosophers. The interleave of forks has a similar configuration.
We leave the last philosopher to the last step of this case study in order to analyse in details the dining
philosopher problem and its solution.

Figure 7.2 Interleave of Philosophers

From the Definition 6.10, the metadata of an interleave composition is defined from the metadata of
the original components. Protocols are preserved, while decoupled channels are defined as the possible



7.1 THE DINING PHILOSOPHERS EXAMPLE 104

combination of the channels of the original components. FORKS and PHILS are the result of several in-
terleave compositions. The set of decoupled channels is given the following set DecKFORKS and Dec

K
PHILS,

respectively. Consider

DecKFORKS ={(c1,c2)| {c1,c2}?CEF ORK1 ?CEF ORK2 ?CEF ORK3 ?CEF ORK4 ?CEF ORK5 ?
{c1,c2}* CEF ORK1 ?{c1,c2}* CEF ORK2 ?{c1,c2}* CEF ORK3 ?
{c1,c2}* CEF ORK4 ?{c1,c2}* CEF ORK5}

DecKPHILS ={(c1,c2)| {c1,c2}?CEPHIL1 ?CEPHIL2 ?CEPHIL3 ?CEPHIL4 ?{c1,c2}* CEPHIL1 ?
{c1,c2}* CEPHIL2 ?{c1,c2}* CEPHIL3 ?{c1,c2}* CEPHIL4}

As a consequence of the interleave composition, a channel of one component is decoupled of all chan-
nels of the other components. In other words, despite the components are placed together in a composi-
tion (FORKS or PHILS) the behaviour observed in their channels is independent of the behaviour of the
other components. Preservation of the protocols is important in all composition rules, except in the in-
terleaved one, since we do not need the additional step to derive them from the compositions. Similarly,
decoupled channels are useful in feedback compositions. These can be used in the compositions, which
are more elaborate than the interleave composition.

We use some derived composition rules, which can be explained in terms of more basic ones. In this
step, we assemble each philosopher within PHILS to his left fork in FORKS using the extended com-
munication composition which results in the PHIL?LFKS composition, presented below. Figure 7.3
shows this composition.

LEFTPHFKS = PHILS [?pfk.1.1,pfk.2.2,pfk.3.3,pfk.4.4???fk.1.1,fk.2.2,fk.3.3,fk.4.4?]FORKS

The extended communication composition compositions LEF TPHFKS can be observed as the application
of a sequence of more basic compositions (see Section 6.2.3). It is the same as applying a communica-
tion composition between PHILS and FORKS via pfk.1.1 and fk.1.1. Then apply successive feedback
compositions on the resulting component via pfk.2.2 and fk.2.2, then via pfk.3.3 and fk.3.3, and, finally,
via pfk.4.4 and fk.4.4. As a consequence, LEF TPHFKS preserves the same protocols of the metadata of
all forks and philosophers within it, and its set of decoupled channels can be described as follows.

DecKLEF TPHFKS ={(c1,c2)| {c1,c2}?CFORKS ?CPHILS ?{c1,c2}* CEF ORK5 ?
{c1,c2}* CEF ORK1 ?CEPHIL1 ?{c1,c2}* CEF ORK2 ?CEPHIL2 ?
{c1,c2}* CEF ORK3 ?CEPHIL3 ?{c1,c2}* CEF ORK4 ?CEPHIL4}

Figure 7.3 Communication between philosophers and their left forks



7.1 THE DINING PHILOSOPHERS EXAMPLE 105

After linking one channel of one component to another, we restrict the set of decoupled chan-
nels. For instance, channels of F ORK1 are not decoupled from the channels of PHIL1. The set
above explained by the communication and feedback compositions involve in the composition
LEF TPHFKS (see Section 6.3.2).

Then, in the next step, we use the extended feedback composition (see Definition 6.6) to
assemble each philosopher within LEF TPHFKS to his right fork (see Figure 7.3), resulting in the
PHILFKS composition. Figure 7.4 shows this composition.

PHILFKS = LEFTPHFKS[?pfk.2.1,pfk.3.2,pfk.4.3,pfk.5.4? ?? ?fk.2.1,fk.3.2,fk.4.3,fk.5.4?]

Figure 7.4 Communication between philosophers and their right forks

It is easy to observe that the composition PHILSFKS is deadlock-free. There are more forks
on the table than philosophers. The same is observed according to our rules, which preserve
deadlock-freedom. The problem arises when we decide to add the last philosopher CtrPHIL5.
The reason is that the way philosophers are defined, a system with a cycle of philosophers and
forks might deadlocks. Below, we show the composition that assembles the last philosopher to
his left fork. Figure 7.5 shows this composition.

LEFTLSTPH = PHILFKS[pfk.5.5 ? fk.5.5]CtrPHIL5

The composition LEF TLST PH is still deadlock-free, but the system development is unfinished.
Roughly, at this moment, the last philosopher uses a fork on the table and another from outside.
The next step would be to assemble the philosopher to his right fork on the table. This is
performed in our strategy by assembling two channels of a same component, using the feedback
or the reflection composition rules. However, none of our composition rules allows assembling
the channels pfk.1.5 and fk.1.5 in the component LEF TLST PH . The application of the former
rule is prevented because these channels are dependent. The application of the latter is also
forbidden because their dependence protocol is not reflexive compatible. The key reason, as we
said before, is that by adding the last philosopher we might introduce deadlock scenarios to the
system.

To solve the problem it is necessary to investigate its cause. The system fate is decided
by the preferences of all philosophers in always picking up the left fork first. As a result, the



7.1 THE DINING PHILOSOPHERS EXAMPLE 106

Figure 7.5 Communication of the last philosopher and his left fork

system might deadlock when all left forks are held. There are several solutions to the dining
philosophers problem. Most of them can be categorised in three ways. A set of solutions
tries to understand the system globally, introducing a global controller that avoids the deadlock
scenarios; for instance, allowing a butler to be in charge of the dining table [Ros98]. Another
category follows a spontaneous symmetric breaking strategy, defining elaborate protocols to
a philosopher acquire and release a fork [CM84], or, roughly, making the philosophers more
polite. The last and the easiest category of solutions follows an explicit symmetric breaking
strategy. They simply avoid critical scenarios by changing the preferences of some philosophers
on the table. For instance, we can replace PHIL5 by another philosopher PHIL5?, which always
picks up the right fork first (pfk.1.5), and puts it down last. PHIL5? has the same contract as
PHIL5, except by this subtle difference in its behaviour. The enriched version of its contract
EPHIL5? is also very similar to EPHIL5.

PHIL5? =CompINST (CtrPHIL,{pf 1 7? pfk.1.5,fk2 7? pfk.5.5})
EPHIL5? =Enrich(PHIL5?,MetaProt(PROTPH,pf 1,pfk.5.5,pfk.1.5))

Based on this new component contract, we can continue with the system development. The
composition that assembles the new last philosopher (PHIL5?) to his left fork is represented by:

ALEFTLSTPH = PHILFKS[pfk.5.5 ? fk.5.5]EPHIL5?

Finally, the whole system is represented by the following composition DINING.

DINING = ALEFTLSTPH[pfk.1.5 ¯??fk.1.5]

The final composition DINING is presented in Figure 7.6.
The DINING system is deadlock-free thanks to the symmetry breaking of the philosophers

preferences. In this last step, we chose to use the reflection composition rule, since the involved
channels are dependent. Unlike the system with all symmetric philosophers, ALEF TLST PH al-
lows the application of our rules. In this component, the involved protocols are reflexive com-
patible. As a consequence, no cycle of ungranted requests is introduced in the system, and the
system is deadlock-free.



7.2 A ROUTING COORDINATOR EXAMPLE 107

Figure 7.6 Communication of between all philosophers and their forks

It is interesting to note that all components in the dining philosopher belong to the cyclic
architectural style presented in Section 6.3. As a consequence, the cost of verifications is alle-
viated. Since those are interaction components, verification about divergence-freedom by con-
struction is also simplified. For instance, one could be just interested in events about philoso-
phers life in order to know when he is thinking, eating or seated. This can be obtained by
wrapping the DINING component contract, hiding all communication about forks on the table.
The component PHILLIF E represents the wrapped component.

PHILLIFE = DININGdd{pfk,fk}

According to Lemma 6.1, since DINING is deadlock-free and there is no iteration pattern
(cycle) formed only of events within the channels pfk and fk, then PHILLIF E is livelock-free.

Appendix C presents the specification of the dinig philosophers example in CSPM , and ex-
plains how this study case can be verified in the model checker FDR.

7.2 A routing coordinator example

In order to illustrate the application of the composition rules proposed in Section 6.1 on com-
ponent coordinators, we refine the scenario of the ATM system initially presented in Section 5
(see Figure 5.1). This more elaborate scenario consists mainly of two CLIENT and two SERVER
instances that run concurrently (see Figure 7.7.a). No component instance knows each other;
each CLIENT (Client1 or Client2) interacts with an arbitrary SERVER (Server1 or Server2) to
request services, without knowing the identity of each other. The consistent interaction of
CLIENTs and SERVERs must be carefully coordinated by the system. In order to achieve that, we
design an elaborate connector (called Connector Network in Figure 7.7.a) composed of other
connector instances (see its structure in Figure 7.7.b).

The Connector Network consists of instances of two kinds of connectors: LBC and CCM.
Together, they efficiently route all communications of a CLIENT to a SERVER, establishing a
safe communication path between both components until they finish their interaction. The LBC
is a load balance connector, which verifies which SERVER is available at the moment. The CCM
formalises a component communication manager, which identifies whether a SERVER is able



7.2 A ROUTING COORDINATOR EXAMPLE 108

(a) Black box view of the System (b) Structure of the Connector Network

Figure 7.7 Case Study: A more elaborate ATM System.

to interact with a new CLIENT or whether it is busy with an existing interaction. To coordinate
the information routing, these connectors communicate data and control events. The control
events are used to provide feedback on how the communication is performed.

The following CCM and LBC processes represent the equally named connectors.

CCM(?co,c1,c2, f1, f2?,?P[co],P2,P3,P4,P5?,SEQI) = CCM
?(c1,c2, f1, f2,co,P[co])

LBC(?c1,c2,ci, f1, f2?,?P[c1],P[c2],P3,P4,P5?,SEQI) = LBC
?(ci, f1, f2,c1,c2,P[c1],P[c2])

As observed in the expressions above, some protocol and interface information are immaterial
in the definition of the connectors. The channels of both connectors are distinguished between
control and data information. In fact, to help understanding, we only show data channels in
Figure. 7.7). Below, we provide the definitions of the auxiliary meta processes CCM? and LBC?.
These use some conditions that are not legal in CSP, but that abstractly specifies behaviors that
can be later specified in CSP, when the connector becomes concrete.

channel f ree
CCM?(c1,c2, f1, f2,co,P[co]) = µ X. Copy(c1,co,??,P[co]) ; f ree ? X

2 Copy(c2,co,??,P[co]) ; f ree ? X
?{|c1,c2, f ree|} (Avail( f1,c2,idle) ||| Avail( f2,c1,idle))

Avail( f ,c,status) = f .in?isbusy ? f .out!status ? Avail( f ,c,status)
2 c ? Avail( f ,c,busy)
2 f ree ? Avail( f ,c,idle)

Copy(ci,co,s,P[co]) = ci.in?x ? co.out!x ?Copy
?(ci,co,s

_?x?,P[co])
2 co.in?y ? ci.out!y ?Copy?(ci,co,s_?y?,P[co])

Copy?(ci,co,s,P[co]) = SKIP&lt;I f ailures(P[co]) = f ailures(P[co]/s)&gt;I Copy(ci,co,s,P[co])

In the meta processes above, ci, c1, c2, and co are channels used for communicating data.
The channels c1 and c2 are used to communicate data between the connectors LBC and CCM,
whereas ci and co represent channels for communication with the environment. The channels
f1 and f2 are used to communicate control data between the connectors. The channel f ree is
used for internal synchronisation in the CCM. To ease the definitions of the connectors, we use
protocol P[c j], where c j stands for the channel associated to the protocol. In fact, these protocols
represent the behaviour of the SERVER component over these channels when the connector is
instantiated.



7.2 A ROUTING COORDINATOR EXAMPLE 109

The CCM repeatedly behaves as a connector that copies events from c1 to co or from c2
to co. It chooses between the two behaviours depending on which channel (c1 or c2) has first
enabled an event to be performed. It continuously transfers values between such channels
until it concludes an interaction (a trace that leads the process to its initial state). In order to
check if interaction has finished, we use the semantic condition failures(P[co]) = failures(P[co]/s
(see Definition 5.10) At any time, the process CCM can receive an event f j.isbusy asking if
the connector is already engaged in an interaction. If so, it performs f j.busy; otherwise, it
communicates f j.idle.

LBC?(ci, f1, f2,c1,c2,P[c1],P[c2]) = µ X. f1.out!isbusy ? f2.out!isbusy ?
( f1.in?idle ? f2.in?x ?Copy(ci,c1,??,P[c1]) ; X
2 f1.in?busy ? ( f2.in?idle ?Copy(ci,c2,??,P[c2]) ; X

2 f2.in?busy ? X))

The LBC starts by sending an event f j.isbusy to each connector assembled to c1 and c2. The
first to answer f j.idle enables a communication. It continuously copies data from a channel ci
to this connector until it finishes an interaction.

Before building the Connector Network, we have to instantiate the connectors LBC and CCM,
which represent concrete connectors. The instance depends on the coordinated component
contracts. In our example, we assume they are used to mediate the communication between
CLIENT and SERVER, previously described in Section 5.2.2. So, data channels have the same
interfaces as those of the components, and protocols are based on the SERVER protocol (P[c j] =
Prot(CtrSV ,sv)). Control channels do not depend on the communication data. Below, we present
the necessary interfaces, channels and auxiliary processes used to instantiate our connectors.

IF D = IOTF DIN ,F DOU T
IRC = IOTF DOU T ,F DIN

F DIN : isBusy

F DOU T : busy|idle
PortRole : u|1|2

ConInstance : l1|l2|m1|m2
channel idataai : ConInstance.PortRole.ISV
channel odata : ConInstance.PortRole.ICL
channel i f eed : ConInstance.PortRole.IF D
channel o f eed : ConInstance.PortRole.IRC

RN(c) =RUN({|c|})[x/c.x]
PT (c) =ProtCtrSERVER(sv)

The channels idata and odata are data channels, and they are typed by the same interfaces
used by CLIENT and SERVER. The channels i f eed and o f eed are control channels. They are
typed by the interfaces IF D and IRC, which are new. All channels defined in this example use



7.2 A ROUTING COORDINATOR EXAMPLE 110

a common, and elaborate, strategy in CSP. They have indexes for different processes which
communicate the same events typed by their respective interfaces. For instance, idata have
an index (ConInstance) to distinguish connectors, and another (PortRole) to distinguish ports
within each connector. The other channels have similar formats. We also define the auxiliary
processes RN(c) and PT (c). The former is used when the communication order in the channel
c is immaterial. The latter is used to perform verification of communication within c based on
the SERVER protocol.

Based on these auxiliary channels, interfaces and processes, we define two instances of
each connector LBC and CCM. The component contracts are called LBC1, LBC2, CCM1 and
CCM2, respectively. Although we define a small number of channels in CSP, their indexes
allow us to map a bigger number of ports in each component.

LBC1 = F(LBC,?idata.l1.u,odata.l1.1,odata.l1.2,o f eed.l1.1,o f eed.l1.2?,?ICL,ISV ,ISV ,IRC,IRC?,
?RN(idata.l1.u),PT (odata.l1.1),PT (odata.l1.2),RN(o f eed.l1.1),RN(o f eed.l1.2)?)

LBC2 = F(LBC,?idata.l2.u,odata.l2.1,odata.l2.2,o f eed.l2.1,o f eed.l2.2?,?ICL,ISV ,ISV ,IRC,IRC?,
?RN(idata.l2.u),PT (odata.l2.1),PT (odata.l2.2),RN(o f eed.l2.1),RN(o f eed.l2.2)?)

CCM1 = F(CCM,?idata.m1.1,idata.m1.2,odata.m1.u,i f eed.m1.1,i f eed.m1.2?,?ICL,ICL,ISV ,IF D,IF D?,
?RN(idata.m1.1),RN(idata.m1.2),PT (odata.m1.u),RN(i f eed.m1.1),RN(i f eed.m1.2)?)

CCM2 = F(CCM,?idata.m2.1,idata.m2.2,odata.m2.u,i f eed.m2.1,i f eed.m2.2?,?ICL,ICL,ISV ,IF D,IF D?,
?RN(idata.m2.1),RN(idata.m2.2),PT (odata.m2.u),RN(i f eed.m2.1),RN(i f eed.m2.2)?)

Based on these component contracts, we are now able to construct the Connector Network.
Figure 7.8 summarises our strategy to compose such components (concrete connectors). To
build the coordinator, we first compose the two instances of LBC using an interleave com-
position (see Figure 7.8.a). Then, we perform a communication composition with each CCM
connector to the result of the previous composition (see Figure 7.8.b). Subsequently, we use a
feedback composition to connect channels of the resulted connector in order to assembly the in-
ner instances of the LBC to instances of the CCM (see Figure 7.8.c and 7.8.d). Control channels
are composed using similar feedback compositions.

The following compositions are built throughout this strategy.

ConNet1 = LBC1 [|||]LBC2
ConNet2 = (ConNet1[odata.l1.1 ? idata.m1.1]CCM1)[odata.l2.2 ? idata.m2.2]CCM2
ConNet3 = (ConNet2[odata.l1.2 ?? idata.m2.1])[odata.l2.1 ?? idata.m1.2]
ConNet4 = (ConNet3[o f eed.l1.1 ?? i f eed.m1.1])[o f eed.l2.2 ?? i f eed.m2.2]
ConNet = (ConNet4[o f eed.l1.2 ?? i f eed.m2.1])[o f eed.l2.1 ?? i f eed.m1.2]

The compositions ConNet1 and ConNet2 represent the steps presented in figures 7.8.a, 7.8.b.
On these compositions the two LBC instances are interleaved. After the composition ConNet3,
which represents the steps in the figures 7.8.c and 7.8.d, all data channels are assembled. Con-
trol channels are assembled on the compositions ConNet4 and ConNet. In fact the ConNet repre-
sents the entire Connector Network.



7.2 A ROUTING COORDINATOR EXAMPLE 111

a. b.

c. d.

Figure 7.8 The composition steps of basic connectors to form the network of connectors.

Using our composition rules, we guarantee by construction that ConnectorNetwork is dead-
lock-free. A black-box version of this coordinator (see Figure 7.7) can also be built using the
wrapping operation. Thanks to the fact that all concrete connectors are interaction components,
the verification of livelock-freedom is also amenable by construction. In fact, it is easy to
see that all interactions of the final coordination depend on communications with clients and
servers, which guarantees livelock-freedom after internal channels are hidden.

The clients Client1 and Client2, and the servers Server1 and Server2 component contracts are
specified as follows.

channel icl : Int.ICL
channel isv : Int.ISV

CtrClient1 = ?CLIENT[icl.1.x/cl.x],{icl.1 7? ICL},{ICL},{icl.1}?
CtrClient2 = ?CLIENT[icl.2.x/cl.x],{icl.2 7? ICL},{ICL},{icl.2}?
CtrServer1 = ?(SERVER \{us})[isv.1.x/sv.x],{isv.1 7? ISV},{ISV},{isv.1}?
CtrServer2 = ?(SERVER \{us})[isv.2.x/sv.x],{isv.2 7? ISV},{ISV},{isv.2}?

The definitions of these contracts are based on the CLIENT and SERVER processes previ-
ously defined in Section 5.2.2. icl and isv are indexed channels, whose indexes represent which
client (Client1 or Client2) or server (Server1 or Server2) is communicating via the channel, re-
spectively. The indexed channels are used in the component contracts definition to represent
clients’ and serves’ interaction points. Based on these component contracts, the final system can



7.2 A ROUTING COORDINATOR EXAMPLE 112

be represented by the composition of the interleave of clients (CLIENT s) and servers (SERVERs).

channel cl2 : ICL
channel sv2 : ISV
CLIENT s =CtrClient1 [|||]CtrClient2
SERVERs =CtrServer1 [|||]CtrServer2

CLSV s =CLIENT S [|||]SERVERs
AT MSY ST EM =CLSV s[?cl,cl2,sv,sv2???idata.l1.u,idata.l2.u,odata.m1.u,odata.m2.u?]ConNet

All clients and servers are independent of each other and, furthermore, are interleaved in
CLSV s. Their communication composition with the coordinator ConNet is represented by the
composition AT MSY ST EM , which according to our composition rules, is deadlock-free.

Appendix C presents the specification of the study cases presented here in CSPM , and ex-
plains how these study cases can be verified in the model checker FDR.



CHAPTER 8

Conclusions, related and future work

Although component-based development (CBD) provides mechanisms and tools for construct-
ing systems by plugging components together, the safe construction of these systems is still a
research challenge. Trustworthiness is required during several development activities, such as
safe composition of third-party components or the correct adaptation of library components.

In this work, we have proposed a correct by construction approach for building trustworthy
component-based systems. The approach focuses on performing analyses that are intended to
address engineering concerns on CBD. In special, we focus on component integration. The
entire approach is underpinned by the CSP process algebra, which offers rich semantic models
that support a wide range of process verifications, and comparisons. In fact, CSP has shown to
be very useful to support the rigorous development of component based systems, as a hidden
formalism for modelling languages used in practise [RSM05, RSM06].

This work contributions fall into the following areas.

A study of protocol compatibility. This study has been performed independently of the con-
cept of components and considers both synchronous and asynchronous mediums. More-
over, test characterisations via refinement checking are presented. The novelty in this
study is not only presenting compatibility in asynchronous mediums, but also consider-
ing complex I/O communications, covering a wide variety of applications.

The BRIC component model. This component model is aligned to other models with behav-
iour descriptions. It focuses on (re)active components that are input deterministic and
output decisive. Reuse and compositions are allowed not only to components, but also to
connectors. Furthermore, it considers not only compositions between two distinct com-
ponents, but also the assembly between ports of the same component. This brings more
flexibility to design decisions at development. An operation for hiding information to
pack components into black-boxes is also presented.

A comprehensive set of composition rules. We present a set of composition rules that can be
regarded as safe steps in the development. The application of the rules can be used to
systematically develop a wide variety of trustworthy component systems, and guarantees,
by construction, the absence of deadlock and livelock. The approach covers not only
tree-topologies but also topologies with cycles in a compositional method, without being
aware of needing to know the overall structure of the system. Port-protocols play an
important role in the approach, and, in conjunction with other properties, help to alleviate
verifications by supporting local analyses.

113



8.1 SUMMARY 114

Improvement of verification using enriched component with metadata. We propose an in-
tegrated correct by construction approach for component contracts using metadata, which
extends our approach for arbitrary components with improved and lightweight side con-
ditions. Metadata are derived from component contract elements and are used in substi-
tution to heavier verifications in the version without metadata. Additionally, metadata of
compositions can be easily derived from the metadata of its constituting components. As
a result, the order of complexity of the verifications is drastically reduced. Moreover, the
improvements in this approach ensure not only the absence of deadlock and livelock, but
also guarantee local progress of all components in the system.

Despite these contributions, the proposed approach has some limitations:

1. We require that component contracts have an associated behaviour. This is not always
the case in several component models in industry, however it is essential to support be-
havioural verifications;

2. The benefits of using metadata are limited to the application of composition and feed-
back composition rules. Although this corresponds to two of the four basic proposed
composition rules, the application of the other composition rules is compatible with our
strategy with metadata. Moreover, one of these composition rules, the interleave one, is
already very simple, and does not need of further improvements.

3. The strategy with metadata indicates that some compatible communications between
components, as incompatible (false-negatives). This is an intrinsic problem in local anal-
ysis methods, which is acceptable considering the advantages that it brings in scalability.
In these scenarios, the developer have to use traditional verification methods to com-
plement our strategy. Furthermore, the strategy with metadata must be adopted as a
technique that guides the attention of the integrator to the most crucial compositions, and
not as a ‘silver bullet’ method for the composition problem in general.

A summary with some more details of our contributions is presented in the next section.
In Section 8.2, we relate our work with others in the literature. And, finally, we present in
Section 8.3 future research directions for this work.

8.1 Summary

To achieve the contributions previously mentioned, which have been also partially presented
in [RSM10, RSM09], we have defined the BRIC and BRICK component models for compo-
nents (see Chapter 5), whose contracts are described by their dynamic behaviour, interfaces,
interaction points (ports), and optionally some metadata (see definitions 5.3 and 5.16). These
basic elements of a component contract are called B, R, I, C, and K, respectively. The BRIC
and BRICK models are distinguished by metadata. BRIC component contracts contains B, R,
I and C elements. This component model imposes the necessary constraints that characterise
which kind of components, as well as interactions, are supported by our approach. BRICK



8.1 SUMMARY 115

components contracts add the existence of K elements. Since metadata can be derived from the
other four elements of the contract, a BRIC component can be easily converted into an BRICK
component. Aligned with other practical approaches [MB05], connectors are introduced in
our component model at two different abstraction levels. To increase the range of compo-
nents they integrate, connectors are abstractly defined at the design level, in a parametrised
form. When all parameters are fulfilled, a connector is instantiated as a component, which is
ready to be composed with other components, or to form more elaborate connectors. Based
on these basic notions, we define important constructive constraints that underline important
component-based development activities in Chapter 6.

All composition rules ensure the preservation of design properties by construction. In par-
ticular, we propose compositions that are defined on top of the notion of service conformance.
Service conformance can be understood as a design principle to be followed, when permit-
ted: unused services of a component should be still available after composition. The degree
of satisfaction of this notion may vary from preserving all services to at least one, respectively
corresponding to the strong and the weak conformance notions. The set of composition rules
for the BRIC and BRICK component models satisfies the weak and the strong service confor-
mance notion, respectively. Additional constraints in the BRICK component model ensure the
preservation of such services. In this context, the set of composition rules for BRIC compo-
nents is aimed at more general components. On the other hand, the set of rules for BRICK
components additionally considers enriched contracts. The latter set of rules performs simple
calculations with the metadata in substitution to more general verifications in the original rules
for BRIC components. As a result, the complexity of verifications for BRICK is reduced, and
the composition task is simplified.

A distinguishing feature of our approach is that each of the proposed composition rules is
intentionally simple to capture a particular communication pattern with the relevant side con-
ditions to preserve behavioural properties. The approach mainly relies on three basic rules for
composing components: interleave, communication and feedback compositions. Altogether
these three composition rules allow the construction of a wide variety of useful complex com-
ponent based systems with tree topology structure configurations (see Section 6.2). An elabo-
rate composition rule, called reflexive, is also provided for constructing systems with arbitrary
architectural configurations. Complex interactions can be progressively built from these very
simple rules, as illustrated in Section 6.2.

Each composition results in a component, whose properties are directly derived from the
components involved in the composition. The rules guarantee both deadlock-freedom and
livelock-freedom in the compositions based on the assumption that the original components
hold these properties. The verification of livelocks is straightforward, since this problem is
not introduced by any of our composition rules, but by performing wrapping operations after-
wards (see Section 5.2.5). This operation hides the part of the component behaviour that is not
available for composition (the interaction between the sub-components of the composition).
The verification of livelock in general systems (BRIC components) is prohibitive, since it must
be verified in the whole system (rather than based on information of the inner components in
the system). Means to alleviate the verification of wrapping (see Section 5.2.5), in a specific
architectural style, is presented in Section 6.3.



8.2 RELATED WORK 116

To guarantee deadlock-freedom in simpler topologies, the composition rules include side
conditions that require the compatibility between communication protocols and the decoupled
channels. The former ensures compatibility between component communications, and the lat-
ter avoids undesirable architectural configurations. To simplify verifications of these side con-
ditions, one can optionally enrich component contracts using component metadata (see Sec-
tion 6.3.2). Composition is improved by carrying out partial verification results on component
metadata throughout component compositions. To guarantee deadlock-freedom in structures
with cycles of communicating components, more elaborate conditions are considered. These
ensure that no cycles of ungranted requests [Ros98] are presented in the system.

To guarantee livelock-freedom, we analyse some interesting properties that explain how
livelocks are introduced in the interaction component style. Based on these properties we
can propose new composition rules that preserve livelock-freedom. Those composition rules
include side conditions (see Section 6.3), which require that no interaction pattern (recurring
behaviour) of the original component be entirely hidden in the black-box composition. An
integrated approach with composition rules for the interaction components architectural style
is presented in [RSM09].

The application of our approach has been illustrated in two case studies in Chapter 7: the
dining philosophers example and a routing coordinator example. Each case study has a differ-
ent purpose. The objective of the dining philosophers case study is to place our strategy in the
context of others, including non component-based ones, concerning the guaranteeing of quality
attributes. The purpose of the routing coordinator case study is to show the diversity of the
design elements covered by our composition rules, which are used in this case to construct an
elaborate coordination system.

8.2 Related work

The topic of this thesis expands over fields of architecture and reliability modelling. We have
studied a variety of approaches in each domain, and identified a few approaches that span both
domains. In this section, we first present a summary of related approaches to architectural
modelling. We then provide an overview on existing reliability models. The former focuses
on the characteristics of our component model, and the latter on the constructive constraints to
ensure properties on component-based systems. Since there is an extensive number of works
in these fields, we focus on the works being most influential and related to our work.

8.2.1 Component models

There are several different approaches to component models. As pointed out in [Wal03], each
component model is designed to achieve specific goals. Furthermore, each one has its benefits
and deficiencies, depending on the context in which it is analysed. In this section, we consider
related works and compare them according to the context of this thesis. For instance, there are
multiple (modelling) aspects for component [RM04].

To begin with, we do not relate our work with other component models that define low-level
granularity components, in which contracts/interfaces capture solely syntactical information



8.2 RELATED WORK 117

(like method signatures). Low-level granularity component models are associated to compo-
nent technologies found in industry that are usually designed to support quick development or
to permit the use of different programming languages in development. These are furthermore
not designed for reasoning. In order to get around this limitation concerning interface represen-
tation, several authors [FLF01, LD00, LW94] propose the specification of the ‘behaviour’ part
via pre- and post conditions and invariants. According to [Pla05], one of the key obstacles in
applying these approaches to components is that they require an explicit capturing of (object)
state - this may be both a very hard-to-achieve and, potentially, limiting decision at an early
stage of a component design.

We focus on works that support behaviour description of entities. The idea of expressing
behaviour of an object as a regular process (via traces as sequences of method calls) has been
published in [Nie93]. It even considers the role of client calls (in a simple case) via parallel
composition. The importance of capturing behaviour of components as sequences of events for
COTS components (commercial off the shelf) is emphasized also in [DR02] where a way of
identifying behaviour via monitoring experiments is described.

There have been a huge number of publications on behaviour description of components
and connectors [ADG98, BCD02, HLL06b, BHP06, Arb04, Sif10, CZ07]. Our approach in-
tegrates aspects from different but closely related domains. The target concrete syntax of our
work is CSP, but the elements within BRIC component contracts (see Definition 5.3) are not
directly represented by this notation. CSP is used to give the underlying semantics of our com-
ponent model, and to help verifications. However, there are more suitable concrete syntaxes
to represent our notions at development phase, such as Architectural Description Languages
(ADLs) [MT00] or the modelling languages UML-RT [SR98] and UML2 [Obj07]. The con-
cepts in these languages are highly compatible with our component model, and one can benefit
from using both approaches, like modelling in one language and performing verifications in
another.

Our component model is based on I/O transition systems, has explicit architectural struc-
ture, and presents connectors as first class design elements. These characteristics resemble
several ADL approaches, such as Wright [AG97, ADG98], Darwin [MK96], PADL [BCD02],
and ROOM [SGW94]. Our component model focuses on design elements, and does not take
into consideration the expressiveness of programming languages as architectural programming
models, such as ArchJava [ACN02], SOFA [BHP06], Fractal [BCL+06], rCOS [HLL06a,
CHLZ07] and BIP [Sif10]; the design concepts in these ADLS are, however, compatible
with concepts in our component model. Another related ADL is ROOM [SGW94], which later
evolved to UML-RT [SR98], which in the meantime has been incorporated into UML2 [Obj07].

Despite their similarities, the representation of components in these works differs in some
extent. Some consider the internal behaviour of components, e.g. [BCL+06, HLL06a], other
the external behaviour, e.g. [ADG98]. Some component models represent components solely
by their port-protocols, e.g. [CZ07], other neglects this kind of behaviour, e.g. [HLL06a]. In
our work, we discriminate the external behaviour of components and their points of interactions
(port-protocols). Component contracts have the whole external component behaviour, or are
enriched with port-protocols (see component contracts and metadata in Chapter 5). Each kind
of behaviour has its benefits in reasoning. Port-protocols alleviate verifications, whereas the



8.2 RELATED WORK 118

whole behaviour of components is essential for structural analysis of larger systems. The com-
parison with approaches to verify component-based systems is presented in the next section.
Our component model also has operations to hide information in component contracts. The
wrapping operation hides the part of the component behaviour that is not available for com-
position (the interaction between the sub-components of the composition). This is, however,
different from the concept of publication presented in rCOS [ZKL10] for creating ‘black-box
components’. In rCOS, a publication is an abstraction of a contract that removes behavioural
information from the contract.

Another important issue is the representation of connectors. Some works have an explicit
representation for connectors, e.g. [ADG98], others connectors are not distinct from compo-
nents, e.g. [HLL06a]. In some approaches both in components and connectors can be reused.
Our approach is closest to that of [Spi04], in which, at the design level, connectors are repre-
sented as parametrised CSP processes, called connector wrapper templates. At the integration
phase, connectors have the same representation as components [ADG98, Spi04]. This provides
means of enhancing existing connectors at different levels of abstraction, which is aligned with
practical approaches of connector representation [MB05]. The more abstract one is used at
design and it is meant for reuse. The more concrete one has the same structure of components,
and it can, therefore, be used as units of compositions.

This issue is related to coordination languages. In these languages, connectors are used to
coordinate component interactions. Compared to ADL connectors, these connectors can repre-
sent much more sophisticated coordination policies for sets of components. In the coordination
language Reo [Arb04], complex connectors are constructed from a composition of a compre-
hensive set of basic connectors. The computational aspects of the connectors are therefore
limited to these basic connectors. In our work, we do not focus on coordination issues. Apart
from that, one can build exogenous coordination on the top of our component model. Connec-
tors can also be built from more basic ones, and, at any level, connectors can have complex
behaviours (see the routing coordinator example in Section 7.2.

Most of these component models [AG97, BCD02, HLL06b, Sif10, CZ07] have an under-
lying semantics, which allows verifications; most of these component models are classified as
ADL, and typically subsumes a formal semantic theory [MT00]. In the next section, we discuss
the relations between our approach and the verification methods in these works.

8.2.2 Reasoning model

There are several efforts on the verification of Component-based Systems [BCD02, MCM08,
HJK10, MW97, AG97]. The scalability issue in compositional verification has been actively
addressed in this field; compositional verification is based on the idea that the correctness check
of a complex system can be divided into smaller verification tasks for its components. In this
section, we compare our work, not only with approaches with an explicit component model,
but also with others that focus on the verification of behavioural elements (which may not be
fully aligned with a component development method).

The work reported in [GGMC+07, MCMM07, MCM07] presents an extensive study of
quality properties in CBS. It discusses liveness, local progress, deadlock, fairness and ro-
bustness. We implicitly discuss these properties, except fairness and robustness. The dead-



8.2 RELATED WORK 119

lock property is locally addressed by our compatibility notion, which is an important condi-
tion of our composition rules. Therefore, deadlock is preserved by our composition rules for
BRIC components, and local progress is also preserved when composition rules are applied
for BRICK components (components with metadata). None of the composition rules introduce
livelock. In our approach, these may be introduced by wrapping operators. In this context,
we also present an approach to alleviate the compositional verifications of these properties on
these operations. Relating to fairness (of process schedules or of internal event choices), we
believe that it must be performed by coordinators, which mediate component interactions. As
a consequence, fairness is a property associated to a coordination purpose and that requires a
specific verification, which is out of the scope of this work. Robustness is a desirable property
which is not addressed by our work.

Even though there are many approaches to formally model component based systems (CBS)
[ADG98, AB03, IM08, HLL06b, PV02], to our knowledge the question of preserving, by
construction, behavioural properties has not yet been fully systematised as we have done in
this work. Despite the fact that our black-box component contracts are compatible with most
component-based approaches, especially those based on CSP or CSP-like notations [Ros98,
HLL06b], most approaches to date aim at verifying the entire component-based systems before
implementation, but not predicting behavioural properties by construction during design. We
can ensure deadlock- and livelock-freedom in a constructive way, as a result of applying com-
position rules, as opposed to performing model checking verification after the system has been
built. The compositional approach can be applied in heterogeneous systems (synchronous and
asynchronous) with different topologies (tree or cyclic).

Approaches to verifying a system tend to use abstraction techniques to reduce the state
space. They map a set of states of the actual system to an abstract, and a smaller set of
states in a way that preserve the behaviours of the system. [ZM10] adopts counterexample
guided abstraction refinement scheme to alleviate the state explosion problem of deadlock de-
tection. It extends the classical labelled transition system models by qualifying transitions as
certain and uncertain to make deadlock-freedom conservative. A similar approach is presented
in [Kwi07]. It determines their sets of ‘conflict-free’ actions, called untangled actions. Un-
tangled actions are compositional; synchronisation on untangled actions will not destroy their
‘conflict-freedom’. Following the same approach, [CCH+09] proposes a deadlock detection
algorithm based on navigating and marking transitions on a dynamic synchronization depen-
dency graph.

Other approaches tend to design components and interactions using strict component mod-
els in order to avoid undesirable properties, such as deadlock. [DZZL10] builds up a service
interaction model and analyses the deadlock problem related with shared internet resources. It
proposes some interaction solutions to effectively prevent deadlocks. In this context, our ap-
proach can also be specialised for a specific architectural style. In [RSM09], we combine side
conditions presented in this thesis to propose specific composition rules for interaction compo-
nents. In this work, all verifications and notions support the analysis of partitions of the com-
ponent (and composition) behaviour in space (protocols) and time (interaction patterns). This
approach combines the advantages of the approaches presented in [VVR06] and in [BBT01],
where physical and temporal partitions are realised, respectively. Protocols are observed as a



8.2 RELATED WORK 120

particular type in [VVR06], which permits the verification of compatibility. However, concerns
about the entire component behaviour are ignored in the definitions of [VVR06]. Interaction
patterns are also defined in [BBT01], however without defining any conformance notion for
components or compositions. None of these works defines test characterisations that can me-
chanically be performed in verification tools.

The study of deadlock-freedom is related to the analysis of component incompatibilities. In
this context, component compatibility is established by determining those components which,
when connected, are free of deadlock. The study of behavioural compatibility helps to reduce
the cost of analysing deadlocks in compositions. The criterion exploits compositionality in the
sense that a condition is locally checked on pairs of neighbouring components. If the condition
is satisfied we can derive the property of deadlock-freedom. Thus, the state space construction
related complexity is O(n) in the case of the architectural compatibility check, and O(? n) in the
case of the direct check.

In PADL [BCD02] and in [MCM08] compatibility is used to detect architectural mis-
matches and it is shown that pairwise compatibility is a sufficient criterion to derive deadlock-
freedom of an acyclic assembly from the deadlock-freedom of its local components. These
approaches consider the whole behaviour of the constituting components in the composition.
Differently, our approach is centred on the use of port-protocols to alleviate compatibility veri-
fications.

Closer to our approach is the work presented in [LMC10, CZ07] that performs architec-
tural compatibility verifications based on compatibility of port-protocols. The restriction in
[LMC10] is that only deterministic protocols are considered. [CZ07] proposes a formal model
of component interaction, in which component compatibility is verified using labelled Petri
nets. In this work, the behaviour of components is represented solely by their port-protocols,
called interface languages, which contains either possible sequences of required or provided
services. A request (rich) interface is compatible with a provider (rich) interface if and only if
all sequences of services requested by the former can be provided by the latter. This condition
reassembles our denotation definition of compatibility. However, as we deal with bidirectional
I/O channels, these conditions are verified in each state of the protocol for both directions.

A notion similar to behavioural compatibility is used by [HJK10] under the name of neutral-
ity. The verification of properties for the whole component then follows from the verification
step that uses only weakly deterministic port-protocols. Behavioural neutrality is defined in
terms of observational equivalence between the behaviour of an assembly with two connected
components and the behaviour of an assembly with a single component and the binary connec-
tor replaced by a unary one. This notion plays an important role in its reduction strategy. A
component neutral to another can be removed from the analysis of composition because they
do not contribute with any change in the external observable behaviour of the composition.
There are two restrictions in the approach: components must be weakly deterministic and in
order to be neutral their input and output labels must mutually coincide. As verified in [CZ07],
it is possible that one component does not use all services of another, and, therefore, that one
component might output fewer events than the other one may possibly input.

Another notion related to behavioural compatibility is used in [CK96] under the name of
transparency. In [CK96] automatically derived context constraints (restrictions imposed by the



8.2 RELATED WORK 121

environment on subsystem behaviour) are used to construct the LTS behaviour of composed
systems more efficiently. Context constraints take the form of interface processes, which cap-
ture the interplay of the environment of a single fixed component as part of the composition
with other components. If the composition of the interface process and the fixed process results
in a smaller transition system, it is substituted in the overall analysis. The correctness of the ap-
proach relies on a transparency property which requires a strong semantic equivalence between
the fixed process and its composition with its interface process. Compatibility is verified by
checking if the interface process is well-formed. In [AG97], the interface process associated to
a port is called a deterministic process of a process. Compatibility of two processes is checked
by verifying the refinement relationship between a process and the synchronisation of another
process and the deterministic process of the former. In our work, the interface process and
deterministic versions are called contextual process, and similarly to [AG97] is used solely in
compatibility checks, rather than in a more general analysis as in [CK96]. Similarly to [AG97],
we check compatibility of two protocols as the refinement of a protocol by its context process
synchronised with the dual protocol of the other. A dual protocol represents the most nonde-
terministic process that is compatible with a protocol. We use this notion as we deal with I/O
processes in this work.

Our component model considers I/O processes that implicitly support bidirectional com-
munications. The possible existence of non-determinism in I/O processes and of bidirectional
communication brings more complexity to our verifications than the works related to the no-
tion of compatibility mentioned above [CK96, AG97, BCD02, MCM08, HJK10, LMC10]. For
instance, in [LMC10, BCD02] components must be deterministic. This prevents designer from
considering situations where the components take internal decision (see output decisiveness,
Definition 4.4). Bidirectional communication may implicitly introduce small cycles (with two
components), and furthermore is not addressed by the works above, since they use compat-
ibility in component-based systems with tree-topology structures of unidirectional channels.
However, bidirectional communication is implicit in our component model, and is furthermore
directly support by our compatibility notion. Except for the work on PADL [BCD02, AB03],
none of the works cited above deal with cyclic topologies. Even this approach does not present
a solution to alleviate the verification of applications in such topologies. In [BCD02, AB03]
to verify deadlock-freedom, deadlock freedom is locally considered in the relationship of each
component with the others in the whole cycle. Similarly to the seminal work on deadlock-
freedom [Ros98], the approach needs to know the internal structure of the entire system (which
is also a component) a priori, which is in the opposite direction of a compositional method.
In our work, cyclic topologies are verified in compositional correct-by-construction approach,
as soon as the cycle appears. A detailed comparisons between the basic concepts in [Ros98]
and our study on protocol compatibility is presented in Appendix A. Means to alleviate the
verification are presented by the notion of decoupled channels (see Section 6.2.1).

A further important difference between checking compatibility of port-protocols (as done
in our work) and checking the compatibility of entire component behaviours is that the use
of explicit port behaviours makes the check for compatibility more efficient. Furthermore,
as mentioned in [LMC10], this supports a gray box view of the components that is desired
in CBD similar to the principle of information hiding. Despite the benefits of port-protocol



8.3 FUTURE WORK 122

representation, representing the whole component is also necessary. For instance, the approach
in [CZ07] abstracts the internal behaviour of components, and concentrates solely upon the
behaviour exhibited by port-protocols. Concentrating solely upon the behaviour exhibited by
port-protocols, these works indirectly restrict the structure of their systems to tree-topologies,
without cycles. For the same reason, it is forbidden to assembly multiple points of interaction
between components, which implicitly introduce minor cycles. Similarly, the approach forbids
the verification of other emerging properties of the system, such as livelock, which emerges
from the interaction of the components.

Some approaches [IM08, MW97] do predict some system properties based on the proper-
ties of its constituting components. This is performed by categorising components and their
communication patterns in order to prevent scenarios in which the interaction among compo-
nents would introduce improper states. These works focus on different properties. The work
reported in [IM08] does not focus on behavioural properties; rather, it presents some results on
performance. The approach presented in [MW97] proposes rules to guarantee the absence of
deadlocks by construction. However, it presents rules for specific protocol patterns, such as re-
source sharing and client-server, using simple data communication; for instance, a component
must always accept any input data value.

8.3 Future work

The correct by construction approach proposed in this thesis can be extended in many ways.
There are several directions for building on the results of this work. Moreover, there are oppor-
tunities for new interesting related research directions.

Some extensions and improvements to the contributions of this work include:

More complex case studies. In order to better support the process of component-based de-
velopment, it is necessary to develop further case studies and carefully analyse what is
the support needed by the developers to apply the proposed rules in practice. A promis-
ing case study to start with is the CoCoME [RRMP08], which is a common component
modelling example that has been used to evaluate and compare the practical appliance of
existing component models;

Evaluation of the time complexity of the approach. An important issue is to perform a com-
parative study of the performance of our approach and other existing approaches in the
literature. This is essential to reinforce the benefits of our approach;

Increased breadth of architectural styles support, both in the number of styles and in the
specialised constructive constraints to support their development. This requires the study
of the specialities of each style and how these would help to alleviate verifications in a
compositional approach;

Incorporating and building on additional kinds of formalisms and analysis techniques, to
provide analyses of quality attributes for which our current component contracts are pos-
sible awkward or inadequate. For instance, the combination of process and data-based



8.3 FUTURE WORK 123

specifications, such as CSP-OZ [MORW04] and Circus [SWC02], can improve our strat-
egy to deal with component contracts with pre- and post conditions;

Adopt a concrete syntax. It is essential to adopt a more convenient concrete syntax to the use
of our notions. UML2 [Obj07] introduces notions of components, ports and structured
classifiers which are, not surprisingly, a perfect match with the syntactic requirements
of our component model. Given that the UML2 shows a number of semantics variation
points, and also ambiguities, a mapping to our used semantics is needed. A start point
could be the similar mapping performed by the author from UML-RT into the Circus
process algebra [RSM05].

Incorporate new metadata to enrich component contracts that can improve our approach.
For instance, the notion of channel interactions (see Section 6.3.1) could be used to im-
prove subsequent wrapping operations in a system. Other metadata can be identified and
incorporated to our approach.

Building tool support for the design of trustworthy component systems based on our ap-
proach. This would include the environment for modelling and integrate components,
as well as to perform rule compositions.

There are several other directions in which our work can be extended. These include:

New wrapping operators. Recently came to the author new ideas for performing wrapping
operations. Instead of just hiding events of a channel to build back-box components,
one would require to ban the events. The reason is that hiding in CSP is an ‘eager’
abstraction, since it reflects the idea that events abstracted are thought of as occurring at
the earliest opportunity. Change to the abstraction operator may bring big consequences
to our approach. Applying wrappings would possibly introduce, for instance, deadlocks
to the system.

Substitutability. Besides composition, substitution is another important aspect in the devel-
opment of component-based systems. Most works on substitutability are based on the
notions of behavioural subtyping [LW94, Weh03], which is a strong form of relationship
between two (component) types. It requires instances of a subtype and of a supertype to
fulfil the principle of type substitutability [LW94]:

An instance of the subtype should be usable wherever an instance of the su-
pertype is expected, without a client being able to tell the difference.

This suggests the use of some form of refinement [Ros98] to formalise behavioural sub-
typing. Refinement guarantees substitutability in an even stronger form: a system can
always be replaced by its refinement without any noticeable difference. For subtyping,
we want only a replacement to be unnoticeable at places where a supertype is expected.
This is a weaker form of substitutability, but that nevertheless can be characterised in
terms of refinement [Weh03]. Different substitutability relations can be defined if we are
aware of the context in which the component is. For instance, in [RSM10], we propose



8.3 FUTURE WORK 124

new substitutability relations for components in which the environment can be partitioned
in distinct parts that are intermediated by the component.

In contrast with composition, substitutability relate components that not currently pre-
sented in the system (it relates a present configuration with a future one). As conse-
quence, besides the definition of substitutability notions, it also is necessary to establish
as a future work its relation with other constructive relations, as the composition rules
presented here.

Coordination An open issue in this work is the coordination of components. More research
has to be done in this direction. A desirable issue, for instance, is to easy the correct con-
struction of exogenous coordinators, aligned to the concepts of our component model. A
first candidate to be the building blocks of this approach would be the connectors of our
component model. In our routing example, for instance, we compose connector to coor-
dinate the load balance of servers (see Chapter 7). In [RSM10], we present coordinators
in a systematic strategy to interoperate components. However, other entities could also
be defined as coordinators.

Another interesting related approach can be mentioned. We could incorporate and build
on techniques for the synthesis of coordinators to adapt or integrate components; this
will automatically generate the necessary glue code to reuse a component or integrate
heterogeneous components. For instance, the works [AINT07, BCP06] provide formal
methodologies and tools to synthesise suitable coordinators for solving behavioural mis-
matches between heterogeneous.

Incorporate other development tasks In this thesis we focus on correct compositions, but
other tasks in development also deserve such an attention. So, in order to add more
value to a development approach of trustworthy components, other development tasks
have to be incorporated. In [RSM06], for instance, we propose transformations laws
for components in UML-RT; these can be observed as refactorings for component-based
systems, and could be incorporated to our systematic approach. Due to the different
semantics used in both works, some effort is necessary.



APPENDIX A

Relation between protocol compatibility and
conflict freedom

The notion of protocol compatibility presented in Definition 4.12 is related to the seminal study
of Roscoe on deadlock-free process [Ros98]. In fact, as we show is this chapter, compatible
protocols are also free of strong conflicts; being conflict freedom a cornerstone property in the
study of deadlock. Two processes are in strong conflict if neither process can communicate
with other, or with the environment. Observe that this study consider some assumptions, and
all of them are satisfied by our work. One important assumption is that all processes are triple-
disjoint, meaning that no event requires the synchronisation of more than two processes.

There are also other observations that must be taken into account. For instance, protocols
are equivalent to projections of more complexes I/O process, and focus on specific channels of
such process. Therefore, synchronisations between protocols are always considered to be total;
they synchronise on all events of their alphabet.

The assumptions made in [Ros98] are all present in this thesis:

a No I/O process can terminate. which does not preclude them from being constructed out
of sub-process that can;

b Synchronisation set are defined with the alphabet of the processes that are part of the
synchronisation;

c networks of I/O processes (or components) are triple-disjoint, meaning that there is no
event that requires the synchronization of more than two processes. This is imposed by
our composition rules, and by the way interactions are defined in our component model.
Analysis of protocol compatibilities are made in the context of synchronisations between
two processes.

d Compositions does not contains hidings.

e Compositions rules and the analysis of protocols compatibility assume the network is
busy, defined to mean that each component process is deadlock-free.

Before we present the central theorem that relates the notions of protocol compatibility and
strong conflicts, we present the formalisation related to conflicts, presented in [Ros98].

In order to identify conflicts in a synchronisation of two processes P and Q, Roscoe analyses
all possible states of such synchronisation. We translate the notion of state from [Ros98] as
below. In order to reinforce that outputs of a protocol are considered as inputs of the other, we
require that synchronised protocols are conjugate.

125



APPENDIX A RELATION BETWEEN PROTOCOL COMPATIBILITY AND CONFLICT FREEDOM 126

Definition A.1 (Deadlock state). Let P and Q be conjugate protocols. A state of Q ? P is a pair
(s,?XP,XQ?) where

• (s,XP)? failures(P)? (s,XQ)? failures(Q)

• XP ? ?8(IsP ? O
s
P)? XQ ? ?8(I

s
Q ? O

s
Q)

The definition of states above is slightly different from the one for regular processes, pre-
sented in [Ros98]. The difference is that we translate the provisos in [Ros98] to our domain.
Here, we synchronise protocols on their whole alphabets, and, furthermore, the trace s must
exist in both processes Q and P. The initials of a protocol P after performing a trace s is repre-
sented by all inputs ( IsP) and outputs ( O

s
P) it might perform.

A strong conflict is defined as follows.

Definition A.2 (Strong conflict). Let P and Q be conjugate protocols. Then a strong conflict of
Q ? P is a state (s,?XP,XQ?) which satisfies:

• ?8XP ? XQ ? ?8XQ ? XP

Since Q?P is a total synchronisation, the vocabulary is equals to the union of their alphabets
(inputs(P)?outputs(Q)); this vocabulary is also used as the synchronisation set. Based on this,
and on the fact that protocols are deadlock-free, the definition above is much simpler than
in [Ros98]. For the sake of brevity, we define strong conflicts directly, without relating it to
ungranted requests or regular conflicts; these are conditions that underline the notion of strong
conflicts in [Ros98].

Based on the definitions above, we state the following theorem, which shows the equiva-
lence of protocol compatibility and the absence of strong conflicts.

Lemma A.1. Let P and Q be two conjugate protocols. Then P ? Q is a pair of processes frees
of strong conflicts if, and only if, P and Q are compatible.

Proof. Based on the Definition A.2, the absence of strong conflicts can defined as:

?(s,XP)? failures(P),(s,XQ)? failures(Q)|XP ? ?8(IsP ? O
s
P)? XQ ? ?8(I

s
Q ? O

s
Q)

• ?8XP * XQ ? ?8XQ * XP

So, we have to prove that if two protocols are compatible than the statement above is satisfied,
and vice-versa. The first part of our proof focus on that protocol compatibility implies in the
absence of strong conflicts. We start by the central statement of Definition 4.12, saying that
the following is satisfied for all s ? traces(P)? traces(Q). For the sake of brevity, consider, for a
given process S, INS = inputs(S) and OU TS = outputs(S).

?s ? traces(P)?traces(Q)•
(OsP 6= /0 ? O

s
P ? I

s
Q)? (O

s
Q 6= /0 ? O

s
Q ? I

s
P)

?[Definition 4.4]
?(s,XP)? failures(P),(s,XQ)? failures(Q)|XP ? ?8(IsP ? O

s
P)? XQ ? ?8(I

s
Q ? O

s
Q)•

(OsP 6= /0 ? O
s
P ? I

s
Q ? I

s
Q ? ?8XQ ? O

s
P * XP)?

(OsQ 6= /0 ? O
s
Q ? I

s
P ? I

s
P ? ?8XP ? O

s
Q * XQ)



APPENDIX A RELATION BETWEEN PROTOCOL COMPATIBILITY AND CONFLICT FREEDOM 127

?[as a direct implication of the statement above]
?(s,XP)? failures(P),(s,XQ)? failures(Q)|XP ? ?8(IsP ? O

s
P)? XQ ? ?8(I

s
Q ? O

s
Q)•

(OsP 6= /0 ? O
s
P ? I

s
Q ? I

s
Q ? ?8XQ ? O

s
P * XP ? ?8XQ * XP)?

(OsQ 6= /0 ? O
s
Q ? I

s
P ? I

s
P ? ?8XP ? O

s
Q * XQ ? ?8XP * XQ)

?[simplifying]
?(s,XP)? failures(P),(s,XQ)? failures(Q)|XP ? ?8(IsP ? O

s
P)? XQ ? ?8(I

s
Q ? O

s
Q)•

(?8XQ * XP)? (?8XP * XQ)

The other part of this proof is concerned with proving that the absence of strong conflicts
implies that P and Q are compatible.

?(s,XP)? failures(P),(s,XQ)? failures(Q)|XP ? ?8(IsP ? O
s
P)? XQ ? ?8(I

s
Q ? O

s
Q)•

(?8XQ * XP)? (?8XP * XQ)
?[rewriting]
?(s,XP)? failures(P),(s,XQ)? failures(Q)|XP ? ?8(IsP ? O

s
P)? XQ ? ?8(I

s
Q ? O

s
Q)•

(OsP 6= /0 ? ?8XQ * XP)? ((O
s
P = /0 ? ?8XQ * XP)?

(OsQ 6= /0 ? ?8XP * XQ)? (O
s
Q = /0 ? ?8XP * XQ)

?[Based on the Definition 4.4 we imply: ?a : OsP • I
s
P ?{a}? ?8XP.

By induction, we have that ?8XP * XQ ? OsP 6= /0 ? O
s
P * XQ; the same is valid for O

s
Q]

?(s,XP)? failures(P),(s,XQ)? failures(Q)|XP ? ?8(IsP ? O
s
P)? XQ ? ?8(I

s
Q ? O

s
Q)•

(OsQ 6= /0 ? ?8XQ * XP ? O
s
Q * XP ? O

s
Q * XQ)?

(OsP 6= /0 ? ?8XP * XQ ? O
s
P * XQ ? O

s
P * XP)?

((OsQ = /0 ? ?8XQ * XP ? I
s
Q = ?8XQ)?

(OsP = /0 ? ?8XP * XQ ? I
s
P = ?8XP)

?[P and Q are conjugate, OU TP ? INQ ? OU TQ ? INP]
By induction, we have that ?8XP * XQ ? OsP 6= /0 ? O

s
P * XQ; the same is valid for O

s
Q]

?(s,XP)? failures(P),(s,XQ)? failures(Q)|XP ? ?8(IsP ? O
s
P)? XQ ? ?8(I

s
Q ? O

s
Q)•

(OsQ 6= /0 ? ?8XQ * XP ? O
s
Q * XP ? O

s
Q * XQ ? O

s
Q ? I

s
P)?

(OsP 6= /0 ? ?8XP * XQ ? O
s
P * XQ ? O

s
P * XP ? O

s
P ? I

s
Q)?

((OsQ = /0 ? ?8XQ * XP ? I
s
Q = ?8XQ ? O

s
P 6= /0 ? O

s
P * XP)?

(OsP = /0 ? ?8XP * XQ ? I
s
P = ?8XP ? O

s
Q 6= /0 ? O

s
Q * XQ)



APPENDIX A RELATION BETWEEN PROTOCOL COMPATIBILITY AND CONFLICT FREEDOM 128

?[Based on the Definition 4.4, XP is a maximal refusal, we imply: ?b : OsP • XP = ?8(I
s
P ?{a});

By induction, considering that INP ? INQ = /0, IsQ * XP ? O
s
P ? I

s
Q; the same is valid for O

s
Q.]

?(s,XP)? failures(P),(s,XQ)? failures(Q)|XP ? ?8(IsP ? O
s
P)? XQ ? ?8(I

s
Q ? O

s
Q)•

(OsQ 6= /0 ? ?8XQ * XP ? O
s
Q * XP ? O

s
Q * XQ ? INP8I

s
P ? XP ? O

s
Q ? I

s
P)?

(OsP 6= /0 ? ?8XP * XQ ? O
s
P * XQ ? O

s
P * XP ? INQ8I

s
Q ? XQ ? O

s
P ? I

s
Q)?

((OsQ = /0 ? ?8XQ * XP ? I
s
Q = ?8XQ ? O

s
P 6= /0 ? O

s
P ? I

s
Q)?

(OsP = /0 ? ?8XP * XQ ? I
s
P = ?8XP ? O

s
Q 6= /0 ? O

s
Q ? I

s
P)

?[simplifying, considering that IsP, I
s
Q, O

s
P and O

s
Q depends solely of the traces of P and Q]

?s ? traces(P)?traces(Q)•
(OsP 6= /0 ? O

s
P ? I

s
Q)? (O

s
Q 6= /0 ? O

s
Q ? I

s
P)

Besides there is an equivalence between a pair of protocols being compatible and absent of
strong conflicts, the notion of protocol compatibility has the benefit of being defined solely in
terms of the traces of the protocols, what easy further reasoning.



APPENDIX B

Proofs of composition rules with metadata

This appendix provides details about the proofs of the theorems stated in Section 6.3.2.

Theorem 6.9 (Enriched Interleaving Composition Compatibility). An enriched interleaving
composition is an enriched component contract.

Proof. Based on the definitions 5.16 and 6.10, in order to an enriched interleave composition
P[|||]Q being an enriched component contract, we have to prove that:

1. S = ?BP,RP,IP,CP??? ? ???BQ,RQ,IQ,CQ? is a protocol oriented component.

2. dom ProtKPQ ?CS ??c : dom Prot
K
PQ • Prot

K(c)vF ProtIMP(S,c)

3. dom DecK ?CS ? ran DecK ?CS ?
(?c1,c2 : CS • c1 DecK c2 ?{c1,c2}DecoupledIn S ? c2 DecKPQ c1)

Considering the items above, we split the proof in three parts; one corresponding to each
item. We do not show the proofs about preservation of context process and dual protocols.
These are similar to the proof for item 2.
Part 1) Prove that the composition is a protocol oriented component (see Definition 5.15) is
the same as proving that for any process R, channel c, and set of events Z, such that c ? CS,
Z ? ?BS ?? R, BS ?

{|Z|}
R is deadlock-free, the following holds:

BS |? {|c|}vF (BS ?
{|Z|}

R) |? {|c|}

?[Definition 6.2, CS = CP ?CQ, BS = BP |||BQ]
(c ?CP ? ((BP |||BQ) |? {|c|}vF ((BP |||BQ) ?

{|Z|}
R) |? {|c|})?

(c ?CQ ? ((BP |||BQ) |? {|c|}vF ((BP |||BQ) ?
{|Z|}

R) |? {|c|})

?[rewriting, ?BP ??BQ = /0]
(c ?CP ? (BP |? {|c|}vF BP ?

{|Z|}
(BQ ?

{|Z|}
R) |? {|c|})?

(c ?CQ ? (BQ |? {|c|}vF BQ ?
{|Z|}

(BP ?
{|Z|}

R) |? {|c|})

?[P and Q are protocol oriented components]
true

129



APPENDIX B PROOFS OF COMPOSITION RULES WITH METADATA 130

Part 2) In this part, in order to prove that the composition is an enriched component contract,
we prove the following assertion:

dom ProtKPQ ?CS ??c : dom Prot
K
PQ • Prot

K
PQ(c)vF ProtIMP(S,c)

?[Definition 6.10, ProtKPQ = Prot
K
P ?Prot

K
Q ]

(dom ProtKP ?dom Prot
K
Q )?CS ?

?c : (dom ProtKP ?dom Prot
K
Q )• Prot

K
PQ(c)vF ProtIMP(S,c)

?[Definition 6.2, CS = CP ?CQ, BS = BP |||BQ]
(dom ProtKP ?dom Prot

K
Q )? (CP ?CQ)?

?c : (dom ProtKP ?dom Prot
K
Q )• Prot

K
PQ(c)vF (BP |||BQ) |? {|c|}

?[Definition 5.16, dom ProtKP ?CP ? dom Prot
K
Q ?CQ]

?c : (dom ProtKP ?dom Prot
K
Q )• Prot

K
PQ(c)vF (BP |||BQ) |? {|c|}

?[ ?BP ?{|CQ|}= /0 ? ?BQ ?{|CP|}= /0]
(?c : dom ProtKP • Prot

K
PQ(c)vF BP |? {|c|})?

(?c : dom ProtKQ • Prot
K
PQ(c)vF BQ |? {|c|})

?[Definitions 6.10 and 4.8]
(?c : dom ProtKP • Prot

K
P (c)vF ProtIMP(P,c))?

(?c : dom ProtKQ • Prot
K
Q (c)vF ProtIMP(Q,c))

?[Definition 5.16, P and Q are enriched component contracts]
true

Part 3) Finally, in this part, we prove the sentence in item 3. This is proved by contradiction,
assuming that the statement is false.

dom DecKPQ ?CS ? ran Dec
K
PQ ?CS ?

(?c1,c2 : CS • c1 DecKPQ c2 ?¬{c1,c2}DecoupledIn S ?¬c2 Dec
K
PQ c1)

?[Definition 6.2, CS = CP ?CQ]
dom DecKPQ ?CP ?CQ ? ran Dec

K
PQ ?CP ?CQ ?

(?c1,c2 : CP ?CQ • c1 DecKPQ c2 ?¬{c1,c2}DecoupledIn S ?¬c2 Dec
K
PQ c1)

?[Definition 6.10, DecKPQ is symmetric]
DecKPQ = Dec

K
P ?Dec

K
Q ?{(c1,c2)|(c1 ?CQ ? c2 ?CP)? (c1 ?CP ? c2 ?CQ)}?

(?c1,c2 : CP ?CQ • c1 DecKPQ c2 ?¬{c1,c2}DecoupledIn S)



APPENDIX B PROOFS OF COMPOSITION RULES WITH METADATA 131

?[rewriting the statement, splitting in the four possible subsets of DecKPQ]
(?c1,c2 : CP |c1 DecKP c2 •¬{c1,c2}DecoupledIn S)?
(?c1,c2 : CQ |c1 DecKQ c2 •¬{c1,c2}DecoupledIn S)?
(?c1 : CP,c2 : CQ •¬{c1,c2}DecoupledIn S)?
(?c1 : CQ,c2 : CP •¬{c1,c2}DecoupledIn S)
?[Definition 4.21]
(?c1,c2 : CP |c1 DecKP c2 • ProtIMP(S,c1) ||| ProtIMP(S,c1) /?F S |? {c1,c2})?
(?c1,c2 : CQ |c1 DecKQ c2 • ProtIMP(S,c1) ||| ProtIMP(S,c1) /?F S |? {c1,c2})?
(?c1 : CP,c2 : CQ • ProtIMP(S,c1) ||| ProtIMP(S,c2) /?F S |? {c1,c2})?
(?c1 : CQ,c2 : CP • ProtIMP(S,c1) ||| ProtIMP(S,c2) /?F S |? {c1,c2})
?[Definitions 4.7 and 6.2, BS = BP |||BQ ]

(?c1,c2 : CP |c1 DecKP c2 • ProtIMP(S,c1) ||| ProtIMP(S,c2) /?F P |? {c1,c2})?
(?c1,c2 : CQ |c1 DecKQ c2 • ProtIMP(S,c1) ||| ProtIMP(S,c2) /?F Q |? {c1,c2})?
(?c1 : CP,c2 : CQ • ProtIMP(S,c1) ||| ProtIMP(S,c2) /?F P |? {c1} ||| Q |? {c2})?
(?c1 : CQ,c2 : CP • ProtIMP(S,c1) ||| ProtIMP(S,c2) /?F Q |? {c1} ||| P |? {c2})
?[Definitions 4.8 and 6.2]
(?c1,c2 : CP |c1 DecKP c2 • ProtIMP(P,c1) ||| ProtIMP(P,c2) /?F P |? {c1,c2})?
(?c1,c2 : CQ |c1 DecKQ c2 • ProtIMP(Q,c1) ||| ProtIMP(Q,c2) /?F Q |? {c1,c2})
?[Contradiction with Definition 4.21]

false

The following lemma is stated to help the proof of Theorem 6.10.

Lemma B.1. Let S = P[ic ? oc]Q be a communication composition of two protocol oriented
components P and Q, and c1 and c2 two channels, such that {c1,ic} DecoupledIn P, c1 ?CP, and
c2 ?CQ. Then {c1,c2}DecoupledIn S.

Proof.

S |? {c1,c2}
?F [Definition 6.3]

BQ ?
{|oc|}

(BP ?
{|ic|}

BU F F ?IO(ic,oc)) |? {|c1,c2|}

?F [rewriting]
BQ ?
{|oc|}

(BP ?
{|ic|}

BU F F ?IO(ic,oc))\{|CP8{ic,c1}|} |? {|c1,c2|}



APPENDIX B PROOFS OF COMPOSITION RULES WITH METADATA 132

?F [applying the hiding operator]
BQ ?
{|oc|}

(P |? {ic,c1} ?
{|ic|}

BU F F ?IO(ic,oc)) |? {|c1,c2|}

?F [{c1,ic}DecoupledIn P]
BQ ?
{|oc|}

((PIMP(P,c1) ||| PIMP(P,ic)) ?
{|ic|}

BU F F ?IO(ic,oc)) |? {|c1,c2|}

?F [rewriting]
PIMP(P,c1) ||| (BQ ?

{|oc|}
(PIMP(P,ic) ?

{|ic|}
BU F F ?IO(ic,oc))) |? {|c1,c2|}

?F [Definition 4.8, and considering the above]
PIMP(S,c1) ||| PIMP(S,c2)

Additionally, considering the proof above and that Q is a protocol oriented component, we
conclude that:

PIMP(S,c1)?F PIMP(P,c1)? PIMP(P,c2)vF PIMP(S,c2)

Lemma B.2. Let Ctr be a component contract, c1 a channel, and Z a set of channels, such that
?z : Z •{c1,z}DecoupledInCtr. Then:

Ctr |? {c1}?Z ?F Ctr |? {c1} |||Ctr |? Z

Proof. The idea of decoupled channels is close to the idea of non-interference of flows [RS01].
We translate it to our model as below, considering that P is a component contract, and A and B,
such that A?B = /0, then:?

??
P |? A ?F (P ?

{|B|}
SKIP) |? A ?

P |? B ?F (P ?
{|A|}

SKIP) |? B

?
??? P |? A?B ?F P |? A ||| P |? B

Composing SKIP in parallel with P over the alphabet H has the effect of preventing all traces
with events within the synchronizing set (A or B). The notion above presents two ways to
represent that the view of the behaviour of P over A is independent of events within B, and
vice-versa. Based on the notion presented above, we prove the lemma.

The events within c1 are independent of events within Z, and vice-versa, ?z : Z • {c1,z}
DecoupledInCtr. So:

Ctr |? {c1}?F (Ctr ?
{|Z|}

SKIP) |? {c1}?Ctr |? Z ?F (Ctr ?
{|c1|}

SKIP) |? Z

as a consequence
Ctr |? {c1}?Z ?F Ctr |? {c1} |||Ctr |? Z



APPENDIX B PROOFS OF COMPOSITION RULES WITH METADATA 133

Lemma B.3. Let S = P[ic ? oc]Q be a communication composition of two protocol oriented
components P and Q, and c1 and c2 two channels, such that {c1,c2,ic}?CP, {c1,ic}DecoupledIn P,
{c1,c2}DecoupledIn P. Then {c1,c2}DecoupledIn S.

Proof.

S |? {c1,c2}
?F [Definition 4.7]

S |? {|c1,c2|}
?F [rewriting]

S |? {|c1,c2,ic|} |? {|c1,c2|}
?F [ Lemma B.2 ]

(S |? {c1} ||| S |? {c2,ic}) |? {|c1,c2|}
?F [Definition 4.8, and considering the above]

(ProtIMP(S,c1) ||| ProtIMP(S,c2)) |? {|c1,c2|}

Additionally, considering the proof above and that Q is a protocol oriented component, we
conclude that:

PIMP(S,c1)?F PIMP(P,c1)? PIMP(P,c2)vF PIMP(S,c2)

Theorem 6.10 (Enriched Communication Composition Compatibility). An enriched commu-
nication composition is an enriched component contract.

Proof. Despite a communication composition being more complex than an interleave one, this
proof follows steps similar to the proof of Theorem 6.9.

Based on the definitions 5.16 and 6.11, in order to an enriched interleave composition P[ic?
oc]Q being an enriched component contract, we have to prove that:

1. S = ?BP,RP,IP,CP??ic? ? ?oc??BQ,RQ,IQ,CQ? is a protocol oriented component.

2. dom ProtKPQ ?CS ??c : dom Prot
K
PQ • Prot

K(c)vF ProtIMP(S,c)

3. dom DecK ?CS ? ran DecK ?CS ?
(?c1,c2 : CS • c1 DecK c2 ?{c1,c2}DecoupledIn S ? c2 DecKPQ c1)

Considering the items above, we split the proof in three parts; one corresponding to each
item. We do not show the proofs about preservation of context process and dual protocols.
These follow a proof similar to the one associated to item 2.
Part 1) Prove that the composition is a protocol oriented component (see Definition 5.15) is the
same as proving the following is true for any process R, channel c, and set of events Z, such that



APPENDIX B PROOFS OF COMPOSITION RULES WITH METADATA 134

c ?CS, Z ? ?BS ?? R, BS ?
{|Z|}

R is deadlock-free.

BS |? {|c|}vF (BS ?
{|Z|}

R) |? {|c|}

?[Definition 6.3, CS = (CP ?CQ)8{ic,oc}, BS = BP ?
{|ic|}

(BQ ?
{|oc|}

BU F F ?IO(ic,oc))]

(c ?CP8ic ? (BS |? {|c|}vF (BP ?
{|ic|}

(BQ ?
{|oc|}

BU F F ?IO(ic,oc)) ?
{|Z|}

R |? {|c|})?

(c ?CQ8oc ? (BS |? {|c|}vF (BP ?
{|ic|}

(BQ ?
{|oc|}

BU F F ?IO(ic,oc)) ?
{|Z|}

R |? {|c|})

?[rewriting, Definition 5.15, ?BP ??BQ = /0]
(c ?CP8ic ? (BP |? {|c|}vF BP ?

{|Z?{ic}|}
((BQ ?

{|oc|}
BU F F ?IO(ic,oc)) ?

{|Z|}
R) |? {|c|})?

(c ?CQ8oc ? (BQ |? {|c|}vF BQ ?
{|Z?{oc}|}

((BP ?
{|ic|}

BU F F ?IO(ic,oc)) ?
{|Z|}

R) |? {|c|})

?[Definition 5.15, P and Q are protocol oriented components]
true

Part 2) In this part, in order to prove that the composition is an enriched component contract,
we prove the following assertion:

dom ProtKPQ ?CS ??c : dom Prot
K
PQ • Prot

K
PQ(c)vF ProtIMP(S,c)

?[Definition 6.11]
(dom ProtKP 8{ic}?dom Prot

K
Q 8{oc})?CS ?

?c : (dom ProtKP ?dom Prot
K
Q )8{ic,oc}• Prot

K
PQ(c)vF ProtIMP(S,c)

?[Definitions 5.16 and 6.3, CS = (CP ?CQ)8{ic,oc}]
?c : (dom ProtKP ?dom Prot

K
Q )8{ic,oc}• Prot

K
PQ(c)vF ProtIMP(S,c)

?[rewriting using Definition 6.3 ]
(?c : dom ProtKP • c 6= ic ? Prot

K
PQ(c)vF BP ?

{|ic|}
(BQ ?

{|oc|}
BU F F ?IO(ic,oc)) |? {|c|})?

(?c : dom ProtKQ • c 6= oc ? Prot
K
PQ(c)vF BQ ?

{|oc|}
(BP ?

{|ic|}
BU F F ?IO(ic,oc)) |? {|c|})

?[ P and Q are protocol oriented components with disjoint alphabets]
(?c : dom ProtKP • c 6= ic ? Prot

K
PQ(c)vF BP |? {|c|})?

(?c : dom ProtKQ • c 6= oc ? Prot
K
PQ(c)vF BQ |? {|c|})

?[ Definitions 4.8 and 6.11]
(?c : dom ProtKP • c 6= ic ? Prot

K
P (c)vF ProtIMP(P,c))?

(?c : dom ProtKQ • c 6= oc ? Prot
K
Q (c)vF ProtIMP(Q,c))

?[Definition 5.16, P and Q are enriched component contracts]
true



APPENDIX B PROOFS OF COMPOSITION RULES WITH METADATA 135

Part 3) Finally, in this part, we prove the sentence in item 3. This is proved by contradiction,
assuming that the statement is false.

dom DecKPQ ?CS ? ran Dec
K
PQ ?CS ?

(?c1,c2 : CS • c1 DecKPQ c2 ?¬{c1,c2}DecoupledIn S ?¬c2 Dec
K
PQ c1)

?[Definition 6.3, CS = (CP ?CQ)8{ic,oc}]
dom DecKPQ ? (CP ?CQ)8{ic,oc}? ran Dec

K
PQ ? (CP ?CQ)8{ic,oc}?

(?c1,c2 : (CP ?CQ)8{ic,oc}• c1 DecKPQ c2 ?¬{c1,c2}DecoupledIn S ?¬c2 Dec
K
PQ c1)

?[Definition 6.11, DecPQ is symmetric]
DecKPQ ={(c1,c2)|({c1,c2}?{ic,oc}= /0)? (

((c1 Dec
K
P ic ? ic Dec

K
P c1)? (c2 ?CQ ? c1Dec

K
P c2))?

((oc DecKQ c2 ? c2 Dec
K
Q oc)? (c1 ?CP ? c1Dec

K
Q c2)))}?

(?c1,c2 : (CP ?CQ)8{ic,oc}• c1 DecKPQ c2 ?¬{c1,c2}DecoupledIn S)
?[rewriting the statement, splitting in the four possible subsets of the symmetric relation DecKPQ ]
(?c1,c2 : CP8{ic}|c1 DecKP c2 ? c1 Dec

K
P ic •¬{c1,c2}DecoupledIn S)?

(?c1,c2 : CQ8{oc}|c1 DecKQ c2 ? c2 Dec
K
Q oc •¬{c1,c2}DecoupledIn S)?

(?c1 : CP8{ic},c2 : CQ8{oc}|c1 DecKP ic •¬{c1,c2}DecoupledIn S)?
(?c1 : CP8{ic},c2 : CQ8{oc}|c2 DecKQ oc •¬{c1,c2}DecoupledIn S)
?[Lemma B.1]
(?c1,c2 : CP8{ic}|c1 DecKP c2 ? c1 Dec

K
P ic •¬{c1,c2}DecoupledIn S)?

(?c1,c2 : CQ8{oc}|c1 DecKQ c2 ? c2 Dec
K
Q oc •¬{c1,c2}DecoupledIn S)

?[Contradiction with Lemma B.3]
false

The following lemma is stated to help in the proof of Theorem 6.11.

Lemma B.4. Let S = P ?
???ic?
?oc? be a feedback composition, P a protocol oriented component,

and c1 and c2 two channels, such that {c1,c2}DecoupledIn P, {c1,ic}DecoupledIn P, and {c1,oc}
DecoupledIn P. Then {c1,c2}DecoupledIn S.
Proof. Assume P |? {ic,c1}?F (Pic? ||| Pc1?), ProtIMP(P,ic)vF Pic?, and ProtIMP(P,c1)vF Pc1?.

S |? {c1,c2}
?F [Definition 6.3]

(BP ?
{|ic,oc|}

BU F F ?IO(ic,oc)) |? {|c1,c2|}

?F [rewriting]
(BP ?

{|ic,oc|}
BU F F ?IO(ic,oc)) |? {|c1,c2,ic,oc|} |? {|c1,c2|}



APPENDIX B PROOFS OF COMPOSITION RULES WITH METADATA 136

?F [Lemma B.2]
((P |? {c1} ||| P |? {c2,ic,oc}) ?

{|ic,oc|}
BU F F ?IO(ic,oc)) |? {|c1,c2|}

?F [Definition 4.8, and considering the above]
ProtIMP(P,c1) ||| ProtIMP(P,c2)

Additionally, considering the proof above and that Q is a protocol oriented component, we
conclude that:

PIMP(S,c1)?F PIMP(P,c1)? PIMP(P,c2)vF PIMP(S,c2)

Theorem 6.11 (Enriched Feedback Composition Compatibility). An enriched feedback com-
position is an enriched component contract.

Proof. Based on the definitions 5.16 and 6.12, in order to an enriched interleave composition
P[|||]Q be an enriched component contract, we have to prove that:

1. S = ?BP,RP,IP,CP??
???ic?
?oc? is a protocol oriented component.

2. dom ProtKPQ ?CS ??c : dom Prot
K
PQ • Prot

K
PQ(c)vF ProtIMP(S,c)

3. dom DecK ?CS ? ran DecK ?CS ?
(?c1,c2 : CS • c1 DecK c2 ?{c1,c2}DecoupledIn S ? c2 DecKPQ c1)

Considering the items above, we split the proof in three parts; one corresponding to each
item. We do not show the proofs about preservation of context process and dual protocols.
These follow a proof similar to the one associated to item 2.
Part 1) prove that S is a protocol oriented component is a direct consequence of the fact that P is
also a protocol oriented component. So, to prove that we have to prove the following statement
for any process R, channel c, and set of events Z, such that c ? CS, Z ? ?BS ?? R, BS ?

{|Z|}
R is

deadlock-free (see Definition 5.15).

BS |? {|c|}vF (BS ?
{|Z|}

R) |? {|c|}

?[Definition 6.4, CS = CP8{ic,oc}, BS = BP ?
{|ic,oc|}

BU F F ?IO(ic,oc)]

(c ?CP8ic,oc ? ((BP ?
{|ic,oc|}

BU F F ?IO(ic,oc)) |? {|c|}vF BP ?
{|Z?{ic,oc}|}

(BU F F ?IO(ic,oc)) ||| R) |? {|c|})

?[Definition 5.15, P are protocol oriented components]
BP |? {|c|}vF BP ?

{|Z?{ic,oc}|}
(BU F F ?IO(ic,oc)) ||| R) |? {|c|})

?[Definition 5.15, P are protocol oriented components]
true



APPENDIX B PROOFS OF COMPOSITION RULES WITH METADATA 137

Part 2) In this part, in order to prove that the composition is an enriched component contract,
we prove the following assertion:

dom ProtKPQ ?CS ??c : dom Prot
K
PQ • Prot

K
PQ(c)vF ProtIMP(S,c)

?[Definitions 6.12 and 6.4]
(dom ProtKP 8{ic,oc})?CP8{ic,oc}?
?c : dom ProtKP 8{ic,oc}• Prot

K
P (c)vF ProtIMP(S,c)

?[Definitions 5.16]
?c : dom ProtKP 8{ic,oc}• Prot

K
P (c)vF ProtIMP(S,c)

?[Definition 6.4]
?c : dom ProtKP 8{ic,oc}• Prot

K
P (c)vF BP ?

{|ic,oc|}
BU F F ?IO(ic,oc) |? {|c|})

?[ P is a protocol oriented component]
?c : dom ProtKP 8{ic,oc}• Prot

K
P (c)vF BP |? {|c|})

?[Definition 5.16, P is an enriched component contracts]
true

Part 3) Finally, in this part, we prove the sentence in item 3. This is proved by contradiction,
assuming that the statement is false.

dom DecKPQ ?CS ? ran Dec
K
PQ ?CS ?

(?c1,c2 : CS • c1 DecKPQ c2 ?¬{c1,c2}DecoupledIn S ?¬c2 Dec
K
PQ c1)

?[Definition 6.3, CS = CP8{ic,oc}]
dom DecKPQ ?CP8{ic,oc}? ran Dec

K
PQ ?CP8{ic,oc}?

(?c1,c2 : (CP ?CQ)8{ic,oc}• c1 DecKPQ c2 ?¬{c1,c2}DecoupledIn S ?¬c2 Dec
K
PQ c1)

?[Definition 6.11, DecKPQ is symmetric]
DecKS ={(c1,c2)|({c1,c2}?{ic,oc}= /0)? c1Dec

K
P c2 ?

((c1 Dec
K
P ic ? c1 Dec

K
P oc)? (ic Dec

K
P c2 ? oc Dec

K
P c2))}

(?c1,c2 : (CP ?CQ)8{ic,oc}• c1 DecKPQ c2 ?¬{c1,c2}DecoupledIn S)
?[rewriting the statement, considering that DecKPQ is a symmetric relation]

(?c1,c2 : CP8{ic} |c1 DecKP c2 ? c1 Dec
K
P ic ? c1 Dec

K
P oc

•¬{c1,c2}DecoupledIn S)
?Contradiction with [Lemma B.4]

false



APPENDIX C

Cases study in FDR

This Appendix complements Chapter 7, explaining how components of the study cases might
be verified in the model checker FDR (for Failure-Divergence-Refinement). The appendix is
not intended to detail the study cases or the strategy presented in this work, but to focus on the
aspects that ease their verification. In fact, we present simplifications of the study cases here.
The dining example presented here, has a reduced set of forks and philosophers. The routing
example presented here consider only instances of the abstract connectors in Chapter 7. This,
however, does not invalidate our intention of showing that verifications can be performed in
FDR, it only focuses on the essential steps of these case studies.

Elements of the component contracts in these cases are represented by datatypes, chan-
nels and processes, as defined in Chapter 5. As the elements are sometimes distributed in the
specification, we mainly represent a component by its behaviour, which is mapped into a CSP
process. All processes presented here are in the machine-readable CSP (CSPM ) notation with
the aim of being verified in FDR. In addition, some assertions are presented in appendix to
illustrate verifications steps in the strategy presented in this work.

The next section are organised as follows. The first part concerns the notation used for
the CSP operators in CSPM , presenting only as far as it was used throughout this appendix;
explanations on related notions in FDR are also presented. Then, we present auxiliary processes
used in the specification of all study cases. These auxiliary processes represent behaviours
related to our component model and strategy. The next sections present the specification and
assertions of the case: the dining philosophers and the routing coordinator examples.

C.1 FDR-CSP

The description given in Table C.1 follows that in [For10]. This is not a complete list of
operations; we have left out those not needed for understanding the CSP specifications of this
work.

{|a|} stands for the set of all events which begin with a. For example, if we define a chan-
nel foo to be of type {1..3}.Bool, then {| foo.3 |} denotes the set {foo.3.true,
foo.3.false}. The assert statement in FDR specifications is used to state properties which
should be checked on the specification. These may concern deadlock or divergence freedom
tests as well as refinement tests. For instance assert P: [deadlock free] asserts that
process P is deadlock free. Such assertions are used to initialise the list of checks for FDR.

138



C.2 AUXILIARY PROCESSES 139

STOP deadlock
SKIP termination
CHAOS(A) the chaotic process (on events in A)
ev -&gt; P prefix: first event ev then P
P; Q sequential composition: first P then Q
P \ A hiding: in P, hide all events in A
P [[ev&amp;lt;- ev’]] renaming: in P, rename ev into ev’
P [] Q external choice between P and Q
P |~| Q internal choice between P and Q
b &amp;amp; P boolean guard: execute P if b evaluates to true
P ||| Q interleaving P with Q
P [| A |[ Q parallel composition of P and Q with synchronisation on A
[] x:A @ P(x) replicated external choice: choose over all P(x) such that x?A
|~| x:A @ P(x) replicated internal choice

Table C.1 Syntax of the CSPM language

C.2 Auxiliary processes

Before present the study case in CSPM , we present some auxiliary parametrised processes that
are used in verifications related to the strategy of construction. To tune verifications in FDR,
we use, when possible, local definitions to separate out those arguments which are passed in
for configuration purposes (sizes, channels and so on) from those which represent process state
and may need to be modified on recursive calls.

BUFFER(ci, co, n) =
let

B(&lt;&gt;) = ci?x -&gt; B(&lt;x&gt;)
B(s) = (co!head(s) -&gt; B(tail(s)))

[] (#s&lt;n &amp;amp; ci?x -&gt; B(s^&lt;x&gt;))
within B(&lt;&gt;)

BFIO(c1,c2) = BUFFER(c1.out,c2.in, 10)
||| BUFFER(c2.out,c1.in, 10)

The process BUFFER(ci, co, n) is a buffer of size n that inputs events performed via a
channel ci to a channel co. And the process BFIO(c1,c2) is a I/O buffer for two channels
c1 and c2. In order to tune the verification of these study cases, we use buffers of size 10,
which does not change the behaviour of studies.

Based on the specification of these buffers, we specify four parametrised processes to rep-
resent our composition rules.

INTER(P,Q) = P ||| Q
COMM(P,Q,c1,c2) = (P ||| Q) [| {| c1,c2 |} |] BFIO(c1,c2)
FEED(P,c1,c2) = P[| {| c1,c2 |} |] BFIO(c1,c2)
REF(P,c1,c2) = P[| {| c1,c2 |} |] BFIO(c1,c2)



C.3 THE DINING PHILOSOPHER’S EXAMPLE 140

INTER(P,Q) represents an interleave composition of the two processes (component behav-
iours) P and Q. COMM(P,Q,c1,c2) represents a communication composition between P and
Q, using the channels c1 and c2. Finally, FEED(P,c1,c2) and REF(P,c1,c2) represent
a feedback and a reflexive composition of P using the channels c1 and c2, respectively. These
parametrised processes represent the structure of the composition, they do not represent all con-
cepts of the compositions rules; provisos must still be satisfied to perform the compositions.

Other processes are related to verifications of rule provisos. For instance, in order to check
that a process P is I/O confluent, we need to perform a data forgetful renaming on the process
(P [[ c.in.x&amp;lt;- i, c.out.y&amp;lt;- o]], and then place an input one-place inwards-
pointing buffer on every individual event of the renamed process (C(i, C(o, P))). The
process InBufferProt below represent these steps altogether.

channel o,i, mid
CP(a,b) =
let
CPBEHAV = a -&gt; b -&gt; CPBEHAV
within CPBEHAV
C(a, P) = (P[[ a&amp;lt;- mid ]] [| {|mid|} |] CP(a,mid)) \ {|mid|}
CIO(P) = C(i, C(o, P))

InBufferProt(P,c) = CIO(P [[ c.in.x&amp;lt;- i, c.out.y&amp;lt;- o,
x&amp;lt;-extensions(c.in), y&amp;lt;-extensions(c.out)]])

These are some auxiliary processes used in verifications of the study case. Not all verifications
steps use an auxiliary process. Some provisos are directly represented by an assertion in the
specifications presented in the next sections.

C.3 The dining philosopher’s example

To easy the definition of I/O types, we define a datatype EVENTS with all possible events in the
system, and another datatype IO that tags events within EVENTS with in or out. Based on this,
all I/O types are defined as subtypes of IO; in fact, we could not define I/O types as datatypes,
since distinct datatype cannot share the same tags.

datatype EVENTS = picksup | putsdown | picksack | putsack |
thinks | sits | eats | getsup

datatype IO = out.EVENTS | in.EVENTS

As said before, all interfaces are defined as subtypes of IO. The interface used by the fork
component is I_FORK, and the interfaces used by the philosopher are I_PHF and I_LIFE.

subtype FKIN = picksup | putsdown
subtype FKOUT = picksack | putsack
subtype I_FORK = out.FKOUT | in.FKIN



C.3 THE DINING PHILOSOPHER’S EXAMPLE 141

subtype LFOUT = thinks | sits | eats | getsup
subtype I_LIFE = out.LFOUT
subtype I_PHFK = in.FKOUT | out.FKIN

The channels typed by these interfaces are fk1, fk2, pf1, pf2 and lf.

channel fk1, fk2: I_FORK
channel pf1, pf2: I_PHFK
channel lf: I_LIFE

Based on these types and channels, we define the behaviour of a fork and a philosopher as the
processes FORK and PHIL.

FORK = (COMPFK(fk1) [] COMPFK(fk2)); FORK
COMPFK(f) = PICKUP_FK(f); PUTDOWN_FK(f)
PICKUP_FK(f) = f.in.picksup -&gt; f.out.picksack -&gt; SKIP
PUTDOWN_FK(f) = f.in.putsdown -&gt; f.out.putsack -&gt; SKIP

PHIL = PREEAT; (lf.out.eats -&gt; POSTEAT); PHIL
PREEAT = lf.out.thinks -&gt; lf.out.sits -&gt; PICKFORKSUP
POSTEAT = PUTFORKSDOWN; (lf.out.getsup -&gt; SKIP)
PICKFORKSUP = PICKUP_PH(pf1); PICKUP_PH(pf2)
PUTFORKSDOWN = PUTDOWN_PH(pf1); PUTDOWN_PH(pf2)
PICKUP_PH(c) = c.out.picksup -&gt; c.in.picksack -&gt; SKIP
PUTDOWN_PH(c) = c.out.putsdown -&gt; c.in.putsack -&gt; SKIP

The contract of a fork and a philosopher component is defined by CtrF ORK and CtrPHIL, respec-
tively.

CtrF ORK = ?F ORK,{ f k1 7? IF ORK, f k2 7? IF ORK},{IF ORK},{ f k1, f k2}?

CtrPHIL = ?PHIL,{l f 7? ILIF E, p f 1 7? IPHF K, p f 2 7? IPHF K},{IPHF K,ILIF E},{l f , p f 1, p f 2}?

These are component types corresponding to the fork and philosopher. The behaviour of
the corresponding instances of these types in the example are represented by the following
processes. The contracts of these instances are presented in Chapter 7. For the sake of brevity,
we present the case study for only 3 philosophers.

FORK0 = FORK [[ fk1&amp;lt;- fk.0.0, fk2&amp;lt;- fk.0.2 ]]
FORK1 = FORK [[ fk1&amp;lt;- fk.1.1, fk2&amp;lt;- fk.1.0 ]]
FORK2 = FORK [[ fk1&amp;lt;- fk.2.2, fk2&amp;lt;- fk.2.1 ]]

PHIL0 = PHIL [[ pf1&amp;lt;- pfk.0.0, pf2&amp;lt;- pfk.1.0 ]]
PHIL1 = PHIL [[ pf1&amp;lt;- pfk.1.1, pf2&amp;lt;- pfk.2.1 ]]
PHIL2 = PHIL [[ pf1&amp;lt;- pfk.2.2, pf2&amp;lt;- pfk.0.2 ]]
PHILA = PHIL [[ pf1&amp;lt;- pfk.0.2, pf2&amp;lt;- pfk.2.2 ]]



C.3 THE DINING PHILOSOPHER’S EXAMPLE 142

The behaviours of compositions among these instances are represented by the following
processes.

FORKS= INTER(INTER(FORK0, FORK1), FORK2)
PHILS= INTER(PHIL0, PHIL1)
LF_PHFKS=FEED(COMM(PHILS,FORKS,fk.0.0,pfk.0.0),fk.1.1,pfk.1.1)
PHILFKS= FEED(FEED(LF_PHFKS,fk.1.0,pfk.1.0),fk.2.1,pfk.2.1)

LF_LSTPH= COMM(PHILFKS, PHIL2, fk.2.2, pfk.2.2)
DEAD_SYSTEM= REF(LF_LSTPH, fk.0.2, pfk.0.2)

LEFT_PHA= COMM(PHILFKS, PHILA, fk.2.2, pfk.2.2)
SYSTEM= REF(LEFT_PHA, fk.0.2, pfk.0.2)

DEAD_SYSTEM corresponds to a possible final composition with deadlock, which contains
philosophers that obtain forks in a symmetric manner. SYSTEM corresponds to the final dead-
lock-free composition that represents the systems; to avoid deadlock, one philosopher (PHILA)
is acquires forks in order different of the others. The processes above represent only the be-
haviour of such compositions, and they do not consider the provisos related to the composition
rules involved. In fact, we would never achieve a composition with the DEAD_SYSTEM be-
haviour, since it does not satisfies the provisos of a reflexive composition. To confirm which
compositions are deadlock-free, we can use the following verifications in FDR.

assert PHILS :[deadlock free [F]]
assert FORKS :[deadlock free [F]]
assert LEFT_PHFKInS :[deadlock free [F]]
assert PHILFKS :[deadlock free [F]]
assert LEFT_LSTPH :[deadlock free [F]]
assert not DEAD_SYSTEM :[deadlock free [F]]
assert LEFT_PHA :[deadlock free [F]]
assert SYSTEM :[deadlock free [F]]

Most provisos of the compositions above (those related to protocols and decoupled channels)
can be verified in FDR. This cover the provisos related to interleave, communication and feed-
back compositions rules. As the components in this study case satisfy the constraints to be
BRIC components, the verifications of the composition rules are performed directly in the
metadata. Here, we only need to perform verifications on elements of the original compo-
nents (forks and philosophers). The does not contain any decoupled channels (some decoupled
channels are identified latter during composition), therefore, we focus on verifications about
protocols.

The protocols of PHIL and F ORK are PROT_PH and PROT_FK, respectively. These are
very simple protocols, since they do not present the common non-determinism related to out-
put events. For this reason, their dual protocols and context process have an equivalent behav-
iour, as we can observe on the dual protocol of DPROT_FK and context process CTX_FK of
PROT_FK, presented below.



C.4 ROUTING COORDINATION 143

PROT_PH = PICKUP_PH(pf1); PUTDOWN_PH(pf1); PROT_PH
PROT_FK = COMPFK(fk1); PROT_FK
DPROT_FK = COMPFK(fk1); DPROT_FK
CTX_FK = COMPFK(fk1); CTX_FK

To verify that these protocols are compatible, we verify the following assertion, which translates
the test characterisation for protocol compatibility presented in Section 4.1.

PROTCTX_PH = (PROT_PH [[pf1.in&amp;lt;-fk1.out,pf1.out&amp;lt;-fk1.in]])
[| {|fk1|} |] CTX_FK

assert DPROT_FK [F= PROTCTX_PH

To verify that these protocols satisfy FOP, we just need to verify that hiding outputs does not
introduce divergences (infinity hidden traces). The follow assertion translates this verification.

assert PROT_PH \ {|pf1.out |}:[divergence free [FD]]
assert PROT_FK \ {|fk1.out |}:[divergence free [FD]]

Finally, we present how to verify that these protocols are I/O confluent. In order to verify this,
we have to verify that the protocol with one-place inwards-pointing buffer on every individual
event, after applying a forgetful renaming on that protocol, is deterministic. This verification
uses the process InBufferProt presented early.

assert InBufferProt(Prot_FK) :[deterministic [F]]
assert InBufferProt(Prot_PH) :[deterministic [F]]

This concludes the translation of this example into CSPM , and its verification in FDR.

C.4 Routing coordination

Similar to the dining philosophers example, we define a datatype EVENTS with all possible
events in the system, and a root supertype IO for all I/O Types. IO is constructed by adding the
tags in or out to all events within EVENTS. The nametype SubInt is used to tune verification
in FDR, restricting the set of integers in consideration when performing verifications about the
system.

nametype SubInt = {1..2}
datatype EVENTS = wd.SubInt | resBal.SubInt | ackWd.Bool |

reqBal | isbusy | busy | idle
datatype IO = in.EVENTS | out.EVENTS

The interfaces for communicating data are I_DTSV and I_DTCL. If a component transmits
data through the routing network, it has a port typed by one of these interfaces, and its receiver
has a port typed by the other interface. Observe that the interfaces of the routing network are
specific for the components intermediated by the connector in the example. In fact, these are the
same interfaces used by these components. Communications among connectors of the network
use ports typed by I_FDSV and I_FDCL.



C.4 ROUTING COORDINATION 144

subtype CLOUT = wd.SubInt | reqBal
subtype CLIN = ackWd.Bool | resBal.SubInt
subtype I_DTSV = in.CLOUT | out.CLIN
subtype I_DTCL = in.CLIN | out.CLOUT

subtype FEEDASK = isbusy
subtype FEEDSTATUS = busy | idle
subtype I_FDSV = in.FEEDASK | out.FEEDSTATUS
subtype I_FDCL = out.FEEDASK | in.FEEDSTATUS

As said before, the ports used by the connector in the example are typed by the interfaces
above. The channels ifd, ofd, idt and odt are used by the connectors in the example. To
illustrate the components in the extreme of the network, we define the channels sv and cl to
present in the specification of protocols of these systems.

channel ifd: I_FDSV
channel ofd: I_FDCL

channel idt, sv: I_DTSV
channel odt, cl: I_DTCL

The protocols of the components in the extreme of the connectors are important in the
specification of the network, since they parametrise the connectors abstract behaviour. Here,
we present these protocols to help the understanding of the system. Only concrete specifications
(after parameters are resolved) are presented. Below the specification of the protocol of a server
(PROT_SV), the protocol of a client (PROT_CL), its dual protocol (DPROT_CL) and its context
process (CTX_CL).

PROT_SV = (sv.in.wd?x -&gt;
(|~| a: Bool @ sv.out!ackWd.a -&gt; PROT_SV))

[] (sv.in.reqBal -&gt;
(|~| y: SubInt @ sv.out!resBal.y -&gt; PROT_SV))

PROT_CL = |~| val:SubInt @ cl.out!wd.val -&gt; cl.in.ackWd?a -&gt;
cl.out!reqBal -&gt; cl.in.resBal?x -&gt; PROT_CL

DPROT_CL = cl.out.wd?val -&gt; |~| a:Bool @ cl.in.ackWd!a -&gt;
cl.out.reqBal -&gt;
|~| x: SubInt @ cl.in.resBal!x -&gt; DPROT_CL

CTX_CL = cl.out.wd?val -&gt; cl.in.ackWd?a -&gt; cl.out.reqBal -&gt;
cl.in.resBal?x -&gt; CTX_CL

As presented below these are compatible protocols.

PROTCTX_SV = (PROT_SV [[ sv.in&amp;lt;- cl.out, sv.out&amp;lt;- cl.in ]])
[|{|cl|} |] CTX_CL

assert InBufferProt(PROT_SV, sv) :[deterministic [F]]



C.4 ROUTING COORDINATION 145

The behaviour of the two connectors in this example is given by the following processors
CCM and LBC.

CCM(c1,c2, f1, f2, co) = CHOICECOPY(c1,c2,co)
[| {|c1,c2|} |] AVAIL(c1,c2,f1,f2)

CHOICECOPY(c1,c2, co) =
let

TWOCOPIES = (COPY(c1,co); TWOCOPIES)
[] (COPY(c2,co); TWOCOPIES)

within TWOCOPIES

AVAIL(c1,c2,f1,f2) =
let
AVST = (f1.in.isbusy -&gt; f1.out!idle -&gt; AVST)

[] (f2.in.isbusy -&gt; f2.out!idle -&gt; AVST)
[] (c1.in?x -&gt; AVST1; AVST)
[] (c2.in?x -&gt; AVST2; AVST)

AVST1 = (f1.in.isbusy -&gt; f1.out!idle -&gt; AVST1)
[] (f2.in.isbusy -&gt; f2.out!busy -&gt; AVST1)
[] (c1.out?x -&gt; SKIP)

AVST2 = (f1.in.isbusy -&gt; f1.out!busy -&gt; AVST2)
[] (f2.in.isbusy -&gt; f2.out!idle -&gt; AVST2)
[] (c2.out?x -&gt; SKIP)

within AVST

COPY(ci,co) = CPSTEP(ci,co); CPSTEP(co,ci)
CPSTEP(ci,co) = ci.in?x -&gt; co.out!x -&gt; SKIP

LBC(ci,f1,f2, c1,c2) =
let
LBCBEHAV = f1.out!isbusy -&gt; f2.out!isbusy -&gt;

( (f1.in.idle -&gt; f2.in?x -&gt; COPY(ci,c1); LBCBEHAV)
[] (f1.in.busy -&gt; ((f2.in.idle -&gt; COPY(ci,c2); LBCBEHAV)

[] (f2.in.busy -&gt; LBCBEHAV))))
within LBCBEHAV

Most of the processes use local definitions to tune verifications in FDR. This is performed
separating out those arguments which are passed in for configuration purposes (sizes, channels
and so on) from those which represent process state and may need to be modified on recursive
calls.

Instances of the concrete protocols presented above are built by adding am identifier index
in all channels used by these connectors, as presented below.

channel ifeed : {1..6}.I_FDSV



C.4 ROUTING COORDINATION 146

channel ofeed : {1..6}.I_FDCL

channel idata : {1..8}.I_DTSV
channel odata : {1..8}.I_DTCL

LBC1 = LBC(idata.1, ofeed.3, ofeed.5, odata.3, odata.5)
LBC2 = LBC(idata.2, ofeed.4, ofeed.6, odata.4, odata.6)

CCM1 = CCM(idata.3, idata.4, ifeed.3, ifeed.4, odata.1)
CCM2 = CCM(idata.5, idata.6, ifeed.5, ifeed.6, odata.2)

The behaviour of compositions among these instances are represented by the following
processes. The first four processes represent compositions between data channels, and the
last two compositions represent compositions between feedback channels (channels used to
exchange control information in the routing).

CONNET1 = COMM(LBC1, CCM1, idata.3, odata.3)
CONNET2 = COMM(LBC2, CCM2, idata.4, odata.4)
CONNET3 = COMM(CONNET1, CONNET2, idata.5, odata.5)
CONNET4 = REF(CONNET3, idata.6, odata.6)
CONNET5 = REF(REF(CONNET4,ifeed.3,ofeed.3),ifeed.4,ofeed.4)
CONNET6 = REF(REF(CONNET5,ifeed.5,ofeed.5),ifeed.6,ofeed.6)

These are deadlock-free compositions, as assert below.

assert CONNET1 :[deadlock free [F]]
assert CONNET2 :[deadlock free [F]]
assert CONNET3 :[deadlock free [F]]
assert CONNET4 :[deadlock free [F]]
assert CONNET5 :[deadlock free [F]]
assert CONNET6 :[deadlock free [F]]

Verifications about protocols of these components are performed to ensure the provisos
of the compositions above. The following processes represent the protocols. PROT_CMMDT
and PROT_CMMFD are the protocols for data and control communication of CCM, respectively.
DPROT_CMMDT and DPROT_CMMFD are their dual protocols, respectively. PROT_LBCDT and
PROT_LBCFD are the protocols for data and control communication of LBC.

PROT_CMMFD = ifd.in.isbusy -&gt;
|~|y: FEEDSTATUS@ ifd.out.y -&gt; PROT_CMMFD

PROT_CMMDT = idt.in?y -&gt; |~| x:CLIN @ odt.out?x -&gt; PROT_CMMDT
DPROT_CMMFD = ifd.in.isbusy -&gt; ifd.out?x -&gt; DPROT_CMMFD
DPROT_CMMDT = |~|y:CLOUT@ idt.in.y -&gt; idt.out?x -&gt; DPROT_CMMDT

PROT_LBCFD = ofd.out.isbusy -&gt; ofd.in?x -&gt; PROT_LBCFD
PROT_LBCDT = |~|y:CLOUT@ odt.out.y -&gt; odt.in?x -&gt; PROT_LBCDT



C.4 ROUTING COORDINATION 147

To assert that these protocols are compatible, the following verification is performed in FDR.

PROT_LBCFDREN = PROT_LBCFD [[ofd.in&amp;lt;- ifd.out,
ofd.out&amp;lt;- ifd.in]]

PROT_LBCDTREN = PROT_LBCDT [[odt.in&amp;lt;- idt.out,
odt.out&amp;lt;- idt.in]]

assert DPROT_CMMFD [F= PROT_LBCFDREN
assert DPROT_CMMDT [F= PROT_LBCDTREN

We assert they are I/O confluent, using the following verification

assert InBufferProt(PROT_SV, sv) :[deterministic [F]]
assert InBufferProt(PROT_CL, cl) :[deterministic [F]]
assert InBufferProt(PROT_CMMFD, ifd) :[deterministic [F]]
assert InBufferProt(PROT_CMMDT, idt) :[deterministic [F]]
assert InBufferProt(PROT_LBCFD, ofd) :[deterministic [F]]
assert InBufferProt(PROT_LBCDT, odt) :[deterministic [F]]

Finally, we assert they satisfy FOP by the assertions.

assert PROT_CMMFD \ {|ifd.out |} :[divergence free [FD]]
assert PROT_CMMDT \ {|idt.out |} :[divergence free [FD]]
assert PROT_LBCFD \ {|ofd.out |} :[divergence free [FD]]
assert PROT_LBCDT \ {|odt.out |} :[divergence free [FD]]

This concludes the translation of this example into CSPM , and its verification in FDR.



Bibliography

[AAG+07] E. Almeida, A. Alvaro, V. Garcia, J. Mascena, V. Burégio, L. Nascimento, D. Lu-
crédio, and S. Meira. C.R.U.I.S.E: Component Reuse in Sofware Engineering.
C.E.S.A.R. e-books, 2007.

[AB03] A. Aldini and M. Bernardo. A general approach to deadlock freedom verifica-
tion for software architectures. In International Symposium of Formal Methods
Europe, volume 2805 of Lecture Notes in Computer Science, pages 658–677.
Springer, 2003.

[ABB+01] C. Atkinson, J. Bayer, C. Bunse, E. Kamsties, O. Laitenberger, R. Laqua,
D. Muthig, B. Paech, J. Wüst, and J. Zettel. Component-Based Product Line
Engineering With UML. Addison Wesley, 2001.

[ACN02] J. Aldrich, C. Chambers, and D. Notkin. Archjava: connecting software architec-
ture to implementation. In International Conference on Software Engineering.
ACM Press, 2002.

[ADG98] R. Allen, R. Douence, and D. Garlan. Specifying and analyzing dynamic soft-
ware architectures. In Conference on Fundamental Approaches to Software En-
gineering (FASE), Lisbon, Portugal, March 1998.

[AG97] R. Allen and D. Garlan. A formal basis for architectural connection. ACM
Transactions on Software Engineering and Methodology, 6(3):213 – 249, July
1997.

[AINT07] M. Autili, P. Inverardi, A. Navarra, and M. Tivoli. SYNTHESIS: a tool for
automatically assembling correct and distributed Component–Based systems. In
29th International Conference on Software Engineering, pages 784–787. IEEE
Computer Society, 2007.

[AM02] F. Arbab and F. Mavaddat. Coordination through channel composition. In In-
ternational Conference on Coordination Models and Languages, pages 22–39.
Springer-Verlag, 2002.

[Arb04] F. Arbab. Reo: a channel-based coordination model for component composition.
Mathematical. Structures in Computer Science, 14(3):329–366, 2004.

[Arb06] F. Arbab. Coordination for component composition. Electronic Notes in Theo-
retical Computer Science, 160:15–40, 2006.

148



BIBLIOGRAPHY 149

[Bae05] J.C.M. Baeten. A brief history of process algebra. Theoretical Computer Sci-
ence, 335(2-3):131–146, 2005.

[BB04] M. Barbosa and L. Barbosa. Specifying software connectors. In 1st International
Colloquim on Theoretical Aspects of Computing, pages 53–68. Springer, 2004.

[BBB+00] F. Bachmann, L. Bass, C. Buhman, S. Comella-Dorda, F. Long, J. Robert,
R. Seacord, and K. Wallnau. Volume ii: Technical concepts of component-based
software engineering, 2nd edition. Technical Report CMU/SEI-2000-TR-008,
Software Engineering Institute, Carnegie Mellon University, 2000.

[BBT01] A. Bracciali, A. Brogi, and F. Turini. Coordinating interaction patterns. In ACM
Symposium on Applied Computing, pages 159–165. ACM, 2001.

[BCD02] M. Bernardo, P. Ciancarini, and L. Donatiello. Architecting families of software
systems with process algebras. ACM Transactions on Software Engineering and
Methodology, 11(4):386–426, 2002.

[BCK03] L. Bass, P. Clements, and R. Kazman. Software Architecture in Practice.
Addison-Wesley Longman, Reading, MA, 2nd edition, 2003.

[BCL+06] E. Bruneton, T. Coupaye, M. Leclercq, V. Quéma, and J.B. Stefani. The FRAC-
TAL component model and its support in Java. Software: Practice and Experi-
ence, 36(11-12):1257–1284, 2006.

[BCP06] A. Brogi, C. Canal, and E. Pimentel. Component adaptation through flexible
subservicing. Science of Computer Programming, 63(1):39–56, 2006.

[BDH+98] M. Broy, A. Deimel, J. Henn, K. Koskimies, F. Plasil, G. Pomberger, W. Pree,
M. Stal, and C. Szyperski. What characterizes a (software) component. Software
Concepts &amp;amp; Tools, 19(1):49–56, 1998.

[BGL+08] A. Basu, M. Gallien, C. Lesire, T.-H. Nguyen, S. Bensalem, F. Ingrand, and
J. Sifakis. Incremental component-based construction and verification of a
robotic system. In 18th European Conference on Artificial Intelligence, vol-
ume 178 of Frontiers in Artificial Intelligence and Applications, pages 631–635.
IOS Press, 2008.

[BHB+03] G. Beneken, U. Hammerschall, M. Broy, M. Cengarle, J. Jurjens, B. Rumpe, and
M. Schoenmakers. Componentware - state of the art. In Background Paper For
the Understanding Components Workshop of the CUE Initiative, 2003.

[BHP06] T. Bures, P. Hnetynka, and F. Plasil. SOFA 2.0: Balancing Advanced Features
in a Hierarchical Component Model. In 4th International Conference on Soft-
ware Engineering Research, Management and Applications, pages 40–48. IEEE,
2006.



BIBLIOGRAPHY 150

[BLL09] D. Bosnacki, S. Leue, and A. Lluch-Lafuente. Partial-order reduction for general
state exploring algorithms. STTT, 11(1):39–51, 2009.

[BRSV99] K. Bergner, A. Rausch, M. Sihling, and A. Vilbig. Componentware - method-
ology and process. In International Workshop on Component-Based Software
Engineering. IEEE, 1999.

[CCH+09] E. Cheung, X. Chen, H. Hsieh, A. Davare, A. Sangiovanni-Vincentelli, and
Y. Watanabe. Runtime deadlock analysis for system level design. Design Au-
tomation for Embedded Systems, 13(4):287–310, 2009.

[CD01] J. Cheesman and J. Daniels. UML Components, A Simple Process for Specifying
Component-Based Systems. Addison-Wesley, 2001.

[Cha85] D.M. Chapiro. Globally-asynchronous locally-synchronous systems (perfor-
mance, reliability, digital). PhD thesis, Stanford University Stanford, CA, USA,
1985.

[Chi09] Z. Chi. Components Composition Compatibility Checking Based on Behavior
Description and Roles Division. In International Conference on Management of
e-Commerce and e-Government, pages 262–265. IEEE, 2009.

[CHLZ07] X. Chen, J. He, Z. Liu, and N. Zhan. A model of Component-Based program-
ming. In International Symposium on Fundamentals of Software Engineering,
volume 4767 of Lecture Notes in Computer Science, pages 191–206. Springer,
2007.

[CK96] S. Cheung and J. Kramer. Context constraints for compositional reachabil-
ity analysis. ACM Transactions on Software Engineering and Methodology,
5(4):334–377, 1996.

[CM84] K. Chandy and J. Misra. The drinking philosophers problem. ACM Transactions
on Programming Languages and Systems, 6:632–646, 1984.

[CZ07] D.C. Craig and WM Zuberek. Compatibility of software components-modeling
and verification. In International Conference on Dependability of Computer
Systems, pages 11–18. IEEE, 2007.

[DK06] L. DeMichiel and M. Keith. Enterprise javabeans specification, version 3.0.
Technical Report JSR 220, Sun Microsystems, 2006.

[DR02] MS Dias and DJ Richardson. Identifying cause and effect relations between
events in concurrent event-based components. In 17th IEEE International Con-
ference on Automated Software Engineering, pages 245–248. IEEE, 2002.

[DW98] D. D’Souza and A. Wills. Objects, Components and Frameworks With UML:
The Catalysis Approach. Addison-Wesley, 1998.



BIBLIOGRAPHY 151

[DZZL10] J. Ding, H. Zhu, H. Zhu, and Q. Li. Formal Modeling and Verifications of Dead-
lock Prevention Solutions in Web Service Oriented System. In 2010 17th IEEE
International Conference and Workshops on Engineering of Computer-Based
Systems, pages 335–343. IEEE, 2010.

[FG03] A. Farias and Y. Guéhéneuc. On the coherence of component protocols. Elec-
tronic Notes Theoretical Computer Science, 82(5):42–53, 2003.

[FLF01] R.B. Findler, M. Latendresse, and M. Felleisen. Behavioral contracts and behav-
ioral subtyping. ACM SIGSOFT Software Engineering Notes, 26(5):229–236,
2001.

[For10] Formal-Systems. Failures-Divergence Refinement: FDR2 User Manual. Tech-
nical report, Formal Systems (Europe) and Oxford University Computing Labo-
ratory, 2010.

[GGMC+06] G. Gößler, S. Graf, M. Majster-Cederbaum, M. Martens, and J. Sifakis. Ensuring
properties of interaction systems. In Theory and Practice on Program Analysis
and Compilation, volume 4444 of Lecture Notes in Computer Science, pages
201–224. Springer, 2006.

[GGMC+07] G. Gößler, S. Graf, M. Majster-Cederbaum, M. Martens, and J. Sifakis. An
approach to modelling and verification of component based systems. In Current
Trends in Theory and Practice of Computer Science, volume 4362 of Lecture
Notes in Computer Science, pages 295–308. Springer, 2007.

[GMW00] D. Garlan, R. Monroe, and D. Wile. ACME: Architecture Description of
Composed-Based Systems. In Foundations of Component-Based Systems, pages
47–68. Cambridge University Press, 2000.

[Har87] D. Harel. Statecharts: A visual formalism for complex systems. Science of
Computer Programming, 8:231–274, 1987.

[HGK+06] M. Hepner, R. Gamble, M. Kelkar, L. Davis, and D. Flagg. Patterns of conflict
among software components. The Journal of Systems &amp;amp; Software, 79(4):537–
551, 2006.

[HH10] J. He. and C. Hoare. CSP is a retract of CCS. Theoretical Computer Science,
411(11-13):1311–1337, 2010.

[HJK10] R. Hennicker, S. Janisch, and A. Knapp. On the observable behaviour of com-
posite components. Electronic Notes in Theoretical Computer Science, 260:125–
153, 2010.

[HLL06a] J. He, X. Li, and Z. Liu. rCOS: a refinement calculus of object systems. Theo-
retical Computer Science, 365(1-2):109–142, 2006.



BIBLIOGRAPHY 152

[HLL06b] J. He, X. Li, and Z. Liu. A theory of reactive components. Electronic Notes in
Theoretical Computer Science, 160:173–195, 2006.

[Hoa85] C. Hoare. Communicating Sequential Processes. Prentice-Hall, 1985.

[Hoa06] C. Hoare. Why ever CSP? Electr. Notes Theor. Comput. Sci., 162:141–146,
2006.

[IM08] J. Ivers and G. Moreno. PACC starter kit: developing software with predictable
behavior. In ICSE Companion, pages 949–950. ACM, 2008.

[Kwi07] X.W.M. Kwiatkowska. Compositional state space reduction using untangled
actions. In 13th International Workshop on Expressiveness in Concurrency, vol-
ume 175 of Electronic Notes in Theoretical Computer Science, pages 27–46,
2007.

[LD00] Gary Leavens and Krishna Dhara. Concepts of behavioral subtyping and a sketch
of their extension to Component-Based systems. In Foundations of Component-
Based Systems, pages 113–135. Cambridge University Press, 2000.

[Lev95] N. Leveson. Safeware: System Safety and Computers. Addison-Wesley, 1995.

[Lil03] J. Lillieskold. Coordinating dependencies in complex system development
projects. In Engineering Management Conference, pages 400–404, 2003.

[LMC10] C. Lambertz and M. Majster-Cederbaum. Port protocols for deadlock-freedom
of component systems. In 3rd Interaction and Concurrency Experience: Guar-
anteed Interaction, volume 38 of Electronic Proceedings in Theoretical Com-
puter Science, pages 7–11, 2010.

[LW94] B. Liskov and J. Wing. A behavioral notion of subtyping. ACM Transactions on
Programming Languages and Systems, 16(6):1811–1841, 1994.

[Mah90] M. Mahoney. The roots of software engineering. CWI Quarterly, 3(4):325–334,
1990.

[MB05] S. Matougui and A. Beugnard. How to Implement Software Connectors? A
Reusable, Abstract and Adaptable Connector. In IFIP WG 6.1 International
Conference in Distributed Applications and Interoperable Systems, volume 3543
of Lecture Notes in Computer Science, pages 83–94. Springer, 2005.

[MC94] T. Malone and K. Crowston. The interdisciplinary study of coordination. ACM
Computing Surveys, 26:87–120, 1994.

[McI68] D. McIlroy. Mass-produced software components. In Software Engineering,
NATO Science Committe report, pages 138–155, 1968.



BIBLIOGRAPHY 153

[MCM07] M. Majster-Cederbaum and M. Martens. Robustness in interaction systems. In
27th International Conference on Formal Methods for Networked and Distrib-
uted Systems, volume 4574 of Lecture Notes of Computer Science, pages 325–
340. Springer, 2007.

[MCM08] M Majster-Cederbaum and M. Martens. Compositional analysis of deadlock-
freedom for tree-like component architectures. In 8th ACM international con-
ference on Embedded software, pages 199–206. ACM, 2008.

[MCMM07] M. Majster-Cederbaum, M. Martens, and C. Minnameier. A polynomial-time
checkable sufficient condition for deadlock-freedom of component-based sys-
tems. SOFSEM 2007: Theory and Practice of Computer Science, pages 888–
899, 2007.

[MCMM08] M. Majster-Cederbaum, M. Martens, and C. Minnameier. Liveness in Interaction
Systems. Electronic Notes in Theoretical Computer Science, 215:57–74, 2008.

[Mey92] B. Meyer. Applying “Design By Contract”. Computer, 25(10):40–51, 1992.

[Mey97] B. Meyer. Object-Oriented Software Construction. Prentice-Hall International,
2nd edition, 1997.

[MH05] P. Merson and S. Hissam. Predictability by construction. In 20th Annual ACM
SIGPLAN Conference on Object-Oriented Programming, Systems, Languages,
and Applications, pages 134–135. ACM, 2005.

[Mic11] Microsoft Developer Network. Component object model technologies. Techni-
cal report, http://www.microsoft.com/com, 2011.

[Mil80] R. Milner. A Calculus of Communicating Systems, volume 92 of Lecture Notes
in Computer Science. Springer, 1980.

[Mil89] R. Milner. Communication and Concurrency. Prentice-Hall, 1989.

[Min07] C. Minnameier. Local and global deadlock-detection in component-based sys-
tems are NP-hard. Information Processing Letters, 103(3):105–111, 2007.

[MJG+10] A. Mota, J. Jesus, A. Gomes, F. Ferri, and E. Watanabe. Evolving a Safe System
Design Iteratively. In 29th International Conference Computer Safety, Relia-
bility, and Security, volume 6351 of Lecture Notes in Computer Science, pages
361–374. Springer, 2010.

[MK96] J. Magee and J. Kramer. Dynamic structures in software architecture. In 4th Sym-
posium On the Foundations of Software Engineering, pages 3–14. ACM Press,
1996.



BIBLIOGRAPHY 154

[MMP00] N. Mehta, N. Medvidovic, and S. Phadke. Towards a taxonomy of software
connectors. In International Conference on Software Engineering, pages 178–
187. ACM Press, 2000.

[MORW04] M. Möller, E.-R. Olderog, H. Rasch, and H. Wehrheim. Linking CSP-OZ With
UML and Java: A Case Study. In Eerke A Boiten, John Derrick, and Graeme
Smith, editors, 4th International Conference on Integrated Formal Methods, vol-
ume 2999 of LNCS, pages 267–286. Springer, 2004.

[MT00] N. Medvidovic and R. Taylor. A classification and comparison framework for
software architecture description languages. Transactions on Software Engineer-
ing, 26(1):70–93, 2000.

[MW97] J.M.R. Martin and P.H. Welch. A design strategy for deadlock-free concurrent
systems. Transputer Communications, 3(4):215–232, 1997.

[Nie93] O. Nierstrasz. Regular types for active objects. ACM Sigplan Notices, 28(10):1–
15, 1993.

[NR69] P. Naur and B. Randell, editors. Software Engineering Techniques: Report on
a Conference sponsored by the NATO Science Committee. Brussels: Scientific
Affairs Division, Rome, Italy, 1969.

[Obj07] Object Management Group. Unified Modeling Language, Superstructure,
V2.1.2. Technical Report formal/2007-11-02, OMG, 2007. OMG Adopted Spec-
ification.

[Obj08] Object Management Group. Common Object Request Broker Architecture
(CORBA) Specification. Technical Report Version 3.1, OMG, 2008.

[PA98] G. Papadopoulos and F. Arbab. Coordination models and languages. Advances
in Computers - The Engineering of Large Systems, 46:330–401, 1998.

[Pla05] F. Plasil. Enhancing component specification by behavior description: the SOFA
experience. In 4th international symposium on Information and communication
technologies, page 190. Trinity College Dublin, 2005.

[PV02] F. Plasil and S. Visnovsky. Behavior protocols for software components. IEEE
Transactions on Software Engineering, 28(11):1056–1076, 2002.

[RG02] M. Richters and M. Gogolla. OCL: Syntax, semantics, and tools. In Object
Modeling With the OCL: The Rationale Behind the Object Constraint Language,
volume 2263 of LNCS, pages 42–68. Springer, 2002.

[RM04] R. Roshandel and N. Medvidovic. Multi-View software component modeling for
dependability. In Architecting Dependable Systems II, volume 3069 of Lecture
Notes in Computer Science. Springer, 2004.



BIBLIOGRAPHY 155

[Ros98] A. W Roscoe. Theory and Practice of Concurrency. Prentice-Hall Series in
Computer Science. Prentice-Hall, 1998.

[Ros05a] A. Roscoe. On the expressiveness of CSP refinement. Formal Aspects of Com-
puting, 17(2):93–112, 2005.

[Ros05b] A. W. Roscoe. The pursuit of buffer tolerance. Technical report, Oxford Univer-
sity, May 2005.

[Ros06] A. W. Roscoe. Confluence thanks to extensional determinism. Electronic Notes
in Theoretical Computer Science, 162:305–309, 2006.

[Ros10] A. W. Roscoe. CSP is expressive enough for ? . Reflections on the Work of CAR
Hoare, pages 371–404, 2010.

[RRMP08] Andreas Rausch, Ralf Reussner, Raffaela Mirandola, and Frantisek Plasil, edi-
tors. The Common Component Modeling Example: Comparing Software Com-
ponent Models, volume 5153 of Lecture Notes in Computer Science. Springer,
2008.

[RS01] P. Ryana and S. Schneider. Process algebra and non-interference. Journal of
Computer Security, 9(1):75–103, 2001.

[RSM05] R. Ramos, A. Sampaio, and A. Mota. A semantics for UML-RT active classes via
mapping into circus. In 7th IFIP International Conference on Formal Methods
for Open Object-based Distributed Systems, volume 3535 of Lecture Notes in
Computer Science, pages 99–114. Springer, 2005.

[RSM06] R. Ramos, A. Sampaio, and A. Mota. Transformation laws for UML-RT. In
8th IFIP International Conference on Formal Methods for Open Object-Based
Distributed Systems, volume 4037 of Lecture Notes in Computer Science, pages
123–138. Springer, 2006.

[RSM08] R. Ramos, A. Sampaio, and A. Mota. Framework composition conformance via
refinement checking. In ACM Symposium on Applied computing, pages 119–
125. ACM, 2008.

[RSM09] R. Ramos, A. Sampaio, and A. Mota. Systematic development of trustworthy
component systems. In 2nd World Congress on Formal Methods, volume 5850
of Lecture Notes in Computer Science, pages 140–156. Springer, 2009.

[RSM10] R. Ramos, A. Sampaio, and A. Mota. Conformance notions for the coordination
of interaction components. Science of Computer Programming, 75(5):350–373,
2010.

[SC97] M. Shaw and P. Clements. A field guide to boxology: Preliminary classification
of architectural styles for software systems. In Internationall Computer Software
and Applications Conference, pages 6–13, August 1997.



BIBLIOGRAPHY 156

[SDS01] Z. Stojanovic, A. Dahanayake, and H. Sol. An integrated component-oriented
framework for effective and flexible enterprise distributed systems development.
In International Conference on Enterprise Information Systems, pages 667–672,
2001.

[SG96] M. Shaw and D. Garlan. Software Architecture - Perspectives On an Emerging
Discipline. Prentice Hall, 1996.

[SGW94] B. Selic, G. Gullekson, and P. Ward. Real-Time Object-Oriented Modeling. John
Wiley &amp;amp; Sons, Inc., 1994.

[Sha95] M. Shaw. Abstractions for software architecture and tools to support them. IEEE
Transactions on Software Engineering, 21:314–335, 1995.

[Sif10] J. Sifakis. Component-Based Construction of Heterogeneous Real-Time Sys-
tems in Bip. The Future of Software Engineering, page 150, 2010.

[Spi04] B. Spitznagel. Compositional Transformation of Software Connectors. PhD
thesis, Carnegie Mellon University, 2004. Number: CMU-CS-04-128.

[SR98] B. Selic and J. Rumbaugh. Using UML for modeling complex RealTime sys-
tems. Technical report, Rational Software Corporation, 1998.

[SW03] D. Sangiorgi and D. Walker. The ? -calculus: A theory of mobile processes.
Cambridge University Press, 2003.

[SWC02] A. Sampaio, J. Woodcock, and A. Cavalcanti. Refinement in Circus. In Inter-
national Symposium of Formal Methods Europe, volume 2391 of LNCS, pages
451–470. Springer, 2002.

[Szy02] C. Szyperski. Component Software: Beyond Object–Oriented Programming.
Addisonn-Wesley, 2002.

[VVR06] A. Vallecillo, V.T. Vasconcelos, and A. Ravara. Typing the behavior of soft-
ware components using session types. Fundamenta Informaticae, 73(4):583–
598, 2006.

[Wal03] Kurt C. Wallnau. Volume III: a technology for predictable assembly from cer-
tifiable components. Technical Report CMU/SEI-2003-TR-009, Software Engi-
neering Institute, Carnegie Mellon University, 2003.

[Weh00] H. Wehrheim. Specification of an automatic manufacturing system: A case study
in using integrated formal methods. In 3rd Internationsl Conference Funda-
mental Approaches to Software Engineering, volume 1783 of Lecture Notes in
Computer Science, pages 334–348. Springer, 2000.

[Weh03] H. Wehrheim. Behavioral subtyping relations for active objects. Formal Methods
in System Design, 23(2):143–170, 2003.



BIBLIOGRAPHY 157

[ZKL10] N. Zhan, E. Kang, and Z. Liu. Component publications and compositions. Uni-
fying Theories of Programming, pages 238–257, 2010.

[ZM10] H. Zeng and H. Miao. Deadlock Detection for Parallel Composition of Compo-
nents. Computer and Information Science, pages 23–34, 2010.

[ZW97] A. Zaremski and J. Wing. Specification matching of software components. ACM
Transactions On Software Engineering and Methodology (TOSEM), 6(4):333–
369, October 1997.


</field>
	</doc>
</add>