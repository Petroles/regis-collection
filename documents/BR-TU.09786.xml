<?xml version="1.0" encoding="utf-8"?>
<add>
	<doc>
		<field name="docid">BR-TU.09786</field>
		<field name="filename">14782_TESE%20Abner%20Correa%20Barros.pdf</field>
		<field name="filetype">PDF</field>
		<field name="text">^^Centro
de Informática
U • F ■ P • E
Pós-Graduação em Ciência da Computação
UMA METODOLOGIA PARA A DETERMINAÇÃO DA PRECISÃO NUMÉRICA NECESSÁRIA À IMPLEMENTAÇÃO DO ALGORITMO RTM
Abner Corrêa Barros
Tese de Doutorado
r

Universidade Federal de Pernambuco posgraduacao@cin.ufpe.br www.cin.ufpe.br/~posgraduacao
Abner Corrêa Barros
UMA METODOLOGIA PARA A DETERMINAÇÃO DA PRECISÃO NUMÉRICA NECESSÁRIA À IMPLEMENTAÇÃO DO ALGORITMO RTM
Trabalho apresentado ao Programa de Pós-graduação em Ciência da Computação do Centro de Informática da Universidade Federal de Pernambuco como requisito parcial para obtenção do grau de Doutor em Ciência da Computação.
Orientador: Dr. Manoel Eusebio de Lima Co-Orientador: Dr. Renato José de Sobral Cintra
Catalogação na fonte
Bibliotecária Jane Souto Maior, CRB4-571
Barros, Abner Corrêa
Uma metodologia para a determinação da precisão numérica necessária á implementação do algoritmo RTM / Abner Corrêa Barros. - Recife: O Autor, 2014.
233 p., fig., tab., gráf.
Orientador: Manoel Eusebio de Lima.
Tese (doutorado) - Universidade Federal de Pernambuco. CIn, Ciência da Computação, 2014.
Inclui referências e apêndice.
1.	Arquitetura de computadores. 2. Computação de alto desempenho. 3. Computação científica. I. Lima, Manoel Eusebio de (orientador). II. Título.
004.22
CDD (23. ed.)
MEI2014 - 136
Proía. Marcilia Andrade Campos
Centro de Informática / UFPE
Prof. Abel Guilhermino da Silva Filho Centro de Informática / UFPE
Prof. José Antonio Barbosa
Departamento de Geologia / UFPE
Prof. Paulo Sérgio Brandão Nascimento
Instituto Federal de Pennambuco
Prof. Ismael Humberto Ferreira dos Santos Centro de Pesquisa da Petrobras
Visto e permitida a impressão.
Recife, 14 de março de 2014.
Profa. Edna Natividade da Silva Barros
Coordenadora da Pós-Graduação em Ciência da Computação do Centro de Informática da Universidade Federal de Pernambuco.
Dedico este trabalho aos meus pais, à minha querida esposa, Rosangela, aos meus filhos Natalia, Gabriela, Yuri e Laysa, e ao meu netinho Ravi.
Agradecimentos
Ao meu querido filho Yuri, por sua inestimável ajuda na resolução das intermináveis séries de cálculos e avaliações dos experimentos e pelas longas e acaloradas discussões sobre os fenômenos físicos envolvidos na propagação da onda sísmica.
Ao meu amigo Ricardo de Bragança, um verdadeiro Doutor em Geofísica. Alguém que eu aprendi a respeitar e admirar por sua competência e espírito prestativo. Foram suas as primeiras orientações que me mostraram o rumo a seguir.
Ao meu orientador e amigo, Prof. Dr. Manoel Eusebio de Lima, por suas palavras de incentivo e apoio.
Ao meu coorientador, Prof. Dr. Renato Cintra, que tantas vezes conseguiu ver no meu trabalho algo que nem eu mesmo era capaz de ver.
Às minhas amigas Aline Timóteo e Flávia Merlin, companheiras de longas datas. Pelas críticas sempre tão construtivas e pelas palavras de incentivo ditas sempre em momentos tão oportunos.
Ao Centro de Informática da UFPE, que me concedeu a oportunidade de desenvolver minhas pesquisas e meu potencial em um ambiente tão vibrante e, ao mesmo tempo, tão acolhedor.
Ao Cenpes, à Petrobras e à Finep, pelo suporte financeiro através da bolsa de pesquisa e pelos recursos necessários à conclusão deste trabalho. .
No princípio criou Deus os céus e a terra, a terra porém era sem forma e vazia.
—GENESIS 1:1
Resumo
Nestes últimos anos, com o início da prospecção de petróleo em regioões com litolo-gias complexas, tem se observado um crescente interesse no uso do algoritmo Reverse Time Migration(RTM) como solução para o imageamento sísmico.
Devido ao seu elevado custo computacional, o algoritmo RTM exige o uso de sistemas computacionais de alto desempenho, os quais demandam investimentos elevados em infra-estrutura, o que normalmente representa também um aumento substancial no consumo de energia.
Neste cenário, o desenvolvimento de coprocessadores aritméticos de alto desempenho, implementados por meio dos Field Programmable Gate Arrays(FPGAs), passou a ser considerado uma alternativa viável no objetivo de aumentar o a capacidade de processamento de sistemas computacionais já existentes, com impactos positivos tanto nos investimentos em infra-estrutura quanto no consumo de energia.
Entretanto, o desenvolvimento destes coprocessadores normalmente exige um estudo prévio minucioso das características do algoritmo a ser implementado e do conjunto de dados a ser processado, a fim de determinar a precisão numérica mnima que deve ser empregada em sua implementação.
O objetivo deste trabalho foi desenvolver uma metodologia que permita identificar a precisão numérica mínima necessária à implementação do algoritmo RTM, baseado nos fenômenos físicos envolvidos na propagação da onda sísmica e nas litologias prováveis da região a ser imageada.
Para chegar a este objetivo foi desenvolvido um método analítico, capaz de predizer a atenuação esperada para as ondas sísmicas durante os processos de modelagem e migração presentes no algoritmo RTM. Esse método foi baseado em uma nova abordagem no tratamento da atenuação por espalhamento geométrico para modelos com múltiplas camadas, denominada de Raio Efetivo.
Como estudo de caso de validação dessa metodologia, foram feitas predições e analisados os resultados de imageamento de diversos modelos sintéticos propostos por um especialista em geologia, os quais eram formados apenas por camadas horizontais, planas e paralelas. Além desses modelos mais simples, foi também utilizado um modelo reconhecidamente complexo, conhecido como modelo de marmousi. Os resultados obtidos em todos os estudos se mostraram dentro de uma margem de segurança de 1 bit de precisão.
Abstract
In recent years, with the beginning of oil exploration in regions with complex lithologies, has observed an increasing interest in the use of the Reverse Time Migration (RTM) algorithm as solution for seismic imaging.
Due to its high computational cost, the algorithm emph RTM requires the use of high performance computing systems, which require high investments in infrastructure, which usually also represents a substantial increase in energy consumption.
In this scenario, the development of the high performance arithmetic co-processor, implemented using Field Programmable Gate Arrays (FPGAs), has been considered a viable alternative, in order to increase the the capacity of processing existent computational systems, with positive impacts both in investments in infrastructure and energy consumption.
However, the development of these coprocessors typically requires thorough previous study of the characteristics of the algorithm to be implemented and about of set of data to be processed in order to determine the minimum numerical precision that must be used in its implementation
The aim of this study was to develop a methodology that allows identify the minimum numerical precision necessary to implement the RTM algorithm, based on the physical phenomena involved in propagation of the seismic waves and the likely lithologies in the region to be imaged.
To reach this goal it was developed a analytical method, able to predict the expected attenuation for seismic waves during the processes of modeling and migration present in the algorithm emph RTM. This method was based on a new approach treatment of attenuation by geometrical spreading for models with multiple layers, called Effective Radius.
As a case study validating this methodology, predictions were made and analyzed the results of various synthetic models proposed by an expert in geology. These models are carecterized by having only horizontal layers, flat and parallel, in compatible dimension with the expected in the real physical medium. Besides these simple models we also used a complex known model, known as the Marmousi model. The results obtained in all studies were within a safety margin of 1 bit precision.
Keywords: High-performance computing. emph Field Programmable Gate Arrays. emph FPGA. Floating-point arithmetic. Fixed-point arithmetic. Reverse-Time Migration algorithm. RTM algorithm. Processing Seismic Data. Seismic imaging. Effective Radius.
Lista de Figuras
1.1	Ilustração das camadas em subsuperfície até a camada pré-sal................. 20
1.2	Vibrosis e Airgun - Fontes controladas de energia utilizadas no imageamento
sísmico .................................................................... 22
1.3	Ilustração do método sísmico de reflexão..................................... 22
1.4	Comparativo entre as arquiteturas GPU e CPU.................................. 24
1.5	Visão macro da arquitetura interna dos FPGAs................................. 25
1.6	Resultado do processamento sísmico utilizando o algoritmo PSTM em diversas
precisões numéricas......................................................... 27
1.7	Primeiros resultados publicados deste trabalho referentes ao efeito da precisão
numérica no processamento	sísmico utilizando o algoritmo RTM.............. 29
1.8	Etapas de processamento do ponto-flutuante................................... 32
1.9	Comparação entre as representações em ponto-fixo e ponto-flutuante........... 34
2.1	Medição do tempo de trânsito do pulso sísmico no algoritmo PSTM.............. 37
2.2	Propagação do pulso sísmico ................................................. 40
2.3	Princípio de funcionamento do algoritmo RTM ................................. 41
2.4	Comparativo do tempo de execução do algoritmo RTM ........................... 42
2.5	Distribuição dos valores utilizados para determinar o intervalo de valores e a
precisão do padrão de representação......................................... 44
2.6	Plataforma de processamento sísmico baseada em FPGAs......................... 45
2.7	SNR e UQI total medido em diversas precisões ................................ 48
2.8	SNR e UQI de transporte...................................................... 48
3.1	Representação do pulso sísmico modelado por meio da segunda derivada da
função gausiana ............................................................ 51
3.2	Amplitude do pulso sísmico introduzido em relação à velocidade do meio ...	52
3.3	Ondas compressionais (P) e ondas transversais (S)............................ 53
3.4	Ondas refletidas, compressionais RP e transversais RS, e refratadas, compressio-
nais TP e transversais TS .................................................. 54
3.5	Ilustração da aplicação do Princípio de Huygens à propagação da onda em
espaços isotrópicos......................................................... 56
3.6	Ilustração da forma de propagação	da onda sísmica em meio isotrópico........ 57
3.7	Exemplo de cálculo do raio efetivo	rE........................................ 60
3.8	Configuração do experimento 1................................................ 62
3.9	Atenuação por divergência cilíndrica no primeiro experimento de validação do
raio efetivo ............................................................... 63
3.10	Compensação da atenuação por divergência por meio da aplicação da Equação
3.28.................................................................... 63
3.11	Compensação da atenuação por divergência por meio da aplicação conjunta das
Equações 3.28 e 3.26.................................................... 64
3.12	Configuração do experimento 2.......................................... 64
3.13	Atenuação causada pela divergência cilíndrica em meio isotrópico com duas
camadas com velocidade de propagação de 1500 e 2500 m/s................. 65
3.14	Compensação da atenuação causada pela divergência cilíndrica em modelo com
duas camadas, sem a aplicação do raio efetivo........................... 65
3.15	Compensação da atenuação causada pela divergência cilíndrica em modelo com
duas camadas com a aplicação do raio efetivo............................ 66
3.16	Configuração do experimento 3.......................................... 67
3.17	Tentativa de compensação da atenuação causada pela divergência cilíndrica em
meio com três camadas utilizando o raio real............................ 67
3.18	Compensação efetiva da atenuação causada pela divergência cilíndrica em meio
com três camadas por meio da utilização do conceito do raio efetivo .... 68
3.19	Esquema gráfico	com o percurso da onda sísmica......................... 70
3.20	Esquema gráfico	para a demonstração do cálculo da atenuação efetiva.... 71
3.21	Esquema gráfico	para a demonstração do cálculo da atenuação efetiva ... 71
3.22	Algoritmo utilizado para a predição da menor amplitude das ondas sísmicas
refletidas.............................................................. 75
3.23	Identificação dos elementos gerados com a execução do algoritmo proposto. . .	76
4.1	Estrutura geológica dos modelos 1, 2, 3 e 4............................. 80
4.2	Estruturas geológicas do modelo 5 e do modelo de Marmousi............... 81
4.3	Resultados	obtidos	com o processamento	com o Modelo 1 .................. 82
4.4	Resultados	obtidos	com o processamento	com o Modelo 2................... 83
4.5	Resultados	obtidos	com o processamento	com o Modelo 3 .................. 84
4.6	Resultados	obtidos	com o processamento	com o Modelo 4 .................. 85
4.7	Resultados	obtidos	com o processamento	com o Modelo 5 .................. 86
4.8	Resultados	obtidos	com o processamento	com o Modelo de Marmousi ........ 87
4.9	Valores encontrados com a métrica UQI em comparação com o SNR para o
modelo 1 .............................................................. 88
4.10	Valores encontrados com a métrica UQI em comparação com o SNR para o
modelo 3 ............................................................... 88
4.11	Valores encontrados com a métrica UQI em comparação com o SNR para o
modelo 4 ............................................................... 89
4.12	Valores encontrados com a métrica UQI em comparação com o SNR para o
modelo 5 .............................................................. 89
4.13	Valores encontrados com a métrica UQI em comparação com o SNR para o
modelo de Marmousi.................................................... 90
4.14	Estruturado PE-Float Altera.......................................... 92
4.15	Estrutura interna utilizada na implementação do PE-Float............. 94
4.16	Estrutura	interna	do módulo Multiplica_2Bij.......................... 95
4.17	Estrutura	interna	do módulo Absi_Absj................................ 96
4.18	Estrutura	interna	do módulo Menos_Aij................................ 96
4.19	Estrutura	interna	do módulo Vel_Vel_Fat.............................. 97
4.20	Estrutura	interna	do módulo Núcleo Soma.............................. 97
4.21	Estrutura	interna	do módulo M16Soma.................................. 98
4.22	Estrutura	interna	do módulo M1Soma................................... 98
4.23	Estrutura	interna	do módulo M60...................................... 99
4.24	Estrutura	interna	do módulo Conversor. .............................. 99
4.25	Estrutura	interna	do módulo Comparador...............................100
4.26	Estrutura	interna	do módulo Multiplica_V2FAT_NS......................100
4.27	Estrutura	interna	do módulo Soma_MAij_V2FAT_NS.......................101
4.28	Estrutura interna dos módulos Multiplica_ABS_1 e Multiplica_ABS_2....101
4.29	Estrutura	interna	do módulo Soma_2Bij_NS.............................102
4.30	Estrutura	interna	do módulo que normaliza e	arredonda os resultados..102
4.31	Estrutura interna do núcleo de processamento 2D em ponto-fixo........103
A.1 Estrutura geológica do modelo 1........................................118
A.2 Imageamento de referência para o modelo 1 gerado no padrão de ponto-flutuante. 119
A.3	Imageamento do	modelo	1	obtido	com 22 bits	de precisão...............120
A.4	Imageamento do	modelo	1	obtido	com 20 bits	de precisão...............121
A.5	Imageamento do	modelo	1	obtido	com 18 bits	de precisão...............122
A.6	Imageamento do	modelo	1	obtido	com 16 bits	de precisão...............123
A.7	Imageamento do	modelo	1	obtido	com 14 bits	de precisão...............124
A.	8	Imageamento do	modelo	1	obtido	com 13 bits	de precisão...............125
B.	1 Estrutura geológica do modelo 2......................................128
B.2 Imageamento de referência para o modelo 2 gerado no padrão de ponto-flutuante. 129
B.3	Imageamento do	modelo	2	obtido	com 24 bits	de precisão...............130
B.4	Imageamento do	modelo	2	obtido	com 22 bits	de precisão...............131
B.5	Imageamento do	modelo	2	obtido	com 20 bits	de precisão...............132
B.6	Imageamento do	modelo	2	obtido	com 18 bits	de precisão...............133
B.7	Imageamento do	modelo	2	obtido	com 16 bits	de precisão...............134
B.8	Imageamento do	modelo	2	obtido	com 15 bits	de precisão...............135
B.9	Imageamento do	modelo	2	obtido	com 14 bits	de precisão...............136
C.6 Imageamento do modelo 3 obtido com	16 bits de precisão.............143
C.7 Imageamento do modelo 3 obtido com	16 bits de precisão.............144
C.8 Imageamento do modelo 3 obtido com	14 bits de precisão.............145
C.9 Imageamento do modelo 3 obtido com	13 bits de precisão.............146
C.10 Imageamento do modelo 3 obtido com	12 bits de precisão.............147
C.	11 Imageamento do modelo 3 obtido com	11 bits de precisão.............148
D.	1 Estrutura geológica do modelo 4.....................................150
D.2 Imageamento de referência para o modelo 4 gerado no padrão de ponto-flutuante. 151
D.3 Imageamento do modelo 3 obtido com	23 bits de precisão.............152
D.4 Imageamento do modelo 4 obtido com	21 bits de precisão.............153
D.5 Imageamento do modelo 4 obtido com	19 bits de precisão.............154
D.6 Imageamento do modelo 4 obtido com	18 bits de precisão.............155
D.7 Imageamento do modelo 4 obtido com	16 bits de precisão.............156
D.8 Imageamento do modelo 4 obtido com	14 bits de precisão.............157
D.9 Imageamento do modelo 4 obtido com	13 bits de precisão.............158
D.	10 Imageamento do modelo 4 obtido com	12 bits de precisão.............159
E.	1 Estrutura geológica do modelo 5.....................................162
E.2 Imageamento de referência para o modelo 5 gerado no padrão de ponto-flutuante. 163
E.3 Imageamento do modelo 5 obtido com	23 bits de precisão.............164
E.4 Imageamento do modelo 5 obtido com	21 bits de precisão.............165
E.5 Imageamento do modelo 5 obtido com	19 bits de precisão.............166
E.6 Imageamento do modelo 5 obtido com	18 bits de precisão.............167
E.7 Imageamento do modelo 5 obtido com	16 bits de precisão.............168
E.8 Imageamento do modelo 5 obtido com	14 bits de precisão.............169
E.9 Imageamento do modelo 5 obtido com	13 bits de precisão.............170
E.	10 Imageamento do modelo 5 obtido com	12 bits de precisão.............171
F.	1	Estrutura geológica do modelo de Marmousi............................174
F.2 Imageamento de referência para o modelo de Marmousi gerado no padrão de
ponto-flutuante......................................................175
F.3	Imageamento do modelo de Marmousi com 24 bits	de	precisão............176
F.4	Imageamento do modelo de Marmousi com 22 bits	de	precisão............177
F.5	Imageamento do modelo de Marmousi com 20 bits	de	precisão............178
1.1	Organização dos campos que formam a representação do padrão de ponto-flutuante204
1.2	Distribuição dos valores representáveis em ponto-flutuante..............209
1.3	Diferença na representação entre um significando com 3 e um com 5 bits. . .	.	210
1.4	Comparação entre valores representáveis com significandos com 5 e 3 bits.	.	.	211
1.5	Arredondamento em direção ao Zero.......................................211
1.6	Direção do arredondamento em direção ao+&lt;^..............................212
1.7	Direção do arredondamento em direção ao-&lt;*&gt;.............................212
1.8	Direção do arredondamento para o mais próximo ou par....................213
1.9	Exemplos de Arredondamento em direção ao +^: e ao-&lt;*&gt;...................213
1.10	Exemplo de Arredondamento para o mais próximo e em direção ao zero......213
1.11	Esquema para obtenção do LSB bit, do Guard bit e do Sticky bit..........214
1.12	Nova organização dos bits para simplificar a análise do processo de arredonda-
mento........................................................................ 214
1.13	Geração do novo significando por meio dos bits extraídos do significando original
e do Round bit obtido durante o processo de arredondamento....................215
1.14	Localização do valor relativo do número a ser arredondado por meio do Guard
Bit e do Sticky Bit...........................................................217
1.15	Exemplos de operações efetuadas em ponto-flutuante de base binária com valores
normalizados que geram valores	desnormalizados...............................219
1.16	Realinhamento do significando.................................................223
1.17	Representação esquemática da conversão de Op2 para o formato de ponto-
flutuante proposto. ......................................................... 224
1.18	Representação esquemática da conversão de Op3 para o formato de ponto-
flutuante proposto. ......................................................... 225
1.19	Representação esquemática da conversão de Op4 para o formato de ponto-
flutuante proposto. ......................................................... 225
1.20	Diagrama esquemático da operação de soma entre Op1 e Op2......................225
1.21	Representação do resultado da operação entre Op1 e Op2 no formato de ponto-
flutuante proposto. ......................................................... 226
1.22	Representação esquemática da operação de adição entre Op3	e	Op4...............226
1.23	Operação de normalização sobre resultado da adição de Op3	e	Op4...............227
1.24	Distribuição dos bits durante o processo de arredondamento....................227
1.25	Resultado do processo de arredondamento. .................................... 227
1.26	Fluxo de execução das operações de soma e subtração...........................228
1.27	Distribuição dos bits como resultado de uma operação de multiplicação entre
dois inteiros de tamanho n....................................................229
1.28	Fluxo de execução da operação de multiplicação.............................
1.29	Representação esquemática da conversão de Op1 para o formato de ponto-
flutuante proposto..........................................................
1.30	Representação esquemática da conversão de Op2 para o formato de ponto-
flutuante proposto..........................................................
1.31	Representação esquemática da conversão do resultado para o formato de ponto-
flutuante proposto..........................................................
229
230
230
231
Lista de Tabelas
2.1	Desempenho da implementação do algoritmo RTM............................... 42
4.1	Menor amplitude e precisões numéricas preditas para os modelos geológicos
avaliados ................................................................. 81
4.2	Comparação entre as precisões numéricas preditas e as encontradas ......... 90
1.1	Formatos de ponto-flutuante................................................207
1.2	Valores especiais e suas representações segundo o padrão IEEE 754 ........ 209
1.3	Definição do Round-Bit no arredondamento para mais próximo ou par..........218
1.4	Resultados esperados para operações de multiplicação dos elementos da linha
inicial pelos elementos da coluna inicial. ............................... 221
1.5	Resultados esperados para operações de divisão dos elementos da linha inicial
pelos elementos da coluna inicial..........................................222
1.6	Resultados esperados para operações de adição dos elementos da linha inicial
pelos elementos da coluna inicial..........................................222
1.7	Resultados esperados para operações de subtração dos elementos da linha inicial
pelos elementos da coluna inicial..........................................222
1.8	Formato de ponto-flutuante com 9 bits, formulado apenas para fins didáticos. . 224
Lista de Acrônimos
ASIC	Application Specific Integrated Circuit..................................35
CENPES	Centro de Pesquisa e Desenvolvimento da Petrobras........................91
CI	Circuito Integrado.......................................................35
CORDIC	Coordinate Rotation Digital Computer.....................................36
CPU	Central Processing Unit..................................................23
DSP	Digital Signal Processing................................................32
FPGA	Field Programmable Gate Array............................................23
FPU	Floating Point Unit......................................................32
GPGPU	General-Purpose Graphics Processing Unit.................................23
HDL	Hardware Description Language............................................26
MDF	Método das Diferenças Finitas............................................47
NaN	Not a Number.............................................................31
PE	Processing Element.......................................................91
PSPI	Phase Shift Plus Interpolation...........................................22
PSTM	Pre-stack Kirchhoff Time Migration.......................................22
RTM	Reverse Time Migration...................................................22
SNR	Signal to Noise Ratio....................................................45
UQI	Universal Quality Indice.................................................45
ULA	Unidade Lógica e Aritmética..............................................23
Sumário
1	Introdução	20
2	Trabalhos Relacionados	35
2.1	Processamento de dados sísmicos utilizando FPGAs........................ 35
2.2	Efeitos da precisão numérica no processamento de dados sísmicos......... 43
2.3	Precisão da modelagem da propagação da onda sísmica por meio dos operadores
de diferenças finitas................................................... 47
3	Determinação da precisão numérica mínima necessária à execução do algoritmo
RTM	49
3.1	Fatores que influenciam na amplitude da onda sísmica.................... 50
3.2	Efeito da fonte sísmica utilizada ...................................... 51
3.3	Efeito das dimensões e das características das camadas em subsuperfície ....	52
3.3.1	Efeitos refrativos e reflexivos.................................. 53
3.3.2	A divergência da frente de onda.................................. 56
3.4	Metodologia para a predição da amplitude das ondas sísmicas refletidas ....	59
3.4.1	Cálculo do Raio Efetivo para modelagem bidimensional............. 59
3.4.2	Experimentos de validação do cálculo do raio efetivo ............ 61
3.4.2.1	Primeiro Experimento.................................... 62
3.4.2.2	Segundo Experimento .................................... 64
3.4.2.3	Terceiro Experimento.................................... 66
3.4.3	Experimentos de validação da predição da atenuação devido à configura-
ção litológica................................................... 68
3.5	Desenvolvimento e validação	da metodologia.............................. 69
4	Estudo de Caso	79
4.1	Experimentos de validação da metodologia ............................... 79
4.1.1	Métrica de avaliação da qualidade das imagens geradas............ 88
4.1.2	Discussão dos resultados......................................... 90
4.2	Desenvolvimento do núcleo de processamento aritmético................... 91
4.3	Projeto dos núcleos de processamento baseados em aritmética de ponto-flutuante 92
4.3.1	Módulo Multiplica 2Bij .......................................... 94
4.3.2	Módulo Absi Absj ................................................ 95
4.3.3	Módulo Menos Aij ................................................ 96
4.3.4	Módulo Vel_Vel_Fat............................................... 96
4.3.5	Módulo Núcleo_Soma............................................... 97
4.3.6	Módulo Multiplica_V2FAT_NS...................................100
4.3.7	Módulo Soma_MAij_V2FAT_NS....................................101
4.3.8	Módulos Multiplica_ABS_1 e Multiplica_ABS_2..................101
4.3.9	Módulo Soma_2Bij_NS..........................................101
4.3.10	Módulo Normaliza e Arredonda ............................... 102
4.4	Projetos dos núcleos de processamento baseados em aritmética de ponto-fixo . 103
5	Conclusões e trabalhos futuros	105
5.1	Trabalhos futuros...................................................106
Referências	109
Apêndice	115
A	Imagens do Modelo 1	117
B Imagens do Modelo 2	127
C	Imagens do Modelo 3	137
D Imagens do Modelo 4	149
E Imagens do Modelo 5	161
F	Imagens do modelo de Marmousi	173
G Implementação do PE-ASM	181
H	Implementação do algoritmo de predição	189
I	Revisão sobre padrões de representação numérica	201
1.1	Notação de inteiros ............................................... 202
1.2	Notação de ponto-fixo ............................................. 202
1.3	Notação de ponto-flutuante..........................................203
1.4	O padrão IEEE754 .................................................. 203
1.4.1	Formato de representação dos dados ......................... 205
1.4.2	Representação de valores especiais ......................... 207
1.4.3	Arredondamento ............................................. 209
1.4.3.1	Modos de Arredondamento.............................211
1.4.3.2	Algoritmo do modo de arredondamento em direção ao zero . 216
1.4.3.3	Algoritmo do modo de arredondamento em direção ao + e ao
- Infinito ......................................... 216
I.4.3.4	Algoritmo do modo de arredondamento em direção ao mais próximo ou par ................................................. 216
1.4.4	Normalização ....................................................218
1.4.4.1	Algoritmo de Normalização...............................220
1.4.5	Operações aritméticas ......................................... 221
1.4.5.1	Operações de Soma e Subtração...........................223
1.4.5.2	Operação de Multiplicação ............................. 228
1
Com o início da prospecção de petróleo em regiões com estruturas geológicas mais complexas, tais como na camada pré-sal1, cresceu a importância de se imagear2 as camadas em subsuperfície com a maior precisão possível (SANTOS, 2012). A prospecção de petróleo em tais condições envolve riscos econômicos e ambientais altíssimos (NIEMEYER, 2011; SOARES, 2012). Uma perfuração infrutífera ou um desastre ambiental causado pela prospecção em local inadequado pode representar prejuízo de milhões de dólares. A Figura 1.1 ilustra de maneira simplificada as profundidades e a estrutura das camadas em subsuperfície até a camada pré-sal.
Ptetafoime porfíiia abaixo cn camada de sa! para extrair o óleo
5000 m
Essas reservas
estão localizadas | snlm 5 mil e 7 mil------
metros abaixo do nível do mar
— PROFUNDIDADE
2000 H!
7000 m
Ôleo es!á sob camada de str! que pode ter a1é £ mil metros de espessura
Figura 1.1: Ilustração das camadas em subsuperfície até a camada pré-sal(G1, 2009).
Por esse motivo as empresas têm investido cada vez mais em novas tecnologias que permitam obter o melhor conhecimento possível das litologias em subsuperfície antes de iniciar o processo de exploração do petróleo (PETROBRAS, 2013). Essa medida tanto minimiza os riscos de desastres quanto otimiza o processo de perfuração dos poços (SANTOS, 2012).
1A camada pré-sal são estruturas geológicas localizadas abaixo da camada de sal existente na crosta terrestre, a mais de 5000 metros abaixo do nível do mar (G1, 2009).
2Imagear neste contexto significa gerar imagens através do uso de instrumentos.
Grande parte desse conhecimento é adquirido por meio do imageamento sísmico3. É o imageamento sísmico que se permite identificar a localização e o volume das reservas dos hidrocarbonetos existentes em subsuperfície (SANTOS, 2012).
Atualmente uma das metodologias mais empregadas na geração do imageamento sísmico é o método sísmico de reflexão (SANTOS, 2012).
O método sísmico de reflexão utiliza princípios de sismologia para identificar e estimar as propriedades das camadas em subsuperfície. Todo o processo é baseado na análise das reflexões geradas pela passagem de ondas sísmicas artificiais através das interfaces das diversas camadas geológicas existentes. As ondas sísmicas utilizadas são geradas por meio de fontes controladas de energia tais como os explosivos e os Vibrosis4 para o imageamento a partir da superfície terra e os Airguns5 para o imageamento a partir da superfície da água (ROBERT E. SHERIFF, 1995). O objetivo em ambos os casos é a geração de uma onda acústica de baixa frequência e alta intensidade, capaz de excitar as camadas em subsuperfície. A Figura 1.2 traz uma ilustração do uso dos Vibrosis e dos Airguns.
A Figura 1.3 apresenta de maneira simplificada como ocorre a geração das ondas sísmicas artificiais e como as ondas refletidas são capturadas através dos hidrofones e geofones6.
Ao chegarem à superfície, as ondas sísmicas refletidas nas interfaces das diversas camadas geológicas apresentam amplitudes proporcionais ao contraste das impedâncias acústicas existentes nessas interfaces (ROBERT E. SHERIFF, 1995).
3Procedimento utilizado para imagear a subsuperfície a partir da análise dos efeitos da inserção de pulsos sísmicos artificiais.
4Vibrosis são caminhões especiais equipados com dispositivos capazes de introduzir vibrações de baixa frequência nas camadas em subsuperfície, servindo assim como fonte de energia sísmica controlada (DURHAM, 2007).
5Airgun ou canhões de ar comprimido para aplicação em sísmica são dispositivos rebocados por navios para atirar fortes rajadas de ar comprimido através da água a quilômetros de profundidade no mar. Estas ondas ao se chocarem com o fundo do mar refletem de volta informações sobre depósitos de petróleo e gás existentes na subsuperfície marinha (OCEANA, 2012).
6Hidrofones e geofones são de transdutores eletroacústicos utilizados para converter a pressão acústica gerada pelas ondas sísmicas em impulsos elétricos. Os geofones são utilizados para o registro das ondas que chegam à superfície da terra e os hidrofones para o registro das ondas que chegam à superfície do mar.
Dessa forma, ao estudar as amplitudes e outras características dessas ondas, é possível estimar as características litológicas das camadas em subsuperfície (SANTOS, 2012).
Figura 1.2: Na Figura à direita um Vibrosis (DURHAM, 2007) e a esquerda um Airgun (GROBE, 2007) - Fontes controladas de energia utilizadas no imageamento sísmico
Figura 1.3: Ilustração do método sísmico de reflexão (DOMINGOS, 2003)
O conjunto de procedimentos utilizados na conversão das ondas refletidas em imagens, dando origem ao imageamento sísmico, é conhecido como Migração Sísmica (BULCãO, 2004).
Apesar de existirem diversos algoritmos que podem ser empregados nesse processo, atualmente os mais utilizados são (SANTOS, 2012):
■	o algoritmo de Pre-stack Kirchhoff Time Migration (PSTM);
■	o algoritmo de Phase Shift Plus Interpolation (PSPI);
■	o algoritmo de Reverse Time Migration (RTM).
Desses três, o que tem apresentando melhores resultados em áreas com litologias mais complexas, tais como no pré-sal, é o algoritmo RTM (SANTOS, 2012).
Apesar de ter sido proposto e implementado há mais de três décadas (SANTOS, 2012; BAYSAL; KOSLOFF; SHERWOOD, 1983; MCMECHAN, 1983; WHITMORE, 1983), devido ao seu elevado custo computacional, o algoritmo RTM ficou por anos sem utilização mais intensa por parte da indústria de petróleo. Nesse período, a indústria dispunha de outros métodos e algoritmos, tal como o algoritmo PSTM, os quais permitiam o imageamento das camadas em subsuperfície com uma qualidade aceitável e a um custo computacional bem mais acessível (LIU et al., 2010).
Foi apenas mais recentemente, em razão do início da prospecção em áreas com estruturas geológicas mais complexas, que o algoritmo RTM passou a ser mais amplamente utilizado (LIU et al., 2010).
De modo geral, os algoritmos de imageamento sísmico sempre foram tidos como algoritmos de alto custo computacional. Mesmo o algoritmo PSTM, que tem um custo de execução por volta de 15 vezes menor que o algoritmo RTM (SANTOS, 2012), exige o uso de sistemas computacionais de alta performance para que possa ser executado com um desempenho aceitável (PANETTA et al., 2007). Por esse motivo, nestes últimos anos diversos trabalhos científicos têm proposto a implementação desses algoritmos em arquiteturas de processamento não convencionais, tais como nos General-Purpose Graphics Processing Unit (GPGPU) (LIU et al., 2010; GROSSER et al., 2011; KRUEGER et al., 2011; CLAPP; FU; LINDTJORN, 2010; ABREO et al., 2012) e nos Field Programmable Gate Array (FPGA) (NEMETH et al., 2008,?; FLYNN et al., 2008; FU et al., 2008, 2009; CLAPP; FU; LINDTJORN, 2010; PELL; CLAPP, 2007; JAMRO et al., 2008; KRUEGER et al., 2011; GROSSER et al., 2011; DIMOND; RACANIèRE; PELL, 2011; MEDEIROS et al., 2013; LINDTJORN et al., 2011; HE; LU; SUN, 2004; MENEZES et al., 2012; ABREO et al., 2012; BRAGANçA et al., 2013; PELL, 2010).
Em ambos os casos, o objetivo é explorar o paralelismo intrínseco existente nessa classe de algoritmos, buscando com isso obter ganhos tanto de desempenho quanto de consumo de energia (WU; LIU, 2008) .
Os GPGPUs são unidades de processamento de propósito geral construídas a partir de unidades de processamento gráfico conhecidas Graphic Processing Unit (GPU). Um GPU difere de um processador de propósito geral por ter uma estrutura interna especialmente desenvolvida para explorar o paralelismo intrínseco existente nos algoritmos de processamento gráfico.
Por esse motivo, diferentemente de um processador de propósito geral, mais conhecidos como Central Processing Unit (CPU), o qual tem uma única unidade de controle e uma única estrutura de memória cache conectada a um pequeno número de unidades lógicas e aritméticas Unidade Lógica e Aritmética (ULA)1, os processadores gráficos têm dezenas de pequenas
7A unidade lógica e aritmética é a estrutura onde são efetuadas todas as operações lógicas e aritméticas sobre as variáveis dos programas em execução. Atualmente os processadores de propósito geral dispõem de duas a quatro dessas unidades.
unidades de controle, cada uma com a própria memória cache, conectadas a dezenas e até centenas de unidades lógicas e aritméticas. São esses verdadeiros clusters8 de processamento, projetados especialmente para efetuar as operações lógicas e aritméticas necessárias ao processamento gráfico, que estão acessíveis através dos GPGPUs. A Figura 1.4 ilustra de maneira simplificada essas duas arquiteturas.
CPU	GPU
Controle	ULA	ULA
	ULA	ULA
Memória Cache		
] Unidade de Controle |	| Memória Cache |	| Unidade Lógica e Aritmética
Figura 1.4: Comparativo entre as arquiteturas GPU e CPU
Os FPGAs, por sua vez, são circuitos integrados projetados para terem suas funcionalidades definidas em campo, após o seu processo de fabricação, de acordo com a necessidade da sua aplicação. Por esse motivo os FPGAs são muitas vezes referidos como unidades hardware reconfigurável, uma vez que podem ser configurados para se tornarem virtualmente qualquer tipo de circuito ou sistema digital (FAROOQ; MARRAKCHI; MEHREZ, 2012).
Diferentemente dos demais circuitos integrados digitais, os quais já saem de fábrica com uma funcionalidade preestabelecida, a arquitetura interna dos FPGAs foi concebida de forma a permitir que eles possam ser configurados em campo para assumirem as características e as funcionalidades que deles se esperam. A configuração desses componentes é feita de maneira extremamente simples e eficaz, através da carga de um arquivo de configuração em uma área de memória de programação do componente. Dessa forma, um mesmo componente pode ser reconfigurado inúmeras vezes, podendo assim exercer mais de uma funcionalidade em um sistema computacional, de acordo com a necessidade da aplicação. Essa reconfiguração pode ser feita a qualquer momento, mesmo remotamente, inclusive depois que uma placa eletrônica já estiver instalada em campo.
A Figura 1.5 traz uma visão macro da arquitetura interna de um FPGA, em que se destacam os seguintes elementos:
■ Blocos de Entrada e Saída - estruturas que permitem configurar as características de cada terminal de entrada e saída, determinando deste o sentido de sua operação, se será entrada, saída ou ambas, sua funcionalidade e até a sua tensão de operação.
8O termo cluster, neste contexto, é utilizado no sentido de um agrupamento coordenado de unidades de processamento semelhantes ou equivalentes que podem ser utilizadas para um fim específico.
■	Blocos Lógicos - estruturas configuráveis que podem implementar qualquer função lógica atômica e outras funções lógicas de menor complexidade, tanto de lógica combinacional quanto de lógica sequencial.
■	Blocos de Memória RAM - elementos de memória estática que podem ser acessados em palavras de qualquer tamanho, podendo, dessa forma, ser utilizados tanto para formar estruturas de armazenamento mais simples, tais como registradores de um único bit, quanto estruturas de armazenamento mais complexas, tais como memórias cache associativas.
■	Rede de Interconexão - estrutura responsável pelo transporte dos sinais elétricos que os blocos lógicos trocam entre si, assim como os blocos de memória. Também são utilizados para a conexão dos blocos lógicos e memória com os blocos de entrada e saída.
■	Rede de Comutação - estruturas que permitem desviar os sinais elétricos de uma rede de interconexão para outra, interligando assim, virtualmente, todas as estruturas internas do FPGA.
Figura 1.5: Visão macro da arquitetura interna dos FPGAs
Interconexão ■ Comutação
Desse modo, diferentemente dos demais circuitos integrados existentes no mercado, um FPGA não é escolhido para um projeto por uma funcionalidade que possa oferecer, mas sim pelos recursos internos de que dispõe. Por isso, a fim de melhor destacar as características e os recursos existentes em seus componentes, os fabricantes dos FPGAs oferecem ao mercado diversas famílias de FPGAs, dedicadas às mais diversas áreas de aplicação.
As famílias dos FPGAs diferem entre si pelo tipo e pela quantidade de recursos de que dispõem. Por exemplo, algumas famílias de FPGAs dispõem de um número maior de elementos lógicos; outras de mais elementos de memória; outras de canais de comunicação ultrarrápidos; outras ainda de maior número de módulos aritméticos especializados.
Diferentemente da metodologia de desenvolvimento normalmente empregada em sistemas baseados em CPUs e GPGPUs, a qual consiste basicamente na implementação de algoritmos por meio do uso de linguagens de programação, ou seja, desenvolvimento de software, nos sistemas baseados em FPGAs, os algoritmos devem ser descritos e implementados de tal forma que possam ser transformados em um componente de hardware.
Nos projetos para FPGAs, em vez de uma linguagem de programação, normalmente se utiliza uma linguagem de descrição de hardware ou diretamente de um diagrama esquemático baseado em portas lógicas. Em seguida, na etapa de compilação do algoritmo, em vez de o compilador gerar um arquivo executável, este transforma a descrição do algoritmo em um arquivo de configuração para o FPGA adotado.
É importante destacar que a eficiência dos sistemas assim implementados estará diretamente ligada à forma do mapeamento do algoritmo nos recursos disponíveis no FPGA utilizado. Por exemplo, a implementação de módulos aritméticos será muito mais eficiente em FPGAs que já dispõem de operadores aritméticos como um recurso interno do que naqueles em que esses operadores tenham de ser implementados mediante o uso de portas lógicas.
Por outro lado, quanto maior a quantidade de recursos disponíveis em um determinado FPGA, maior será o seu custo. Ou seja, a escolha do FPGA para um determinado projeto será função do algoritmo a ser implementado, do desempenho que se espera dele e do montante de recursos financeiros disponíveis para a implementação do projeto.
Mais especificamente com relação ao uso dos FPGAs em processamento de dados sísmicos, diversos trabalhos publicados nestes últimos anos têm buscado destacar as vantagens, tanto do ponto de vista de desempenho quanto do consumo de energia, da adoção de um padrão de representação numérico diferente do padrão de ponto-flutuante conforme definido no padrão IEEE754 (FU et al., 2008, 2009; GROSSER et al., 2011; GOVINDU et al., 2004; ABREO et al., 2012; BARROS et al., 2011; BRAGANçA et al., 2013; MEDEIROS et al., 2013).
A preferência pela adoção de um padrão numérico não convencional em projetos com FPGAs deve-se ao fato de a grande maioria dos FPGAs, atualmente comercializados, não dispor nativamente de unidades aritméticas de ponto-flutuante, o que exige que essas unidades sejam implementadas diretamente em um por meio de uma Hardware Description Language (HDL) ou a partir de bibliotecas fornecidas pelos fabricantes dos FPGA, ou ainda por empresas especializadas. No entanto, pela complexidade das operações de ponto-flutuante, a utilização desses módulos pode ter um impacto muito negativo no desempenho do sistema.
Por outro lado, alguns trabalhos indicam também que, tratando-se da modelagem sísmica, uma mudança no padrão de representação numérica pode ter um impacto na qualidade das imagens geradas (BARROS et al., 2011; FU et al., 2009, 2008). Muitas vezes, uma diferença de
Figura 1.6: Resultado do processamento sísmico utilizando o algoritmo PSTM em diversas precisões numéricas (FU et al., 2009)
Reduced precision seismic image “True” image: single-precision floating-point
um ou dois bits na precisão numérica adotada é o suficiente para tornar os resultados obtidos impróprios para o uso a que se destinam.
Na Figura 1.6, temos os resultados de experimentos relatados em (FU et al., 2009) e que demonstram o quanto o núcleo de processamento aritmético do algoritmo PSTM é sensível à precisão numérica utilizada em sua implementação.
Como pode-se observar pelo gráfico apresentado nessa figura, a qualidade das imagens geradas com a aplicação do algoritmo PSTM está diretamente ligada à precisão numérica utilizada na implementação da operação de raiz quadrada (SQRT) existente em seu núcleo de processamento aritmético. Verifica-se por esse gráfico que a qualidade das imagens decai bruscamente quando esta operação é implementada com menos que 10 bits de precisão. Por outro lado, verifica-se também que não ocorrem melhoras significativas quando é utilizado mais que 10 bits de precisão. Dessa forma, os autores de (FU et al., 2009) concluem que o ideal é que esta operação seja efetuada com exatos 10 bits de precisão.
Em (BARROS et al., 2011), são apresentados os primeiros resultados obtidos ainda no início do trabalho que resultou nesta tese, no qual foram avaliados os efeitos da precisão numérica empregada na implementação do algoritmo RTM. A Figura 1.7 apresenta os resultados
ali obtidos. Como se pode observar pelo gráfico apresentado nessa figura, à semelhança do algoritmo PSTM, o algoritmo RTM também apresenta uma grande sensibilidade a variações do padrão de representação numérica adotado em sua implementação.
À semelhança do experimento conduzido em (FU et al., 2009), nesse trabalho também foi conduzido um experimento para averiguar a qualidade do imageamento sísmico gerado pelo algoritmo RTM para um modelo geológico de referência, o modelo de Marmousi9, (MARTIN; WILEY; MARFURT, 2006) em diversas precisões numéricas. A Figura 1.7 apresenta os resultados obtidos nesse experimento. O gráfico apresentado nessa figura registra o grau de semelhança medido entre as imagens geradas pela aplicação do algoritmo RTM em diversas precisões e uma imagem de referência gerada com o processamento sendo efetuado devido à não precisão numérica adotada. O grau de semelhança foi avaliado a partir do Universal Quality Index (UQI) (WANG; BOVIK, 2002). O UQI é uma métrica que procura avaliar o grau de semelhança entre duas imagens do ponto de vista de um observador humano. Por esse motivo, o grau de semelhança leva em conta não apenas os artefatos presentes nas imagens, mas também o seu brilho e contraste. Como pode-se observar pelo gráfico apresentado, diferentemente do que ocorreu com os resultados relatados em (FU et al., 2009), no algoritmo RTM, o grau de semelhança entre as imagens varia mais suavemente, de forma quase linearmente proporcional à precisão numérica adotada.
Conforme se pode observar por esses dois exemplos, a mudança do padrão de representação numérico na implementação de um algoritmo para o imageamento sísmico é algo que exige muito cuidado e atenção. Deve ser levado em conta que questões como a estabilidade dos resultados, a convergência do algoritmo e o grau de incerteza dos resultados obtidos estão diretamente ligados ao padrão numérico adotado.
Apesar da sua importância, esse é um tema pouco abordado tanto nos cursos de graduação quanto nas pesquisas científicas em nível de pós-graduação. Isso porque a representação dos números reais em praticamente todos os sistemas computacionais está baseada em um mesmo padrão numérico, o padrão IEEE 754 (P754, 1985). Esse padrão estabelece como devem ser representados e operados os números reais em sistemas computacionais. Em razão da forma como os números são representados nesse padrão, ele ficou conhecido como padrão de números em ponto-flutuante.
A adoção do padrão IEEE 754 representou um grande avanço para a computação científica em geral (SEVERANCE, 1998). Foi só a partir do seu estabelecimento que os desenvolvedores e cientistas mais ligados à computação científica puderam deixar de lado as questões mais ligadas à representação dos dados e passar a concentrar seus esforços apenas no desenvolvimento e na implementação dos algoritmos. Atualmente, a sua utilização está de tal forma difundida entre os profissionais da área que a grande maioria desconhece completamente tanto os detalhes de sua implementação quanto as suas limitações. Eles simplesmente o utilizam como
9O modelo de Marmousi é um modelo geológico sintético muito utilizado como modelo de referência para testes de validação para o imageamento sísmico.
Figura 1.7: Primeiros resultados publicados deste trabalho (BARROS et al., 2011) referentes ao efeito da precisão numérica no processamento sísmico utilizando o algoritmo RTM.
a representação dos números reais em sistemas computacionais (GOLDBERG, 1991).
De fato, pela forma como os dados são representados, esse padrão permite trabalhar com a falsa ideia de que é possível representar o contínuo, o infinito não enumerável, o qual é a própria essência dos números reais, nos sistemas computacionais. O que na verdade é impossível (GOLDBERG, 1991).
No padrão de ponto-flutuante, os valores são representados por convenção, através de uma estrutura muito semelhante à adotada na representação de números em notação científica, a qual é formada por três campos distintos, denominados:
■	Sinal: representa o sinal algébrico do valor representado.
■	Expoente: está associado à magnitude do valor representado.
■	Significando: representa o conjunto de dígitos significativos do número representado.
Esses três campos são armazenados na forma de uma única palavra binária, a qual é reconhecida como um valor numérico no padrão de ponto-flutuante. O valor numérico representado por essa palavra binária é dado pela seguinte equação:
V = (-1)8 * S* 2e
em que, V é o valor numérico representado, 8 representa o valor do campo sinal, S o conteúdo do campo significando e e o valor representado no campo expoente.
Ainda à semelhança da notação científica, no padrão de ponto-flutuante, o campo significando também é representado de maneira normalizada, ou seja, com apenas um dígito na sua parte inteira, sendo este diferente de zero.
O padrão IEEE 754 prevê ainda que valores muito pequenos, que não possam ser representados de maneira normalizada, sejam representados fora desse padrão, o que é conhecido como forma desnormalizada ou apenas números denormais. Nesse caso, a fim de indicar essa discrepância com o padrão de representação, atribui-se um valor diferenciado para o campo expoente.
Outro detalhe importante da representação no padrão de ponto-flutuante é o processo de mapeamento de cada um dos infinitos valores reais existentes em um dos valores por ele representáveis. Esse processo de mapeamento é denominado de arredondamento. É o processo de arredondamento que permite que todo e qualquer valor real, mesmo os números irracionais, possam ser representados. Existem quatro modos de arredondamento previstos no padrão IEEE 754, denominados de arredondamento para o mais próximo ou par, o arredondamento para mais infinito, o arredondamento para menos infinito e o arredondamento para zero.
É a interação do padrão de representação normalizado aliado à flutuação do ponto decimal, devido à interação do campo significando com o expoente e, por fim, o processo de
arredondamento, que permitem criar a falsa ideia de que é possível representar todo o conjunto dos números reais através dos sistemas computacionais. O Apêndice I traz um resumo das principais características e do princípio de funcionamento do padrão de ponto-flutuante conforme estabelecido pela norma IEEE 754.
Toda essa flexibilidade tem, entretanto, um alto custo de implementação em hardware.
Uma vez que no padrão de ponto-flutuante os dados passam a ser representados por convenção e não mais por meio da notação posicional, é necessário que exista um suporte em hardware especialmente desenvolvido para operar nesse padrão. Qualquer operação, por mais simples que seja, envolvendo dados no padrão de ponto-flutuante, exige a execução de diversas etapas de pré e pós-processamento. A Figura 1.8 traz de maneira simplificada todas essas etapas. O Apêndice I traz a operação dessas etapas de maneira mais detalhada.
Primeiramente é necessário que se faça o desempacotamento do dado, ou seja, é necessário que o valor armazenado seja recuperado.
Em seguida é necessário que se verifique se o valor armazenado é de fato um número ou se é uma codificação de exceção: Infinito, Not a Number (NaN) ou um número denormal.
Recuperado o valor armazenado, pode-se então efetuar a operação propriamente dita. Cada operação tem o seu próprio fluxo de execução. O Apêndice I traz alguns detalhes de implementação das operações de soma e multiplicação.
Feita a operação, o resultado obtido precisa ser arredondado e normalizado. O processo de arredondamento mapeia o valor obtido no valor representável mais próximo no formato de ponto-flutuante adotado. O processo de normalização ajusta o significando para o modo normalizado, compensando essa operação pela atribuição do valor do campo expoente.
Por fim, o resultado obtido depois do arredondamento e da normalização é verificado para identificar a ocorrência de exceções, tais como Infinito ou denormal. Caso tenha ocorrido alguma exceção, os valores atribuído aos campos expoente e fração do significando são ajustados para sinalizar a exceção identificada.
Figura 1.8: Etapas de processamento do ponto-flutuante.
Por esse motivo, a fim de permitir a implementação do tipo de dado de ponto-flutuante nas diversas linguagens de programação existentes, atualmente todos os processadores, incluindo os processadores de uso mais específico como os GPGPUs, os Digital Signal Processing (DSP) - e até mesmo os de menor porte como muitos microcontroladores, têm internamente uma unidade de processamento aritmético de ponto-flutuante, também conhecida como Floating Point Unit (FPU), que é responsável pelas operações em ponto-flutuante.
Vale salientar que o padrão IEEE 754 não é a única forma de representar os números reais em sistemas computacionais. Existem ainda inúmeros outros padrões de representação numéricos, tais como o padrão de números residuais, o padrão logaritmo e o padrão de ponto-fixo. Cada um com vantagens e desvantagens que os tornam especialmente indicados para determinados tipos de aplicações (FU, 2009).
Mais especificamente, tratando-se do processamento de dados sísmicos através dos FPGAs, depois de uma pesquisa exaustiva nos trabalhos científicos publicados nos últimos dez anos, realizada durante a fase investigativa deste trabalho, pôde-se constatar uma nítida preferência por parte dos diversos autores pela adoção do padrão de ponto-fixo em detrimento de todos os demais padrões.
Isso se explica pelo fato de ser esse o padrão de representação numérico com o menor custo de implementação em hardware. Todos os FPGAs têm internamente certo número de operadores aritméticos, o que permite o mapeamento dos algoritmos com módulos aritméticos diretamente em hardware.
Todos os demais padrões, incluindo o padrão de ponto-flutuante, exigem que módulos de hardware específicos sejam implementados, o que tem que ser feito lançando mão dos outros
recursos de lógica disponíveis nos FPGAs, o que muitas vezes limita o número de módulos que podem ser implementados, além de reduzir a sua frequência de operação. Com isso, o desempenho do sistema em sua totalidade pode ser comprometido.
Uma vez que o desempenho alcançado pelos sistemas baseados em FPGA está diretamente ligado ao grau de paralelismo e à frequência de trabalho dos módulos de hardware implementados, e considerando ainda que esses dois parâmetros dependem diretamente da quantidade de recursos do FPGA que esses módulos consomem para serem implementados, a opção por um padrão de representação numérico mais simples, como o padrão de ponto-fixo, pode significar um ganho de desempenho considerável (GUO et al., 2004).
Entretanto, se não for feita com muita cautela, a mudança do padrão de representação de ponto-flutuante para o padrão de ponto-fixo pode trazer sérias implicações para a qualidade dos resultados obtidos.
Diferentemente do padrão de ponto-flutuante, no qual o limite do erro de representação percentual independe do valor representado 10, no padrão de ponto-fixo, esse erro não tem um limite definido, estando, assim, diretamente ligado ao valor a ser representado11. A Figura 1.9 traz uma comparação entre as representações nos padrões de ponto-flutuante e de ponto-fixo, destacando o efeito da mudança automática de escala presente no padrão de ponto-flutuante no nível de erro de representação.
Em algoritmos de processamento de sinais, tal como ocorre no processamento de dados sísmicos, essa variação no nível de erro de representação, com r
10O erro percentual de representação no padrão de ponto-flutuante é sempre menor que 2-n, onde n é a quantidade de bits da fração do significando.
11O erro de representação percentual para um padrão de ponto-fixo com n bits de precisão, ou seja, com n bits reservados à representação da parte fracionária, será igual a , em que x é o valor representado.
Ponto-Fixo
Escala Constante
Erro de representação variável
Expoente =-4
J Lrepresentação constante
Mudança automática de escala com o intervalo de valores representados
Erro de
Ponto-Flutuante
1
Expoente =1
Expoente =-2
Figura 1.9: Comparação entre as representações em ponto-flutuante (A) e em ponto-fixo (B). Observa-se em (A) o efeito da mudança automática do expoente devido ao processo de normalização e à consequente mudança automática de escala. Em (B), verifica-se a perda de precisão à medida que a magnitude do valor representado diminui.
2
Trabalhos Relacionados
Neste capítulo é apresentada uma revisão dos principais trabalhos científicos relacionados com o tema da definição da precisão numérica necessária ao processamento de dados sísmicos em FPGAs.
Esses trabalhos são agrupados em três áreas distintas: Processamento de dados sísmicos utilizando FPGAs, onde são apresentadas implementações de plataformas de processamento de dados sísmicos baseados em FPGA; efeitos da precisão numérica no processamento de dados sísmicos, onde são discutidos trabalhos que tratam diretamente desta temática; e precisão da modelagem de propagação da onda sísmica por meio dos operadores de diferenças finitas, onde são apresentados trabalhos que avaliam quão fiéis ao modelo físico real são as implementações de algoritmos de processamento sísmico por meio de operadores de diferenças finitas.
2.1	Processamento de dados sísmicos utilizando FPGAs
O uso de coprocessadores de aplicação específica baseados nos FPGAs não é algo novo em computação de alto desempenho. Diversos trabalhos científicos destacam a sua utilização em áreas tão distintas na computação científica quanto bioinformática (YAMAGUCHI et al., 2013; DANDASS et al., 2008; CHEN et al., 2013), física (FROHLICH et al., 2002; LIU et al., 2008), análise financeira (SCHRYVER et al., 2011), microscopia eletrônica (GRULL et al., 2011) e processamento de dados sísmicos (MENCER; MORF; FLYNN, 1998; GOVINDU et al., 2004; HE; LU; SUN, 2004; HERBORDT et al., 2007; BARROS et al., 2008).
Tendo sido projetados inicialmente com o objetivo de servir como laboratório de proto-tipação para circuitos lógicos digitais, com o avanço da tecnologia, os FPGAs passaram a ser considerados uma alternativa viável para projetos em áreas de aplicação até então dominadas pelos Circuito Integrado (CI) tipo ASIC1, tais como o desenvolvimento de coprocessadores de aplicação específica.
1 Um Application Specific Integrated Circuit (ASIC) é um circuito integrado construído para executar uma tarefa específica tal como controlar uma interface de comunicação ou garantir a segurança de acesso a dados de um sistema.
Em tais aplicações, de modo a permitir o uso mais racional dos recursos disponíveis no FPGA, é comum substituir o padrão IEEE 754 (P754,1985), na representação dos números reais, por outro de menor precisão, tal como o padrão de ponto-fixo.
Tal estratégia é importante porque, para muitas dessas aplicações, a adoção de um padrão de representação de menor precisão terá pouco ou nenhum efeito sobre a qualidade dos resultados obtidos e, em contrapartida, permitirá que as operações aritméticas possam ser implementadas de maneira mais simples e consequentemente com menor custo em hardware (FU, 2009).
Um ponto a destacar, entretanto, é que qualquer mudança no padrão de representação numérica deve passar obrigatoriamente por um estudo minucioso dos efeitos que essa mudança poderá ter no algoritmo a ser implementado e no conjunto de dados a ser processado (FU, 2009).
Em (HE; LU; SUN, 2004) é apresentada a primeira plataforma de processamento baseada em FPGAs, dedicada ao processamento de dados sísmicos. Essa plataforma foi desenvolvida com o objetivo de acelerar a execução do algoritmo Pre-Stack KirchhoffTime Migration (PSTM). Os resultados obtidos apontaram um desempenho 15,6 vezes maior que a versão em software, mesmo executado a uma frequência de operação 48 vezes menor. A versão implementada em FPGA executou a 50 MHz, enquanto a versão em software foi executada em uma estação de trabalho Pentium 4 de 2,4GHz. Vale salientar que na época da implementação dessa plataforma o processador Pentium 4 era considerado de primeira linha para aplicações em computadores de mesa.
O algoritmo PSTM implementado em (HE; LU; SUN, 2004) baseia-se no cálculo do tempo de trânsito2 das ondas refletidas pelas diversas camadas geológicas em subsuperfície. Calcula-se esse tempo conforme o exemplo apresentado na Figura 2.1, por meio da aplicação da seguinte equação:
R
+ —
em que TSR representa o tempo de propagação do pulso sísmico desde a sua inserção até a captura das ondas refletidas, TS representa o tempo de propagação entre o ponto de inserção e o ponto de reflexão, TR o tempo de propagação entre o ponto de reflexão e os receptores sísmicos, t a profundidade estimada do ponto de reflexão e VT a velocidade RMS 3 entre o ponto de inserção e o ponto de reflexão.
A fim de atingir melhor desempenho em hardware, a plataforma apresentada em (HE; LU; SUN, 2004) contou com uma versão otimizada da Equação 2.1, na qual as operações de raiz quadrada foram implementadas em ponto-fixo utilizando módulos Coordinate Rotation Digital Computer (CORDIC)4 com pipeline5, segundo o modelo proposto em (ANDRAKA, 1998).
2O tempo de trânsito corresponde ao intervalo de tempo medido entre o momento da inserção do pulso sísmico até a chegada das ondas refletidas à superfície.
3 Velocidade RMS é a velocidade média quadrática de propagação da onda acústica no meio.
4CORDIC é uma classe de algoritmos simples e eficiente para calcular funções hiperbólicas e trigonométricas
5Nesse contexto pipeline significa uma estrutura de processamento em que o algoritmo é dividido em várias partes menores que são executadas em paralelo. Dessa forma é possível, ao mesmo tempo, aumentar a frequência
Figura 2.1: Esquema simplificado do processo de medição do tempo de trânsito do pulso sísmico no algoritmo PSTM (HE; LU; SUN, 2004)
Diversos autores apresentam implementações do algoritmo Reverse Time Migration (RTM) em FPGA(HE; ZHAO; LU, 2005a; NEMETH et al., 2008; GROSSER et al., 2011; CLAPP; FU; LINDTJORN, 2010; LINDTJORN et al., 2011; KRUEGER et al., 2011; BRAGANçA et al., 2013; ARAYA-POLO et al., 2011; HE; ZHAO; LU, 2005b).
O algoritmo RTM difere do algoritmo PSTM por se basear não apenas no cálculo dos tempos de trânsito das ondas refletidas, mas sim em uma solução completa da equação que rege a propagação da onda sísmica.
A propagação da onda sísmica é regida pela seguinte equação,
d 2P d 2P d2P _	1 d 2P
d x2 + d y2 + d z2 v2 (x, y, z) d t2
na qual d2P representa a variação de pressão no meio em razão da passagem da onda, x, y, z representam as coordenadas do espaço, v(x,y, z) representa a velocidade de propagação da onda no ponto de coordenadas x, y, z e t representa o tempo de propagação da onda, medido em relação ao momento de sua inserção no meio.
Por ser a Equação 2.2 uma equação diferencial sem resolução algébrica para sistemas com grandes variações de velocidade, o algoritmo RTM baseia-se não em uma aplicação direta dessa equação, mas sim em uma resolução construída por meio da aplicação de um operador de diferenças finitas, o qual pode ser descrito para problemas de duas dimensões na seguinte equação:
de trabalho do hardware e o reúso de partes do hardware que ficariam sem uso enquanto o algoritmo não fosse concluído.
Ci,j =absi x absj x	2.3
(2Bj,j + absi x absj x Vel-j x fat x (16 x (Bi,j+i + Bi,j-1 + Bi+1,j + Bi—1,j)
—	1 x (Bi,j+2 + Bi,j—2 + Bi+2,j + Bi—2,j)
-	60 x B, j
) - Ai,í
)
em que A,B e C representam respectivamente o estado anterior, o atual e o futuro do meio por onde a onda se propaga, ou seja, modelam a propagação da onda acústica tanto no espaço quanto no tempo, Veli,j representa a velocidade de propagação do pulso sísmico no ponto i, j, o qual é uma característica das camadas geológicas que estão sendo modeladas, e fat é um fator constante, calculado a fim de garantir a estabilidade e a convergência do operador de diferenças finitas.
Dessa forma, mais do que identificar a distância dos refletores que deram origem às ondas refletidas, o algoritmo RTM permite confirmar outras informações igualmente valiosas, tais como a amplitude e a fase das ondas durante a sua propagação.
Por esse motivo, o algoritmo RTM permite obter resultados de melhor qualidade do que o algoritmo PSTM. O algoritmo RTM é capaz de gerar o imageamento em áreas com litologias mais complexas, áreas para as quais o algoritmo PSTM não é aplicável (SANTOS, 2012).
A Figura 2.3 apresenta de forma simplificada o princípio de funcionamento do algoritmo RTM, o qual pode ser resumido como executado em três etapas.
A primeira etapa consiste na geração e captura de um sismograma6 gerado em campo por meio do uso de fontes sísmicas artificiais. Esse sismograma contém uma assinatura descritiva da subsuperfície da região de interesse, registrada pelas ondas refletidas durante a passagem do pulso sísmico - Figura 2.3(1).
A segunda etapa realiza-se em laboratório, e tem por objetivo simular o processo realizado em campo na primeira etapa do algoritmo. Essa simulação, que tem como base o modelo geológico provável da região de interesse, busca modelar a propagação do pulso sísmico no tempo e no espaço durante toda a sua trajetória, desde o ponto de inserção até cobrir toda a área a ser imageada.
O modelo geológico provável é representado por meio de uma matriz numérica com as mesmas dimensões da região a ser imageada. Cada elemento dessa matriz representa a velocidade de propagação da onda acústica em um ponto específico do meio. Neste trabalho esta
6Um sismograma é o registro da atividade sísmica ocorrida em uma determinada região. Em nosso contexto, um sismograma é um arquivo com o registro dos sinais captados pelos receptores sísmicos.
matriz é denominada de Matriz de Velocidades do meio.
Durante a simulação, a fonte sísmica é modelada numericamente através da curva gerada pela aplicação da segunda derivada da função Gausiana sobre um valor constante igual a 1. Os valores assim obtidos são aplicados e propagados no meio pela aplicação da Equação 2.3 em um conjunto de matrizes denominadas de Matrizes do Campo de Pressão.
Utilizam-se três matrizes: uma para modelar a pressão acústica exercida pelo pulso sísmico no tempo atual; outra para o tempo anterior e a terceira para o tempo futuro.
A cada etapa da simulação, essas matrizes se sobrepõem umas as outras: a matriz do tempo futuro passa a ser a matriz do tempo presente e a matriz do tempo presente, a matriz do tempo anterior. A Figura 2.2 apresenta a dinâmica do uso dessas três matrizes.
Como resultado dessa segunda etapa, gera-se um arquivo com os tempos de trânsito anotados das ondas refletidas em cada ponto de reflexão até a superfície - Figura 2.3(2).
A terceira etapa do algoritmo também se realiza em laboratório e consiste em uma segunda simulação do processo realizado em campo. Nessa segunda simulação substitui-se o pulso sísmico artificial pela depropagação7 do sismograma capturado em campo no campo de pressão.
Durante o processo de depropagação, nos intervalos de tempo registrados no arquivo com os tempos de trânsito, são feitas capturas dos estados da matriz que representa o tempo presente. O objetivo dessas capturas é registrar as amplitudes da frente de onda no momento em que as ondas registradas no sismograma alcançam as profundidades esperadas para cada uma das camadas que lhes deram origem.
Por fim, somam-se todas essas capturas em uma nova matriz, a qual será convertida em uma imagem. Nessa imagem espera-se que sejam destacadas as interfaces das camadas em subsuperfície (SANTOS, 2012) - Figura 2.3(3).
Caso o modelo de velocidades provável utilizado na execução do algoritmo seja compatível com o modelo geológico real encontrado em campo, o imageamento se mostrará nítido e coerente com as demais informações que já se possui do meio; caso contrário, o imageamento se mostrará difuso e incoerente.
Em (ARAYA-POLO et al., 2011) é apresentado um estudo comparativo do desempenho do algoritmo RTM em quatro arquiteturas de processamento distintas:
■	um Processador Xeon E5460;
■	um GP-GPU NVIDIA Tesla C1060 (NVIDIA. TESLA C1060 COMPUTING PROCESSOR BOARD: BOARD SPECIFICATION, 2008);
■	um Processador IBM Cell/B.E. (IBM, 2011) e
■	quatro FPGAs Xilix Virtex5-LX330.
7Depropagação, neste contexto, significa propagação inversa, em sentido contrário ao que foi gerado.
Figura 2.2: Dinâmica da simulação da propagação do pulso sísmico pelo campo de pressão
Todos os experimentos foram suportados por meio de placas especiais adicionadas a uma plataforma de processamento híbrida Convey HC-1 8 (Convey Computer, 2014). O gráfico apresentado na Figura 2.4 apresenta os tempos de execução do algoritmo em cada uma das tecnologias avaliadas.
Apesar de ter sido executada a uma frequência de trabalho de 150 MHz, aproximadamente 10 vezes menor que a frequência de trabalho da GP-GPU e 21 vezes menor que a frequência de operação da CPU, o desempenho da implementação do algoritmo em FPGA foi aproximadamente 20 vezes maior que o obtido com o processador, ficando um pouco abaixo do desempenho obtido pela implementação na GP-GPU.
Na análise apresentada na conclusão de (ARAYA-POLO et al., 2011), os autores afirmam que, caso houvesse sido adotado outro padrão de representação numérico mais simples, por exemplo, o padrão de ponto-fixo em lugar do padrão de ponto-flutuante, o desempenho obtido com a implementação em FPGA poderia ter sido ainda maior, superior também àquele apresentado pela implementação em GP-GPU.
Em (CLAPP; FU; LINDTJORN, 2010) é apresentado um segundo estudo comparativo do desempenho do algoritmo RTM quando implementado em GP-GPU e em FPGA. Nesse trabalho, embora não sejam apresentados resultados concretos em relação ao desempenho, destaca-se o fato de que o desempenho da implementação em FPGA liga-se diretamente, entre outras coisas, ao custo de implementação dos módulos aritméticos utilizados. Em razão de seu alto custo de implementação em hardware, esses autores recomendam que se evite adotar, sempre que possível, o padrão de ponto-flutuante para aplicações de alto desempenho que utilizem FPGAs como coprocessadores aritméticos.
Em (HE; ZHAO; LU, 2005a,b) apresentada a implementação do algoritmo RTM em um FPGA Xilinx Virtex4. Nessa implementação adota-se o padrão de ponto-flutuante na implementação do núcleo de processamento. A fim de melhor avaliar a relação do desempenho
8A plataforma Convey HC1 foi posteriormente substituida pela plataforma HC2.
Figura 2.3: Princípio de funcionamento do algoritmo RTM e do processo de depropagação do sismograma para a geração do imageamento da subsuperfície
60
50
20
250
300
350	400	450
Problem dimension [points]
500
40
X---
NVIDIA Tesla C1060 — IBM Cell/B.E. —x-FPGA (CONVEY HC-1) — Intel Xeon E5460 h-
■■ -3K -• -----h----
Figura 2.4: Comparativo do tempo de execução do algoritmo RTM nas arquiteturas GP-GPU, IBM Cell/B.E., Intel Xeon e através de FPGAs Xilix Virtex5-LX330 (ARAYA-POLO et al., 2011)
da implementação em hardware com o padrão de acesso à memória, avaliaram-se diversas configurações de operadores de diferenças finitas, variando o grau do operador no tempo e no espaço. A Tabela 2.1 apresenta os resultados obtidos.
Tabela 2.1: Desempenho da implementação do algoritmo RTM apresentada em (HE;
ZHAO; LU, 2005b). As velocidades de execução apresentadas foram medidas em mpp/s (milhões de pontos processados por segundo).
Configuração do Operador (tempo, espaço)	Velocidade em sw	Velocidade em hw	desempenho hw/sw
(2,2)	15,37 mpp/s	49,69 mpp/s	3,23
(2,4)	12,38 mpp/s	49,57 mpp/s	4,01
(2,8)	8,59 mpp/s	49,43 mpp/s	5,69
(4,4)	7,11 mpp/s	48,46 mpp/s	6,84
(4,8)	5,71 mpp/s	48,48 mpp/s	8,49
Em (BRAGANçA et al., 2013) é apresentada a implementação em uma FPGA Altera Stratix-III do algoritmo RTM para modelagem em três dimensões, desenvolvido dentro de um projeto de convênio de cooperação entre o Centro de Informática da UFPE e a Petrobras.
A fim de se obter maior desempenho, o núcleo de processamento aritmético do projeto apresentado em (BRAGANçA et al., 2013) foi implementado utilizando o padrão de ponto-fixo.
Apesar de esse núcleo estar sendo processado a uma frequência de apenas 50MHz, o seu desempenho ficou entre 17 e 30 vezes mais rápido do que o de um processador Intel Xeon E5430 de 2,66GHz. A variação no desempenho se deveu a variações nas dimensões dos modelos geológicos que foram processados.
Em (PELL et al., 2013) é proposto um fluxo de projeto para a implementação do algoritmo RTM em FPGA com base no uso de uma plataforma de hardware desenvolvida pela Empresa Maxeler (Maxeler Tecnologies, 2009) e no ambiente de programação MaxGenFD, também desenvolvido pela mesma empresa.
No fluxo de projeto proposto em (PELL et al., 2013), o núcleo aritmético do algoritmo RTM pode ser implementado tanto no padrão de ponto-fixo quanto no padrão de ponto-flutuante. Quando este for implementado utilizando o padrão de ponto-fixo, a fim de garantir sempre a melhor precisão dos resultados, utiliza-se um esquema híbrido de processamento, no qual os dados são processados em ponto-fixo e armazenados na memória no padrão de ponto-flutuante.
2.2	Efeitos da precisão numérica no processamento de dados sísmicos
Em (FU et al., 2008, 2009) é apresentada uma abordagem que tem como objetivo determinar de forma semiautomática, baseada na qualidade das imagens geradas, as configurações de um padrão de representação numérico adequado à implementação do algoritmo PSTM. Essas configurações dizem respeito às características que esse padrão numérico deve ter, tais como o intervalo de valores representáveis e a precisão com que os valores neste intervalo devem ser representados.
O trabalho apresentado em (FU et al., 2009) parte da premissa de que não existe uma definição clara do nível de precisão numérica que os algoritmos sísmicos exigem. Por essa razão, os autores propõem que a melhor estratégia seria eleger diversas configurações candidatas e dentre elas escolher aquela que apresente a melhor qualidade de imageamento quando comparada com um resultado tido como de referência.
A abordagem apresentada consiste em primeiramente definir um padrão candidato, baseado na análise do intervalo de valores gerados durante o processamento sísmico de um modelo geológico de referência, para, em seguida, avaliar a qualidade do imageamento gerado por meio de variações desse padrão candidato.
A análise do intervalo de valores é feita por meio de uma versão modificada do programa que implementa o algoritmo PSTM. Modifica-se o código original do programa de forma a permitir registrar todos os valores atribuídos às variáveis utilizadas no núcleo aritmético do programa.
Ao final da execução do algoritmo, anotam-se os maiores e menores valores positivos e negativos atribuídos a cada uma dessas variáveis, respectivamente os valores d, c, b e a do
esquema apresentado na Figura 2.5. Por meio dos valores a e d, determina-se o intervalo de valores a ser representado e, pelos valores b e c, determina-se a precisão do padrão candidato.
a	b 0 c	¿1
— CQ					+ oa
					
Figura 2.5: Distribuição dos valores utilizados para determinar o intervalo de valores e a precisão do padrão de representação.
Caso se deseje adotar o padrão de ponto-fixo, o intervalo de valores representados determinará a quantidade de bits a ser utilizada na parte inteira da representação, enquanto a precisão determinará a quantidade de bits a ser utilizada na sua parte fracionária.
Seguindo a abordagem proposta em (FU et al., 2009), após a definição de um padrão de representação candidato, uma nova versão do programa é implementada e executada sobre o modelo geológico de referência. Por meio da comparação das imagens geradas com essa nova versão do programa contra imagens de referência, pode-se ajustar a precisão do padrão candidato até chegar a um padrão de representação considerado ideal, que equalize o custo de implementação em hardware com a qualidade das imagens geradas.
Esses autores (FU et al., 2009) ainda propõem que, a fim de reduzir o custo de implementação e alcançar melhor desempenho em sistemas implementados em FPGAs, seja feita uma análise do impacto que cada uma das operações aritméticas existentes no núcleo de processamento tem sobre o sistema em sua totalidade. Apenas as operações que apresentarem maior impacto, no uso do hardware ou na qualidade dos resultados, devem ser consideradas no processo de ajuste da precisão. No experimento apresentado, após a verificação do custo de implementação de cada uma das operações existentes, foram identificadas como alvo as operações de raiz quadrada e a exponencial complexa. O núcleo aritmético do algoritmo implementado pode ser visto por meio da Equação 1 em (FU et al., 2009).
Em (MEDEIROS et al., 2013; BARROS et al., 2011) são apresentados resultados observados na fase inicial deste trabalho sobre os efeitos da redução da precisão aritmética na implementação do algoritmo Reverse Time Migration (RTM).
Esses resultados foram obtidos dentro de um projeto de pesquisa mais amplo, firmado entre o Centro de informática da Universidade Federal de Pernambuco e a Petrobras, com o objetivo de desenvolver uma plataforma de processamento de alto desempenho baseada em FPGAs, dedicada à execução do algoritmo Reverse Time Migration (RTM) (MEDEIROS et al., 2013; BRAGANçA et al., 2013). A Figura 2.6 detalha a estrutura da plataforma implementada.
Uma plataforma de hardware e software foi desenvolvida especialmente para o projeto. O objetivo dessa plataforma foi permitir que o algoritmo RTM pudesse ser executado de forma otimizada, parte em software e parte diretamente em hardware. A parte relativa ao ajuste de dados e a visualização das imagens geradas foi implementada e executada no PC Host, o qual
dispunha de um processador Intel Core 2 Quad 6600 de 2.4 GHz com 2 GB de memória RAM. A parte relativa ao processamento aritmético foi implementada para execução em um FPGA Stratix III de uma placa de desenvolvimento GIDEL PROCe-III (GIDEL, 2010).
Figura 2.6: Plataforma de processamento sísmico implementada em (MEDEIROS et al., 2013; BRAGANçA et al., 2013)
À semelhança do que havia sido proposto em (FU et al., 2008, 2009), nesse projeto também se efetuaram estudos prévios do intervalo de valores gerados pelo núcleo de processamento aritmético, a partir do qual, definiram-se algumas configurações candidatas para o padrão de representação numérico a ser adotado (MEDEIROS et al., 2013).
A fim de atingir alto desempenho, a exemplo dos demais trabalhos citados, nesse optouse também pela utilização do padrão de ponto-fixo em lugar do padrão de ponto-flutuante na implementação do núcleo de processamento.
Para avaliar a qualidade das imagens geradas nas diversas configurações de ponto-fixo candidatas, foram utilizadas duas métricas: uma mais objetiva, a Signal to Noise Ratio (SNR), e outra mais subjetiva, proposta em (WANG; BOVIK, 2002), denominada de Universal Quality Indice (UQI).
A métrica SNR foi utilizada com o objetivo de relacionar o nível de ruído introduzido nas imagens com a configuração de ponto-fixo utilizada. Sua implementação se deu por meio da equação a seguir:
SNR = 20 x log
Vrms (x)
Vrms(x y')
em que
1	N /—	1 N /----------
Vrms(x) = N E x2,	Vrms(x - y) = N E (xi - yi)2
na qual Vrms representa a intensidade média quadrática dos pixels da imagem, medidos em regiões quadradas com N pixel.
A métrica UQI foi utilizada com o objetivo de mensurar o grau de semelhança entre as imagens geradas nas diversas configurações de ponto-fixo avaliadas e uma imagem de referência gerada em ponto-flutuante. Conforme descrito em (WANG; BOVIK, 2002), essa métrica busca mensurar esse grau de semelhança do ponto de vista da percepção humana do brilho, contraste e artefatos presentes nas imagens. Sua implementação baseou-se na aplicação da seguinte equação:
UQI =
4ox,yxy
(o2+O2) [(x2) + (y2)]
(25)
em que
_	1 N
X = N E xi'
2 _ 1
O = N—1
1
°x’y = N- 1
1N
y=uEyi
N
E (Xi - X)2,	O-y2
i=1
N
E (xi- x)(yi- y)
i=1
1
N- 1
N
E (yi - y)2 i=1
Tanto na Equação 2.5 quanto na Equação 2.4, x representa a intensidade do sinal na imagem gerada enquanto y representa a intensidade do sinal na imagem de referência. Em ambos os casos, as medidas foram aplicadas em janelas com 9x9 pixels cada.
A Figura 2.7 apresenta os resultados obtidos com as métricas na avaliação do image-amento do modelo de Marmousi (MARTIN; WILEY; MARFURT, 2006) nas diversas configurações avaliadas. Como se pode observar, as duas métricas apresentam um comportamento semelhante, com um crescimento acelerado na qualidade dos resultados no intervalo entre 10 e 15 bits de precisão. A partir desse ponto, verifica-se que o SNR permanece inalterado para todas as demais configurações, apesar da métrica UQI apresentar ainda um pequeno crescimento.
Para melhor avaliar esse resultado, executou-se ainda um segundo experimento, no qual o processamento dos dados foi efetuado utilizando-se um núcleo aritmético em ponto-flutuante, mantendo-se entretanto o armazenamento dos resultados em ponto-fixo. Os resultados obtidos nesse segundo experimento denominaram-se de SNR e UQI de transporte, uma vez que o ruído
então avaliado era causado apenas pelo transporte dos dados que estava sendo efetuado em menor precisão. A Figura 2.8 traz os gráficos que relacionam esses resultados com a precisão utilizada no padrão de ponto-fixo.
Como se pode observar, comparando os gráficos apresentados nas Figuras 2.7 e 2.8, os ruídos causados pelas operações aritméticas do núcleo de processamento dominam sobre o ruído causado apenas pelo armazenamento dos dados, sendo, dessa forma, um limitante na qualidade dos resultados. Por esse motivo, pode-se considerar como um artifício válido no processo de otimização do sistema operar os dados em uma precisão e armazená-los em outra. Isso permitiria melhorar a qualidade dos resultados sem impactar no custo do transporte dos dados.
Ainda por esse mesmo experimento, verifica-se que uma relação sinal-ruído (SNR) em torno de 70dB, o que correspondeu a uma configuração com 16 bits de precisão, pode ser considerado como um limite adequado à geração de sismogramas para o modelo geológico de Marmousi(MARTIN; WILEY; MARFURT, 2006). Uma vez que, a partir dessa configuração, o grau de semelhança medido através do UQI não apresenta ganhos que possam ser considerados significativos.
2.3	Precisão da modelagem da propagação da onda sísmica por meio dos operadores de diferenças finitas
O Método das Diferenças Finitas (MDF) foi um dos primeiros métodos computacionais desenvolvidos para a resolução de equações diferenciais. Ele consiste na substituição das derivadas presentes na equação em estudo por expressões algébricas de diferenças, obtidas pelo truncamento de expansões da série de Taylor (SANTOS, 2012).
Uma vez que esse método representa uma resolução discretizada para funções contínuas, sua aplicação sofre algumas restrições; entre elas, a aplicação do MDF deve ser feita considerando-se o domínio de sua ap
Figura 2.7: SNR e UQI total medido nas diversas configurações avaliadas (MEDEIROS
Figura 2.8: SNR e UQI de transporte medido nas diversas configurações avaliadas (MEDEIROS et al., 2013)
T-X j	1	» fv	S •	S •
Determinação da precisão numérica mínima necessária à execução do algoritmo RTM
A definição da precisão numérica necessária à implementação de um algoritmo está diretamente ligada à magnitude dos valores a serem processados e à sensibilidade desse algoritmo ao nível de ruído introduzido pelo processamento.
Quanto menor a magnitude dos valores a serem processados, maior a precisão numérica necessária para representá-los.
Da mesma forma, quanto mais sensível for o algoritmo ao ruído introduzido pelo processamento, maior terá de ser a precisão dos operadores aritméticos utilizados em sua implementação.
Essas duas premissas estão diretamente ligadas ao objetivo deste trabalho, ou seja, à determinação da precisão numérica mínima necessária à implementação do algoritmo RTM.
Nesse contexto, este trabalho buscou estabelecer uma metodologia que permita identificar essa precisão por meio da análise dos fenômenos físicos envolvidos na propagação da onda sísmica e da determinação das características litológicas da região a ser imageada.
A metodologia aqui proposta foi estabelecida a partir da realização dos seguintes objetivos:
a)	O desenvolvimento de um método analítico capaz de predizer, a partir da análise das características da região a ser imageada, a menor amplitude esperada para as ondas sísmicas durante o seu processamento.
b)	O desenvolvimento de um algoritmo computacional, baseado no método analítico proposto, que seja capaz de identificar deforma automática, com uma margem de segurança de pelo menos 1 bit, a precisão numérica mínima necessária à execução do algoritmo RTM.
3.1	Fatores que influenciam na amplitude da onda sísmica
Do ponto de vista dos fenômenos físicos associados à propagação da onda sísmica, pode-se dizer que a amplitude desta será diretamente afetada pelos seguintes fatores (ROBERT E. SHERIFF, 1995):
■	a fonte sísmica utilizada;
■	as dimensões e as características das camadas em subsuperfície;
■	os fenômenos dissipativos associados à transformação da energia transportada pela onda sísmica em outras formas de energia.
No entanto, é importante ressaltar que, destes, apenas os dois primeiros fatores listados estão de fato presentes na modelagem computacional empregada na implementação do algoritmo RTM.
Por ter sido desenvolvido apenas com base na equação que rege a propagação da onda acústica, sem levar em conta fenômenos físicos dissipativos associados a essa propagação, tais como o fator de qualidade do meio e possíveis transformações da energia acústica em outras formas de energia, o operador de diferenças finitas empregado no algoritmo RTM fica restrito apenas à modelagem dos fenômenos físicos associados à conservação de energia capturados por essa equação (SANTOS, 2012).
Além dos fenômenos físicos já descritos, existem outros fatores ligados à configuração do operador de diferenças finitas que podem também influenciar na amplitude da onda sísmica durante a execução do algoritmo RTM.
Parâmetros, tais como o intervalamento espacial e temporal das amostras, as velocidades de propagação mínima e máxima esperadas para o modelo de velocidades e a frequência do pulso sísmico utilizado, podem afetar na amplitude das ondas sísmicas modeladas (BOORE, 1972; VOSSEN; ROBERTSSON; CHAPMAN, 2002) e, dessa forma, interferir na precisão numérica necessária para processá-las.
Entretanto, por se tratar de parâmetros de configuração, que não estão diretamente ligados a nenhum fenômeno físico, esses fatores não serão considerados no método aqui proposto.
Dessa forma, de todos os fenômenos físicos e fatores de configuração que podem afetar a amplitude da onda sísmica, apenas as características da fonte sísmica utilizada e as dimensões e características das camadas em subsuperfície serão consideradas. Os efeitos esperados de cada um desses elementos na amplitude das ondas sísmicas serão descritos a seguir.
3.2	Efeito da fonte sísmica utilizada
As características da fonte sísmica utilizada na Sísmica de Reflexão 1 é algo de fundamental importância para a qualidade das imagens geradas. Entre outras coisas, esta deve gerar um pulso que seja limitado no tempo e no espectro (SANTOS, 2012).
Na modelagem computacional, a fonte sísmica deve ser representada por uma função matemática que tenha as mesmas características do pulso sísmico real.
No algoritmo RTM, o pulso sísmico é modelado por meio da segunda derivada da função gaussiana. O pulso gerado por essa função em um meio visco-elástico é conhecido em geofísica como Pulso de Ricker (ROBERT E. SHERIFF, 1995). Neste trabalho essa função é modelada através da seguinte equação:
f(t) =
1 - 2(t x a/075 x n x fc)2

em que t representa o tempo de simulação e fc representa a frequência central do pulso sísmico gerado (ROBERT E. SHERIFF, 1995). O formato do pulso gerado pode ser verificado na Figura
3.1.	Por suas características temporais e espectrais, essa função é a mais largamente utilizada para esse tipo de aplicação (SANTOS, 2012; ROBERT E. SHERIFF, 1995).
Figura 3.1: Representação do pulso sísmico modelado por meio da segunda derivada da função gausiana
Nos experimentos conduzidos ao longo deste trabalho, observou-se que, apesar da função geradora do pulso sísmico não estar relacionada com as características do meio de simulação, a amplitude do pulso efetivamente inserido no meio varia de acordo com a velocidade de propagação da camada na qual se faz a sua inserção. O gráfico apresentado na Figura 3.2
1 Sísmica de Reflexão é a designação dada aos métodos de imageamento sísmico baseados nas ondas refletidas
pela subsuperfície.
apresenta a relação encontrada entre essa amplitude e a velocidade do meio, para uma modelagem em duas dimensões.
Figura 3.2: Amplitude do pulso sísmico introduzido em relação à velocidade do meio
Verifica-se pelo gráfico da Figura 3.2 que a amplitude do pulso sísmico efetivamente inserido será inversamente proporcional ao quadrado da velocidade do meio.
Apesar desse fenômeno não ter nenhum efeito na qualidade do imageamento quando a modelagem computacional está baseada no padrão de ponto flutuante, o mesmo não ocorre quando este utiliza um padrão numérico de precisão fixa, tal como o padrão de ponto fixo. Isso porque, diferentemente do padrão de ponto flutuante, no qual o nível de ruído introduzido com o processamento independe da amplitude dos dados, no padrão de ponto fixo este será inversamente proporcional à sua amplitude.
3.3	Efeito das dimensões e das características das camadas
em subsuperfície
Um grande número de fenômenos físicos que afetam a amplitude da onda sísmica está diretamente associado às dimensões e às características das camadas em subsuperfície. Dentre esses fenômeno,s destacam-se:
■	a divergência da frente de onda, ou espalhamento geométrica da onda;
■	os efeitos refrativos e reflexivos em razão do contraste de impedância nas interfaces das camadas geológicas;
■	as iterações construtivas e destrutivas devido ao encontro de duas ou mais frentes de ondas refratadas e/ou refletidas;
os efeitos de multipercursos (multi-path);
■	o espalhamento da frente de onda;
■	o efeito de dispersão.
Dessa forma, o efeito verificado na qualidade do imageamento sísmico devido às dimensões e as características das camadas em subsuperfície será, na verdade, um somatório dos efeitos introduzidos por esses fenômenos.
3.3.1	Efeitos refrativos e reflexivos
Ao se propagar de uma camada geológica para a outra, a onda sísmica sofre efeitos refrativos e reflexivos proporcionais ao contraste de impedâncias acústicas existentes entre essas camadas (ROBERT E. SHERIFF, 1995).
A impedância acústica é a característica do meio que identifica o grau de resistência deste à passagem das ondas sísmicas.
Existem dois tipos de onda sísmica, ondas primárias ou compressionais, denotadas como ondas P e ondas secundárias ou transversais, denotadas como ondas S. Essas ondas se diferenciam entre si pela forma como se propagam no meio. A Figura 3.3 apresenta esquematicamente como essas ondas se comportam (ROBERT E. SHERIFF, 1995).
Ondas Primárias (P) - Compressionais Ondas Secundárias (S) -Transversais
Direção de Propagação da Onda
Figura 3.3: Ondas compressionais (P) e ondas transversais (S)
Por esse motivo, o meio apresentará também dois tipos de impedâncias acústicas, uma relacionada com a onda P e outra relacionada a onda S.
Em ambos os casos, a impedância acústica é definida como o produto da densidade do meio, denotada por p, pela velocidade de propagação da onda. Como as ondas P e S se propagam a velocidades distintas, para as ondas P tem-se:
Zp = p x Vp
em que ZP denota a impedância acústica do meio relativa à onda P e VP denota a velocidade de propagação da onda P. Para as ondas S, tem-se:
em que ZS denota a impedância acústica do meio relativa à onda S e VS a velocidade de propagação da onda S.
Tanto as ondas P quanto as ondas S, podem ser originadas devido à passagem de uma onda P pela interface entre duas camadas geológicas.
O diagrama da Figura 3.4 apresenta de maneira simplificada como uma onda sísmica compressional, denotada por Onda P, interage com o meio ao passar de uma camada para a outra.
Dependendo do ângulo de incidência da onda com a interface entre as camadas, angulo 0i, ela pode dar origem a ondas refletidas compressionais, ondas RP, e ondas refletidas transversais, ondas RS, respectivamente com ângulos 01 e Â1. Da mesma forma, poderão ser geradas ondas transmitidas compressionais, ondas TP e ondas transmitidas transversais, ondas TS, respectivamente com ângulos 02 e Â2.
Figura 3.4: Ondas refletidas, compressionais RP e transversais RS, e refratadas, compressionais TP e transversais TS
É importante destacar que, quando o ângulo de incidência da onda com a interface entre as camadas, ângulo 01, estiver entre 0 e 20 graus, apenas ondas refletidas e refratadas compressionais serão geradas, ondas RP e TP. Nessa situação pode-se determinar as intensidades das ondas geradas por meio do princípio da conservação da energia. Os percentuais da energia da onda incidente que serão refletidos e refratados, aqui denominados de coeficientes de reflexão e de transmissão, denotados por CR e CT, podem ser calculados pelas seguintes equações (ROBERT E. SHERIFF, 1995):
Z2 - Z1
R	Z2 + Z1
e
r	2Zi
T Z2 + Zi ’
na quais Z1 é a impedância da camada onde a onda se encontra e Z2 a impedância da camada para onde a onda se propaga.
Neste trabalho, uma vez que não interessa analisar as ondas transversais, apenas as ondas compressionais geradas com incidência normal ao meio serão consideradas. Todas as camadas que formam a subsuperfície serão tidas como lineares, paralelas, perfeitamente elásticas, homogêneas e isotrópicas.
Considerando que todas as camadas em subsuperfície têm densidade constante igual a 1, as equações 3.4 e 3.5 podem ser reescritas de maneira mais simples, apenas em função das velocidades das camadas envolvidas, ou seja,
V2 - Vi
T	V2 + Vi'
Por terem sido derivados mediante o princípio da conservação de energia, os coeficientes de transmissão e reflexão assim calculados não determinam diretamente as amplitudes das ondas resultantes, e sim as suas intensidades (ROBERT E. SHERIFF, 1995). A fim de calcular essas amplitudes, é necessário primeiramente relacionar a intensidade do fluxo da energia da onda, aqui denotado por I, com a sua amplitude e as características do meio, ou seja, sua velocidade e densidade. Essa relação pode ser descrita pela equação a seguir (ROBERT E. SHERIFF, 1995):
I
1	pA2
2	’
Assim sendo, uma vez que a intensidade da parcela da energia que é transmitida da primeira para a segunda camada, aqui denotada por IT12, é igual à intensidade da energia que é recebida na segunda camada, aqui denotada por I2, tem-se:
IT12 = I2,
ou seja,
1	p AT12
2	V2
1	p a2
2	V2 •
Cancelando os termos comuns e rearranjando os termos restantes, têm-se:
A2 = At 12 x
V1
Entretanto,
AT 12 = A1 x Cr,
o que nos leva a
A2 = A1 x
2V1	V2
V1 + V2 x Vi
O que pode ser ainda simplificado e reescrito da seguinte forma:
A2 = Ai x
2V2
V1 + V 2 ’
Essa equação permite, portanto, calcular a amplitude da onda transmitida para a segunda camada, em função da amplitude da onda incidente na primeira camada e das velocidades de cada uma das camadas. Aplicando o mesmo raciocínio com relação à amplitude da onda refletida na primeira camada, denotada por Rn, têm-se:
V1
R11 = A1 x Cr x Vi,
o que nos leva a
R11 = A1 x Cr .
Do que se pode concluir que as amplitudes das ondas refletidas e transmitidas podem ser preditas pela aplicação conjunta das Equações 3.14, 3.16 e 3.6. A atenuação que a onda sísmica sofre nesse processo é denominada neste trabalho de atenuação em razão da configuração litológica do meio.
3.3.2	A divergência da frente de onda
O termo divergência ou espalhamento geométrico da frente de onda está diretamente associado ao processo de propagação da onda conforme descrito pelo Princípio de Huygens. Segundo esse princípio, cada partícula excitada pela energia de uma frente de onda dará origem a uma nova frente de onda (ROBERT E. SHERIFF, 1995), conforme ilustrado na Figura 3.5.
Figura 3.5: Ilustração da aplicação do Princípio de Huygens à propagação da onda em espaços isotrópicos.
Com isso, em espaços isotrópicos, o fluxo de energia gerado por um pulso sísmico
57	3.3. EFEITO DAS DIMENSÕES E DAS CARACTERÍSTICAS DAS CAMADAS EM
_______________________________________________________________SUBSUPERFÍCIE se propagará de maneira homogênea, em todas as direções, podendo ser visto como esferas concêntricas em meio tridimensional ou como círculos concêntricos em um meio bidimensional.
A intensidade do fluxo de energia produzido pela passagem da frente de onda, aqui denotado por I, pode ser calculada mediante a seguinte equação:
I = 1v p A2m 2
na qual A é a amplitude da frente de onda, V e m são respectivamente as suas velocidades linear e angular e p é a densidade do meio na qual a onda se propaga (ROBERT E. SHERIFF, 1995)
Em uma modelagem sísmica tridimensional baseada no operador de diferenças finitas utilizado no algoritmo RTM, considerando que o raio da frente de onda cresça de r1 para r2, conforme ilustrado na Figura 3.6, verifica-se que a intensidade do fluxo de energia que atravessa a superfície da esfera de raio r1, superfície S1, deve ser igual à intensidade do fluxo de energia que atravessa a superfície da esfera de raio r2, superfície S2, ou seja,
IS1 = IS2,
em que IS1 e IS2 representam respectivamente a intensidade do fluxo de energia que atravessa as superfícies S1 e S2.
Figura 3.6: Ilustração da forma de propagação da onda sísmica em meio isotrópico
Aplicando a Equação 3.17 na Equação 3.18, tem-se:
1V pAjrn 2S1 = 2v pA2 m 2S2.
Cancelando os termos comuns em ambos os lados dessa equação, obtém-se:
a2S1 = a2s2
ou, ainda,
Sabendo-se que a área de uma superfície esférica é igual a
S	= nr2.
Aplicando-se esta definição à equação 3.20, obtém-se:
A2 = A1 x
ou, ainda,
A2 = Ai x —.
r2
A Equação 3.22 permite portanto calcular a amplitude que a frente de onda terá ao alcançar a superfície S2, a partir da amplitude que essa possui na superfície S1 e da relação entre os raios de propagação da frente de onda em cada uma dessas superfícies.
Dessa forma, para modelagens em três dimensões, a amplitude de uma frente de onda produzida por um pulso inicial de amplitude A0 e raio r0 = 1, a uma distância r do seu ponto de inserção, será igual a:
./ x Ao A r = —
Em uma modelagem bidimensional, substituindo as superfícies esféricas S1 e S2 da Equação 3.20 por circunferências concêntricas de perímetro
L1 = 2n r1
e
L2 = 2n r2,
tem-se
A1	/2n r1
A2 =\ 2ñ7~2 ’
ou, ainda,
A2 = A1 x
Vr2
Dessa forma, para modelagens em duas dimensões, a amplitude de uma frente de onda produzida por um pulso inicial de amplitude A0 e raio r0 = 1, a uma distância r do seu ponto de inserção, será igual a:
Nos experimentos conduzidos ao longo deste trabalho, verificou-se que, apesar das Equações 3.23 e 3.25 serem adequadas para modelar a atenuação por divergência em modelos com apenas uma camada, elas não são adequadas para se modelar atenuações por divergência em modelos com mais de uma camada. Esses experimentos serão apresentados na Seção 3.4.2.
3.4	Metodologia para a predição da amplitude das ondas sísmicas refletidas
Um dos elementos-chave na definição da precisão numérica necessária à execução do algoritmo RTM são as amplitudes com que as ondas sísmicas refletidas chegam à superfície.
Por esse motivo, um dos objetivos deste trabalho foi desenvolver um método analítico que permitisse estimar essas amplitudes com base nas características do pulso sísmico introduzido e nas camadas em subsuperfície.
O método aqui proposto baseia-se na análise dos seguintes fatores:
■	a amplitude do pulso sísmico efetivamente introduzido em subsuperfície, Seção 3.2;
■	a atenuação causada pelos efeitos refrativos e reflexivos, Seção 3.3.1;
■	a atenuação causada pela divergência da frente de onda, Seção 3.3.2.
A amplitude do pulso sísmico introduzido na modelagem computacional pode ser obtida por meio dos valores experimentais registrados na curva da Figura 3.2.
A atenuação causada pelos efeitos refrativos e reflexivos pode ser obtida mediante a aplicação das Equações 3.6, 3.14 e 3.16.
A princípio, a atenuação causada pela divergência da frente de onda deveria ser calculada pela Equação 3.25. Entretanto, os experimentos conduzidos ao longo deste trabalho indicaram que ela não é adequada à determinação da atenuação em modelos com mais de uma camada. Por isso, foi necessário desenvolver outra equação que permite ajustar os valores obtidos através da Equação 3.25 para modelos com qualquer número de camadas. Esse ajuste ocorre por meio de uma correção feita no valor do raio da frente de onda fornecido à Equação 3.25, resultando em uma nova equação aqui denominada de Cálculo do Raio Efetivo.
3.4.1	Cálculo do Raio Efetivo para modelagem bidimensional
Com os experimentos conduzidos ao longo deste trabalho, constatou-se que é necessário efetuar um ajuste no valor do raio aplicado à Equação 3.25, para que ela possa calcular corretamente a atenuação sofrida pela frente de onda em modelos com mais de uma camada. Esse ajuste deve ser aplicado a cada nova camada encontrada em subsuperfície. O novo raio assim calculado, aqui denotado como raio efetivo, rE, será obtido por meio da seguinte equação:
(M = E (i -i=0 Vo
na qual hz e hi representam respectivamente: a distância percorrida pela frente de onda e a distância de onde começa a camada geológica atual. Ambas as distâncias devem ser tomadas em relação ao ponto de inserção do pulso sísmico, medidas em função do intervalamento espacial do operador de diferenças finitas utilizado. Vo e Vi- representam respectivamente as velocidades de propagação do pulso na primeira camada e na posição na qual se encontra a frente de onda.
Dessa forma, reescrevendo a Equação 3.25, utilizando agora o raio efetivo no lugar do raio real, chegamos à equação
a qual permite calcular a atenuação por divergência para modelos com qualquer configuração de camadas.
O conceito do raio efetivo é, até onde foi possível investigar, uma contribuição original deste trabalho. Todo o seu arcabouço teórico ainda precisa ser mais bem estudado e estabelecido, uma vez que ele foi elaborado de maneira empírica, exclusivamente por meio dos resultados obtidos nos diversos experimentos conduzidos neste trabalho.
Com a utilização do conceito do raio efetivo, do ponto de vista da atenuação por divergência, um meio com diversas camadas passa a ser visto como se tivesse uma única camada, com velocidade igual à velocidade da primeira camada e tamanho igual ao somatório das projeções de cada uma das outras camadas na primeira camada.
A Figura 3.7 ilustra a aplicação da Equação 3.26 no cálculo do raio efetivo para um modelo geológico com três camadas.
Verifica-se, por meio do cálculo do raio efetivo apresentado nessa figura, que a primeira parcela do somatório da Equação 3.26 corresponde à distância percorrida pela frente de onda
ainda na primeira camada, ou seja,
1000
1ÔÔÔ ,
3
a segunda parcela corresponde a distância percorrida na segunda camada,
2
2000
1000
e a terceira parcela corresponde à distância percorrida na terceira camada,
.	3000
4 x-----.
1000
Nesse exemplo, o raio efetivo calculado para uma distância de 9 pontos no grid original do modelo de velocidades utilizado corresponde a uma distância de 19 pontos em um modelo com uma única camada, com uma velocidade de propagação igual à da primeira camada.
3.4.2	Experimentos de validação do cálculo do raio efetivo
Os experimentos utilizados na validação no cálculo do raio efetivo se basearam no seguinte princípio: sendo a Equação 3.25 a função que determina a atenuação que a frente de onda sofrerá em razão da divergência da frente de onda, e que o operador de diferenças finitas utilizado no algoritmo RTM não modela fatores dissipativos, a aplicação da inversa da Equação 3.25 sobre uma curva gerada por esta deve resultar em um valor constante, equivalente à amplitude do pulso inicialmente inserido no meio, ou seja, se
então
g(f (Ao,ri),ri) = Ai x^/r, = Ao.
Partindo desse princípio, foram efetuados três experimentos a fim de validar o conceito do raio efetivo, os quais se basearam não na predição da atenuação introduzida pela divergência da frente de onda, mas sim no seu cancelamento. Esses experimentos tiveram como objetivo verificar a eficiência do método nas seguintes situações:
■ em um modelo com uma única camada;
■ em um modelo com duas camadas;
■ em um modelo com mais de duas camadas.
Cada experimento foi efetuado em três etapas distintas, conforme descrito a seguir:
a)	Primeiramente, realizou-se a simulação computacional da propagação da onda sísmica no modelo geológico. Ao longo dessa simulação, foram sendo capturadas
as amplitudes de chegada da frente de onda em cada um dos pontos localizados perpendicularmente abaixo do ponto de inserção do pulso sísmico.
b)	Em seguida, aplicou-se a Equação 3.28 aos valores capturados na primeira etapa, sendo Ai a amplitude da frente de onda no ponto i e ri a distância do ponto i ao ponto de inserção do pulso sísmico. O novo conjunto de valores assim obtido é reservado para fins de comparação com o método proposto.
c)	Por fim, reaplica-se a Equação 3.28 aos valores capturados na primeira etapa, substituindo o valor de cada ri pelo seu raio efetivo, rE, calculado através da Equação
3.26.
3.4.2.1	Primeiro Experimento
O primeiro experimento consistiu em mensurar a atenuação por divergência em um modelo sintético com velocidade constante igual a 1500 m/s. A Figura 3.8 traz a configuração desse experimento.
	Sf			
Pulso / Sísmico		Pontos &gt; de medição
V=1500 m/s		
Figura 3.8: Configuração do experimento 1.
O gráfico da Figura 3.9 apresenta as amplitudes da frente de onda nos pontos de medição.
O decaimento dessa curva deve-se à atenuação por divergência nesse modelo.
Amplitude da frente de onda
Figura 3.9: Atenuação por divergência cilíndrica no primeiro experimento.
Em seguida, ao aplicar a Equação 3.28 ao conjunto de dados obtidos na primeira etapa desse experimento, obteve-se o gráfico da Figura 3.10.
Amplitude da frente de onda com
Figura 3.10: Compensação da atenuação por divergência por meio da aplicação da Equação 3.28.
Por fim, na terceira etapa do experimento, ao aplicar a Equação 3.28 substituindo-se o raio da frente de onda pelo raio efetivo, com a aplicação da Equação3.26, obteve-se o gráfico da Figura 3.11.
Amplitude da frente de onda com
Figura 3.11: Compensação da atenuação por divergência por meio da aplicação conjunta das Equações 3.28 e 3.26.
Como se pode verificar pelos gráficos das Figuras 3.10 e 3.11, em ambos os casos, ocorreu um efetivo cancelamento da atenuação por divergência nos valores capturados, uma vez que as amplitudes em todos os pontos dos dois gráficos ficaram constantes. Isso permite dizer que tanto a Equação 3.25 quanto a Equação 3.27,modelam corretamente a atenuação por divergência em modelos com apenas uma camada geológica.
3.4.2.2	Segundo Experimento
O segundo experimento consistiu em mensurar e verificar o cancelamento da atenuação por divergência em um modelo com duas camadas. Para tanto, utilizou-se um modelo geológico com uma camada com 1.500 m/s e outra com 2.500 m/s, conforme indicado na Figura 3.12.
V =1500 m/s	5	
V =2500 m/s 2	
Figura 3.12: Configuração do experimento 2.
O gráfico da Figura 3.13 apresenta os valores capturados na primeira etapa do experimento. Nesse gráfico pode-se observar na posição 250 do raio o efeito conjunto da atenuação por divergência e por fenômenos ligados à litologia.

Atenuação da frende de onda para um modelo com duas
camadas paralelas de 1500 e 2500 m/s
Figura 3.13: Atenuação causada pela divergência cilíndrica em meio isotrópico com duas camadas com velocidade de propagação de 1500 e 2500 m/s.
O gráfico da Figura 3.14 apresenta o resultado obtido na segunda etapa desse experimento.
Amplitude da frende de onda com correção da atenuação
Figura 3.14: Compensação da atenuação causada pela divergência cilíndrica em modelo com duas camadas, sem a aplicação do raio efetivo.
Como se pode observar, por esse gráfico, a simples aplicação da Equação 3.25, sem a utilização do raio efetivo, não foi suficiente para cancelar a atenuação por divergência na segunda camada do modelo. Verifica-se pelo decaimento apresentado nessa parte da curva que ela ainda
contém resíduos da atenuação por divergência.
Por fim, na terceira etapa do experimento, ao se utilizar o raio efetivo, com a aplicação conjunta das Equações 3.25 e 3.26, obteve-se o gráfico da Figura 3.15.
Amplitude da frende de onda com correção da atenuação
Figura 3.15: Compensação da atenuação causada pela divergência cilíndrica em modelo com duas camadas com a aplicação do raio efetivo.
Como se pode observar, por esse gráfico, dessa vez, tanto a atenuação da primeira camada quanto a atenuação da segunda camada foram efetivamente compensadas.
A diferença das amplitudes observadas nesse gráfico se deve à atuação dos efeitos refrativos e reflexivos envolvidos na passagem da onda sísmica da primeira para a segunda camada do modelo e na representação da energia da onda sísmica em cada camada.
3.4.2.3	Terceiro Experimento
O terceiro experimento teve como objetivo verificar a aplicabilidade do método para modelos com mais de duas camadas. Para tanto, nesse experimento foi utilizado um modelo com três camadas, com velocidades de 1.500, 2.500 e 3.500 m/s. A disposição do experimento pode ser vista na Figura 3.16.
Nesse experimento, a exemplo dos experimentos anteriores, primeiramente se verificou o cancelamento da atenuação utilizando o raio real da frente de onda, obtendo-se como resultado o gráfico da Figura3.17.
Figura 3.16: Configuração do experimento 3.
Amplitude da frente de onda com correção da atenuação
Figura 3.17: Tentativa de compensação da atenuação causada pela divergência cilíndrica em meio com três camadas utilizando o raio real.
Como se pode observar, por esse gráfico, apenas a atenuação da primeira camada foi efetivamente cancelada. Mais uma vez pode-se constatar que a simples aplicação do modelo de atenuação sem a utilização do raio efetivo não é suficiente para cancelar a atenuação por divergência para modelos com mais de uma camada.
Em seguida, repetiu-se o processo, dessa vez substituindo as distâncias dos pontos por seus raios efetivos. O resultado pode ser visto no gráfico da Figura 3.18.
Amplitude da frente de onda com correção da atenuação
Figura 3.18: Compensação efetiva da atenuação causada pela divergência cilíndrica em meio com três camadas por meio da utilização do conceito do raio efetivo.
Nesse gráfico, observa-se que, com a utilização do raio efetivo no lugar do raio real, as atenuações por divergência das três camadas foram efetivamente compensadas.
Com esses resultados, pode-se concluir por indução que o método proposto é efetivo tanto para o cancelamento quanto para a predição da atenuação por divergência para modelos com qualquer número de camadas.
3.4.3	Experimentos de validação da predição da atenuação devido à configuração litológica
A validação das Equações 3.16 e 3.14 relativas à atenuação pela configuração litológica deu-se com base nos resultados já obtidos nos experimentos de validação do cálculo do raio efetivo.
Ao observar os resultados obtidos naqueles experimentos, verifica-se que, para modelos com duas ou mais camadas, a compensação da atenuação por divergência da frente de onda gera gráficos com amplitudes distintas para cada camada do modelo.
Aplicando-se a Equação 3.14 à configuração utilizada no experimento que gerou o gráfico da Figura 3.15, obtém-se
A2 = 1,07 x
2 x 2500
1500+2500
= 1, 337,
o qual é o valor verificado na amplitude da frente de onda registrada no gráfico da Figura 3.15. Da mesma forma, utilizando as configurações das camadas do modelo utilizado no experimento que gerou o gráfico da Figura 3.18 , obtém-se
A2 = 1,07 x
2 x 2500
1500+2500
= 1, 337,
para o primeiro degrau da curva, e
A3 = 1,337 x
2 x 3500
2500+3500
= 1 , 56,
para o segundo degrau.
Ao observar o gráfico da Figura 3.18, verifica-se que os valores assim calculados são os mesmos registrados naquela curva.
Dessa forma, conclui-se que a Equação 3.14 e, por conseguinte, a Equação 3.16 são adequadas à predição da variação de amplitude que a frente de onda sofre em razão da configuração do modelo geológico utilizado.
3.5	Desenvolvimento e validação da metodologia
Após a análise dos fenômenos físicos associados à propagação da onda sísmica, verificase que os principais fatores que afetam a sua amplitude e que, portanto, podem ser utilizados na predição da precisão numérica necessária ao seu processamento, são:
a)	a atenuação que o pulso sísmico sofre ao ser introduzido no meio, conforme registrado no gráfico da Figura 3.2;
b)	a atenuação causada pelo raio efetivo da frente de onda, que está ligado à atenuação por divergência, Equação 3.27;
c)	a atenuação devido à configuração litológica do modelo que está sendo processado, Equações 3.14 e 3.16.
Neste trabalho o segundo e o terceiro fatores foram reunidos e representados através de um único coeficiente, denominado de coeficiente de atenuação efetiva, denotado por CAE. Numericamente esse coeficiente nada mais é do que a ação conjunta do coeficiente de atenuação por divergência, denotada por CAD, com o coeficiente de atenuação por litologia, denotado por CAL, ou seja,
Cae = Cal x Cad
Sendo assim, a predição da amplitude que uma onda sísmica alcançará ao fim do processo de imageamento pode ser determinada pelo conhecimento da sua amplitude inicial e da atenuação efetiva que ela sofre durante os processos de modelagem e migração.
A Figura 3.19 traz um modelo esquemático que exemplifica de maneira simplificada o percurso de uma onda sísmica em todas as etapas de execução do algoritmo RTM, indo desde o momento da inserção do pulso sísmico na etapa de modelagem, passando pela geração do sismograma sintético e indo até a geração da seção migrada. O exemplo foi desenvolvido para um modelo geológico sintético com três camadas.
Figura 3.19: Percurso da onda sísmica desde a inserção do pulso sísmico no processo de modelagem, passando pelo registro das ondas refletidas e chegando até a geração da seção migrada no processo de migração.
As Figuras 3.20 e 3.21 apresentam o processo de cálculo da atenuação efetiva para o imageamento do modelo geológico da Figura 3.19.
Em cada uma dessas figuras, estão destacados tanto os elementos responsáveis pela atenuação por litologia quanto os responsáveis pela atenuação pela divergência da frente de onda.
Figura 3.20: Esquema gráfico para a demonstração do cálculo da atenuação efetiva da onda refletida na interface entre a primeira e a segunda camada da Figura 3.19.
Figura 3.21: Esquema gráfico para a demonstração do cálculo da atenuação efetiva da onda refletida na interface entre a segunda e a terceira camada da Figura 3.19.
Como se pode observar, fazendo um paralelo do diagrama esquemático da Figura 3.20 com o da Figura 3.19, no início do processo de modelagem, insere-se um pulso sísmico na primeira camada em subsuperfície, a qual tem velocidade V1 e profundidade h1. A inserção desse pulso dá origem à frente de onda P1 com amplitude aP. Ao alcançar a interface entre a primeira e a segunda camada, esta dá origem à onda refletida P2, que tem intensidade determinada pelos coeficientes de reflexão e de transmissão entre essas duas camadas, aqui denotado por CR12.
Ao fim do processo de modelagem, a onda refletida P2 é gravada no arquivo que armazena o sismograma.
No processo de migração, a onda P2 é lida do arquivo do sismograma e reintroduzida no meio. Essa onda é então propagada até a interface da primeira com a segunda camada, aonde chega com amplitude AMRP1.
Observa-se por esse diagrama que a frente de onda AP percorreu um raio efetivo igual a 3 x h1 e foi submetida a uma atenuação por litologia igual ao coeficiente de reflexão entre a primeira e a segunda camada, CR12. Baseado nessa análise e na equação 3.29, verifica-se que ela sofreu uma atenuação efetiva igual a
CR12
ou seja, a amplitude esperada para a onda sísmica, que ao fim do processo de migração imageia a interface entre as camadas 1 e 2, aqui denotada por aMrP1, é igual a:
AMrP1 = AP x
A designação aMrP1 foi utilizada para indicar que essa onda tem origem na reflexão da onda P1 na interface entre as camadas 1 e 2.
Da mesma forma, analisando-se em paralelo os diagramas das Figuras 3.19 e 3.21, verifica-se que a onda inicial P1 dá origem à onda transmitida P3 ao ser transmitida da primeira para a segunda camada. A intensidade da onda P3 será determinada pelo coeficiente de transmissão entre a primeira e a segunda camada, denotado por Cr 12.
A onda P3, por sua vez, dá origem à onda refletida P4, na interface entre a segunda e a terceira camada. A amplitude da onda P4 é determinada pelo coeficiente de reflexão entre essas camadas, aqui denotado por CR23.
Em seu retorno à primeira camada, a onda refletida P4 dá origem à onda transmitida P5, a qual tem a intensidade determinada pelo coeficiente de transmissão entre a segunda e a primeira camada, que é denotado por CT21.
Por fim, a onda P5 é gravada no sismograma.
No processo de migração, a onda P5 será lida do sismograma e reinserida no meio. Esta será então propagada até a interface das camadas 1 e 2, onde dá origem à nova onda transmitida P6, que tem a intensidade determinada pelo coeficiente de transmissão entre essas camadas. A onda P6 é então propagada até a interface entre as camadas 2 e 3, aonde chega com amplitude
AMr 23.
Ao fim desse processo, a onda P1 terá sido submetida a uma atenuação por litologia igual
a:
2Ct 12 x Ct2i x Cr23,
e a uma atenuação por divergência igual a:
1
^3hi + 3h2 V1
o que nos leva a uma atenuação efetiva igual a:
2CT12 x CT21 x CR23
y/3hi + 3h2 Vi
Desse modo, a amplitude esperada para a onda AMrP3 pode ser definida como:
AMRP3 = AP x
2CT12 x CT21 x CR23
^3h1 + 3h2
Por meio da análise da regularidade dos resultados obtidos nesse exemplo, desenvolveu-se um algoritmo que permite predizer a amplitude que as ondas refletidas pelas camadas da subsuperfície terão ao fim do processo de migração. Trata-se de um algoritmo recursivo, baseado em três elementos básicos que podem ser calculados pela combinação das equações 3.29, 3.6 e
3.26.	São eles:
■	A atenuação por litologia que a onda sísmica sofre ao ser transportada de uma camada para a outra, entre as diversas camadas que formam a subsuperfície. Esse cálculo inclui tanto a atenuação sofrida no processo de modelagem quanto no processo de migração. Para fins de cálculo, a atenuação assim calculada é passada implicitamente de uma camada para a outra por meio da amplitude da onda que é transmitida, aqui denotada por At.
■	O raio efetivo até a camada atual, o qual é passado recursivamente para a camada seguinte para que seja utilizado no cálculo do raio efetivo das próximas camadas.
■	A atenuação que a onda sísmica sofre ao ser refletida na interface entre duas camadas.
A fim de simplificar a implementação desse algoritmo, considerou-se que, ao passar por uma camada, a frente da onda já sofre toda a atenuação por litologia prevista para os processos de modelagem e migração que envolvem essa camada. Esse procedimento inclui as duas passagens que a onda sísmica faz no sentido direto e uma no sentido inverso. Dessa forma verifica-se que a
amplitude da onda a ser transferida à próxima camada pode ser definida pela equação 3.14 da seguinte forma:
2Vn+i	2Vn	2Vn+i
At = -------- x ------- X -------- X Ap,
1	Vn + Vn+1 Vn + Vn+1 Vn + Vn+1	P’
que pode ser expresso de maneira simplificada por:
At =
(Vn + Vn+1)3
x Ap,
em que AP denota a amplitude do pulso inserido na camada atual, AT denota a amplitude do pulso propagado para a próxima camada e Vn e Vn+1 denotam respectivamente as velocidades da camada atual e a velocidade da próxima camada.
Em seguida, pode-se predizer a amplitude que a onda refletida em cada uma das camadas em subsuperfície vai ter ao fim do processo de migração, denotada por ARM, por meio da combinação das equações 3.26, 3.27 e 3.6 e da amplitude da onda inserida na respectiva camada, resultando em:
1
arm =
Vn
V0+ '
Vn+1 - Vn
Vn + Vn+1
Ap,
em que V0, Vn e Vn+1 representam respectivamente a velocidade da primeira camada, a velocidade da camada atual e a velocidade da próxima camada; hn e rn-1 representam respectivamente a profundidade interna da camada atual e o raio efetivo até chegar à camada atual; AP representa a amplitude do pulso inserido na camada atual.
No algoritmo proposto, foram utilizadas as equações 3.30 e 3.31 em conjunto, a fim de determinar a menor amplitude esperada ao fim do processo de migração para as ondas refletidas nas diversas camadas em subsuperfície, denotada por Amin. Essa amplitude será então utilizada para determinar a precisão numérica necessária ao processamento desse modelo. O fluxograma desse algoritmo é apresentado na Figura 3.22.
Figura 3.22: Algoritmo utilizado para a predição da menor amplitude das ondas sísmicas refletidas.
Na primeira chamada do algoritmo, o raio efetivo, r0, é carregado com zero, a amplitude mínima, Amim, é carregada com 10000. Isso é feito a fim de garantir que essa amplitude seja, já na primeira iteração do algoritmo, substituída pela amplitude da onda refletida entre a primeira e a segunda camada. AP é carregado com a amplitude da onda gerada pelo pulso sísmico para uma camada de velocidade igual à velocidade da primeira camada do modelo.
Durante a sua execução, a cada nova iteração, o algoritmo calcula recursivamente a amplitude que a onda refletida em cada camada terá ao fim do processo de migração. Dessa forma, a cada nova camada encontrada no modelo geológico utilizado, verifica-se se a amplitude refletida nessa camada é menor que a menor amplitude encontrada até então. Caso seja, esta é tida como a nova amplitude mínima e Amin é atualizado.
A Figura 3.23 apresenta os elementos gerados ao longo da execução do algoritmo proposto, destacando as incidências dos coeficientes de transmissão entre as camadas, a evolução do raio efetivo e o coeficiente de reflexão entre a última e a penúltima camada.
Figura 3.23: Identificação dos elementos gerados com a execução do algoritmo proposto.
Após a execução do algoritmo, o número de bits de precisão necessário ao processamento, aqui denotado por Nbüs, é determinado de forma a garantir um erro de representação percentual de Amin menor ou igual a um por cento, ou seja,
em que NB,ts denota o número de bits de precisão a ser utilizado, f.^ denota a operação teto da representação e |. | denota a operação valor absoluto da representação.
4
Estudo de Caso
Sendo este um trabalho multidisciplinar, envolvendo processamento geofísico e engenharia da computação, a sua validação foi feita em duas etapas, primeiramente por meio de um conjunto de experimentos nos quais se pode atestar a aplicabilidade da metodologia desenvolvida e, em seguida, por meio da implementação de um núcleo de processamento aritmético para uma plataforma de processamento de alto desempenho dedicada à execução do algoritmo RTM.
4.1	Experimentos de validação da metodologia
Os experimentos de validação da metodologia foram realizados por meio da predição das precisões numéricas necessárias ao imageamento de um conjunto de modelos geológicos sintéticos de baixa complexidade, formado por camadas paralelas planas e horizontais, os quais foram elaborados em colaboração com especialistas da área de Geologia. Estes modelos foram concebidos com o objetivo de representar as configurações litológicas normalmente encontradas em subsuperfície em regiões de prospecção de hidro-carbonetos.
Além desses modelos mais simples, foi utilizado também um modelo mais complexo conhecido como modelo de Marmousi (MARTIN; WILEY; MARFURT, 2006), o qual é um modelo de referência largamente empregado na validação de novos algoritmos e processos aplicados ao imageamento sísmico.
Para cada um desses modelos, o estudo de casos consistiu em aplicar a metodologia apresentada na Seção 3.5, identificar a precisão numérica necessária ao seu imageamento e comparar a qualidade do imageamento obtido nessa precisão com a qualidade do imageamento obtido em outras precisões numéricas.
As Figuras 4.1 e 4.2 trazem as configurações litológicas de cada um dos modelos utilizados. As dimensões indicadas nas figuras, tanto no sentido horizontal quanto no vertical, são relativas à quantidade de pontos na matriz por meio da qual os modelos foram representados, ou seja, ao grid espacial de cada modelo. Todos os modelos foram representados utilizado-se um intervalamento espacial de 4,12 metros.
11J		50	100	150	200	250
		1500 m/s			h=90
	100 -				
	1-4200..^	2200 m/s			h=110
	■ 3525				
	300-	1900 m/s			h=125
	- 2175400_				
	■ 1500	2600 m/s			h=160
	500 _				
	300 -	3500 m/s			h=145
	700-	4200 m/s			h=120
Modelo.l
	0	50	100 1	150	200 1	250 1
	100 -	3700 m/s				
	r5600._	2800 m/s				h=93
						
	- 4900					
		4000 m/s				h=93
	300-					
	-4200					
		4500 m/s				h=69
	-3500 40() _					
	- 2800	5100 m/s				h=114
	500 -					
	600 -					
	700-					
		5600 m/s				h=279
Modelo_2
		50	100	150	200	250
	100-	1400 m/s				h=172
	1-5200... 200-					
	-4250	2300 m/s				h=88
	300 -					
	- 3300	3200 m/s				h=124
	-2350400-					
	-1400					
	500-	4100 m/s				h=128
	600-					
	700 -	5200 m/s				h=238
Modelo_3
:j J		50	100 1	150	200 1	
		1600 m/s				h=35
	100-	2200 m/s				h=73
	4900	4600 m/s				h=82
	200-					
	- 4075 300	2800 m/s				h=no
	- 3250					
	-2425400-					
	-1600 500-					
	600-	3000 m/s				h=340
		4900 m/s				lt=45
	700-	4100 m/s				h=65
				Modelo 4		
4300 m/s	h=S4
2200 m/s	h=90
3000 m/s	h=246
1900 m/s	h=29
_3800 m/s	h=150
5100 m/s	h=24
1600 m/s	h=114
Figura 4.2: Estruturas geológicas do modelo 5 e do modelo de Marmousi.
A Tabela 4.1 apresenta tanto as precisões numéricas encontradas quanto as menores amplitudes esperadas para as ondas sísmicas durante a execução do algoritmo RTM para cada um desses modelos.
Tabela 4.1: Menor amplitude e precisões numéricas preditas para os modelos geológicos avaliados
Modelo	Menor Amplitude	Precisão Numérica (No de bits)
Modelo 1	8.98 x 10-5	21
Modelo 2	1.65 x 10-5	23
Modelo 3	1.1 x 10-4	20
Modelo 4	3.07 x 10-5	21
Modelo 5	5.68 x 10-5	21
Marmousi	3.08 x 10-5	22
As Figuras 4.3,4.4, 4.5, 4.6,4.7 e 4.8 apresentam os resultados do imageamento de cada um dos modelos em precisões acima e abaixo dos valores preditos. Essas Figuras também podem ser vistas em tamanho grande nos Apêndices de A a F
Figura 4.3: Resultados obtidos com o processamento com o Modelo 1.
18 bits	20 bits
Figura 4.4: Resultados obtidos com o processamento com o Modelo 2.
Figura 4.5: Resultados obtidos com o processamento com o Modelo 3.
Figura 4.6: Resultados obtidos com o processamento com o Modelo 4.
Figura 4.7: Resultados obtidos com o processamento com o Modelo 5.
Figura 4.8: Resultados obtidos com o processamento com o Modelo de Marmousi.
4.1.1	Métrica de avaliação da qualidade das imagens geradas
Para a avaliação da qualidade das imagens geradas com operadores aritméticos de menor precisão, foram utilizadas duas métricas distintas: a relação sinal-ruído, SNR, e o índice universal de qualidade de imagens (WANG; BOVIK, 2002), UQI, descritas na seção 2.2.
O objetivo da adoção conjunta dessas duas métricas foi avaliar não apenas o grau de semelhança entre as imagens geradas, mas também identificar o grau de sensibilidade do imageamento gerado por meio do algoritmo RTM com o nível de ruído introduzido com a precisão numérica adotada em sua execução.
As Figuras 4.9, 4.10, 4.11, 4.12 e 4.13 relacionam os valores encontrados com amétrica UQI em comparação com o SNR para cada um dos modelos avaliados.
Figura 4.9: Valores encontrados com a métrica UQI em comparação com o SNR para o modelo 1
Figura 4.10: Valores encontrados com a métrica UQI em comparação com o SNR para o modelo 3
Figura 4.11: Valores encontrados com a métrica UQI em comparação com o SNR para o modelo 4
Figura 4.12: Valores encontrados com a métrica UQI em comparação com o SNR para o modelo 5
Figura 4.13: Valores encontrados com a métrica UQI em comparação com o SNR para o modelo de Marmousi
4.1.2	Discussão dos resultados
Com base na análise da qualidade das imagens geradas, verifica-se que a metodologia desenvolvida neste trabalho foi capaz de predizer, com uma margem de segurança entre 1e 2 bits, a precisão numérica a partir da qual as imagens podem ser consideradas como aceitáveis. A Tabela 4.2 permite fazer uma comparação entre as precisões numéricas preditas e as precisões numéricas a partir das quais as imagens geradas passam a permitir a identificação de todas as camadas em subsuperfície.
Tabela 4.2: Comparação entre as precisões numéricas preditas e as precisões numéricas
encontradas
Modelo	Precisão predita (N°deBits)	Precisão encontrada (N°deBits)
Modelo 1	21	20
Modelo 3	20	19
Modelo 4	21	19
Modelo 5	21	19
Marmousi	22	20
Outro ponto a destacar nos resultados obtidos é quanto à sensibilidade do algoritmo RTM em relação ao nível de ruído gerado com o processamento.
Observa-se por meio dos gráficos das Figuras 4.9, 4.10, 4.11,4.12e4.13,em comparação com as precisões registradas na Tabela 4.2, que todas as imagens geradas com uma relação sinal-ruído melhor que 20 dB, além de permitirem uma identificação clara e precisa de todas camadas em subsuperfície, não apresentam artefatos que posam levar a uma má interpretação das estrtuturas ali existentes. Essa informação é importante porque permite estabelecer um limiar de
segurança para o nível de ruído que pode ser introduzido durante a execução do algoritmo RTM sem que seja comprometida a qualidade do imagemaneto gerado .
4.2	Desenvolvimento do núcleo de processamento aritmético
O núcleo de processamento aritmético desenvolvido como parte deste estudo de caso, aqui denotado como Processing Element (PE)1, é o módulo de hardware que implementa o operador de diferenças finitas descrito por meio da equação 2.3, que, para facilitar a leitura desta seção, se encontra transcrita a seguir.
Ci,j =absi x absj x
(2Bijj + absi x absj x Velfj x fat x
(16 x (Bi,j+1 + Bi,j—1 + Bi+1,j + Bi—1,j)
—	1 x (Bi,j+2 + Bi,j—2 + Bi+2,j + Bi—2,j)
-	60 x Bij
) - AiJ
)
Para fins de avaliação do custo de implementação em hardware e da qualidade do imageamento gerado, foi necessário implementar três versões do PE.
A primeira versão, baseada na aritmética de ponto-flutuante, foi construída utilizando módulos de hardware gerados automaticamente por meio da ferramenta Quartus II (ALTERA, 2014). Essa versão foi implementada utilizando o tipo de dado shortreal2 da linguagem System Verilog (IEEE, 2013), por esse motivo, denominada PE-Float Altera.
A segunda versão também foi baseada na aritmética de ponto-flutuante. Entretanto, diferentemente da primeira versão, nessa os operadores aritméticos de ponto-flutuante utilizados foram implementados por meio do tipo de dado logic e dos operadores lógicos e aritméticos para inteiros disponíveis na linguagem System Verilog. Essa versão foi denominada PE-Float.
A terceira versão foi baseada na aritmética de ponto-fixo. Essa versão também foi implementada por meio do tipo de dado logic e dos operadores lógicos e aritméticos para inteiros disponíveis na linguagem System Verilog. Essa última versão recebeu a denominação de PE-Fixo.
A plataforma para a qual esse núcleo de processamento foi desenvolvido faz parte de um projeto de pesquisa mais amplo, conveniado entre o Centro de Informática da UFPE e o Centro de Pesquisa e Desenvolvimento da Petrobras (CENPES), e teve como requisito de validação o
1 PE é a abreviação da expressão inglesa Process Element, utilizada neste contexto com o significado de elemento ou núcleo de processamento.
2O tipo de dado shortreal implementa o ponto-flutuante de precisão simples na linguagem SystemVerilog. Ele equivale ao tipo de dado float da linguagem C.
imageamento do modelo geológico de Marmousi (MARTIN; WILEY; MARFURT, 2006).
4.3	Projeto dos núcleos de processamento baseados em aritmética de ponto-flutuante
O fluxo de projeto do PE-Float Altera foi extremamente simples. Por ter sido construído diretamente por meio do tipo de dado shortreal, o seu fluxo de projeto consistiu basicamente em um arquivo na linguagem System Verilog, no qual as várias operações aritméticas existentes no núcleo de processamento foram mapeadas e interconectadas conforme apresentado na Figura 4.14 a seguir.
Como toda a estrutura dos módulos aritméticos foi gerada automaticamente pelo Quartus II, com total garantia de compatibilidade com o que estabelece o padrão IEEE-754, a sua
validação exigiu apenas uma sequência de testes a fim de garantir o mapeamento das conexões existentes entre esses módulos.
O fluxo de projeto do PE-Float, por outro lado, exigiu um grande esforço, tanto para ser implementado, quanto para ser validado. Apesar da linguagem System Verilog dispor de suporte ao tipo de dados de ponto-flutuante, através do tipo real, na prática os módulos de hardware gerados com esta abordagem não são uma boa opção para o desenvolvimento de módulos de processamento de alto desempenho, isso porque, à semelhança dos módulos gerados pelo Quartus II, cada operação aritmética utilizada no PE será instanciada como um módulo aritmético completo, com diversas estruturas redundantes e que acabam tendo um impacto muito negativo no processo de otimização do PE.
Dessa forma, a fim de atingir maior desempenho com menor custo de implementação em hardware, o PE-Float foi desenvolvido dentro de uma metodologia denominada Fused Data Path3 (BERKELEY DESIG TECHNOLOGY INC, 2012). Nessa metodologia múltiplas operações de ponto-flutuante são implementadas como se formassem uma única operação com múltiplos argumentos, com uma só etapa de desempacotamento dos dados no início da primeira operação e uma só etapa de normalização e arredondamento ao término da última operação.
Desse modo, foi possível obter uma economia de aproximadamente 95% no hardware destinado ao arredondamento e à normalização dos resultados.
Para simplificar esse processo, dividiu-se o projeto em vários módulos de hardware menores, organizados por meio das operações aritméticas constantes no operador de diferenças finitas em uma estrutura que pode ser vista na Figura 4.15.
3Fused Data Path foi uma designação criada para definir uma metodologia que propõe que múltiplas operações aritméticas de ponto-flutuante sejam vistas como uma única operação, na forma de um único caminho de dados.
Figura 4.15: Estrutura interna utilizada na implementação do PE-Float.
		
	Multiplica_Abs_1	
			
—		—
	Soma_2Bij_NS	
				/
Uma vez que cada um dos módulos presentes nessa estrutura foi inteiramente descrito através da linguagem System Verilog, foi necessário testá-los e validá-los individualmente contra um modelo de referência implementado na linguagem C++.
O uso da metodologia Fused Data Path exigiu um cuidado especial de modo a garantir que não ocorressem perdas de precisão nos resultados obtidos com o PE-Float. O projeto de hardware de cada um dos seus módulos internos teve de ser feito de modo a operar e a propagar de maneira exata os resultados provenientes dos módulos anteriores. No padrão IEEE 754, esse modo de operação é denominado operação em precisão infinita (P754, 1985).
A seguir, serão descritas as funcionalidades e os detalhes de implementação de cada um dos módulos que formam o PE-Float.
4.3.1	Módulo Multiplica 2Bij
Esse módulo é responsável ao mesmo tempo por converter o valor de Bi,j do padrão de ponto-flutuante para ponto-fixo, e por multiplicar o valor convertido por dois. Sua estrutura interna pode ser vista na Figura 4.16 a seguir.
Figura 4.16: Estrutura interna do módulo Multiplica_2Bij.
O módulo Desnormalizador é responsável por gerar uma versão em ponto-fixo, da magnitude de 2 x B,.j. Primeiramente é efetuada a reconstrução do significando de Bi,j, por meio da recuperação do bit implícito da sua mantissa. Em seguida, efetua-se um ajuste no significando recuperado, de forma que esse passe a representar o dobro da magnitude de B,.j no padrão de ponto-fixo. Esse ajuste é feito por meio de deslocamentos sucessivos do conteúdo do significando. A quantidade e a direção desses deslocamentos é calculada por meio da expressão
nShift = Exp - BIAS - PRECISAO_OPERANDOS + 1,
em que: nShift representa o número de vezes e o sentido dos deslocamentos a serem aplicados no significando de B,.j; BIAS é o valor de referência para a representação do campo expoente em ponto-flutuante; Exp é o valor representado através do campo Expoente. PRECISAO_OPERANDOS é a constante de configuração que determina a precisão com que a amplitude de pressão da frente de onda é representada e a constante +1 representa a multiplicação do significando por 2.
Quando nShift é positivo, o significando é deslocado nShift vezes para a esquerda e, quando nShift é negativo, o significando é deslocado nShift vezes para a direita.
Na segunda etapa do processo de conversão, o significando, assim obtido, é então convertido do modo de sinal-magnitude para o modo de complemento a dois.
4.3.2	Módulo Absi_Absj
Esse módulo é responsável por efetuar a multiplicação das constantes de absorção de bordas, utilizadas para modelar o meio semi-infinito. Sua estrutura interna pode ser vista na Figura 4.17.
Nesse módulo, à semelhança do módulo anterior, a primeira parte da operação consiste na conversão dos operandos do formato de ponto-flutuante para o formato de ponto-fixo, o que é feito por meio dos módulos desnormalizadores. Em seguida, os significandos obtidos são multiplicados entre si. Por fim, o resultado obtido é arredondado para a precisão estabelecida
para a representação das constantes de absorção das bordas.
Figura 4.17: Estrutura interna do módulo Absi_Absj.
4.3.3	Módulo Menos_Aij
Este módulo converte o valor de Ai, j de ponto-flutuante para ponto-fixo, ao mesmo tempo em que o multiplica por -1. Sua estrutura interna está ilustrada na Figura 4.18.
A primeira parte da operação consiste na conversão dos operandos do formato de ponto-flutuante para o formato de ponto-fixo. Em seguida, obtém-se o negativo do valor de Ai,j pela inversão do sinal de Ai,j no momento da conversão do significando para o formato de complemento a dois.
Figura 4.18: Estrutura interna do módulo Menos_Aij.
4.3.4	Módulo Vel_Vel_Fat
Este módulo efetua a operação Veli, j x Veli, j x FAT. Sua estrutura interna pode ser vista
na Figura 4.26.
Seu funcionamento é muito parecido com o funcionamento do módulo Absi_Absj. O único destaque é a operação de elevar Vel ao quadrado, que é feita simplesmente multiplicando-se seu valor já desnormalizado por ele mesmo.
Figura 4.19: Estrutura interna do módulo Vel_Vel_Fat.
4.3.5	Módulo Núcleo_Soma
Este módulo é responsável por efetuar a operação
16 X	+ Bi-1,j + Bi,j+1 +	— 1 x (Bi+2,j + Bi-2,j + Bi,j+2 + Bi,j—2) — 60 X Bi,j.
Para simplificar sua implementação, esse módulo foi dividido em três módulos menores denominados M16Soma, MISoma e M60, conforme indicado na Figura 4.20.
Figura 4.20: Estrutura interna do módulo Núcleo Soma.
A estrutura interna de cada um desses módulos pode ser vista respectivamente nas Figuras
4.21, 4.22 e 4.23.
Figura 4.21: Estrutura interna do módulo M16Soma.
Figura 4.22: Estrutura interna do módulo MISoma.
60*5,
Figura 4.23: Estrutura interna do módulo M60.
A exemplo dos módulos anteriores, a primeira etapa de funcionamento desses módulos é a conversão dos operandos do formato de ponto-flutuante para o formato de ponto-fixo, o que é feito por intermédio dos módulos conversores. A estrutura interna desse módulos pode ser vista na Figura 4.24.
Mantissa
Ponto-Flutuante
Desnormalizador
Complemento a Dois
Ponto-Fixo
PRECISAO_OPERAÇÃd
I
Figura 4.24: Estrutura interna do módulo Conversor.
O funcionamento de cada módulo conversor é idêntico ao que já foi apresentado para a primeira etapa de operação dos outros módulos. Ou seja, cada módulo conversor recebe, além do operando a ser convertido, uma constante com a precisão a ser utilizada na conversão do operando do padrão de ponto-flutuante para ponto-fixo.
Para o módulo M60, a precisão de operação fornecida ao módulo conversor é de 23 bits.
Já para os módulos M16Soma e MISoma, a precisão de operação é definida com base no expoente do operando de maior magnitude dos quatro que são fornecidos a cada um desses módulos. Essa comparação é feita por um módulo que compara simultaneamente os expoentes dos quatro operandos, conforme ilustrado na Figura 4.25, retornando o maior dentre eles.
Exp.1 Exp.2 Exp.3 Exp.4
JlA
Comparador
I
Expoente Operação
Figura 4.25: Estrutura interna do módulo Comparador.
A fim de permitir ainda maior economia de hardware, as operações de multiplicação por 16, -1 e -60 da equação 2.3 foram aqui substituídas por operações mais simples, que dispensam o uso de blocos multiplicadores em hardware.
No Módulo M16Soma, conforme se pode observar na última parte da Figura 4.21, a operação de multiplicação por 16 foi substituída pela inclusão de quatro zeros à direita do resultado obtido pela soma dos operandos.
No Módulo M1Soma, a multiplicação por menos um foi substituída pela subtração do resultado obtido de zero, conforme indicado na última parte da Figura 4.22.
No Módulo M60, a multiplicação por 60 foi substituída pela multiplicação do operando Bi, j ao mesmo tempo por 64, pela inclusão de 6 zeros à direta do valor convertido para ponto-fixo, e por 4, pela inclusão de 2 zeros. Os valores assim obtidos são então subtraídos um do outro dando como resultado o valor correto de 60 x Bi,j, conforme indicado na Figura 4.23.
4.3.6	Módulo Multiplica_V2FAT_NS
Este módulo multiplica o resultado obtido no módulo Núcleo_Soma com o resultado obtido no módulo em Vel_Vel_Fat, arredondando o resultado final para a precisão definida para essa operação.
4	
	&lt;	X Conv. Mag. Sinal&amp;lt;		J
Figura 4.26: Estrutura interna do módulo Multiplica_V2FAT_NS.
4.3.7	Módulo Soma_MAij_V2FAT_NS
Este módulo efetua a adição do resultado obtido no módulo Multiplica_V2FAT_NS com o resultado obtido no módulo Menos_Aij, propagando o resultado obtido, com precisão infinita, para o módulo seguinte.
Menos_Aij Multiplica_V2FAT_NS
V
MAij_V2FAT_NS
Figura 4.27: Estrutura interna do módulo Soma_MAij_V2FAT_NS.
4.3.8	Módulos Multiplica_ABS_1 e Multiplica_ABS_2.
Os módulos Multiplica_ABS_1 e Multiplica_ABS_2 têm um mesmo hardware interno, que pode ser visto na Figura 4.28.
Resultado de Maij V2FAT NS
Vel2FAT_NS
Figura 4.28: Estrutura interna dos módulos Multiplica_ABS_1 e Multiplica_ABS_2.
O destaque nesses módulos é a conversão da representação de complemento a dois para magnitude e sinal antes da operação de multiplicação, e o retorno para a representação em complemento a dois após a operação. Essa conversão faz-se necessária a fim de simplificar o hardware que efetua a multiplicação. Propaga-se o resultado obtido para o módulo seguinte com precisão infinita.
4.3.9	Módulo Soma_2Bij_NS
Este módulo efetua a adição do resultado obtido no módulo Multiplica_2Bij com o resultado obtido no módulo Multiplica_Abs1, propagando o resultado obtido para o módulo seguinte. Sua estrutura interna encontra-se na Figura 4.29.
Mulriplica_2Bij Multiplica_Abs_1
2Bij_NS
Figura 4.29: Estrutura interna do módulo Soma_2Bij_NS.
4.3.10	Módulo Normaliza e Arredonda
Este módulo é responsável por converter o valor final do operador de diferenças finitas do padrão de ponto-fixo para o padrão de ponto-flutuante.
Normaliza
NSHIFT
ç-------------
Analiza_Norm
L_____________
Multiplica_Abs_2
, r
- Conv_Mag_Sig
l/
•	■
		1 Arredonda 		
	
Mantissa
Figura 4.30: Estrutura interna do módulo que normaliza e arredonda os resultados.
A primeira etapa do processo de conversão consiste em primeiramente converter o valor recebido do modo de complemento a dois para o modo de magnitude e sinal. Em seguida, coloca-se o valor convertido no formato normalizado. Para tanto, analisa-se o seu conteúdo para verificar quantas vezes será necessário deslocá-lo para a direita ou para a esquerda até que sua parte inteira fique igual a 1. Essa análise é feita pelo módulo Analiza_Norm da Figura 4.30. O resultado obtido dessa análise, NSHIFT, assume valores positivos para indicar a necessidade de deslocamentos à direita e valores negativos para deslocamentos à esquerda. NSHIFT é utilizado ao mesmo tempo tanto para efetuar a normalização quanto como base ao cálculo do valor do campo expoente.
O resultado obtido após a normalização é então arredondado para 23 bits de precisão.
Nesse projeto, a fim tornar a implementação desse módulo mais simples em hardware, adotou-se o arredondamento para mais próximo ou mais infinito no lugar do arredondamento para mais próximo ou par.
O arredondamento para mais próximo ou mais infinito arredonda o valor obtido para o número representável mais próximo ou, em havendo empate, para o primeiro número representável de maior magnitude que o número a ser arredondado.
Dessa forma, a implementação do módulo arredondador da Figura 4.30 consistiu simplesmente em somar o vigésimo quarto bit à direita do ponto decimal do valor normalizado à palavra binária formada até essa posição, desprezando todos os bits que estão além desse.
4.4	Projetos dos núcleos de processamento baseados em aritmética de ponto-fixo
A implementação do núcleo de processamento baseado no padrão de ponto-fixo, denominado PE-Fixo, foi estruturada conforme apresentado na Figura 4.31.
Figura 4.31: Estrutura interna do módulo de hardware que implementa o núcleo de processamento 2D no padrão de ponto-fixo.
Observa-se que, à exceção da ausência do Módulo de Normalização e Arre
5
Conclusões e trabalhos futuros
Os resultados obtidos por meio dos experimentos de validação apresentados no Capítulo 3, bem como o estudo de caso real apresentado no Capítulo 4 permitem concluir que este trabalho atingiu seus objetivos. Sua aplicação tornou possível verificar a sua hipótese inicial e estabelecer que:
A definição da precisão numérica necessária ao processamento de dados sísmicos por meio do algoritmo RTM está diretamente ligada às litologias das camadas em subsuperfície.
Ou seja, por meio dos resultados obtidos neste trabalho, pode-se afirmar que a precisão numérica necessária para a execução do algoritmo RTM não pode ser estabelecida unicamente pela análise do imageamento gerado por meio de um modelo geológico de referência, a exemplo do que se verificou em todos os trabalhos pesquisados (HE; LU; SUN, 2004; ARAYA-POLO et al., 2011; CLAPP; FU; LINDTJORN, 2010; FU et al., 2008, 2009; HE; ZHAO; LU, 2005a,b; PELL et al., 2013; BARROS et al., 2011; BRAGANçA et al., 2013; MEDEIROS et al., 2013). A não ser que esse modelo seja compatível com as litologias que se espera encontrar na região a ser imageada.
Para chegar a esses resultados, foi desenvida uma metodologia inédita que permite determinar de maneira automática, por meio de um programa de computador, qual a precisão numérica necessária à execução do algoritmo RTM de acordo com as características do meio a ser imageado.
Vale resslatar que essa metodologia foi baseada em um método analítico inédito, também desenvolvido neste trabalho.
Uma outra contribuição original deste trabalho, o conceito do raio efetivo, definido pela Equação 3.26, transcrita a seguir:
rE (fiz) = £ V x (i - hi)
permite modelar de maneira eficiente a atenuação por divergência da frente de onda em modelos geológicos com diversas camadas.
Sua utilização tornou-se elemento-chave no processo da predição da atenuação sofrida pelas ondas sísmicas durante a execução do algoritmo RTM, uma vez que permitiu o cálculo em separado das atenuações em razão da divergência da frente de onda e das configurações litológicas das camadas em subsuperfície.
Até onde foi possível investigar, esta foi também uma abordagem original, não tendo sido encontrada em nenhuma das fontes consultadas, sendo, por conseguinte, uma contribuição importante deste trabalho para esta área de pesquisa.
Outro ponto a ser destacado foi a abordagem utilizada na predição das amplitudes das ondas transmitidas entre as camadas em subsuperfície e na predição das amplitudes com que essas ondas chegam à superfície ao término do processo de migração, Equações 3.30 e 3.31,
transcritas a seguir:	A	8Vn+1Vn „ A AT =(Vn -+Vn+ty X A
arm =
1
X
Vn+1 - Vn
Vn + Vn+1
X AP
Vn
V0+r"-'
Foi o estabelecimento dessas equações que permitiu o desenvolvimento do algoritmo recursivo apresentado na Figura 3.22, o qual serviu de base à implementação da metodologia descrita neste trabalho.
Uma última contribuição deste trabalho à área do processamento sísmico diz respeito à verificação da sensibilidade do algoritmo RTM ao nível de ruído introduzido com o processamento dos dados. Evidenciou-se por meio dos experimentos realizados que é necessário um SNR melhor que 20dB nas imagens geradas para que se obtenha um imageamento no qual todas as camadas em subsuperfície sejam evidenciadas, o que corresponde a um UQI maior que 50%. Em todos os experimentos, esse limiar foi alcançado ao ser estabelecido um erro de representação percentual menor ou igual a 1% para as amplitudes das ondas sísmicas ao fim do processo de migração.
5.1	Trabalhos futuros
A fim de dar continuidade a este trabalho, verifica-se a necessidade de que tanto o método analítico quanto a metodologia aqui desenvolvidos sejam estendidos de modo a incluir fenômenos físicos dissipativos e de multipercurso.
É necessário também, que seja incluído no método o cálculo da relação entre a amplitude da onda gerada pela inserção do pulso sísmico e a velocidade da camada em que esse se insere.
Outro ponto importante ainda a ser trabalhado é o desenvolvimento de uma segunda versão dessa metodologia, que permita trabalhar com modelos de três dimensões, o que envolverá a adaptação das Equações 3.30 e 3.31 para trabalhar em duas e três dimensões.
Deve-se verificar também a aplicabilidade dessa metodologia para a predição da precisão numérica necessária à execução de outros algoritmos de imageamento sísmico.
Pode ser investigado ainda a aplicabilidade do conceito do raio efetivo como instrumento na geração ou validação de modelo de velocidades do meio criados a partir de sismogramas reais capturados em campo. Em uma análise preliminar, baseada nos resultados obtidos nos experimentos de validação da metodologia, verificou-se que o conceito do raio efetivo pode vir a se constituir um bom indicador da relação entre as velocidades de propagação da primeira camada e das demais camadas do meio, uma vez que apenas quando esta relação está correta é possível alcançar o cancelamento total da atenuação por divergência, o que pode ser facilmente verificado por meio dos gráficos gerados.
Por fim, é necessário que o algoritmo recursivo seja estendido a fim de poder receber como entrada arquivos com modelos de velocidade nos formatos su (CWP-SU, 2012) e segy (BARRY; CAVERS; KNEALE, 1975). Atualmente esse algoritmo trabalha apenas com modelos de velocidade representado por meio de arquivos binários planos, sem formatação, ou ainda através de modelos de velocidade descritos manualmente pelo usuário.
Referências
ABREO, S. et al. Alternative computing platforms to implement the seismic migration. In: GOMES, J. S. (Ed.). New technologies in the oil and gas industry. New York: Intech, 2012. p. 83-102.
ALTERA. QuartusII. Acessado em 1 fev. 2014, Disponível em:&amp;lt;http://dl.altera.com/?edition=subscription&gt;.
ANDRAKA, R. A survey of CORDIC algorithms for FPGA based computers. In: ACM/SIGDA SIXTH INTERNATIONAL SYMPOSIUM ON FIELD PROGRAMMABLE GATE ARRAYS,
1998.,	Monterey. Proceedings... ACM, 1998. p. 191-200.
ARAYA-POLO, M. et al. Assessing accelerator-based HPC reverse time migration. IEEE Transactions on Parallel and Distributed Systems, [S.l.], v. 22, n. 1, p. 147-162, Jan 2011.
BARROS, A. C. Implementação em FPGA de um módulo multiplicador e acumulador aritmético de alto desempenho para número em ponto flutuante de precisão dupla, padrão IEEE 754. 2008. Dissertação de Mestrado — Maste’s thesis, CIn-UFPE. Universidade Federal De Pernambuco, Recife, Pernambuco.
BARROS, A. C. et al. Implementation of a double-precision multiplier accumulator with exception treatment to a dense matrix multiplier module in FPGA. In: ANNUAL SYMPOSIUM ON INTEGRATED CIRCUITS AND SYSTEM DESIGN - SBCCI ’08, 21., New York, New York, USA. Proceedings... ACM Press, 2008. p. 40-45.
BARROS, A. C. et al. Performance evaluation model based on precision reduction and FPGAs applied to seismic modeling. In: SIMPÓSIO EM SISTEMAS COMPUTACIONAIS (WSCAD-SSC),, Petrópolis, RJ. New York. Proceedings... IEEE, 2011. p. 2-2.
BARRY, R. M.; CAVERS, D. A.; KNEALE, C. W. Recommended standards for digital tape formats: geophysics. Geophysics, [S.l.], v. 40, n. 2, p. 344-352, Apr. 1975.
BAYSAL, E.; KOSLOFF, D. D.; SHERWOOD, J. W. Reverse time migration. Rev Geophysics, [S.l.], v. 48, n. 11, p. 1514-1524, 1983.
BERKELEY DESIG TECHNOLOGY INC, S. of. An Independent Analysis of Altera's FPGA Floating-Point DSP Design Flow. [S.l.]: Berkeley Design Technology, 2012.
BOORE, D. M. Finite difference methods for seismic wave propagation in heterogeneous materials. In: BOLT, B. A.; ALDER, B. J.; FERNBACH, S. (Ed.). Methods in computational physics: advances in research and applications. New York: Academic Press, 1972. v. 11, p.
1-37.
BRAGANçA, R. et al. Seismic Modeling and RTM Migration on unconventional Hardware. In: INTERNATIONAL CONGRESS OF BRAZILIAN GEOPHYSICAL SOCIETY &amp;amp; EXPOGEF,
13.,	Rio de Janeiro. Proceedings... [S.l.: s.n.], 2013.
BULCãO, A. Modelagem e migração reversa no tempo empregando operadores elásticos e acústicos. 2004. Tese de Doutorado — Instituto Alberto Luiz Coimbra de Pós-Graduação e Pesquisa de Engenharia, Coppe UFRJ. Rio de Janeiro.
CHEN, P et al. Acceleration of the long read mapping on a PC-FPGA architecture (abstract only). In: ACM/SIGDA INTERNATIONAL SYMPOSIUM ON FIELD PROGRAMMABLE GATE ARRAYS, New York, NY, USA. Proceedings... ACM, 2013. p. 271-271. (FPGA ’13).
CLAPP, R. G.; FU, H.; LINDTJORN, O. Selecting the right hardware for reverse time migration. The Leading Edge, [S.l.], v. 29, n. 1, p. 48-58, 2010.
Convey Computer. The HC Series. Acessado em 20 nov. 2013, Disponível em:&amp;lt;http://www.conveycomputer.com/products/hcseries/&gt;.
CWP-SU. Programs. Acessado em 14 fev. 2014, Disponível em:&amp;lt;http://www.seismicunix.com/wZPrograms&gt;.
DANDASS, Y. et al. Accelerating string set matching in FPGA hardware for bioinformatics research. BMC bioinformatics, [S.l.], v. 9, n. 197, p. 1-11, Apr 2008.
DIMOND, R.; RACANIèRE, S.; PELL, O. Accelerating Large-Scale HPC Applications Using FPGAs. Tübingen, Germany: IEEE, 2011. 191-192p. .
DOMINGOS, L. C. G. Breve História do Petróleo. Acessado em 31 out. 2013, Disponível em:&amp;lt;http://histpetroleo.no.sapo.pt/index.htm&gt;.
DURHAM, L. S. Industry Always Enjoys Good Vibes. Acessado em 14 abr. 2013, Disponível em:&amp;lt;http://www.aapg.org/explorer/2007/02feb/vibroseis.cfm&gt;.
EVEN, G.; PAUL, W. On the design of IEEE compliant floating point units. IEEE Transactions on Computers, [S.l.], v. 49, n. 7, p. 398-413, maio 2000.
FAROOQ, U.; MARRAKCHI, Z.; MEHREZ, H. FPGA Architectures: an overview. In: Tree-based Heterogeneous FPGA Architectures: application specific exploration and optimization. New York, NY: Springer, 2012. p. 7-48.
FLYNN, M. et al. Finding Speedup in Parallel Processors. In: INTERNATIONAL SYMPOSIUM ON PARALLEL AND DISTRIBUTED COMPUTING (ISPDC), 7., Krakow, Poland. Proceedings... [S.l.: s.n.], 2008. p. 3-7.
FROHLICH, I. et al. Pattern recognition in the hades spectrometer: an application of fpga technology in nuclear and particle physics. In: IEEE INTERNATIONAL CONFERENCE ON FIELD-PROGRAMMABLE TECHNOLOGY, 2002., Hong Kong, China. New York. Proceedings... [S.l.: s.n.], 2002. p. 443-444.
FU, H. Application-Specific Number Representation. 2009. Tese de Doutorado — Imperial College London Department of Computing Application-Specific.
FU, H. et al. Accelerating seismic computations on FPGAs: from the perspective of number representations. In: EAGE CONFERENCE &amp;amp; EXHIBITION, 70., Roma, Italia. Proceedings... [S.l.: s.n.], 2008.
FU, H. et al. Accelerating seismic computations using customized number representations on FPGAs. EURASIP Journal on Embedded Systems, [S.l.], v. 2009, n. 3, p. 382983, Jan. 2009.
G1. Entenda o que é a camada de pré-sal. Acessado em: 17 out. 2013, Disponível em:&amp;lt;http://www.passeiweb.com/estudos/sala_de_aula/atualidades/ entenda_o_que_e_a_camada_de_pre-sal&gt;.
GIDEL. PROCe III: overview. Acessado em: 20 mar. 2014, Disponível em:&amp;lt;http://www.gidel.com/PROCe%20III.htm&gt;.
GOLDBERG, D. What every computer scientist should know about floating-point arithmetic. ACM Computing Surveys (CSUR), [S.l.], v. 23, n. 1, p. 5-48, 1991.
GOVINDU, G. et al. Analysis of high-performance floating-point arithmetic on FPGAs. In: INTERNATIONAL PARALLEL AND DISTRIBUTED PROCESSING SYMPOSIUM, 18., Santa Fe, New Mexico. Proceedings... IEEE, 2004. p. 149-157.
GROBE, H. Airgun-array hg.png. Acessado em: 31 out. 2013, Disponível em:&amp;lt;http://commons.wikimedia.org/wiki/File:
Airgun-array_hg.png?uselang=pt-br&gt;.
GROSSER, T. et al. Exploiting Heterogeneous Computing Platforms By Cataloging Best Solutions For Resource Intensive Seismic Applications. In: INTENSIVE 2011. THE THIRD INTERNATIONAL CONFERENCE ON RESOURCE INTENSIVE APPLICATIONS AND SERVICES, Venice, Italia. Proceedings... [S.l.: s.n.], 2011. p. 30-6.
GRULL, F. et al. Accelerating image analysis for localization microscopy with FPGAs. In: INTERNATIONAL CONFERENCE ON FIELD PROGRAMMABLE LOGIC AND APPLICATIONS (FPL), Chania, Crete, Greece. New York:. Proceedings... IEEE, 2011. p. 1-5.
GUO, Z. et al. A Quantitative Analysis of the Speedup Factors of FPGAs over Processors. In: ACM/SIGDA 12TH INTERNATIONAL SYMPOSIUM ON FIELD PROGRAMMABLE GATE ARRAYS, 2004., New York, NY, USA. Proceedings... ACM, 2004. p. 162-70. (FPGA ’04).
HE, C.; LU, M.; SUN, C. Accelerating seismic migration using FPGA-based coprocessor platform. In: ANNUAL IEEE SYMPOSIUM ON FIELD-PROGRAMMABLE CUSTOM COMPUTING MACHINES, FCCM 2004., 12., Napa, CA. New York. Proceedings... [S.l.: s.n.], 2004. p. 207-16.
HE, C.; ZHAO, W.; LU, M. Time domain numerical simulation for transient waves on reconfigurable coprocessor platform. In: ANNUAL IEEE SYMPOSIUM ON FIELD-PROGRAMMABLE CUSTOM COMPUTING MACHINES, FCCM 2005., 13., Napa, CA. New York. Anais... IEEE, 2005. p. 127-36.
HE, C.; ZHAO, W.; LU, M. FPGA-Based High-Order Finite Difference Algorithm for 2D Acoustic Wave Propagation Problems. In: ERSA 2005, Las Vegas, Nevada. Proceedings... CSREA Press, 2005. p. 267-73.
HERBORDT, M. et al. Achieving High Performance with FPGA-Based Computing. Computer, [S.l.], v. 40, n. 3, p. 50-7, 2007.
HUCKLE, T. Collection of Software Bugs. Acessado em: 19 maio 2014.
IBM. Cell Broadband Engine. Acessado em 11 nov. 2013, Disponível em:&amp;lt;https://www-01.ibm.com/chips/techlib/techlib.nsf/products/ Cell_Broadband_Engine&gt;.
IEEE. IEEE Standard for SystemVerilog-Unified Hardware Design, Specification, and
Verification Language. IEEE Std 1800-2012 (Revision of IEEE Std 1800-2009), New York, v. .,p. 1-1315, Feb. 2013.
JAMRO, E. et al. Computation acceleration on SGI RASC: fpga based reconfigurable computing hardware. Computer Science, [S.l.], v. 9, p. 21-34, 2008.
KRUEGER, J. et al. Hardware/software co-design for energy-efficient seismic modeling. In: INTERNATIONAL CONFERENCE FOR HIGH PERFORMANCE COMPUTING, NETWORKING, STORAGE AND ANALYSIS, 2011., Seattle, WA. New York, NY.
Proceedings... ACM, 2011. p. 1-73.
KULISCH, U. W.; MIRANKER, W. L. Computer Arithmetic in theory and pratice. [S.l.]: Academic Press, 1981. 1-249p..
LINDTJORN, O. et al. Beyond traditional microprocessors for geoscience high-performance computing applications. Micro, IEEE, [S.l.], v. 31, n. 2, p. 41-9, Mar-Apr 2011.
LIU, H.-W. et al. The Algorithm of High Order Finite Difference Pre-Stack Reverse Time Migration and GPU Implementation. Chinese Journal of Geophysics, [S.l.], v. 53, n. 4, p. 600-10, 2010.
LIU, M. et al. System-on-an-FPGA Design for Real-time Particle Track Recognition and Reconstruction in Physics Experiments. In: EUROMICRO CONFERENCE ON DIGITAL SYSTEM DESIGN ARCHITECTURES, METHODS AND TOOLS (DSD’08), 11., Parma, Italy. New York. Proceedings... IEEE, 2008. p. 599-605.
MARTIN, G. S.; WILEY, R.; MARFURT, K. J. Marmousi2: an elastic upgrade for marmousi. The Leading Edge, [S.l.], v. 25, n. 2, p. 156-66, 2006.
Maxeler Tecnologies. Oil &amp;amp; gas platforms. Acessado em: 25 nov. 2013., Disponível em:&amp;lt;https://www.maxeler.com/solutions/oil-gas/&gt;.
MCMECHAN, G. A. Migration by extrapolation of time-dependent boundary values. Geophysical Prospecting, [S.l.], v. 31, n. 3, p. 413-20, 1983.
MEDEIROS, V. et al. High Performance Implementation of RTM Seismic Modeling on FPGAs: architecture, arithmetic and power issues. In: VANDERBAUWHEDE, W.; BENKRID, K. (Ed.). High-Performance Computing Using FPGAs. New York: Springer, 2013. p. 305-34.
MENCER, O.; MORF, M.; FLYNN, M. PAM-Blox: high performance fpga design for adaptive computing. In: IEEE SYMPOSIUM ON FPGAS FOR CUSTOM COMPUTING MACHINES, Napa Valley, CA. New York. Proceedings... IEEE, 1998. p. 167-74.
MENEZES, G. et al. Energy Estimation Tool FPGA-based Approach for Petroleum Industry. In: INTERNATIONAL CONFERENCE ON PARALLEL PROCESSING WORKSHOPS (ICPPW), 2012, 41., Pittsburgh, PA. New York. Proceedings... [S.l.: s.n.], 2012. p. 600-1.
NEMETH, T et al. Design space analysis for the acoustic wave equation implementation on FPGA circuits. In: EAGE CONFERENCE &amp;amp; EXHIBITION, 70., Rome, Italy. Proceedings... [S.l.: s.n.], 2008.
NEMETH, T. et al. An implementation of the acoustic wave equation on FPGAs. In: SEG TECHNICAL PROGRAM EXPANDED ABSTRACTS 2008. Anais... Society of Exploration Geophysicists, 2008. p. 2874-2878. (SEG Technical Program Expanded Abstracts).
NIEMEYER, P. Os riscos do pré-sal. O Estado de S. Paulo, São Paulo. Economia &amp;amp; Negócios. Acessado em 27 out. 2013, Disponível em:&amp;lt;http://www.estadao.com.br/ noticias/impresso, os-riscos-do-pre-sal, 670213, 0 .htm&gt;.
NVIDIA. Tesla C1060 computing processor board: board specification. Acessado em 20 nov. 2013, Disponível em:
&lt;www.nvidia.com/docs/IO/56483/Tesla_C1060_boardSpec_v03.pdf&gt;.
OCEANA. Seismic Airgun Testing: overview. Acessado em: 31 out. 2013, Disponível em:&amp;lt;http://oceana.org/en/our-work/climate-energy/ seismic-airgun-testing/overview&gt;.
INSTITUTE, A. N. S. (Ed.). ANSI/IEEE 754-1985, Standard for Binary Floating-Point Arithmetic. [S.l.]: pub-IEEE-STD, 1985. 18p..
PANETTA, J. et al. Computational characteristics of production seismic migration and its performance on novel processor architectures. In: INTERNATIONAL SYMPOSIUM ON COMPUTER ARCHITECTURE AND HIGH PERFORMANCE COMPUTING, 2007. SBAC-PAD 2007., 19. Proceedings... [S.l.: s.n.], 2007. p. 11- 8.
PELL, O. Accelerating seismic processing applications with FPGAs. In: EAGE CONFERENCE &amp;amp; EXHIBITION-WORKSHOPS AND FIELDTRIPS, 72., Barcelona, Spain. Proceedings... [S.l.: s.n.], 2010.
PELL, O.; CLAPP, R. G. Accelerating subsurface offset gathers for 3D seismic applications using FPGAs. In: ANNUAL MEETING SOCIETY OF EXPLORATION GEOPHYSICISTS (SEG), 77., San Antonio, Texas. Proceedings... [S.l.: s.n.], 2007. p. 1839-43.
PELL, O. et al. Finite-Difference Wave Propagation Modeling on Special-Purpose Dataflow Machines. IEEE Transactions on Parallel and Distributed Systems, [S.l.], v. 24, n. 5, p. 906-15, 2013.
PETROBRAS. Atuação no pré-sal. Acessado em 31 out. 2013, Disponível em:&amp;lt;http://www.petrobras.com.br/pt/energia-e-tecnologia/ fontes-de-energia/petroleo/presal/&gt;.
QUACK, N.; KAKAQI, N.; FLYNN, M. On fast IEEE rounding: technical report csl-tr-91-459. Stanford, CA: Stanford University, 1991.
ROBERT E. SHERIFF, L. P. G. Exploration Seismology. 2a ed..ed. [S.l.]: Cambridge: Cambridge University Press;, 1995.
SANTORO, M. R.; BEWICK, G.; HAROWITZ, M. A. Rounding Algorithm for IEEE multiplier. In: PROCEEDING OF 9TH SYMPOSIUM ON COMPUTER ARITHMETIC. Anais... Stanford University, 1989. p. 176-83.
SANTOS, J. L. R. dos. Modelagem da equação da onda acústica aplicada ao imageamento de estruturas geológicas. 2012. Dissertação de Mestrado — Maste’s thesis, Coppe UFRJ. Rio de Janeiro: Instituto Alberto Luiz Coimbra de Pós-Graduação e Pesquisa de Engenharia.
SCHRYVER, C. de et al. An energy efficient FPGA accelerator for Monte Carlo option pricing with the Heston model. In: INTERNATIONAL CONFERENCE ON RECONFIGURABLE COMPUTING AND FPGAS (RECONFIG), Cancún, Mexico. New York. Proceedings... IEEE, 2011. p. 468-74.
SEVERANCE, C. Standards: IEEE 754: an interview with William Kahan. j-COMPUTER, [S.l.], v. 31, n. 3, p. 114-5, mar 1998.
SOARES, P. Exploração do pré-sal traz mais riscos. Folha de S. Paulo, São Paulo, 2012 mar. 25. Mercado. Acessado em: 27 out. 2013, Disponível em:
&lt;http://www1.folha.uol.com.br/mercado/ 1066916-exploracao-do-pre-sal-traz-mais-riscos.shtml&gt;.
VOSSEN, R. van; ROBERTSSON, J. O.; CHAPMAN, C. H. Finite-difference modeling of wave propagation in a fluid-solid configuration. Rev Geophys, [S.l.], v. 67, n. 2, p. 618-24, 2002.
WANG, Z.; BOVIK, A. C. A universal image quality index. IEEE Signal Processing Letters, [S.l.], v. 9, n. 3, p. 81-4, Mar. 2002.
WHITMORE, N. Iterative depth migration by backward time propagation. In: ANNUAL INTERNATIONAL MEETING - SEG, EXPANDED ABSTRACTS;, 53. Proceedings... [S.l.: s.n.], 1983. p. 827-30.
WU, E.; LIU, Y. Emerging technology about GPGPU. In: IEEE ASIA PACIFIC CONFERENCE ON CIRCUITS AND SYSTEMS (APCCAS), Macao, China. Proceedings... [S.l.: s.n.], 2008. p. 618-22.
YAMAGUCHI, Y. et al. FPGA-Based HPRC for Bioinformatics Applications. In: VANDERBAUWHEDE, W.; BENKRID, K. (Ed.). High-Performance Computing Using FPGAs. New York: Springer, 2013. p. 137-75.
Apêndice
A
Imagens do Modelo 1
150
250
100
I
200
I
2200 m/s
1900 m/s
h=110
h=125
2600 m/s
/t-160
3500 m/s
4200 m/s
h=145
Modelo_l
Figura A.2: Imageamento de referência para o modelo 1 gerado no padrão de ponto-flutuante.
B
Imagens do Modelo 2
Figura B.1: Estrutura geológica do modelo 2.
ximage
Figura B.2: Imageamento de referência para o modelo 2 gerado no padrão de ponto-flutuante.
0	50	100	150	200	250
Antonio2_24bits
C
Imagens do Modelo 3
Figura C.1: Estrutura geológica do modelo 3.
0	50	100	150	200	250
Modelo3_Float
Figura C.2: Imageamento de referência para o modelo 3 gerado no padrão de ponto-flutuante.
Modelo3_19bits
Müdelü3_17bits
Modelo3_12bits
Modelo3_llbits
500 —
600 —
700-
0*001465
200-
0*000732.
-0*0007324
400-
-0*001465
300 —
0
D
Imagens do Modelo 4
Figura D.1: Estrutura geológica do modelo 4.
Figura D.2: Imageamento de referência para o modelo 4 gerado no padrão de ponto-flutuante.
E
Imagens do Modelo 5
Figura E.1: Estrutura geológica do modelo 5.
4300 m/s	A=54
	h=90
3000 m/s	h=246
1900 m/s	h=29
3800 m/s	h=150
5100 m/s	h=24
4600 m/s	h=114
0	50	100	150	200	250
Modelo5_Float
Figura E.2: Imageamento de referência para o modelo 5 gerado no padrão de ponto-flutuante.
Figura E.5: Imageamento do modelo 5 obtido com 19 bits de precisão.
F
Imagens do modelo de Marmousi
0	500	1000	1500	2000
0|I I I L
100
Marmousi
Figura F.2: Imageamento de referência para o modelo de Marmousi gerado no padrão de ponto-flutuante.
G
Implementação do PE-ASM
PE FIXO.h	1
//............................................................
// CONFIG. OPERANDOS
#define PRECISÃO OPERANDOS 20
#define RANGE OPERANDOS 8
#define NUMBITSOPERANDOS RANGEOPERANDOS+PRECISAO OPERANDOS //............................................................
// VEL2FAT
#define PRECISÃO FAT 28
#define RANGE FAT 2
#define NUMBITS FAT RANGE FAT + PRECISÃO FAT
#define PRECISÃO VEL 6
#define RANGE VEL 14
#define NUMBITS_VEL RANGE VEL + PRECISÃO VEL
#define PRECISÃO VEL2 PRECISÃO VEL*2
#define RANGE VEL2 RANGE VEL *2
#define NUMBITS VEL2 PRECISÃO VEL2 + RANGE VEL2
#define PRECISÃO VEL2FAT PRECISÃO FAT
#define RANGE VEL2FAT RANGE VEL2
#define NUMBITS_VEL2FAT RANGE VEL2FAT + PRECISÃO VEL2FAT //............................................................
// MVEL2_FATxSl_16_60
#define PRECISÃO MVEL2 FATxSl 16 60 PRECISÃO VEL2FAT+PRECISAO OPERANDOS
#define RANGE MVEL2 FATxSl 16 60 RANGE VEL2FAT + RANGE OPERANDOS
#define NUMBITS MVEL2 FATxSl 1660 RANGE MVEL2 FATxSl 1690+ PRECISÃO MVEL2 FATxSl 1690 //............................................................
// MMENOSAIJk
#define PRECISÃO MMENOS AUk PRECISÃO MVEL2 FATxSl 16 60
#define RANGE MMENOSAIJk RANGE MVEL2 FATxSl 1660+1 "
Sdefine NUMBITS MMENOS AUk RANGE MMENOS_AUk+ PRECISÃO MMENOSAIJk
#define AJUSTE MENOSAIJ PRECISÃO MVEL2 FATxSl 16 60-PRECISÃO OPERANDOS //............................................................
// MABSIxABSJxABSK
#define PRECISÃO ABSIABSJ 24
#define RANGE ABSIABSJ 2
#define NUMBITS ABSIABSJ RANGE ABSIABSJ+PRECISAO ABSIABSJ
#define POSICAO_ROUND_ABSIABSJ (PRECISÃO ABSIABSJ)-1 //............................................................
// MmultBordal
#define PRECISÃO MULTB0RDA1 PRECISÃO MMENOSAIJk
#define RANGE MULTB0RDA1 RANGE MMENOS AUk
#define NUMBITS MULTB0RDA1 RANGE MULTB0RDA1+PRECISA0 MULTB0RDA1
#define POS ROUD MULTB0RDA1 (PRECISÃO ABSIABSJ-1) //............................................................
// Msoma2Bijk
#define PRECISÃO S0MA2BUK PRECISÃO MMENOS AUk
#define RANGE S0MA2BUK RANGE MMEN0S_AUk+2
#define NUMBITS S0MA2BIJK RANGE S0MA2BUK + PRECISÃO S0MA2BUK
#define POS ROUD MULTB0RDA2 (PRECISÃO ABSIABSJ+PRECISAO S0MA2BUK-PRECISÃO MULTB0RDA2-1)
#define AJUSTE MS0MA2BU PRECI5A0 MULTB0RDA1 - PRECISAO_OPERANDOS + 1 //............................................................
// MmultBorda2
#define PRECISÃO MULTB0RDA2 PRECISAOOPERANDOS
#define RANGE MULTB0RDA2 RANGE OPERANDOS
Sdefine NUMBITS MULTB0RDA2 RANGE MULTB0RDA2+PRECISA0 MULTB0RDA2
pe_fixo_2D asm.cpp
1
#include "PE FIXO.h"
long long int pe_fixo_asm(
int b i_j, int a i_j, int i menos 1, int j menos 1, int i mais 1, int j mais 1, int imenos 2, int jjrienos 2, int i mais 2, int j mais 2, int velvel fat, int absi, int absj
){
long long int sresultadoM16S; 7/14,23 long long int sresultadoMIS; 7/14,23 long long int sresultadoMõG; //14,23 long long int ssoma 1 16_6G; //16,23 long long int smultabs; // 1,24 my Í128 sma_i_j;
my Í128 smultbordal; //19,54 my Í128 smult_borda2; //20,54 my Í128 s2Bij;//21,54 my il28 svel2Fat_soma; // 17,54 my il28 svel2 FatxSl 16 60; // 13,54
5ma_i_j //
);
long long int smult_s;
Mabsixabsj_asm(
absi,
absj, smult abs
);
MmultBordalasmf smultabs, sma_i_j, smultbordal//
);
Msoma2Bij_asm( b iJ, smultbordal, s2Bij/7
MmultBorda2 asm( smult abs, s2Bij, smult borda2
);
return (smult borda2.Io64);
MlSoma_asm(
i menos 2,
i mais 2,
j menos 2,
j mais 2, sresultadoMIS // );
M16Soma_asm(
i menos 1,
i mais 1, j_menos_l, j_mai5 1,
sresultadoM16S // );
M60_asm( b _i_j, sresultadoM6G
);
MSomal 16_60_asm( sresultadoM16S, s resultadoMIS, sresultadoMõG, ssomal_16_60 //
);
Mvel2 FatxSl 16_60_asm( velvelfat, ssomal1660, svel2 FatxSl_16_60 );
MmenosAij_asm(
svel2 FatxSl 16 60,
a. i j,
pe fixo 2D asm.h	1
#inctude "PE_FIXO.h"
typedef struct {
tong tong int to64;
tong tong int hi64;
} my_il28;
#define neg!28(dado)\
mov %0,	%%rax;	"\	
" mov	0,4 Q-Q-	rbx;	"\
" not	%%rax	;"\	
" not	%%rbx	;"\	
" add	$1,%%	rax;	"\
" adc	$0,%%	rbx;	"\
" mov	%%rax	,%0;	"\
" mov	%%rbx	,%1;	"\
: "=m"(dado.to64),"=m"(dado.hi64)\
: "m"(dado.to64),"m"(dado.hi64)\
: "rax","rbx"\
);\
#define MlSoma_asm(	\	
i_menos_2,\		
i_mais_2,\		
j_menos_2, \		
j_mais_2,\		
retorno) \		
	asm	(" movsxd	%1, %%rax;	"\
" movsxd	%2, %%rbx;'	\
" addq %%	&gt;rbx, %%rax;	;"\
" movsxd	%3, %%rbx;'	\
" adcq %%	&gt;rbx, %%rax;	;"\
" movsxd	%4, %%rbx;'	\
" adcq %%rbx, %%rax;"\
" negq %%rax;"\
" movq %%rax, %0;"\
: "=m"(retorno)\
:"m" (j_menos_2), "m"(j_mais_2), "m"(i_menos_2), "m"(i_mais_2)\ : "rax");
#define M16Soma_asm(\
i_menos_l,\ i_mais_l,\ j_menos_l,\ j_mais_l,\ retorno)\
movsxd %1, %%rax;	"\
movsxd %2, %%rbx;'	\
addq %%rbx, %%rax;	;"\
movsxd %3, %%rbx;'	\
adcq %%rbx, %%rax;	;"\
movsxd %4, %%rbx;'	\
adcq %%rbx, %%rax;	;"\
movq $16,	%%rbx;"	
mutq %%rbx;"\ movq %%rax,%0;"\	
:"=m"(retorno)\
:"m" (j_menos_l), "m"(j_mais_l), "m"(i_menos_l), "m"( i_mais_l)\ : "rbx", "rax", "rdx", "rex");
#define M60_asm(\
b_i_j,\ retorno)\ retorno=-60LL*(tong tong int)b_i_j;
#define MSomal_16_60_asm(\
pe fixo 2D asm.h	2
M16,\
Ml, \
M60,\
retorno)\
asm	(" movq	%1,	%%rax	
" addq	%2,	%%rax;	"\
" addq	%3,	%%rax;	"\
" movq	%%rax,%0;"		\
=m" (retorno)	\		
:”m” (M16),	”m"(M60)\
: ’’ rax");
#define Mabsixabsj_asm( \
absi,	\
absj,	\
retorno	)\		
	asm	("	1 xor	%%rax, %%rax;	"\
	xor	%%rbx, %%rbx;	"\
	mov	%1, %%eax;"\	
	mov	%2, %%ebx;"\	
	mui	%%rbx;"\	
	mov	%3, %%d;" \	
	shrd %%rdx,%%rax;		"\
	shr	$3,%%rdx;"\	
	add	$l,%%rax;"\	
	shr	$l,%%rax;"\	
11	mov	%%eax,%0;"\	
"=m" (retorno)		\	
:”m”(absi), ”m"(absj), "i"(POSICAO_ROUND_ABSIABSJ)\
: "rax", "d","rdx", "r8");
#define MmenosAij_asm(\ vel2f_s, \ a_i_j, \ retorno)\
__asm__( " mov %2, %%rax;"\
" mov %3, %%rdx;"\
" movsxd %4, %%rbx;"\
" prep_negativo: movq $0xFFFFFFFFFFFFFFFF,%%r8;"\
" test %%rbx,%%rbx;"\
" js negativo; "\
" positivo: xor %%r8,%%r8;"\
" negativo: "\
" mov %5,%%d;"\
" shtd %%rbx, %%r8;"\
" sht %5, %%rbx;"\
" sub %%rbx,%%rax;"\
" sbb %%r8, %%rdx;"\
" mov %%rax,%0;"\
" mov %%rdx,%l;"\
: "=m"(retorno,to64),"=m"(retorno.hi64) \
:"m"(vet2f_s.to64), "m"(vet2f_s.hi64),"m"(a_i_j), "i"(AJUSTE_MENOSAIJ)\ : " rax"," rbx"," rdx"," r8");
#define Mvet2_FatxSl_16_60_asm(\
vet2_fat, \ sl_16_60, \ retorno)\ __asm__( " movsxd %2,%%rax;"\
" mov %3,%%r8;"\
" imut %%r8;"\
" mov %%rax,%0;"\
" mov %%rdx,%l;"\
: "=m"(retorno,to64),"=m"(retorno.hi64) \
:"m"(vet2_fat), "m"(sl_16_60)\
: "r8","rax","rdx");
#define MmuttBordal_asm(\
pe fixo 2D asm.h	3
abs, \ dado,\ retorno)\
if (dado.hi64&lt;0){\
mov	%2,%%rax;	"\	
mov	%3,%%rbx;	"\	
not	%%rax; "\		
not	%%rbx;"\		
add	$l,%%rax;	"\	
ade	$0,%%rbx;	"\	
movsxd %4,%!		%r8;	"\
mul	%%r8;"\		
mov	9-9-r*3Y 9-9-r	9;"\	
mov	%%rdx,%%r	10;"	\
mov	%%rbx,%%	rax;	"\
mul	%%r8;"\		
add	9-9--r* s y 9-9-r IdX,1	10;"	\
mov	Q-C, 9-9-z-l ■ 11	\	
shrd %%rl0,%%		r9;"	\
shr	%5,%%rl0;	"\	
not	%%r9;"\		
not	%%rl0;"\		
add	$l,%%r9;"	\	
ade	$0,%%rl0;	"\	
mov	%%r9,%0;"	\	
mov	%%rl0,%l;	"\	
: "=m"(retorno.lo64),"=m"(retorno.hi64) \
:"m"(dado.lo64),"m"(dado.hi64), "m"(abs),"i"(POS_ROUD_MULTBORDAl+l), "i"(64-POS_ROUD_MULTBORDA1)\
: "r8","r9", "rl0", "rax","rbx","rdx");\
} \
{	asm	(" mov %2,		%%rax; "\
" movsxd %4,%%r8;		"\
" mul	%%r8;"\	
" mov	%%rax,%%r9; "\	
" mov	%%rdx,%%rl0;"	\
" mov	%3,%%rax;"\	
" mul	%%r8;"\	
" add	%%rax,%%rl0;"	\
" mov	%5,%%cl;"\	
" shrd %%rl0,%%r9;"		\
" shr	%5,%%rl0;"\	
" mov	%%r9,%0;"\	
" mov	%%rl0,%l;"\	
:"=m"(retorno.lo64),"=m"(retorno.hi64) \
:"m"(dado.lo64),"m"(dado.hi64), "m"(abs),"i"(POS_ROUD_MULTBORDAl+l), "i"(64-POS_ROUD_MULTBORDA1)\
: "r8","r9", "rl0","rax","rdx");\
}
#define MmultBorda2_asm(\
abs, \
dado,\
retorno)\
if (dado.hi64&lt;0){\
___asm__(" mov %2,%%rax;"\
" mov %3,%%rbx;"\
" not %%rax;"\
" not %%rbx;"\
" add $l,%%rax;"\
" ade $0,%%rbx;"\
" movsxd %4,%%r8;"\
" mui %%r8;"\
" mov %%rax,%%r9;"\
" mov %%rdx,%%rl0;"\
" mov %%rbx,%%rax;"\
" mui %%r8;"\
" add %%rax,%%rl0;"\
" mov %5,%%d;"\
pe fixo 2D asm.h	4
" shrd %%rl0,%%r9;"\
" shr %5,%%rl0;"\
" not %%r9;"\
" not %%rlO;"\
" add $l,%%r9;"\
" adc $0,%%rlO;"\
" mov %%r9,%0;"\
" mov %%rlO,%l;"\
: "=m"(retorno.to64),"=m"(retorno.hi64) \
: "m"(dado.lo64),"m"(dado.hi64), "m"(abs),"i"(P0S_R0UD_MULTB0RDA2+l), "i"(64-P0S_R0UD_MULTB0RDA2)\
: "r8","r9", "rlO", " rax","rbx","rdx") ;\
} \
{	asm	(" mov %2	,%%rax; "\
" movsxd %4,%%r8;	
" mul %%r8;"\	
" mov %%rax,%%r9;"	\
" mov %%rdx,%%rlO;	"\
" mov %3,%%rax;"\	
" mul %%r8;"\	
" add %%rax,%%rlO;	"\
" mov %5,%%cl;"\	
" shrd %%rl0,%%r9;	"\
" shr %5,%%rl0;"\	
" mov %%r9,%0;"\	
" mov %%rlO,%l;"\	
:"=m"(retorno.to64),"=m"(retorno.hi64) \
: "m"(dado.lo64),"m"(dado.hi64), "m"(abs),"i"(P0S_R0UD_MULTB0RDA2+l), "i"(64-P0S_R0UD_MULTB0RDA2)\
: "r8","r9", "rlO","rax","rdx");\
}
#define Msoma2Bij_asm(\
b_i_j, \
mutt_b,\
retorno)\
__asm___( " movsxd %2,%%rax;"\
" pl: movq $0xFFFFFFFFFFFFFFFF,%%r8;"\
" test %%rax,%%rax;"\
" js p3;"\
" p2: xor %%r8,%%r8;"\
" p3: "\
" mov %5,%%cl;"\
" shtd %%rax, %%r8;"\
" sht %5, %%rax;"\
" add %3, %%rax;"\
" adc %4, %%r8;"\
" mov %%rax,%0;"\
" mov %%r8,%l;"\
:"=m"(retorno.to64),"=m"(retorno.hi64) \
:"m"(b_i_j),"m"(mult_b.lo64),"m"(mutt_b.hi64),"i"(AJUSTE_MS0MA2BIJ)\
: "rax","r8");\
float my_128_toFloat(my_il28 dado, int precisao);
void floatTo_my_128(float dado, int precisao, my_il28 &amp;amp;retorno);
long long int pe_fixo_asm(
int	b_	
int	a_	
int	i	_menos_l
int	j_	_menos_l
int	i	_mais_l,
int	j_	_mais_l,
int	i	_menos_2
int	j_	_menos_2
int	i	_mais_2,
int		_mais_2,
pe fixo 2D asm.h	5
int vet_vet_fat,
int absi,
int absj
);
H
Implementação do algoritmo de predição
predição.cpp
/*
programa de modelagem
*/
#indude&amp;lt;stdio.h&gt;
#indude&amp;lt;string.h&gt;
#indude&amp;lt;stdlib.h&gt;
#indude cmath. h&gt;
//#indude&amp;lt;omp.h&gt;
#indude "libcenpes_FPGA.h"
#indude "arqMaxPulsolOO.h"
void	inicia_var(int nnoib,int nnojb,float**AO,float**Al, float**A2, float**A3);
void	inicia_vel(int ni,int nj,float**AO,int vel);
void inicia_com_2_vel(int ni,int nj,float**AO,int veil, int hl, int vel2, int h2); void calculoDensidadeEnergiaRms(float *buffer, float *rms, float *energia, int tamanhoBuffer, float velocidade, int janela, float raio);
float rmsPulso(float *buffer, int vel);
int inicia_com_N_vel_2D(int nCamadas, int largura, float**AO,int amort, int ♦profundidades, float *velocidades, int nFiltro);
void calculaAtenuacao( int largura, int profundidade, float**A0);
float atn(int coluna, int camada, int hO, int profundidade, float**VEL, float pulso, float sensibilidade);
float atnMod(int coluna, int camada, int hO, float raioAnteior, int profundidade, float**VEL, float pulso, float sensibilidade, int pMedicao,
float VelPrimeiraCamada, float &amp;amp; AmplitudeRetorno, float &amp;amp; RaioRetorno); float atnMig(int coluna, int camada, int hO, float raioAnteior, int profundidade, float**VEL, float pulso, float sensibilidade, int pMedicao,
float VelPrimeiraCamada, float &amp;amp; menorAmplitude);
void eqnl(float A_incidente, float VI, float V3, float ^refletida, float &amp;amp;refratada);
void teste (int &amp;amp;al, float &amp;amp;a2){
printf ("%f %d\n",a2, al);
}
int main (int argc, char** argv) {
//definição de variaveis				
float	energiaPulso, energiaMeio;			
float	FCorte;	//	Frequência maxima do pulso sismico em Hertz	
float	FC;	//	Parametro relacionado com FCorte usado na funcao ricker		
float	vmax;	//	Maior velocidade do modelo	
float	vmin;	//	Menor velocidade do modelo	
cha r	File 0ut[250];		// Arquivo de saida	
int	nnoi,nnoj;	//	Dimensão do modelo		
int	nnoib,	nnoj	b;	// Dimensão do modelo com bordas de amortecimento	
cha r	N0ME[30];	//	Nome do arquivo	
cha r	CMDLINE[500];		// linha de comando	
int	flag;	//	Teste de abertura de arquivo bem sucedida		
float	**VEL;	//	Matriz campo de velocidades sismicas	
float	■	//	Matriz campo	
float	■	//	Matriz campo de pressão em t-1	
float		//	Matriz campo de pressão em t	
float	**Amax;	//	Matriz condicao de imagem - amplitudes	
float	**Tt ra;	//	Matriz condicao de imagem - tempos de transito	
float	*absi,*absj;		// Vetores de absorcao para CERJAN	
int	ij;	//	Contadores para loops espaciais	
int	t;	// Contado		r para o loop temporal	
float	dt;	//	Intervalo de amostragem temporal		
float	h;	//	Intervalo de amostragem espacial (tamanho do grid)		
float	tempo;	//	Tempo da simulacao	
FILE	*fl;	//	Ponteiro para arquivo de entrada do modelo de velocidades	
FILE	*f2;	//	Ponteiro para arquivo de saida de snapshots (EM TESTE)	
FILE	*f3;	//	Ponteiro para arquivo de saida do sismograma	
FILE	*f4;		// Ponteiro para arquivo de saida da matriz	de tempo
FILE	*f5;		// Ponteiro para arquivo de saida da matriz	de
amplitudes
predicao.cpp	2
FILE	*onda;	// Ponteiro para arquivo de saida de propagacao
FILE	*fmedidas;//
FILE	*testeConfiguracao;
FILE	*fdesvio;
FILE	*fsisrnograrna;
float	fat;		// Fator constante usado dentro do loop mais interno
float	tf;	//	Distancia em tempo do centro da wavelet a origem do eixo do
tempo			
int	ntf;		II Distancia em amostras de tempo da wavelte ate a origirn
float	pi;	//	0 numero PI=3.141592654
int	alpha;	//	Parametro relacionado com a dispersão numérica
int	beta;		II Parametro relacionado com a estabilidade
int	cont_snap;	//	Tempo final do sismograma
int	amort;	//	Espessura da borda de amortecimento
int	dist_recv;	//	Distancia entre receptores em pontos do grid
int	nrecv;	//	Numero do receptor
float	sis_dt;		II Intervalo de amostragem do sismograma em segundos
int	sis_ntr;	//	Numero de traeos do sismograma
float	coef;	// Coeficiente de absorcao de Cerjan
// int cnt;	// Contador para loop de sismograma
float	*slice;	// Buffer para armazenar as amostras correntes do sismograma
int	cl,c2,c3;	// Criterios para condicao de imagem
int	posxTiro;	// Número do tiro usado no nome dos arqs de entrada/saida
int	operacao;	// 0=sismograma, l=matrizes de tempo e amplitude
snap;	// Flag para saida de snapshots: 0=nao, l=saida de snapshots
char	*arqvel; // Caminho/nome do arquivo de velocidade
char	nomesaidas[100]; // Caminho/nome dos arquivos de saida
float score[10][15];
int posX, posY;
float refPulse, maxRefPulse, medPulse, maxMedPulse;
float *medPts, *medidas, *pulsolnserido, *pulsoMedido, *rmsPl, *energiaPl, *rmsP2, *energiaP2, *sismograma;
int profundidadeModelo;
int larguraModelo;
float correcaoPulso;
float AmplitudeRetornoMod, AmplitudeRetornoMig ;
float RaioRetornoMod, RaioRetornoMig;
float menorAmplitudeMig, menorAmplitudeMod, amplitude;
int profundidadeMedida;
int nCamadas;
int pl,p2;
int posyTiro;
int ptr;
float maxPulso;
int coluna;
float pulso;
float sensibilidade;
sprintf(nomesaidas,"desvio. csv");
int al; float a2;
float raioMigracao;
fdesvio = fopen(nomesaidas,"wb"); fprintf(fdesvio,"alpha, beta, desvio\n");
if (atoi(argv[5])!=0 &amp;amp;&amp;amp; (argc != 9+atoi(argv[5])*2)||(atoi(argv[5])==0 &amp;amp;&amp;amp; argc !=
11)){
printff'ERRO %d %d\n",argc, (atoi(argv[5])*2)+8);
//	1	2	3	4	5	6
7	6
putsf'./predicao pulso sensibilidade profundidadeMedida coluna nCamadas [larguraModelo ,ProfundidadeModelo, arqvel] [larguraModelo, vl,hl,v2,h2.....vn,hn], alpha
beta");
putsf'pulso - amplitude do pulso introduzido no meio");
puts("sensibilidade - diferença percentual de velocidades entre camadas defecáveis");
putsCprofundidadeMedida-profundidade em espaços do grid para fazer a predição");
predicao.cpp	3
puts("coluna, coluna a ser analizada (0=analiza todo o modelo)"); puts("nCamadas - numero de camadas do modelo");
puts("[larguraModelo, ProfundidadeModelo, arqvel] - largura e profundidade do modelo a ser lido de arqvel");
puts("[larguraModelo, vl,hl,v2,h2,...,vn,hn] - largura do modelo a ser construido com as velocidade e profundidades indicadas (metros)");
puts("alpha beta - parametros de configuração");
return
}
amort=100; coef=0.00202; dist recv=l; sis dt=0.002f;	// Espessura da borda de amortecimento // Coeficiente de absorcao da camada de amortecimento // Distancia entre receptores em pontos do grid // Intervalo de amostragem do sismograma em segundos
alpha=12;	// Criterio para evitar dispersão numérica
beta=2;
pulso = atof(argv[l]);
sensibilidade = atof(argv[2]);
vmin=1000;
vmax=5500;
//Inicializacao de variaveis
pi = 4.0f*atan(1.0f);	// 0 numero PI=3.141592654...
FCorte=60;	// Frequência maxima do pulso sismico
// Criterio para garantir estabilidade
FC=FCorte/2.0f;	// Relacao entre a freq, maxima e o valor de FC em ricker
h = vmin/(alpha*FC);	// Def. espacam. grid em X e Z p/ satisf. cond.
estabilidade
dt= h/(beta*vmax);	// Def. interv. amostragem temporal p/ satisf. crit.
dispersão numérica
fat = (dt*dt)/(h*h*12.0f);	// Fator constante usado dentro do loop mais interno
sis_ntr = nnoi/dist_recv; // Calcula o numero de traeos do sismograma tf=2.0f*sqrt(pi)/FC;	// Distancia em tempo do centro da wavelet a origem do
eixo do tempo
ntf=tf/dt;	// Distancia em amostras de tempo do centro da wavelet a origem
profundidadeMedida = atoi(argv[3]);
coluna = atoi(argv[4]);
nCamadas = atoi(argv[5]);
if (nCamadas==0){
larguraModelo = atoi(argv[6]);
profundidadeModelo = atoi(argv[7]);
arqvel = argv[8];
puts("\nl_endo arquivo...");
VEL = libcenpes_aloca2Df(larguraModelo,profundidadeModelo,&amp;amp;flag);// Aloca matriz para o campo de velocidades sismicas com bordas
libcenpes_read_mat2Df(arqvel,la rguraModelo,profundidadeModelo,©,0,0,0,VEL); // Le arquivo com modelo de velocidades sem bordas
}else{ larguraModelo=ceil(atoi(argv[6])/h);	// Dimensão X do modelo
float *velocidades = (float *)calloc(nCamadas,sizeof(int));
int *profundidades = (int *)calloc(nCamadas,sizeof(int));
int *profundidadesEmPts = (int *)calloc(nCamadas,sizeof(int));
float	*precisaoModelagem	=	(float	*)calloc(nCamadas,sizeof(int));
float	*precisaoMigracao	=	(float	*)calloc(nCamadas,sizeof(int));
float	*precisaoNaCamada	=	(float	*)calloc(nCamadas,sizeof(int));
int profundidaCamadaAnterior=0;
profundidadeModelo =0;
for(i=0; i&lt;nCamadas; i++){
velocidades[i] = atoi(argv[7+(2*i)]); profundidades[i] = atoi(argv[7+(2*i+l)])-profundidaCamadaAnterior; profundidaCamadaAnterior = atoi(argv[7+(2*i+l)]); profundidaCamadaAnterior = atoi(argv[7+(2*i+l)]); profundidadesEmPts[i] = ceil(profundidades[i]/h); profundidadeModelo+=profundidadesEmPts[i];
}
//Alocacao de memoria do Campo de Velocidades
predicao.cpp	4
VEL = Libcenpes_aloca2Df(larguraModelo,profundidadeModelo,&amp;amp;flag); // Aloca matriz para o campo de velocidades sismicas com bordas
profundidadeModelo = inicia_com_N_vel_2D(nCamadas, larguraModelo, VEL, 0, profundidadesEmPts, velocidades, 1);
//	for (i=0; icprofundidadeModelo; i++)
//	printf("VEL[0][%d]=%f\n",i,VEL[0][i]);
}
int alarrne=0;
for (i=0; idarguraModelo; i++)
for (j=0; jcprofundidadeModelo; j++){
if (VEL[i][j]&lt;1500){
VEL[i][j]=1500;
alarrne=l;
}
}
if (alarme)
puts("Este modelo possui camadas com velocidades abaixo de 1500 m/s que foram ajustadas para 1500 m/s");
printf("Pulso:%f sensibilidade:%f\n",pulso, sensibilidade);
menorAmplitudeMod = 1000;
menorAmplitudeMig = 1000;
float menorAmplitude = 1000;
float pulsoEntrada = pulso;
raioMigracao=0;
i=0;
if (coluna==0) II se coluna=0 analiza todo o modelo
for (i=0; idarguraModelo; i = i+10){
pulso = pulsoEntrada*FATOR[(int)VEL[coluna][0]-1500];
amplitude= atnMod(i, 0, 0, 0, profundidadeModelo, VEL, pulso, sensibilidade, profundidadeMedida, 0, AmplitudeRetornoMod, RaioRetornoMod);
if (amplitudecmenorAmplitudeMod)
menorAmplitudeMod = amplitude;
amplitude= atnMig(i, 0, 0, 0, profundidadeModelo, VEL, pulso, sensibilidade, profundidadeMedida, 0, menorAmplitude);
if (amplitude&lt;menorAmplitudeMig)
menorAmplitudeMig = amplitude;
}
else{
pulso = pulsoEntrada*FATOR[(int)VEL[coluna][0]-1500];
menorAmplitudeMod= atnMod(coluna, 0, 0, 0, profundidadeModelo, VEL, pulso, sensibilidade, profundidadeMedida, 0, AmplitudeRetornoMod, RaioRetornoMod);
menorAmplitudeMig= atnMig(coluna, 0, 0, 0, profundidadeModelo, VEL, pulso, sensibilidade, profundidadeMedida, 0,menorAmplitude);
}
printf("Modelo: %s Profundidade: %d Largura: %d Velocidade da Primeira Camada: %e
Amplitude do Pulso Inicial: %e\n",
arqvel, profundidadeModelo, larguraModelo, VEL[larguraModelo/2][0],
FAT0R[(int)VEL[larguraModelo/2][0] -1500]);
printf("Menor amplitude na Modelagem:%e precisão na base 2:%d bits \n", menorAmplitudeMod, (int)ceil(fabs(Log2(menorAmplitudeMod/100))));
printf("Menor amplitude na Migração:%e precisão na base 2:%d bits \n \n ", menorAmplitudeMig, (int)ceil(fabs(Log2(menorAmplitudeMig/100))));
return 1;
}
// Subrotina para inicializacao de variaveis
void inicia_var(int ni,int nj,float**A0,float**Al, float**A2, float**A3) { int i,j;
//Criacao dos campos de pressão
for (i=0;i&lt;ni;++i) {
for (j=0;j&lt;nj;++j) {
predicao.cpp	5
} } return;
A0[i]	[j]	= 0.0f;	//	Inicializa	0	campo	de	pressao	em	t-2
Al[i]	[j]	= 0.0f;	//	Inicializa	0	campo	de	pressão	em	t-1
A2[i]	[j]	= 0.0f;	//	Inicializa	0	campo	de	pressao	em	t
A3[i]	[j]	= 0.0f;		// Inicializa matriz				de amplitudes		
void inicia_vet(int ni,int nj,ftoat**A0,int vet) { int i,j;
for (i=0;i&lt;ni;++i) {
for (j=0;j&lt;nj;++j) {
A0[i][j] = (float)vel;
}
}
return;
float rmsPulso(float *buffer, int vel){ int i;
float media=0;
for (i=0; i&lt;270; i++)
media += buffer[280+i]*buffer[280+i]; media /=270;
media =sqrt(rnedia);
return media;
void inicia_com_2_vel(int ni,int nj,float**A0,int veil, int hl, int vel2, int h2){ int i,j, x,y;
float media;
for (i=0;i&lt;ni;++i) {
for (j=0;j&lt;nj;++j) {
if (j&lt;hl)
A0[i][j] = (float)vell; else A0[i][j] = (float)vel2;
}
}
void calculoDensidadeEnergiaRms(float *buffer, float *rms, float *energia, int tamanhoBuffer, float velocidade, int janela, float raio){
float frms;
int ent, cntFim, inincio,fim, achei;
int i, j, down, up;
int ptr;
printff'Medidas em velocidade:%f raio:%f janela:%d \n", velocidade, raio, janela);
for (i=0; ictarnanhoBuffer-janela; i++ ){ frrns=0;
for (j=0; jcjanela; j++){ frms=frms+ (buffer[i+j]*buffer[i+j]);
}
frms = sqrt(frms/janela); rms[i]=frms;
energia[i]=frms*frms/velocidade;
}
frms =0;
up=0;
for (i=0; ictarnanhoBuffer-janela; i++ ){
if (rms[i+l]-rms[i]&gt;0.001){
ptr = i;
up++; if(up&gt;5) down=0;
}else{
predicao.cpp	6
down++;
if ((down&gt;50)){
if (up&gt;50)
printf("Pulso:[%d,%d] Energia:%10e Amplitude(rms)=%10e\n",ptr,
ptr+janela, energia[ptr], rms[ptr]);
up=0;
}
}
}
}
int inicia_com_N_vel_2D(int nCamadas, int largura, float* **A0,int amort, int *profundidades, float Velocidades, int nFiltro) {
int i, j, cnt, h, p, np,v;
float media;
cnt=0;
np = amort;
for (i=0;i&lt;amort;++i) // camada de absorção
A0[0][i] = (float)velocidades[0];
for (p=0; p&lt;nCamadas; p++){
for (i=0;i&lt;profundidades[p];++i)
A0[0][i+np] = (float)velocidades[p];
np +=profundidades[p];
}
for (i=0;i&lt;amort;++i) // camada de absorção A0[0][i+np] = (float)velocidades[nCamadas-l]; np +=amort;
for (i=0;i&lt;np-nFiltro;++i){ // filtro media=0;
for (p=0; p&lt;nFiltro; p++) media += A0[0][i+p];
media /=nFiltro; A0[0][i]=media;
}
for (i=0;i&lt;np;++i){	// converte de ld para 2d
for (j=0; j&lt;largura; j++)
A0[j][i]=A0[0][i];
}
return np;
}
float atnMod(int coluna, int camada, int h0, float raioAnteior, int profundidade, float**VEL, float pulso, float sensibilidade, int pMedicao,
float VelPrimeiraCamada, float &amp;amp; AmplitudeRetorno, float &amp;amp; RaioRetorno){
*
*int coluna:coluna do modelo a ser analizada
*int camada: camada atual, indica a última camada a ser visitada
*int h0: profundidade atual, indica a profundidade da última camada visitada, já considera correções por velocidade
*int profundidade: profundidade do modelo
*float**VEL: modelo de velocidades
*float pulso: amplitude do pulso ao deixar a última camada visutada
*float sensibilidade: sensibilidade de detecção de camadas, definido como percentual de variação de velocidade em relação a velocidade da última camada
*
*/
float reflexaolnterna=0;
float retorno;
predição.cpp
float velCamadaAnteriror, velPxCamada, velCamada;
int i=h0;
float raio, raioRefletido;
float indiceRefracao;
float AmplitudeRetornoI;
float RaioRetornoI;
int profundidadeDaCamada;
float indiceTransmissao, indiceRetorno, indiceRefracaoRetorno;
velCamada = VEL[coluna][h0];
if (h0&gt;0) velCamadaAnteriror= VEL[coluna][h0-l];
else {
velCamadaAnteriror=0;
VelPrimeiraCamada = velCamada;
}
// procura próxima camada
{
while ((i&lt;profundidade)&amp;amp;&amp;amp;(fabs(VEL[coluna][i]-velCamada))&lt;velCamada*sensibilidade){ II verifica a profundidade da camada
i++;
}
}
profundidadeDaCamada = i-h0;
velPxCamada = VEL[coluna][i];
if (i==profundidade) { // verifica se chegou ao fim do modelo, a última camada não retorna nada e não acrescenta nada ao raio da frente de ona
RaioRetorno=l;
AmplitudeRetorno = 100000; return 1000;
}
//	// Calcula o raio
{
if (camada==0) { // se esta é aprimeira camada
raio = profundidadeDaCamada; raioRefletido = 2*profundidadeDaCamada;
}else { // se o pulso já vem propagado de outras camadas raio = (profundidadeDaCamada*velCamada/VelPrimeiraCamada)+raioAnteior; // diminui o raio da camada atual caso a velocidade da camada atual seja menor que a anteior raioRefletido = (2*profundidadeDaCamada*velCamada/VelPrimeiraCamada)+raioAnteior;
}
}
//	Calcula a atenuação
{
if (velPxCamada&gt;velCamada) indiceTransmissao = velPxCamada/velCamada;
else indiceTransmissao=l;
if (velCamadaAnteriror&gt; velCamada) indiceRetorno = velCamadaAnteriror/velCamada;
else indiceRetorno=l;
reflexaolnterna = fabs(velPxCamada-velCamada)/(velPxCamada+velCamada); indiceRefracao = (l-reflexaolnterna);
indiceRefracaoRetorno = l-(fabs(velCamadaAnteriror-velCamada)/(velCamadaAnteriror+velCamada));
indiceTransmissao = indiceRefracao*indiceTransmissao;
atnMod(coluna, camada+1, i, raio, profundidade, VEL, indiceTransmissao, sensibilidade, pMedicao, VelPrimeiraCamada, AmplitudeRetornoI, RaioRetornoI);
if ((reflexaolnterna/sqrt(raioRefletido-
predicao.cpp	8
pMedicao)&lt;AmplitudeRetornoI/sqrt(RaioRetornoI+raio-pMedicao))){
AmplitudeRetorno=reflexaoInterna*pulso;
RaioRetorno = raioRefletido;
}else{
AmplitudeRetorno=AmplitudeRetornoI*pulso; RaioRetorno = RaioRetornoI+raio;
}
if (camada!=0)
AmplitudeRetorno=AmplitudeRetorno*indiceRefracaoRetorno*indiceRetorno;
else {
RaioRetorno=RaioRetorno-pMedicao;
}
retorno = AmplitudeRetorno/sqrt(RaioRetorno);
}
return (retorno);
}
float atnMig(int coluna, int camada, int h0, float raioAnteior, int profundidade, float**VEL, float pulso, float sensibilidade, int pMedicao,
float VelPrimeiraCamada, float &amp;amp; menorAmplitude){
*
*int coluna:coluna do modelo a ser analizada
*int camada: camada atual, indica a última camada a ser visitada
*int h0: profundidade atual, indica a profundidade da última camada visitada, já considera correções por velocidade
*int profundidade: profundidade do modelo
*float**VEL: modelo de velocidades
*float pulso: amplitude do pulso ao deixar a última camada visutada
*float sensibilidade: sensibilidade de detecção de camadas, definido como percentual de variação de velocidade em relação a velocidade da última camada
*
*/
float reflexaolnterna=0;
float velCamadaAnteriror, velPxCamada, velCamada;
int i=h0;
float raio;
float indiceRefracao;
int profundidadeDaCamada;
float indiceTransmissao;
float amplitudePulso;
velCamada = VEL[coluna][h0];
if (h0&gt;0)
velCamadaAnteriror= VEL[coluna][h0-l];
else {
velCamadaAnteriror=0;
VelPrimeiraCamada = velCamada;
}
// procura próxima camada
{
while ((i&lt;profundidade)&amp;amp;&amp;amp;(fabs(VEL[coluna][i]-velCamada))&lt;velCamada*sensibilidade){
II verifica a profundidade da camada
i++;
}
}
profundidadeDaCamada = i-h0; velPxCamada = VEL[coluna][i];
if (i==profundidade) { // verifica se chegou ao fim do modelo, a última camada não retorna nada e não acrescenta nada ao raio da frente de ona
predicao.cpp	9
return menorAmptitude;
}
//	// Calcula o raio
raio = ((profundidadeDaCamada*velCamada/VelPrimeiraCamada)+raioAnteior); // utilizado para calcular a atenuação por migração
II	Calcula a atenuação
reflexaolnterna = fabs(velPxCamada-velCamada)/(velPxCamada+velCamada);
indiceRefracao = l-reflexaolnterna;
if (velPxCamada&gt;velCamada){
indiceTransmissao =
pulso*indiceRefracao*indiceRefracao*indiceRefracao*velPxCamada/velCamada*velPxCamada/velC amada;
}else {
indiceT ransmissao = pulso*indiceRefracao*indiceRefracao*indiceRefracao *velCamada/velPxCamada;
}
amplitudePulso = reflexaolnterna*pulso/(raio*sqrt(2));
if (amplitudePulsocmenorAmplitude)
menorAmptitude = amplitudePulso;
atnMig(coluna, camada+1, i, raio, profundidade, VEL, indiceTransmissao,
sensibilidade, pMedicao, VelPrimeiraCamada, menorAmptitude);
return (menorAmptitude);
}
float atn(int coluna, int camada, int h0, int profundidade, float**VEL, float pulso, float sensibilidades
float reftexaolnterna=0;
float reftexaoExterna=0;
float amplitudeNaInterface=0;
float velCamada = VEL[coluna][h0];
int i=h0;
while ((i&lt;profundidade)&amp;amp;&amp;amp;(fabs(VEL[coluna][i]-velCamada))&lt;velCamada*sensibilidade){ i++;
}
printf("velocidade:%f profundidade:%d\n", velCamada,i);
if (i==profundidade) { amplitudeNalnterface = pulso*sqrt(h0+l)/sqrt(fabs(i)); printf("Ultima camada %d coluna%d\n",camada,coluna); printf("Velocidade:%f Profundidade:%d h0:%d Pulso: %e PulsoAtenuado: %e\n\n",velCamada, i-h0, h0, pulso, amplitudeNalnterface);
fflush(stdout);
return (1000);//(amplitudeNaInterface);// amplitude na última camada, esta camada n gera reflexão
}
else {
camada++;
eqnl( pulso, velCamada, VEL[coluna][i], reflexaolnterna, amplitudeNalnterface); reflexaolnterna = fabs(reflexaolnterna);
amplitudeNalnterface = fabs(amplitudeNalnterface); reflexaoExterna = atn(coluna, camada, i, profundidade, VEL, amplitudeNalnterface, sensibilidade);
printf("Camada Interna %d coluna %d\n",camada-l, coluna); printf("Velocidade:%f VelocidadePrxCamada:%f Profundidade:%d [%d-%d] Pulso: %e \n",velCamada,VEL[coluna][i], i-h0, h0, i, pulso);
printf("reflexaolnterna:%e reflexaoExterna:%e
\n\n",reflexaolnterna,reflexaoExterna ); fflush(stdout);
if (reflexaolnternacreflexaoExterna)
return (reflexaolnterna);
else return (reflexaoExterna);
predicao.cpp	10
}
void calculaAtenuacao( int largura, int profundidade, float**A0){
int i, j, hl,h2, coluna, camada, ptrColuna, ptrCamada;
float velocidade;
float amplitudePulso=l;
float velocidades[100][100];
int profundidades[100][100];
int ptr=0;
hl=0;
h2=0;
velocidade = A0[0][0];
ptrCamada = 0;
ptrColuna = 0;
for (coluna=0; colunac largura; coluna=coluna+10){ ptrCarnada=0;
for (camada=0; carnadacprofundidade; camada++) {
if (A0[coluna][camada]!=velocidade){ velocidades[ptrColuna][ptrCamada] = velocidade; profundidades[ptrColuna][ptrCamada]=camada-hl; hl =camada; ptrCamada++; velocidade =A0[coluna][camada];
}
} velocidades[ptrColuna][ptrCamada] = velocidade; profundidades[ptrColuna][ptrCamada]=camada-hl; ptrColuna++;
}
ptrCamada;
float amplitudeReflexao,pulso ;
pulso = 1;
for (camada=0; carnadacptrCarnada; camada++){
printf("Camada:%d\n",camada);
printf("Velocidade:%f Profundidade:%d \n\n",velocidades[0][camada], profundidades!©][camada]);
amplitudeReflexao= (pulso/profundidades[0][i])* //atenuação por divergencia cilindrica nos dois sentidos de propagação
(fabs(velocidades[0][0] -velocidades!©][i+1][/(velocidades!©] [©]+velocidades[0][i+l])); // indice de reflexão
pulso =(pulso/sqrt(profundidades[©][i]))* // atenuação por divergencia cilindrica (1-(fabs(velocidades[0][0]-velocidades!©][i+1])/(velocidades[0] [O]+velocidades[0][i+l])))* // parcela da onda que será retratada
(velocidades[0][i+l]/velocidades[0][i]);//* // indice de retração printf("Amplitude do pulso na camada:%f \n\n",pulso);
}
void eqnl( float A_incidente, float VI, float V3, float &amp;amp;refletida, float &amp;amp;refratada){ float alfa=Vl/V3;
float beta=(alfa*A_incidente*A_incidente)-(A_incidente*A_incidente);
float psi=-2*A_incidente;
float gama=l+alfa;
float delta=(psi*psi)+(4*gama*beta);
float refletidal=(-psi+sqrt(delta))/(2*gama);
float refletida2=(-psi-sqrt(delta))/(2*gama);
float refratadal = (A_incidente-refletidal)*V3/Vl;
float refratada2 = (A_incidente-refletida2)*V3/Vl;
float el = fabs(A_incidente/Vl-refratadal/Vl-refratadal/V3);
float e2 = fabs(A_incidente/Vl-refratada2/Vl-refratada2/V3);
if (refratadal==©){
refletida = refletida2;
retratada = refratada2;
}else
if (refratada2==©){
refletida = refletidal;
predicao.cpp	11
retratada = refratadal;
}else
if ((el)&lt;(e2)){
refletida = refletidal;
retratada = refratadal;
}
else {
refletida = refletida2;
retratada = refratada2;
}
}
I
Revisão sobre padrões de representação nu
X •
mérica
O conteúdo desta seção é uma transcrição com adaptações do conteúdo publicado em (BARROS, 2008).
A definição das características de um padrão de representação numérica está diretamente ligada ao conjunto de valores a ser representado e à capacidade de representação do sistema em que este será utilizado.
Esse problema torna-se mais grave em se tratando do conjunto dos números reais, o qual representa o contínuo, o infinito não numerável.
Uma solução para esse problema foi proposta na forma de uma expansão numérica denominada expansão b-ádica (KULISCH; MIRANKER, 1981).
Pela expansão b-ádica, um número real qualquer pode ser univocamente representado por meio de um somatório ponderado infinito de termos de uma base numérica, através da seguinte expressão:
x=s £ dtfik
k=-tt
em que x é o número representado, 8 é o sinal algébrico, p é a base numérica adotada, d representa o valor de cada um dos termos utilizados.
A representação de valores numéricos por meio de um somatório ponderado de termos é também conhecida como notação posicional.
Nos sistemas computacionais, em consequência de limitações de natureza tecnológica, adotam-se representações finitas da expansão b-ádica para representar conjuntos numéricos específicos, tais como o conjunto dos números inteiros, dos inteiros relativos e dos números reais.
I.1	Notação de inteiros
A notação de inteiros é o padrão de representação numérico mais simples de todos os suportados pelos sistemas computacionais. Ele apresenta a vantagem de ter um baixíssimo custo de implementação em hardware, motivo pelo qual é suportado por todos os processadores.
Na notação de inteiros, um número z pode ser representado por uma base numérica p através da seguinte expressão:
z = ± £ di X p	@
i=0
em que di representa a sequência dos n dígitos utilizados.
Apesar de sua simplicidade, essa notação tem um razoável poder de representação, pois os números são formados por arranjos com repetição dos valores numéricos contidos na base adotada. Em uma representação com n dígitos mais uma representação para o sinal algébrico é possível formar
2	X pn
números ou valores distintos. Em especial na base binária, em que normalmente se reserva o bit mais significativo exclusivamente para a indicação do sinal algébrico, considerando uma representação com n bits, teremos:
±(2n-1
+ 2n-2 + ••• + 21 + 20)
ou seja, 2n números representáveis.
I.2	Notação de ponto-fixo
A notação de ponto-fixo estende a notação de inteiros de forma a permitir a representação tanto de números inteiros quanto de números fracionários.
Nessa notação dividem-se os dígitos da representação em dois grupos distintos, os quais ficam separados pelo ponto decimal. Os dígitos à direita do ponto ficam reservados à representação da parte inteira do número, e os dígitos à esquerda, à sua parte fracionária.
Dessa forma, considerando-se a representação de um número z qualquer, em uma notação de ponto-fixo com n dígitos, estando k desses dígitos reservados à representação da parte fracionária, ou seja, estando o ponto separador colocado entre k-ésimo e o k-ésimo + 1 dígitos, teremos:
z = ± £ di x pi-1-k	@
i=1
Deve-se observar que o acréscimo de expressividade obtido com a inclusão da parte
fracionária veio com o prejuízo do intervalo de números inteiros representáveis, que passa dos possíveis pn da notação de inteiros para pn-k.
Entretanto, como a cada número inteiro representável foram acrescentados pk partições decimais, verifica-se que a quantidade total de valores representáveis não se altera, ou seja,
pn-k x pk = pn.
Apesar da redução no intervalo de números inteiros representáveis, a quantidade de valores representáveis continua sendo pn.
Um detalhe importante relativo à notação de ponto-fixo é que a sua precisão de representação depende da quantidade de dígitos reservados à representação da parte fracionária do número. Para a configuração de ponto-fixo apresentada na Equação I.3, essa precisão é de 2-k.
1.3	Notação de ponto-flutuante
A notação de ponto-flutuante pode ser considerada uma extensão da notação de ponto-fixo, a qual teve seu poder de representação ampliado pelo acréscimo de mais um grupo de dígitos denominado campo expoente.
Outra mudança implementada pela notação de ponto-flutuante em relação à notação de ponto-fixo é que os dígitos reservados à representação da parte inteira e da parte fracionária passam a receber o nome de significando, indicando que estes armazenam conjuntamente os dígitos significativos do valor representado.
Diferentemente do que ocorre nas notações de inteiros e de ponto-fixo, na notação de ponto-flutuante, o valor expresso deixa de ser uma aplicação direta da notação posicional para ser o resultado da interação dos valores representados no expoente e no significando. Seu valor pode ser calculado por meio da seguinte expressão:
±S x pe,
em que S denota o valor representado pelo campo significando, p a base numérica adotada e e o valor representado pelo campo expoente.
1.4	O padrão IEEE 754
O padrão IEEE 754 (P754, 1985) define os requisitos mínimos a serem seguidos na implementação da aritmética de ponto-flutuante para a base binária.
No padrão de ponto-flutuante, o valor expresso deixa de ser representado diretamente por meio da notação posicional para ser representado por convenção, mediante uma estrutura de dados com três campos distintos denominados sinal, expoente e significando. Esses três campos
ficam armazenados em uma mesma palavra binária, distribuídos conforme indicado na Figura
I.1.
Bit de Sinal
Bits do campo expoente
Bits da fração do campo significando
Figura I.1: Organização dos campos que formam a representação do padrão de ponto-flutuante.
O sinal algébrico é representado por um único bit, que é carregado com zero para indicar que o número é positivo e com um para indicar que esse é negativo.
O campo expoente é representado por referência, mediante a diferença entre o valor nele armazenado e um valor de referência ou bias, o qual está associado ao expoente zero. Essa estratégia permite, ao mesmo tempo, tanto a representação de valores positivos e negativos quanto simplifica o projeto do hardware necessário para as operações de comparação de magnitude entre dois ou mais números.
O campo signficando é representado na notação de ponto-fixo normalizado, ou seja, com apenas um dígito na sua parte inteira, sendo este diferente de zero.
É o processo de normalização do significando que garante toda a plasticidade do padrão de ponto-flutuante, ou seja, a sua capacidade de se autoadaptar ao valor a ser representado, permitindo que o valor armazenado seja sempre representado com a melhor precisão possível.
É ainda o processo de normalização do significando que determina o valor a ser armazenado no campo expoente. Como cada deslocamento do significando à direita equivale na prática a multiplicá-lo por dois, da mesma forma que cada deslocamento à esquerda corresponde a dividi-lo por dois, para manter o valor originalmente representado pelo significando, cada deslocamento deve ser compensado respectivamente por incrementos ou decrementos do valor atribuído ao campo expoente.
Em consequência da adoção da representação normalizada do significando, como uma forma de economizar espaço de armazenamento, o padrão IEEE 754 estabelece que apenas os bits que representam a parte decimal do significando sejam armazenados. Por essa razão, o conjunto de bits armazenado recebe o nome de mantissa ou fração do significando. Por ter seu valor definido implicitamente, a partir da adoção do padrão normalizado, e não por ter sido armazenado, o bit que representa a parte inteira do significando é muitas vezes denominado de bit implícito.
Além dos valores normalizados, o padrão IEEE 754 prevê que valores com magnitude menor que o menor valor passível de reapresentação normalizada, os quais exigiriam que o expoente assumisse um valor menor que o menor expoente representável, possam ser armazenados de forma não normalizada, ou desnormalizada. Nesse caso, a fim de sinalizar essa ocorrência, o campo expoente deve ser carregado com o valor absoluto zero, o qual passa então a ser reservado apenas para a indicação desse tipo de ocorrência. Esses valores são designados como valores denormais. Um exemplo notável de valor denormal é o próprio número zero.
O padrão determina também que valores com magnitude maior que o maior valor representável, os quais exigiriam que o expoente assumisse um valor maior que o maior expoente válido, devem ser sinalizados como infinito. Essa sinalização é feita carregando todos os bits do campo expoente com um e todos os bits do significando com o valor zero. Nessa representação o valor do bit que representa o sinal algébrico é preservado a fim de permitir a indicação da ocorrência do mais e do menos infinito, (±«&gt;).
É determinada também uma representação especial para sinalizar resultados de operações que não resultam em número, como o caso da divisão de zero por zero. Ocorrências desse tipo são sinalizadas carregando todos os bits do campo expoente com um e o campo significando com um valor diferente de zero. Esses valores são denominados pela sigla NaN, acrônimo do termo em inglês Not a Number, que significa literalmente que o valor armazenado não é um número.
Dessa forma, o valor de um número armazenado em uma representação de ponto-flutuante com n bits no campo significando e k bits no campo expoente pode ser recuperado por meio da seguinte expressão:
- 1s x ¿ bi x 2i-n-1 x 2e-bias+1 i=1
na qual s representa o sinal algébrico, bi representa cada um dos bits do campo significando, e representa o valor armazenado nos bits do campo expoente e bias representa o valor de referência para o campo expoente. O valor do bias é definido através da seguinte expressão:
bias = 2k-1-1.
I.4.1	Formato de representação dos dados
O padrão IEEE 754 estabelece quatro formatos de representação dos dados, os quais estão divididos pelo tipo de notação adotada, que pode ser básica ou estendida, e pela sua precisão, podendo ser de precisão simples ou dupla.
Os formatos estabelecidos são:
■	ponto-flutuante de notação básica e precisão simples, também conhecido como float, com 32 bits;
■	ponto-flutuante de notação básica e precisão dupla, ou double, com 64 bits;
■	ponto-flutuante de notação estendida e precisão simples, ou float extended, com 43 bits ou mais;
■	ponto-flutuante de notação estendida e precisão dupla, ou double extended, com 79 bits ou mais.
Segundo esse padrão, um formato de ponto-flutuante pode ser totalmente definido pela especificação dos seguintes parâmetros de configuração:
206 APÊNDICE I. REVISÃO SOBRE PADRÕES DE REPRESENTAÇÃO NUMÉRICA
■	p: que representa o números de bits do campo significando;
■	Emin e Emax: representando respectivamente o expoente mínimo e máximo representáveis;
■	Bias: que representa o valor de referência para o campo expoente.
A Tabela I.1, a seguir, apresenta os valores dos parâmetros de configuração dos quatro formatos de ponto-flutuante definidos pelo padrão IEEE 754.
Tabela I.1: Valores padrão para os parâmetros de configuração dos quatro formatos de ponto-flutuante.
Campos	Simples Float	Simples Estendido Extended float	Duplo Double	Duplo estendido Estendido Extended double
Sinal( S )	1 bit	1 bit	1 bit	1 bit
Significando( P )	24 bits	&gt; 32 bits	53 bits	&gt; 64 bits
Expoente(E)	8 bits	&gt; 11 bits	11 bits	&gt; 15 bits
Expoente emax	+127	&gt; +1023	+1023	&gt; +16383
Expoente emin	-126	&gt; -1022	-1022	&gt; -16382
Bias	+127	Não definido	1023	Não definido
A fim de garantir a unicidade da representação, evitando, com isso, representações numéricas redundantes, o padrão 1EEE 754 estabeleceu que o significando de todos os números seja expresso com a sua parte inteira representada por um único bit, sendo este diferente de zero. Essa medida impede que números como o 1,0, por exemplo, tenham diversas representações redundantes, tais como 1,0 x 20 ou 0,1 x 21 ou ainda 0,01 x 22. Além de garantir a unicidade de representação, isso permite também para a dispensa do armazenamento do dígito que representa a parte inteira do significando, uma vez que que o seu conteúdo é conhecido a priori.
Por esse motivo, o padrão 1EEE 754 estabelece que apenas os bits que formam a parte fracionária do significando seja armazenada, ou seja, a sua fração. Ao bit que não é armazenad, dá-se o nome de bit implícito, visto que sua representação é implícita pelo uso da representação normalizada. Essa é a forma de representação considerada padrão para todas as notações de ponto-flutuante que atendem ao padrão 1EEE 754. Assim, todo e qualquer número que atende a essa notação é definido como normalizado e, qualquer representação diferente dessa, é considerada desnormalizada.
I.4.2	Representação de valores especiais
A fim de corrigir incongruências de representação entre a notação adotada no padrão 1EEE 754 e a aritmética clássica, foram definidas algumas representações especiais para valores que, de outra forma, não seriam representáveis.
Essa abordagem adotada pelo 1EEE 754 não encontra equivalência em outros padrões de representação numérica utilizado nos sistemas computacionais. No padrão adotado no sistema 1BM 370, por exemplo, todos os padrões de bits possíveis são utilizados para representar valores numéricos válidos. Dessa forma, nos sistemas 1BM 370, todas as operações que possam dar origem a valores não representáveis são encerradas como uma exceção acompanhada de uma mensagem de texto indicando a condição de falha (GOLDBERG, 1991).
No padrão 1EEE754 foram definidas representações especiais para os seguintes casos:
■	Zero: no padrão IEEE 754, o zero é representado por convenção, com os campos mantissa e expoente iguais a zero. Essa padronização se fez necessária porque, por motivos óbvios, o zero não pode ser expresso de maneira normalizada. Outro detalhe importante na representação do zero no padrão IEEE 754 é que este dispõe de sinal, ou seja, existem +0 e -0. Entretanto, a operação de comparação entre dois zeros retorna sempre verdadeira, independentemente do sinal que estes assumam. A representação do zero com sinal é útil para definir o sinal do resultado de operações envolvendo o zero, as quais, em alguns casos, podem dar origem a ■ ^ e —&lt;*&gt;.
■	NaN: essa sinalização, que literalmente significa que o valor armazenado não é um número, é reservada para ser utilizada como resultado de diversas operações aritmética, tais como 0/0 e 0 x&amp;lt;» que, por definição, devem ser sinalizadas como inconsistentes. Qualquer operação aritmética em que pelo menos um dos operandos seja NaN deve também retornar um NaN como resultado. Todas as operações aritméticas de comparação =,&amp;lt;,&amp;lt;, &gt;, &gt;) exceto =, em que pelo menos um dos operandos seja NaN devem retornar falso. O bit de sinal não tem função associada na representação do NaN. O NaN é representado com o campo expoente carregado com todos os seus bits iguais a 1, e o campo mantissa com um valor diferente de zero.
■	Infinito: a representação de Infinito («&gt;) está reservada para demonstrar que um determinado número é, em módulo, maior que o maior número representável. A sinalização de Infinito tanto pode ser gerada em resposta a uma operação aritmética como durante o processo de normalização e arredondamento. A semelhança da representação do valor zero, o Infinito também tem sinal associado, o qual é útil para preservar o sinal das operações aritméticas. O Infinito é representado com o campo expoente carregado com todos os seus bits iguais a um e o campo mantissa com o valor zero
■	Denormal: esta representação foi adotada para suprir a necessidade de sinalizar corretamente uma faixa de valores que, por serem em módulos menores que o menor valor representável de maneira normalizada, acabam sendo convertidos para zero durante o processo de normalização e arredondamento. A Figura I.2 destaca a localizaçao desses valores e o resultado da sua inclusão destes na distribuição dos valores representáveis. A fim de sinalizar que esses valores não atendem à norma, à semelhança do que ocorre com o número zero, eles são representados com o campo expoente igual a zero.
Figura I.2: Distribuição dos valores representáveis em ponto-flutuante, destacando a faixa de valores que seria representada pelos valores denormalizados.
A Tabela I.2 traz um resumo dos valores especiais e suas representações no padrão IEEE 754.
Tabela I.2: Valores especiais e suas representações segundo o padrão IEEE 754.
	Sinal	Expoente		Fração do significando
+Zero	0	000 ••	0	000---0
-Zero	1	000 ••	0	000---0
+Infinito	1	111 ••	1	000---0
- 1n finito	0	111 ••	1	000---0
Denormal	1	000 ••	0	NNN- N
Obs.: Na Tabela I.2 NNN...N denota uma palavra binária onde pelo menos um dos seus bits é diferente de zero.
I.4.3	Arredondamento
O termo arredondamento, segundo o padrão IEEE 754 é o processo de ajustar ou encaixar um número tido como infinitamente preciso para um formato de menor precisão (P754, 1985).
Ao trabalhar com números em ponto-flutuante, deve-se ter em mente que o processo de arredondamento introduzirá um erro no número arredondado, uma vez que este é, na verdade, uma aproximação do valor original.
Diversos são os relatos de falhas em sistemas ocasionadas por esses erros de arredondamento (HUCKLE, 2014). Padrões mais recentes de representação, tais como o IEEE 854 e o IEEEP 754, buscam minimizar esses erros adotando outras bases numéricas e/ou uma representação com maior precisão.
Existem, a princípio, duas situações nas quais um número real não pode ser representado de forma exata em uma notação de ponto-flutuante. A primeira é quando o número não encontra representação finita na base binária, e a segunda é quando, ainda que encontrando uma
representação, esta exige uma precisão maior que a disponível no formato de ponto-flutuante adotado.
Outra situação que impede que um número seja representado é quando este é menor que o menor ou maior que o maior número representável no formato de ponto-flutuante adotado. Nesses casos o número é convertido para + ou —infinito ou para zero.
Do ponto de vista da implementação, a operação de arredondamento nada mais é que um processo de mapeamento, em que se busca identificar, dentre todos os números representáveis na notação destino, aquele que melhor represente o valor a ser arredondado.
Considerem-se, por exemplo, F1 e F2, dois sistemas de ponto-flutuante. F1 representado com um significando com n1 dígitos e F2 representado com n2 dígitos, sendo n1 &gt; n2. Verificase que todo o número representável em F1 ou será precisamente representável em F2 ou sua representação estará entre dois outros números representáveis em F1, aos quais denominaremos de adjacente superior e adjacente inferior.
Essa característica pode ser explicada pelo fato de o significando ser representado em uma notação de ponto-fixo com apenas um bit na sua parte inteira. Por esse motivo, a diferença de representação dos significandos se dará sempre pela sua capacidade de expressar a parte fracionária do número representado. A Figura I.3 demonstra a diferença entre o poder de representação de um significando com 5 bits quando comparado com um de 3 bits.
p=5	-1	0	1
2'1	2"22 32 4	11111111111111111111111111111111111111111111111111111111111111
p=3	-1	0	1
•po 2 2"^	l	I	l	I	l	I	l
I I	I I I I I I I I I I I I
Figura I.3: Diferença na representação entre um significando com 3 e um com 5 bits.
Como se pode perceber, valores múltiplos de 2—2 como 0, 1, 1/2 ou 3/4 podem ser representados precisamente tanto na primeira quanto na segunda notação. Entretanto, valores múltiplos de 2—3 e 2—4 que não forem múltiplo de 2—2, tais como 1/8 ou3/16, só podem ser representados precisamente em F1, tendo que ser aproximados, ou arredondados, em F2.
Na Figura I.4, ve-se em destaque um conjunto de valores existentes no intervalo entre 0 e 1/4 de F1 que precisam ser arredondados para serem representados em F2.
Nesse caso, cada um dos valores representados terá de ser arredondado ou para 0 ou para 1/4, uma vez que estes são, respectivamente, seus adjacentes inferior e superior em F2. A escolha de qual desses valores será utilizado é determinada conforme o modo de arredondamento adotado.
O padrão IEEE 754 prevê quatro modos de arredondamento:
■	Arredondamento em direção ao zero (Round to Zero)
■	Arredondamento em direção ao +Infinito (Round to +Infinity)
Figura I.4: Comparação entre valores representáveis com significandos com 5 e 3 bits.
■	Arredondamento em direção ao -Infinito (Round to -Infinity)
■	Arredondamento para o mais próximo ou par (Round to Nearest Even).
I.4.3.1	Modos de Arredondamento
■ Arredondamento em direção ao zero (Round to Zero) : neste modo, conforme ilustrado na Figura I.5, o número a ser operado é arredondado para o primeiro valor representável em direção ao zero. Essa é, certamente, a forma mais simples e direta de arredondamento. Na prática, apenas se eliminam os bits além do último bit representável fazendo com que o número resultante esteja assim mais próximo do zero que o número original.
Round to Zero
----► ◄------
1 0 1
Figura I.5: Arredondamento em direção ao Zero.
■ Arredondamento em direção ao +Infinito (Round to +Infinity): Neste modo, arredonda-se o número para o número representável mais próximo em direção ao infinito positivo. Desta forma, números negativos devem que ser arredondados para o seu adjacente inferior, enquanto números positivos devem ser arredondados para o seu adjacente superior.
Round to +oo
Figura I.6: Direção do arredondamento em direção ao +~.
■ Arredondamento em direção ao -Infinito (Round to -Infinity):este formato é semelhante ao anterior, diferindo apenas pelo fato de que o arredondamento se dará sempre para o número representável mais próximo em direção ao infinito negativo. Dessa forma, números negativos devem que ser arredondados para o seu adjacente superior, enquanto números positivos devem ser arredondados para o seu adjacente inferior.
Round to -oo
1 0 1
Figura I.7: Direção do arredondamento em direção ao -~.
■ Arredondamento para o mais próximo ou par (Round to Nearest Even): neste modo busca-se o arredondamento para o número representável mais próximo do valor originalmente calculado e, havendo empate entre dois números igualmente distantes, decide-se sempre pelo adjacente que for par.
Esse é o formato mais utilizado nas implementações do padrão IEEE 754, tanto em software quanto em hardware. Também é aquele que apresenta os resultados mais exatos. Em contrapartida, é também aquele que exige mais recurso computacional para ser implementado. Esse modo de arredondamento só não apresenta os melhores resultados quando a sua aplicação resulta em um número que, após a normalização, se transforme em um número maior que o maior ou menor que o menor número representável, o qual acaba sendo convertido ou para infinito ou para zero.
Existem na literatura diversas propostas de implementação para esse modo de arredondamento, incluindo variações que, de modo geral, buscam melhorar o seu desempenho ou reduzir o hardware e/ou o tamanho de código necessário à sua implementação (EVEN; PAUL, 2000; QUACK; KAKAQI; FLYNN, 1991; SANTORO; BEWICK; HAROWITZ, 1989).
Figura I.8: Direção do arredondamento para o mais próximo ou par.
As Figuras I.10 e I.11 trazem dois exemplos de números gerados originalmente com um significando com 5 bits e suas representações após terem sido arredondados, seguindo os métodos apresentados, para um significando com apenas 3 bits.
Figura I.10: Exemplo de Arredondamento para o mais próximo e em direção ao zero.
Os quatro modos de arredondamento definidos no padrão IEEE 754 compartilham de um mesmo processo inicial de pré- processamento, que tem como objetivo a geração de um
significando pré- arredondado e a obtenção de algumas outras informações que orientarão o restante do processo de arredondamento.
De modo geral, dado um número em ponto-flutuante com um significando com m bits, que se deseja arredondar para uma representação com n bits, primeiramente separam-se os n bits mais significativos do significando original, a fim de formar o significando pré-arredondado. Em seguida, identificam-se três bits especiais denominados LSB-Bit (Least Significant Bit), Guard-Bit e Sticky-Bit, que são obtidos do significando original conforme indicado no esquema da Figura 4.2.
Figura I.11: Esquema para obtenção do LSB bit, do Guard bit e do Sticky bit.
Por fim, durante o processo de arredondamento, a partir da análise do modo de arredondamento, do sinal do número a ser arredondado e dos três bits especiais, define-se o valor a ser atribuído a um quarto bit, denominado Round-Bit, que deve ser adicionado ao significando pré-arredondado a fim de obter o significando final arredondado, conforme mostra a figura I.12.
nBits
2» 2-' 2-2 2-’ 2-
	!•«
	i	_A
n Bits	1—1	" s Y Stickybit
A,	
2°^ 2'1 2J 2J 2&lt;”&gt;	
		® 	!• 1 •
t'
~	Sticky bit
Figura I.12: Nova organização dos bits para simplificar a análise do processo de arredondamento.
Com relação aos bits especiais, o bit Guard-Bit, conforme se pode observar na Figura
4.2,	dividirá os bits do significando original em dois grupos, um à esquerda, com os n bits mais significativos, os quais formarão o significando pré- arredondado, e um à direita, com o
restante dos bits que serão descartados. O Sticky-Bit indica se algum bit do grupo de bits à direita do Guard-Bit é diferente de zero. O LSB-Bit é o bit menos significativo do significando pré-arredondado.
Neste ponto, apenas para simplificar a análise do processo de arredondamento, os bits do significando foram reorganizados, deslocando o ponto separador da sua posição original para a posição entre o LSB-Bit e o Guard-Bit, conforme disposto na Figura I.12.
Essa nova organização dos bits torna-se interessante porque nos permite visualizar o processo de arredondamento de um número qualquer como o processo de arredondamento de um número fracionário para um número inteiro. Dado que todo número fracionário situa-se no intervalo definido por seus dois inteiros adjacentes, como se pode ver no esquema a seguir, pode-se resumir o nosso processo de arredondamento como o processo de escolha para qual desses dois inteiros adjacentes o número fracionário deverá ser arredondado.
(n +1)
n x zzz ••• zz
(n)
Dessa forma, considerando o esquema proposto, têm-se os seguintes exemplos:
a)	10 — 9.2F • • —&gt; 9 (9.21 pode ser arrendondado para 9 ou para 10);
b)	3 — 2.73- • • —&gt; 2 (2.73 pode ser arrendondado para 2 ou para 3);
c)	236 — 235.21 • • • —&gt; 235 (235.21 pode ser arrendondado para 235 ou para 236).
Assim, pode-se perceber que o que está envolvido no processo de arredondamento de um número Real qualquer, não representável em uma determinada notação de ponto-flutuante, é o processo de mapeamento ou escolha entre qual dos seus adjacentes representáveis nessa notação o substituirá. Nessa escolha, o modo de arredondamento adotado é que norteará, em última instância, a escolha de qual dos dois adjacentes deverá ser utilizado.
Desse modo, após a execução dos passos iniciais, aplica-se o algoritmo de arredondamento específico associado ao modo de arredondamento escolhido de forma a poder valorar adequadamente o Round-Bit.
Figura I.13: Geração do novo significando por meio dos bits extraídos do significando original e do Round bit obtido durante o processo de arredondamento.
2&lt;n-n	X 2“
l°l°l°H	l«l
	po o
	§
	tf
	X
	2°
swwrz	1*1
O valor atribuído ao Round-Bit definirá, em última instância, para qual dos números adjacentes representáveis o número original será arredondado, de tal forma que:,
Quando o Round Bit for zero, arredondar-se-á o número para o valor adjacente inferior, ou seja, para aquele com o menor valor em módulo.
Por outro lado, quando o Round Bit for um, arredondar-se-á o número para o adjacente superior, ou seja, para aquele que tem o maior valor em módulo.
1.4.3.2	Algoritmo do modo de arredondamento em direção ao zero
Neste modo de arredondamento o número será sempre arredondado para o seu adjacente inferior, ou para aquele adjacente que esteja mais próximo do zero, conforme indica a Figura I.5. Para tanto, simplesmente atribui-se zero ao Round Bit. Em síntese, simplesmente se eliminam os bits excedentes do significando a ser arredondado, preservando os n bits mais significativos como o significando arredondado.
1.4.3.3	Algoritmo do modo de arredondamento em direção ao + e ao - Infinito
Uma vez que o algoritmo utilizado no modo de arredondamento em direção ao +Infinito é muito semelhante ao aplicado no modo de arredondamento em direção ao -Infinito, serão apresentados primeiramente os detalhes do algoritmo para o modo de arredondamento em Direção ao -Infinito; em seguida, apenas serão indicados os passos que diferenciam esse procedimento do adotado no modo de arredondamento em direção ao +Infinito.
No modo de Arredondamento em Direção ao -Infinito, conforme se pode observar da Figura I.7 , os números positivos devem ser arredondados para o seu adjacente inferior, enquanto os números negativos devem ser arredondados para o seu adjacente superior. Para atingir tal objetivo, aproveita-se o fato de o bit de sinal ter valor zero para números positivos e um para números negativos, e apenas atribui-se o bit de sinal diretamente ao Round-Bit, de tal forma que o Round-Bit seja igual a zero para os números positivos e um para os números negativos.
No modo de Arredondamento em Direção ao +Infinito, aplica-se a mesma lógica, com a única diferença que o Round-Bit é obtido por meio do inverso do bit de Sinal. Assim esse bit será zero quando se estiver arredondando um número negativo e um quando o número for positivo.
1.4.3.4	Algoritmo do modo de arredondamento em direção ao mais próximo ou par
Como o próprio nome diz, neste modo busca-se arredondar o número para o adjacente representável que estiver mais próximo do número original, ou, em caso de empate, para o adjacente que for par.
Dessa forma, conforme indicado na Figura I.8, não se pode definir para qual dos adjacentes um determinado número será arredondado sem antes proceder a uma análise do número a ser arredondado, o que é feito através do Guard-Bit, do Sticky-Bit e do LSB-Bit.
Segundo o esquema proposto na Figura I.12, o Guard Bit estará diretamente associado ao valor atribuído ao bit ponderado com 2-1, ou 0,5, no somatório das partes que compõem essa nova parte fracionária do número. O Sticky Bit, por sua vez, está associado à ocorrência de um valor diferente de zero no somatório dos bits que tenham peso associado menor que2-1. O esquema proposto na Figura I.14 demonstra como se procede a essa análise.
Figura I.14: Localização do valor relativo do número a ser arredondado por meio do Guard Bit e do Sticky Bit.
Primeiramente, observa-se a parte fracionária do número através dos valores atribuídos ao Guard-bit e ao Sticky-bit. Nessa observação podem-se chegar às seguintes situações:
a)	O Guard-bit e o Sticky-bit são ambos iguais a ’1’, o que indica que a parte fracionária do número é maior que 0,5; portanto, o número a ser arredondado está mais próximo do seu adjacente superior do que do seu adjacente inferior. Nesse caso o Round-bit deve ser feito igual a ’1’.
b)	O Guard-bit e o Sticky-bit são ambos iguais a ’0’, o que indica que a parte fracionária do número é também igual a ’0’; portanto, o número é coincidente com o seu adjacente inferior. Nesse caso o Round-bit deve ser feito igual a ’0’.
c)	O Guard-bit é ’0’ e o Sticky-bit é ’1’, o que indica que a parte fracionária do número é menor que 0,5, mas maior que ’0’, estando, dessa forma, o número mais próximo do seu adjacente inferior do que do adjacente superior. Nesse caso o Round-bit deve ser feito igual a ’0’.
d)	O Guard-bit é ’1’ e o Sticky-bit é ’0’, o que indica que a parte fracionária do número é exatamente igual a 0,5, estando o número, desse modo, a igual distância dos seus dois adjacentes representáveis. Nesse caso o número deve ser arredondado para o adjacente par. Uma forma prática de identificar o adjacente par é observando o LSB. Uma vez que, por esta análise, o adjacente inferior é o próprio número representado sem os bits que serão eliminados, quando o LSB for igual a zero, ou seja, quando o bit menos significativo da parte que será preservada for igual a zero, o número e, consequentemente, o adjacente inferior, será par. De maneira análoga, quando o LSB
for igual a ’1’, o adjacente inferior será ímpar, por conseguinte, o adjacente superior será par. Dessa forma, pode-se simplesmente atribuir o valor do LSB ao Round- bit a fim de concluir o processo de arredondamento.
A Tabela I.3 demonstra de maneira sucinta os possíveis valores para os bits Guard Bit, Sticky Bit e LSB e o valor a ser associado ao Round Bit para cada uma das combinações.
Tabela I.3: Definição do Round-Bit no arredondamento para mais próximo ou par.
Guard-Bit	Stick-Bit	LSB-Bit	Round-Bit
0	X	X	0
1	0	0	0
0	0	1	1
1	1	X	0
I.4.4	Normalização
Conforme descrito na seção I.4.1, a fim de garantir a unicidade de representação dos números em ponto-flutuante, o padrão IEEE 754 adota o padrão de representação normalizada para todos os valores representáveis. Como o IEEE 754 adota a base binária, significa dizer que todo número deve ser representado com a parte inteira do significando igual a 1. Toda a representação que não atenda a esse padrão é considerada desnormalizada.
Mesmo que opere apenas com números normalizados, as operações aritméticas podem dar origem a resultados desnormalizados. A Figura I.15 traz alguns exemplos de operações entre operandos normalizados que apresentam resultados desnormalizados.
a)	3,0* 10°*3,0* 10°=9,0* 10°
JZL
(1.100,..00b*2')*( 1.100...00b*2‘)=( 10.010 ...00b*22)
b)	1,0* 10ü+l,0*10"=2,0*10°
JZL
(1.000...00b*2°)+(l.000...00b*2°)=( 10.000.,.00b*2°)
c)	l,0*10°-5,0*10“' = 0,5*10"
JZL
(1,000...00b*2°)-( 1.000 ...00b«2“')=(0.100 ...00b*2°)
Figura I.15: Exemplos de operações efetuadas em ponto-flutuante de base binária com valores normalizados que geram valores desnormalizados.
Como se pode perceber, apesar de expressarem corretamente os resultados da operações, todos os exemplos apresentam resultados em desacordo com o padrão de representação adotado no padrão IEEE 754, sendo, portanto, considerados desnormalizados.
Nos dois primeiros exemplos, os resultados são considerados desnormalizados por apresentarem a parte inteira do significando maior que 1. No terceiro exemplo, o resultado é considerado desnormalizado por apresentar a parte inteira igual a zero. A seguir é apresentado o algoritmo de normalização adotado neste projeto.
I.4.4.1	Algoritmo de Normalização
O algoritmo aqui apresentado destina-se a implementações de ponto flutuante em representação binária, entretanto, com os devidos ajustes, esse algoritmo pode também ser aplicado a implementações de ponto-flutuante em representação decimal:
a)	Identifica-se a posição do primeiro bit igual a um no significando.
b)	Calcula-se a distância da posição do primeiro bit em ’1’ encontrado, para a posição padrão em que este deveria encontrar-se para números normalizados. Ou seja, calculase a distância deste para a primeira posição à esquerda do ponto separador. Se este estiver à esquerda da posição esperada, a distância é considerada positiva; se estiver à direita, a distância é considerada negativa.
c)	Efetua-se o deslocamento dos bits do significando de forma a colocar o primeiro bit na posição correta, ou seja, na primeira posição à esquerda do ponto separador.
d)	Uma vez que o procedimento de deslocar um número para a direita equivale a dividi-lo pela base adotada, ao mesmo tempo em que desloca para a esquerda, equivale a multiplicá-lo pela mesma base; a cada deslocamento do significando, tanto para a direita como para a esquerda, deve-se proceder à correção do expoente, de forma a manter o valor originalmente expresso pelo número representado.
e)	Deve-se ter em mente que o procedimento de normalização não deve modificar o valor originalmente expresso pelo número representado. Dessa forma, não deve haver descarte dos dígitos que forem sendo deslocados.
f)	Por fim, havendo necessidade, deve-se proceder um novo arredondamento do significando após o processo de normalização.
Desse modo, tomando como exemplo os resultados obtidos nos exemplos anteriores, verifica-se que:
’1’ está deslocado uma posição à esquerda da posição em que se deveria encontrar. Portanto, deve-se ao mesmo tempo proceder ao deslocamento do significando em uma posição à direita e efetuar o incremento proporcional do expoente. Dessa forma, respectivamente se teria:
10.010••• 00b x 22 —&gt; 1.0010••• 00b x 23
10.000••• 00b x 20 —&gt; 1.0000••• 00b x 21
■ Para o resultado obtido no exemplo (c), 0.100...00b x 20, tem-se: o primeiro bit em ’1’ está deslocado uma posição à direita da posição em que se deveria encontrar. Nesse caso deve-se, ao mesmo tempo, proceder ao deslocamento do significando em uma posição à esquerda e efetuar o decremento proporcional do expoente. Como resultado, tem-se:
0.100-•-00b x 20 —&gt; 1.000-•-00b x 2-1
I.4.5	Operações aritméticas
O 1EEE 754 determina que todas as suas implementações deem suporte às operações aritméticas de soma, subtração, multiplicação, divisão e resto da divisão inteira.
Apesar de não fazer restrições no tocante aos algoritmos a serem adotados, o padrão emphIEEE 754 define que todas as operações aritméticas devem ser implementadas de modo a produzir um resultado definido por esse padrão como infinitamente preciso, com tantos dígitos quantos forem necessários à sua representação exata, o qual deve então ser arredondado e normalizado para o formato de ponto-flutuante adotado.
Também estão definidos os resultados esperados para as operações em que um ou os dois operandos envolvidos não estejam normalizados. Nessas situações deve-se observar um fluxo alternativo de execução de modo a obter os resultados identificados nas Tabelas I.4, I.5, I.6 e I.7.
Tabela I.4: Resultados esperados para operações de multiplicação dos elementos da linha
inicial pelos elementos da coluna inicial.
	Zero	Numero	Nan	Infinito
Zero	Zero	Zero	Nan	Zero
Número	Zero	Numero	Nan	Infinito
Nan	Nan	Nan	Nan	Nan
Infinito	NaN	Infinito	Nan	Infinito
Tabela I.5: Resultados esperados para operações de divisão dos elementos da linha inicial pelos elementos da coluna inicial.
	Zero	Numero	Nan	Infinito
Zero	NaN	NaN	Nan	NaN
Número	Zero	Numero	Nan	Infinito
Nan	Nan	Nan	Nan	Nan
Infinito	Zero	Zero	Nan	NaN
Tabela I.6: Resultados esperados para operações de adição dos elementos da linha inicial pelos elementos da coluna inicial.
	Zero	Numero	Nan	Infinito
Zero	Zero	Numero	Nan	Infinito
Número	Zero	Numero	Nan	Infinito
Nan	Nan	Nan	Nan	Nan
Infinito	Infinito	Infinito	Nan	Infinito
Tabela I.7: Resultados esperados para operações de subtração dos elementos da linha inicial pelos elementos da coluna inicial.
	Zero	Numero	Nan	Infinito
Zero	Zero	Numero	Nan	Infinito
Número	Zero	Numero	Nan	Infinito
Nan	Nan	Nan	Nan	Nan
Infinito	Infinito	Infinito	Nan	NaN
I.4.5.1	Operações de Soma e Subtração
As operações de soma e subtração em ponto-flutuante compartilham de um mesmo algoritmo de execução. Em ambos os casos, deve-se primeiramente preparar os operandos, efetuar a operação desejada e, por fim, normalizar e arredondar o resultado para o formato de ponto-flutuante adotado.
O procedimento de preparação dos operandos tem como objetivo alinhar os pesos atribuídos ao bits dos dois significandos entre si, de tal forma que a operação de soma ou subtração ocorra somente entre bits que estejam sendo associados a pesos equivalentes.
Esse procedimento se faz necessário uma vez que o expoente irá alterar os pesos atribuídos aos bits do significando, fazendo com que o ponto separador seja virtualmente deslocado da sua posição original.
Considerem-se, para melhor compreensão, dois operandos Op1 e Op2, os quais poderiam ser expressos da seguinte forma:
Op1	■	1' x (bnpe1 + bn-1Pe1-1 + ••• + b1pe1-(n+1) + bope1-n)
Op2	- 1sinal x (bnpe2 + bn-1pe2-1 + • • • + b1pe2-(n+1) + bope2-n)
Sendo e1 o expoente de Op1 e e2 o expoente de Op2, verifica-se que só se pode proceder uma operação de soma ou subtração entre Op1 e Op2 se e1 = e2 , uma vez que só nessa condição os seus bits estarão perfeitamente alinhados entre si.
Percebe-se que, se e1 &gt; e2, têm-se os pesos associados aos bits de Op1 maior que os seus correspondentes em Op2, exigindo dessa forma que se proceda a um realinhamento nos bits de um dos significandos antes de poder operá-los. De maneira análoga, o mesmo ocorre se e2 &gt; e1.
A fim de garantir maior precisão nos resultados, deve-se sempre realinhar o significando do operando com o menor expoente em função do significando do operando com maior expoente, de tal forma a poder expressar ambos em função do maior expoente.
O realinhamento dos bits se faz através de deslocamentos sucessivos à direita dos bits do significando a ser realinhado, conforme demonstrado na Figura I.16. Desloca-se, desse modo, o significando que está sendo realinhado até que a posição do seu ponto separador coincida com a posição do ponto separador do significando que não será alterado.
n bits
Significando
Figura I.16: Realinhamento do significando.
deslocado, uma vez que a operação de deslocamento de um número à direita equivale a dividi-lo pela base numérica adotada, a cada deslocamento, deve-se incrementar o valor do expoente associado.
Após esse procedimento, tem-se os dois operandos expressos em função de um mesmo expoente e, por conseguinte, os pontos separadores e todos os bits realinhados, podendo-se operá-los normalmente.
Apenas como um exemplo prático, considerem-se duas operações de soma entre os operandos Op1, Op2, Op3 e Op4, respectivamente 12,5,4,5 , 14,5 e 4,75 , representados no formato de ponto-flutuante hipotético apresentado na Tabela I.8.
Tabela I.8: Formato de ponto-flutuante com 9 bits, formulado apenas para fins didáticos.
Campo	Valor	Observações
Sinal(s)	1 bit	Tamanho em bits
Significando	6 bits	5 bits armazenados + 1 bit implícito
Expoente Máximo (emax)	3	representado pelo binário 110
Expoente Mínimo (emin )	-2	representado pelo binário 001
Referência do	Ex- poente Bias	3	representado pelo binário 011
As Figuras 2.20,I.17,I.18 e I.19, demonstram o processo de conversão e a representação dos operandos Op1, Op2, Op3 e Op4 para o formato de ponto-flutuante proposto.
Figura I.17: Representação esquemática da conversão de Op2 para o formato de ponto-flutuante proposto.
Figura I.18: Representação esquemática da conversão de Op3 para o formato de ponto-flutuante proposto.
Op4 = 2,375 —&gt;1 *21+0*2°+0*2 *+1*2 2+l*2 3+0*2 4-&gt;10.0110
3
1.00110 *2*
Sinal -0 positivo \	■
Significando “1.00110
Expoente “l + 2fos“4 —100
000110100
V
Op4 Formatado em
Ponto Flutuante
Figura I.19: Representação esquemática da conversão de Op4 para o formato de ponto-flutuante proposto.
Considere-se primeiramente a operação de soma entre os operandos Op1 e Op2. Essa operação pode ser feita de duas maneiras, com e sem o realinhamento do significando, conforme apresentado na Figura I.20.
Na Figura I.20(a), temos a operação sendo efetuada sem o realinhamento do significando. Como se pode observar, ao se tentar efetuar a operação sem proceder ao realinhamento, acaba-se por se obter não apenas um significando resultante incorreto, mas também o expoente associado fica indefinido.
12.50
+ 2.25
1.10010*23
"*”1.00100 *2*
12.50
2.25
1.10010*23
+1.00100*2*
1 10010*23
.--K 0.01001 *23
111011*23
Figura I.20: Diagrama esquemático da operação de soma entre Op1 e Op2.
exemplo, uma vez que Op1 tem o maior expoente, procede-se ao realinhamento do significando de Op2 seguindo o esquema apresentado na Figura I.16.
Depois de haver concluído o realinhamento, efetua-se a soma direta, bit a bit dos dois significandos.
O resultado obtido é considerado no padrão IEEE 754 como infinitamente preciso, ou seja, está expresso na maior precisão alcançável para o formato de ponto-flutuante adotado para os operandos.
Como o resultado obtido já está normalizado, e não necessita ser
Expoente = 3+ Bias~ 6—110
Sinal ~ 0 positivo 1
Significando ~ 1.11011
011011110
V
Formatado em Ponto Flutuante
Figura I.21: Representação do resultado da operação entre Op1 e Op2 no formato de ponto-flutuante proposto.
Considere-se agora a operação de soma entre Op3 e Op4, que está demonstrada esquematicamente na Figura I.22.
Figura I.22: Representação esquemática da operação de adição entre Op3 e Op4.
De maneira semelhante à adotada na operação anterior, antes de serem realinhados, os operandos são primeiramente convertidos do formato de ponto-flutuante para o formato binário.
Como se pode observar, em razão do descarte dos bits menos significativos, o que normalmente ocorre durante o processo de realinhamento do significando, após a operação de realinhamento, o significando do operando Op4 passou de 2,375 para 2,25. A expressão a seguir demonstra o que ocorreu com a representação de Op4.
(2,375io) 10011102 —&gt; (2,25io)OOO1O.O12
Por fim, estando os bits dos significandos já realinhados, pode-se efetuar a operação de soma dos significandos, obtendo como resultado um significando dito infinitamente preciso.
Nessa operação, diferentemente da anterior, obteve-se um resultado desnormalizado, que precisará ser normalizado, e o arredondado antes que se possa obter o resultado final da operação.
O procedimento de normalização se dará conforme descrito na Seção 2.3.6 desta tese. Na Figura I.23 a seguir, apresenta-se o resultado obtido após a normalização.
10.00011*23
Normalização —►JJJ
1.000011*24
Figura I.23: Operação de normalização sobre resultado da adição de Op3 e Op4.
Por fim, aplica-se o algoritmo de arredondamento para o mais próximo ou par ao significando já normalizado, conforme descrito na Seção , obtendo o significando final da operação. Para o formato de ponto flutuante adotado neste exemplo, primeiramente reservam-se os 6 bits mais significativos para formar o significando pré-arredondado, ficando o bit menos significativo do significando original exercendo a função de Guard-Bit. Nesse caso o Guard-Bit será igual a um, e, como não restam mais bits para formarem o Sticky-Bit, assume-se que o Sticky-Bit é igual a zero. O LSB-Bit, neste exemplo, é igual a um. A Figura I.24, a seguir, demonstra como ficam distribuídos os bits do significando original durante o processo de arredondamento.
100001 1 000...0
Significando Guard Bit Sticky Pré-Arredondado	Bit
Figura I.24: Distribuição dos bits durante o processo de arredondamento.
Por fim, aplicando-se os valores obtidos à Tabela 5, verifica-se que o Round bit deve ser feito igual a um. O resultado final do procedimento de arredondamento pode ser visto na Figura I.25 a seguir.
Significando
Pré-Arredondado
1.00001 + 0.00001	— Round Bit
1.00010 ^^.Significando
Arredondado
Figura I.25: Resultado do processo de arredondamento.
A Figura I.26 traz o fluxo de execução das operações de soma e subtração.
Figura I.26: Fluxo de execução das operações de soma e subtração.
I.4.5.2	Operação de Multiplicação
Diferentemente das operações de soma e subtração, a operação de multiplicação dispensa qualquer preparação prévia dos operandos.
O algoritmo de multiplicação pode ser resumido em:
a)	somar os expoentes;
b)	normalizar e arredondar o resultado obtido;
c)	calcular o sinal do resultado através da aplicação da função lógica OU-EXCLUSIVO com os sinais dos operandos.
Dois detalhes importantes devem ser observados durante a execução das operações de multiplicação dos significandos e de soma dos expoentes.
Com relação à multiplicação dos significandos, uma vez que a multiplicação de dois inteiros com n bits resulta em um inteiro 2n bits, e considerando que o ponto separador divide o significando em duas partes distintas: uma representando a parte inteira, com 1 bit, e outra representando a parte fracionária, com n-1 bits restantes, tem-se que o resultado da operação de multiplicação entre os significandos resultará em um significando com 2n bits, com 2 bits representando a parte inteira e 2n-2 bits para a parte fracionária, conforme pode ser visto na Figura I.27.
n Bits		n Bits	
	"X		
20 2'^ 2*2	2H-1	2 o 2’^ 2’2	2n'
	l*l*l*l	X @.I»H	
Figura I.27: Distribuição dos bits como resultado de uma operação de multiplicação entre dois inteiros de tamanho n.
O outro detalhe diz respeito à necessidade do cancelamento do Bias, ou zero de referência, durante a operação de soma dos expoentes. Uma vez que o valor do expoente é formado pela soma do expoente desejado com o valor do Bias, deve-se evitar a soma duplicada do Bias durante a soma dos expoentes, subtraindo o seu valor do resultado final obtido.
A Figura I.28, a seguir, demonstra o fluxo de execução das operações desse algoritmo.
Figura I.28: Fluxo de execução da operação de multiplicação.
Apenas como um exemplo, considere-se a operação de multiplicação entre os operandos Op1 e Op2, respectivamente 1,65625 e 6,125, representados no formato de ponto-flutuante apresentado na Tabela I.8.
Nesse formato, Op1 e Op2 seriam representados da seguinte forma:

Op1 =
Op1 = 1,65625-1*2° +1*2 *+0*2 a+l*2 3 + 0*2 4+l*2 5
010101011
+-■ Formatado em Ponto Flutuante
{Sina l ~ 0( positivo1	,
Significando -1.10101
Expoente ~0 + Bias ~ 3 — 011
Figura I.29: Representação esquemática da conversão de Op1 para o formato de ponto-flutuante proposto.
Op2 = 6,125-1 *2a + l*21 + 0*2° + 0*2 J + 0*2 a+l*2 3 {Sinal - 01 positivo
Significando -\ .10001
Expoente 2 + 5zas~5 —101
Op2 =
4 010001101
T---------'
_____________ v Formatado em Ponto Flutuante
Figura I.30: Representação esquemática da conversão de Op2 para o formato de ponto-flutuante proposto.
Multiplicando os Significandos, tem-se:
1.10101 x 1.10001 = 10.1000100101
Em seguida, somando os expoentes, tem-se:
e1 + e2 — Bias = 0 + 5 — 3 = 2
Operando os sinais
0(Positivo)XOR0(Positivo) = 0(Positivo)
Os quais, operado, resultam em:
23 + 21 + 2-3 + 2-6 + 2-8 = 10,14453125
Pelo padrão IEEE 754, esse seria considerado o resultado infinitamente preciso para essa operação. Entretanto, esse resultado não pode ser diretamente representado no formato de ponto-flutuante adotado, devendo ser primeiramente normalizado e arredondado seguindo o que foi já foi apresentado. Nesse exemplo, aplicando-se o modo de arredondamento para o mais próximo ou par, após a normalização, tem-se:
significando = 10.1000100101 —&gt; 1.01000100101
Expoente = 2 —&gt; 3
Após a aplicação do algoritmo de arredondamento, tem-se:
significando = 1.01000100101 —&gt; 1.0100101
Expoente = 3
3
Por fim, convertendo os resultados obtidos do significando e do expoente para o formato de número real, obtém-se:
23+21+2-2=10.25
Esse é considerado o resultado mais preciso para essa operação nessa notação de ponto-flutuante.
O resultado obtido pode então ser convertido para o formato de ponto-flutuante adotado conforme disposto na Figura I.31 a seguir:
Sinal = 0 &amp;lt;positivo
Significando = 1.01001
Expoente — 3 + Bias = 6—110
001001110
V
Formatado em
Ponto Flutuante
Figura I.31: Representação esquemática da conversão do resultado para o formato de ponto-flutuante proposto.</field>
	</doc>
</add>