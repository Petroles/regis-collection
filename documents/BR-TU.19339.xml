<?xml version="1.0" encoding="utf-8"?>
<add>
	<doc>
		<field name="docid">BR-TU.19339</field>
		<field name="filename">2662_244608.pdf</field>
		<field name="filetype">PDF</field>
		<field name="text">
PAULO HIROAQUI RUIZ NAKASHIMA

ALOCAÇÃO DE GÁS DE ELEVAÇÃO

EM CAMPOS DE PETRÓLEO:

MODELOS E ALGORITMOS

FLORIANÓPOLIS
2007



UNIVERSIDADE FEDERAL DE SANTA CATARINA

PROGRAMA DE PÓS-GRADUAÇÃO
EM ENGENHARIA ELÉTRICA

ALOCAÇÃO DE GÁS DE ELEVAÇÃO

EM CAMPOS DE PETRÓLEO:

MODELOS E ALGORITMOS

Tese submetida à
Universidade Federal de Santa Catarina

como parte dos requisitos para a obtenção
do grau de Doutor em Engenharia Elétrica.

Paulo Hiroaqui Ruiz Nakashima

Florianópolis, Outubro de 2007.



Alocação de Gás de Elevação em Campos de Petróleo:
Modelos e Algoritmos

Paulo Hiroaqui Ruiz Nakashima

‘Esta Tese foi julgada adequada para a obtenção do título de Doutor em Engenharia
Elétrica, Área de Concentração em Automação e Sistemas, e aprovada em sua forma final

pelo Programa de Pós-Graduação em Engenharia Elétrica da Universidade Federal de Santa
Catarina.’

Eduardo Camponogara, Ph.D.
Orientador

Katia Campos de Almeida, Ph.D.
Coordenadora do Programa de Pós-Graduação em Engenharia Elétrica

Banca Examinadora:

Eduardo Camponogara, Ph.D.
Presidente

Marcus Vinicius Soledade Poggi de Aragão, Ph.D. PUC-RJ

Mario Cesar Mello Massa de Campos, Dr. CENPES

Julio Elias Normey Rico, Dr. UFSC

Ubirajara Franco Moreno, Dr. UFSC

ii



Dedico este trabalho a meus pais, Hiroaqui e Ivone, e a minha tia Alice, pela educação e o apoio

que me permitiram chegar até aqui.

iii



AGRADECIMENTOS

Ao Professor Eduardo Camponogara, pela orientação, amizade, paciência, apoio, e pela confiança

depositada em mim para a realização deste trabalho.

Ao jovem camarada Agustinho Plucênio, pela amizade e por sua grande experiência compartilhada

com todos, originando valiosas idéias utilizadas aqui.

Aos Professores Augusto, Daniel e Julio, coordenadores do PRH-34 durante o período deste doutorado,

pelo total apoio a esta pesquisa.

A todos os meus amigos (sem citar nomes pra não correr o risco de esquecer alguém) que estiveram

comigo durante esta minha ótima fase em Florianópolis.

A toda minha família, que soube compreender minha ausência e me apoiou nos momentos difíceis.

A Agência Nacional de Petróleo, que financiou parte desta pesquisa.

iv



Resumo da Tese apresentada à UFSC como parte dos requisitos necessários para obtenção
do grau de Doutor em Engenharia Elétrica.

Alocação de Gás de Elevação em Campos de Petróleo
Modelos e Algoritmos

Paulo Hiroaqui Ruiz Nakashima

Outubro/2007

Orientador: Prof. Dr. Eduardo Camponogara
Co-Orientador: Prof. Dr. Daniel Pagano
Área de Concentração: Automação e Sistemas
Palavras-chave: Algoritmos, Indústria de Petróleo, Métodos de Otimização, Pesquisa Op-
eracional
Número de Páginas: xiii + 110

O sistema de elevação artificial de petróleo por injeção contínua de gás, conhecido como

continuous gas-lift ou simplesmente gas-lift é um dos mais utilizados no Brasil e no mundo,

devido ao seu baixo custo relativo e eficiência satisfatória em uma vasta gama de condições

de operação. Neste sistema de produção, a alocação da taxa disponível de injeção de gás

para um grupo de poços é um problema de grande relevância. A decisão da taxa de injeção

de gás para cada poço normalmente não é ótima, pois é baseada em regras ad hoc. Sendo

assim, ganhos substanciais podem ser alcançados se estas decisões forem substituídas por

soluções ótimas.

Neste trabalho, apresentamos algumas abordagens para a solução do problema de max-

imizar o lucro obtido com a venda de hidrocarbonetos extraídos de um campo com poços

operando via gas-lift. As soluções desenvolvidas utilizam Programação Dinâmica, Progra-

mação Linear Inteira Mista aliada à Teoria de Desigualdades Válidas e algoritmos Branch-

and-Bound e Branch-and-Cut e fornecem a taxa de injeção de gás ótima para cada poço

satisfazendo restrições como por exemplo a taxa de injeção disponível e os limites de pro-

cessamento de fluidos produzidos.

As abordagens desenvolvidas se mostram eficientes para a aplicação em questão. As

soluções encontradas possuem alta qualidade (próximas das soluções ótimas), e o custo

computacional para a obtenção das mesmas é baixo. As técnicas de solução propostas aqui

constituem excelentes ferramentas de suporte à decisão, podendo substituir as decisões sub-

ótimas normalmente fornecidas por pacotes de otimização comerciais.

v



Abstract of Thesis presented to UFSC as a partial fulfillment of the requirements for the
degree of Doctor in Electrical Engineering.

Lift-Gas Allocation for Oil Fields
Models and Algorithms

Paulo Hiroaqui Ruiz Nakashima

October/2007

Advisor: Prof. Dr. Eduardo Camponogara
Co-Advisor: Prof. Dr. Daniel Pagano
Research Area: Systems and Automation
Keywords: Algorithms, Oil Industry, Optimization Methods, Operational Research
Pages: xiii + 110

The artificial lifting method known as continuous gas-lift, or gas-lift for short, is one of

the most used in Brazil and in the world, due to its relatively low cost and good efficiency

on a wide range of operational conditions. For this production system, the available lift-gas

injection rate allocation for a cluster of wells is an important problem. The injection rate for

each well is normally bellow the optimal point, because it is based on ad-hoc rules. Thus,

substantial improvements may be reached if these decisions were substituted by the optimal

solution.

In this work, we show some approaches to solve the problem of maximize the profit

obtained with hydrocarbons extracted from an oilfield with wells producing via gas-lift. The

developed solutions use Dynamic Programming, Mixed Integer Linear Programming allied

to Valid Inequalities Theory, Branch-and-Bound and Branch-and-Cut algorithms, providing

the optimal injection rate for each well, satisfying constraints such as the available lift-gas

injection rate and produced fluid handling capacities.

The developed approaches are very efficient for this particular application. The solutions

shown here have high quality (close to the optimal ones), and the computational cost to obtain

them is low. The solution techniques proposed here are excellent tools to support decisions,

and can substitute the sub-optimal solutions normally provided by commercial optimization

software.

vi



Sumário

1 Introdução 1

1.1 O Método de Gas-Lift . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2

1.2 Revisão Bibliográfica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4

1.3 Objetivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6

1.4 Organização do Documento . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8

2 Fundamentos 10

2.1 Otimização . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

2.2 Programação Dinâmica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11

2.2.1 Programação Dinâmica para o Problema da Mochila . . . . . . . . . . . . . 12

2.3 Linearização por Partes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14

2.3.1 Modelo com pesos por ponto (Modelo I) . . . . . . . . . . . . . . . . . . . 15

2.3.2 Modelo com pesos sequencial (Modelo II) . . . . . . . . . . . . . . . . . . . 16

2.3.3 Modelo de Sherali (Modelo III) . . . . . . . . . . . . . . . . . . . . . . . . 18

2.4 Definições de Poliedro e Dimensão . . . . . . . . . . . . . . . . . . . . . . . . . . . 19

2.5 Descrição de Poliedros através de Facetas . . . . . . . . . . . . . . . . . . . . . . . 20

2.5.1 Caracterização de Facetas . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

2.6 Desigualdades Válidas para o Problema da Mochila . . . . . . . . . . . . . . . . . . 22

2.7 Sumário . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

vii



3 Solução de P( /0) Utilizando Programação Dinâmica 25

3.1 Formulação do Problema . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25

3.2 Solução de P( /0) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

3.2.1 Recorrências . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

3.2.2 Algoritmo PD para P( /0) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

3.3 Resultados Numéricos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31

3.3.1 Comparações com Resultados Publicados . . . . . . . . . . . . . . . . . . . 33

3.4 Generalizações do Problema . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36

3.4.1 Solução de PW ( /0) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37

3.4.2 Incertezas nas W PCs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38

3.5 Desigualdades válidas para P( /0) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40

3.6 Sumário . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42

4 Solução Recursiva de P(G) 44

4.1 Formulação do Problema . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44

4.2 Solução de P(F) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46

4.2.1 Recursões . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47

4.2.2 Algoritmo PD para P(F) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48

4.2.3 Resultados Numéricos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51

4.3 Solução de P(G) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52

4.3.1 Recursões . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53

4.3.2 Algoritmo Recursivo para P(G) . . . . . . . . . . . . . . . . . . . . . . . . 54

4.3.3 Resultados Numéricos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57

4.4 Extensões . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58

4.5 Sumário . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59

viii



5 Solução de P( /0) Utilizando Programação Linear Inteira Mista 60

5.1 Linearização por Partes Aplicada a P . . . . . . . . . . . . . . . . . . . . . . . . . . 60

5.2 Desigualdades Válidas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63

5.3 Lifting de Coberturas Mínimas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73

5.4 Sobre os Fatores de Lifting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76

5.5 Resultados Numéricos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78

5.6 Sumário . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80

6 Solução de P5( /0) Utilizando Programação Linear Inteira Mista 81

6.1 Formulação do Problema . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81

6.2 Desigualdades Válidas para P5( /0) . . . . . . . . . . . . . . . . . . . . . . . . . . . 88

6.3 Resultados Numéricos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94

6.4 Sumário . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96

7 Conclusões 97

7.1 Pesquisa Futura . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98

A Ajuste de Curvas 100

B Desigualdades Válidas para P(G) 102

ix



Lista de Figuras

1.1 Elementos que compõe um conjunto de poços de petróleo que produzem via gas-lift. 3

1.2 Esquema de poço operado via injeção contínua de gás [14]. . . . . . . . . . . . . . . 4

1.3 Típica curva de desempenho de elevação para um poço operado via injeção contínua

de gás. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5

1.4 Curvas de desempenho de gas-lift para poços dos tipos A, B, C e D. . . . . . . . . . 6

2.1 Linearização por partes para o modelo por pesos . . . . . . . . . . . . . . . . . . . . 16

2.2 Linearização por partes para o modelo sequencial . . . . . . . . . . . . . . . . . . . 17

2.3 Linearização por partes para o modelo de Sherali . . . . . . . . . . . . . . . . . . . 18

4.1 Ilustração do algoritmo PD para P(F). O grafo da esquerda define as restrições de

precedência de ativação dos poços. Para uma ordem topológica T = ?1, 2, 3, 4, 5, 6?,

os conjuntos de sub-problemas resolvidos e as tabelas geradas pelo algoritmo são

mostrados na árvore da direita, que indica a ordem na qual os problemas são resolvi-

dos. Por exemplo, 5 : P{5,6}? J{5,6} significa que o conjunto de sub-problemas P
y
{5,6}

foi o quinto a ser resolvido para obter J
y
{5,6}, para y ?{0, 1}. . . . . . . . . . . . . . 50

4.2 Ilustração dos algoritmos recursivos que resolvem P(G). O grafo de restrições de pre-

cedência G possui 5 nós como ilustrado na raíz da árvore de sub-problemas. A ordem

topológica de G usada para guiar a solução é T = ?3, 1, 2, 4, 5?. Cada nó indica um

conjunto de sub-problemas resolvido pelo algoritmo: P (1, 2, 4) representa o conjunto

de sub-problemas P (G[{1, 2, 4}]). . . . . . . . . . . . . . . . . . . . . . . . . . . . 56

5.1 Ilustração da linearização por partes da função do fluxo de saída de um poço n uti-

lizando o modelo de Sherali (Seção 2.3.3). . . . . . . . . . . . . . . . . . . . . . . . 62

x



6.1 Ilustração da linearização por partes da função do fluxo de saída de um poço n uti-

lizando o modelo de pesos por ponto (Seção 2.3.1). . . . . . . . . . . . . . . . . . . 85

xi



Lista de Tabelas

2.1 Valores de fk(?) e de pk(?) para uma instância do problema da mochila . . . . . . . 14

3.1 Parâmetros de uma instância de P( /0) com 6 poços. . . . . . . . . . . . . . . . . . . 30

3.2 Tabela Jm,n, com destaque para a solução ótima JM,1 = J10,1. . . . . . . . . . . . . . 31

3.3 Tabela auxiliar Im,n, com destaque para a alocação ótima de gás qi = (7, 4251; 7, 6954; 7, 4406; 4, 0000; 4, 0000; 7, 03

3.4 Qualidade média da solução e tempo médio de execução do algoritmo com relação

ao nível de discretização M. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

3.5 Resultados da alocação de gás de elevação, Economic Slope [18] e PD . . . . . . . . 33

3.6 Resultados da alocação de gás de elevação, Equal Slope, Ex-In [6] e PD . . . . . . . 34

3.7 Resultados da alocação de gás de elevação, Separable Programming [40] e PD . . . 34

3.8 Alocação de gás de elevação, cenário sem taxas de partida: comparação entre SQP

[1] e PD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35

3.9 Alocação de gás de elevação, cenário com taxas de partida: comparação entre SQP

[1] e PD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35

3.10 Resultados de alocação de gás de elevação: comparação entre GOAL [36] e PD . . . 36

3.11 Comparação entre desempenho do pior caso e caso médio . . . . . . . . . . . . . . . 39

4.1 Soluções de P(F) para uma instância de 6 poços, com qmaxi variável e M = 200. . . . 51

4.2 Qualidade de aproximação e tempo de execução para PM(F) . . . . . . . . . . . . . 52

4.3 Qualidade de aproximação e tempo de execução para PM(G) . . . . . . . . . . . . . 58

5.1 Níveis de injeção para uma instância de 6 poços, qmaxi = 6, 5. . . . . . . . . . . . . . 64

xii



5.2 Limites inferiores para os fatores de lifting, ?n,k. . . . . . . . . . . . . . . . . . . . . 72

5.3 Fatores de lifting exatos, ?n,k. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74

5.4 Limites superiores para os fatores de lifting, ??n,k. . . . . . . . . . . . . . . . . . . . 76

5.5 Experimentos com ILOG CPLEX . . . . . . . . . . . . . . . . . . . . . . . . . . . 79

5.6 Experimentos com GNU MILP solver . . . . . . . . . . . . . . . . . . . . . . . . . 80

6.1 Poço 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89

6.2 Poço 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89

6.3 Poço 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89

6.4 Impacto das coberturas-y na velocidade de solução para instâncias com 32 poços. . . 95

6.5 Impacto das coberturas-y na velocidade de solução para instâncias com 64 poços. . . 95

xiii



Capítulo 1

Introdução

A produção de hidrocarbonetos é realizada através da perfuração de poços em locais que apresen-

tam formações geológicas ricas em óleo e gás, chamadas de reservatórios. Quando a pressão de um

reservatório é suficientemente elevada para superar a pressão hidrostática e a perda de carga na co-

luna de produção, somados à perda de carga nas instalações de superfície, os fluidos nele contidos são

capazes de alcançar a superfície naturalmente. Os poços que produzem desta forma são denominados

poços surgentes. Quando a pressão de um reservatório é relativamente baixa, ou quando a vazão de

um poço está muito abaixo da ideal, há a necessidade de uma suplementação da energia natural do

reservatório através de elevação artificial. Utilizando equipamentos específicos reduz-se a pressão

hidrostática no fundo do poço, resultando em um diferencial maior de pressão entre o reservatório

e o interior do poço, com um consequente aumento de vazão. A elevação artificial é amplamente

utilizada em poços submarinos, especialmente em águas profundas. Os métodos de elevação artificial

mais comuns na indústria de petróleo são:

• gas-lift contínuo e intermitente;

• bombeio centrífugo submerso;

• bombeio mecânico com hastes; e

• bombeio por cavidades progressivas.

A seleção do melhor método de elevação artificial para um determinado poço ou campo sempre

visa a maximização do uso da energia de produção naturalmente disponível em um reservatório.

Esta seleção depende de vários fatores, como número de poços, quantidade de areia trazida pelos

fluidos produzidos, razão gás-líquido, capacidade de vazão disponível, profundidade do reservatório,

viscosidade dos fluidos, disponibilidade de energia, investimento e custo operacional.



1. Introdução 2

A elevação artificial por injeção contínua de gás, mais conhecida como continuous gas-lift ou sim-

plesmente gas-lift, é uma das formas mais utilizadas de elevação artificial para produção de petróleo

[24], [32], devido ao seu amplo campo de aplicação, além de ser o método que mais se assemelha

ao processo de fluxo natural. Seu único requisito básico é que exista uma quantidade de gás de ele-

vação disponível que seja economicamente viável. O sistema de gas-lift é eficiente em uma vasta

gama de condições de operação: é muito versátil em termos de vazão e profundidade, propício para

poços que produzem fluidos com alto teor de areia e elevada razão gás-líquido, exige investimentos

relativamente baixos para poços profundos, e seus custos de instalação e manutenção são mais baixos

que os dos demais métodos de elevação artificial [39]. A seguir, descrevemos os princípios básicos

do método de elevação artificial por injeção contínua de gás.

1.1 O Método de Gas-Lift

A Figura 1.1 ilustra esquematicamente um conjunto de poços equipados para produzir por gas-lift.

O sistema é composto por:

• fonte de gás a alta pressão (compressores);

• controlador de injeção de gás na superfície (choke);

• controlador de injeção de gás de subsuperfície (válvulas de gas-lift, Figura 1.2);

• equipamentos para separação e armazenamento dos fluidos produzidos (separadores e tanques).

A Figura 1.2 mostra o esquema típico de um poço operado via injeção contínua de gás. O sistema

de gas-lift funciona da seguinte maneira. Gás a alta pressão é injetado no espaço anular entre o

revestimento do poço e o tubo de produção, de forma controlada e contínua. O gás entra no tubo de

produção através de uma válvula de gas-lift em um ponto próximo ao fundo do poço, e mistura-se

ao fluido existente na coluna diminuindo sua densidade média. Assim, a componente gravitacional

da pressão no fundo do poço diminui, até que esta diminuição cause um diferencial de pressão entre

a formação e a face dos canhoneados (perforated zone) que seja suficiente para atingir a taxa de

produção desejada. O controle da injeção de gás no poço é feito na superfície através de um regulador

de fluxo (choke).

A Figura 1.3, denominada curva de desempenho de gas-lift, ou WPC (Well Performance Curve),

ilustra o comportamento da vazão de saída de acordo com a taxa de injeção de gás em um poço

que produz via gas-lift. Até certo limite, aumentando-se a quantidade de gás na coluna de produção

diminiui-se o gradiente médio de pressão, com consequente diminuição da pressão de fluxo no fundo

e aumento de vazão. Entretanto, a taxa de injeção de gás não pode ser aumentada indefinidamente,

pois a altas taxas de injeção a perda de carga no tubo de produção devido ao atrito se torna dominante,



1. Introdução 3

Gas a
alta

pressao

Choke de
injeçao

Choke de
produçao

Compressores

Poço 1

Poço 2

~´ Gas a baixa pressao

Separador
´ Agua para tratamento e descarga
´ Oleo

Gas para venda´ 

Oleo + Gas + Agua

Poço N

´ ´ ´ 

´ 

~~

~

Figura 1.1: Elementos que compõe um conjunto de poços de petróleo que produzem via gas-lift.

o que tende a reduzir as taxas de produção, além de poder causar danos como erosão na tubulação.

Tipicamente, poços que operam via injeção contínua de gás possuem um comportamento estável a

taxas elevadas de injeção e comportamento instável a baixas taxas. As condições instáveis de opera-

ção a baixas taxas de injeção fazem com que um poço não produza a máxima quantidade possível de

óleo. Operar um poço via injeção contínua de gás sob condições instáveis torna o controle e alocação

da produção muito difícil, e os picos de surgência (golfadas) representam condições de operação bas-

tante severas para as instalações de produção. Outra variável importante que deve ser controlada é o

diferencial de pressão entre o reservatório e o fundo do poço (drawdown). Este diferencial, que está

diretamente relacionado à taxa de injeção de gás, pode causar danos à formação através de efeitos

indesejáveis como o aumento da produção de areia e elevação do contato água-óleo (conificação),

diminuindo a vida útil e o fator de recuperação do reservatório. Portanto, existe um limite mínimo

para a taxa de injeção de gás, para que a operação instável do poço seja evitada, e também um limite

máximo, além da qual podem ser causados danos à tubulação e ao reservatório.

Existem 4 tipos básicos de W PC, como mostra a Figura 1.4 [1]. Os poços do tipo A são os

chamados surgentes, aqueles que produzem fluidos mesmo sem injeção de gás. Os poços do tipo B

são aqueles que respondem imediatamente à injeção de gás, ou seja, se qp = 0 para qi = 0 e qp &gt; 0

para qi &gt; 0. Os poços do tipo C possuem taxa de partida (kick-off rate), ou seja, só começam a

produzir a partir de uma determinada taxa de injeção de gás. Os poços do tipo D também possuem

taxa de partida, porém começam a produzir a uma taxa maior que zero.

A produção dos poços é normalmente otimizada com base em restrições técnicas e objetivos

econômicos e estratégicos, enquanto leva em conta regras de segurança e de produção, política de

explotação do reservatório (máximo escoamento por poço, quotas de produção), cuidados na inter-



1. Introdução 4

????
????
????
????
????
????
????
????
????
????
????
????
????
????
????
????
????
????
????
????

????
????
????
????
????
????
????
????
????
????
????
????
????
????
????
????
????
????
????
????

?????
?????
?????
?????
?????
?????
?????
?????
?????
?????
?????
?????

?????
?????
?????
?????
?????
?????
?????
?????
?????
?????
?????
?????

Tubo de Produção

Espaço Anular

Óleo, Gás, e
Água Produzidos

Reservatório

Gás de Elevação

Válvula de Gas-Lift

Figura 1.2: Esquema de poço operado via injeção contínua de gás [14].

face entre a parede do poço e a formação (controle de areia) e capacidade das instalações. Neste

trabalho, a função objetivo do problema de otimização é definida pelo benefício econômico do uso do

gás de elevação (maximizar a quantidade de petróleo recuperado por quantidade de gás injetado), e as

restrições do problema são impostas pela taxa de injeção de gás disponível, pelos limites de injeção

de gás mínimo (estabilidade da produção) e máximo (segurança da tubulação, preservação do reser-

vatório e aproveitamento do potencial de elevação do gás), e pelos limites impostos pelas instalações

de superfície, como capacidade de separação, armazenamento e tratamento dos fluidos produzidos.

Na seção seguinte apresentamos a revisão bibliográfica dos trabalhos relacionados ao problema

de alocação de gás de elevação encontrados na literatura, onde são apontadas algumas lacunas que

este trabalho pretende preencher.

1.2 Revisão Bibliográfica

O problema de alocação ótima da taxa disponível de injeção de gás de elevação vem sendo estu-

dado desde a década de 70, quando um procedimento analítico ad hoc foi apresentado em [35], para

determinar a distribuição de gás mais lucrativa entre os poços. Em [18], é apresentado um método

de otimização denominado equal-slope que se utiliza de uma expressão matemática para encontrar a

taxa ótima de injeção de gás, baseando-se na inclinação da curva que relaciona taxa de injeção com

o lucro obtido para cada poço, conhecida como curva de desempenho de gas-lift. Em essência, este

método consiste na solução das equações que caracterizam as condições de primeira ordem (Karush-



1. Introdução 5

Regiao de~ 

utilizaçao otima~ ´ 

Taxa de injeçao de gas~ ´

T
ax

a 
d

e 
p

ro
d

u
ça

o
 d

e 
O

le
o

´
~

Estavel´Instavel´

Figura 1.3: Típica curva de desempenho de elevação para um poço operado via injeção contínua de
gás.

Kuhn-Tucker) para ótimo local de um problema de maximização côncavo. Apesar de estes métodos

fornecerem a solução ótima quando existe gás suficiente para atender todos os poços, eles não podem

ser aplicados quando há poços dos tipos C e D (poços com taxa de partida), pois suas curvas de de-

sempenho são não-côncavas. Além disso, estes métodos não são capazes de tratar outras restrições

além da quantidade limitada de gás de elevação.

Abordagens mais flexíveis e formais foram propostas em [32] e [1], baseadas em técnicas não-

lineares de otimização quasi-Newton e programação quadrática sequencial (ou SQP - Sequential

Quadratic Programming), respectivamente. Estas abordagens são capazes de lidar com limites nas

taxas de injeção de gás e a restrição da quantidade disponível de gás de elevação, mas não admitem a

existência de poços dos tipos C e D.

Métodos heurísticos foram utilizados para resolver o problema da alocação de gás em [23] e [6],

sendo que o primeiro baseia-se em um algoritmo genético e o segundo combina uma exploração

estocástica do domínio de soluções, aliada a um cálculo heurístico de uma direção de descenso.

Métodos heurísticos não são métodos de otimização global, ou seja, as soluções obtidas podem ser

ótimos locais. Além disso, o custo computacional para a exploração do espaço de soluções pode ser

bastante alto.

O problema de maximização da produção de óleo sob múltiplas restrições nas instalações (facility

constraints) é considerado em [15] e [40]. Em [15], as curvas de desempenho dos poços são aproxi-

madas por funções lineares por partes (piecewise linear functions), e o problema linear resultante é

resolvido pelo método Simplex. Porém, para que o método Simplex pudesse ser utilizado, as variáveis

inteiras foram consideradas contínuas, e as soluções encontradas podem ser infactíveis (não inteiras),

necessitando ser tratadas a posteriori. Em [40], variáveis binárias são adicionadas à formulação para



1. Introdução 6

A

B

C

D

Taxa de injeção de gás, qi

T
ax

a
d

e
p

ro
d

u
çã

o
,q

p

Figura 1.4: Curvas de desempenho de gas-lift para poços dos tipos A, B, C e D.

cada W PC não côncava e uma busca branch-and-bound é realizada até que a solução ótima seja en-

contrada. A desvantagem desta abordagem é que algoritmos de branch-and-bound puros podem ter

tempo de execução e consumo de memória muito altos para instâncias complexas, especialmente em

problemas NP-difíceis1 .

Em suma, os modelos existentes não contemplam aspectos importantes do problema, como a

existência de taxas de partida, múltiplas restrições nas facilidades de processamento e restrições de

precedência de ativação. Além disso, nenhum dos trabalhos apresenta algoritmos eficazes no sentido

de tempo computacional e qualidade da solução (aproximar ou encontrar o ótimo global). A seguir,

são apresentados os objetivos deste trabalho.

1.3 Objetivos

No sistema de produção de petróleo via gas-lift, o problema de alocação de gás de elevação é de

bastante relevância. As instalações de compressão de gás representam uma parcela significativa do

custo de operação de um campo de petróleo [6], sendo assim é importante que o gás seja utilizado

da maneira mais eficiente possível [24]. Normalmente, esta alocação é realizada com base em regras

1Um problema pertence à classe P (problema polinomial) se pode ser resolvido em tempo polinomial no seu tamanho
(e.g., problemas de ordenação, caminhos mínimos em grafos, fluxo máximo em redes, Programação Linear). Um problema
pertence à classe NP (problema polinomial não-determinístico) se uma suposta solução para este problema pode ser verifi-
cada em tempo polinomial no seu tamanho. Dizemos que um problema é NP-difícil se ele é pelo menos tão difícil quanto
qualquer problema em NP. Um problema é NP-completo se qualquer problema em NP pode ser reduzido a este problema
em tempo polinomial (e.g., caminho Hamiltoniano, clique máxima em grafos) [38],[42].



1. Introdução 7

ad-hoc [40]. Substituir estas regras por algoritmos de otimização rigorosos pode trazer grandes bene-

fícios. No Brasil, 90% da produção de petróleo provém de poços submarinos, e estima-se que 60%

destes poços operam via gas-lift. Visto que a necessidade de melhoria do desempenho da tecnologia

atual é um fato [2], o aumento, mesmo que pequeno, na eficiência dos processos de produção de

petróleo pode resultar em substanciais ganhos econômicos e ambientais.

Os objetivos deste trabalho são a concepção de modelos formais e o projeto, implementação e

análise de algoritmos eficientes para resolver o problema de alocação de gás de elevação para um

conjunto de poços de petróleo que produzem via gas-lift, de modo a maximizar o lucro obtido com

a venda de hidrocarbonetos extraídos. Neste documento apresentamos algoritmos de Programação

Dinâmica que resolvem este problema, e também formulações de Programação Linear Inteira Mista

(ou MILP - Mixed Integer Linear Programming) para o problema de alocação de gás de elevação

sujeito a outras restrições além da taxa de injeção disponível. Para estas formulações são obtidas

famílias de desigualdades válidas que são utilizadas para auxiliar a solução através de algoritmos de

otimização comerciais e não-comerciais.

Os algoritmos de Programação Dinâmica (doravante chamados algoritmos PD) desenvolvidos

neste trabalho possuem as seguintes características, que se tornarão explícitas ao longo do documento:

• resolvem o problema de otimização mesmo quando cada poço possui múltiplas curvas de de-

sempenho de gas-lift (W PCs), e também sob restrições de precedência de ativação/desativação

de poços;

• poços que que possuem taxa de partida, ou seja, poços dos tipos C e D (Figura 1.4), que

possuem curvas de desempenho não-côncavas, são tratados com naturalidade;

• uma família de problemas é resolvida, ou seja, problemas para várias taxas disponíveis de

injeção de gás, entre 0 e qmaxi (taxa máxima de injeção disponível);

• a solução encontrada é muito próxima da solução ótima, e o tempo gasto para o cálculo da

solução é pequeno (considerando aplicações para o setor de extração de petróleo); e

• é uma ferramenta de suporte à decisão para o engenheiro de produção de petróleo, de baixo

custo e extremamente portável.

A outra abordagem utilizada neste trabalho é a linearização por partes das W PCs e utilização

de MILP para a obtenção das taxas de injeção ótimas. As vantagens desta abordagem são citadas a

seguir, sendo que algumas delas assemelham-se às vantagens mencionadas para o algoritmo PD:

• a transformação do problema não-linear em um problema linear inteiro misto torna mais fácil

a introdução e modificação de restrições, além de tornar possível o uso de algoritmos eficientes

de Programação Inteira para a busca de uma solução ótima global, ou possíveis soluções de boa

qualidade;



1. Introdução 8

• são obtidas famílias de desigualdades válidas que se mostram bastante eficientes na aceleração

do tempo de resposta de algoritmos de Branch-and-Bound e Branch-and-Cut, tornando pos-

sível a utilização de software de baixo custo para a solução do problema de otimização, como

algoritmos de Programação Linear e de Branch-and-Bound em plataformas de software livre;

• poços com taxa de partida podem ser considerados;

• a solução encontrada é quase-ótima e em tempo razoavelmente baixo;

• seu custo de implementação é baixo e possui grande capacidade de portabilidade e suporte à

decisão; e

• os modelos podem ser facilmente estendidos para incorporar outras restrições além das já con-

sideradas.

1.4 Organização do Documento

O Capítulo 2 apresenta o paradigma da Programação Dinâmica, conceitos de funções lineares por

partes e de teoria poliedral. O leitor familiarizado com estes tópicos pode dirigir a leitura ao próximo

capítulo.

Os capítulos seguintes estão organizados seguindo a cronologia da evolução da pesquisa. No

Capítulo 3 é formulada a instância mais básica do problema, denominada P( /0), onde as restrições
são a taxa máxima disponível para injeção de gás a ser alocada entre os poços e os limites inferior

e superior de taxa de injeção para cada poço. Uma solução baseada em Programação Dinâmica é

apresentada, bem como resultados numéricos que comprovam a eficiência dos algoritmos e algumas

comparações de desempenho das soluções desenvolvidas neste trabalho com as soluções encontradas

na literatura.

O Capítulo 4 contém um algoritmo de Programação Dinâmica e uma solução recursiva, respecti-

vamente para as formulações chamadas de P(F) e P(G), onde além das restrições definidas em P( /0)
existem também restrições de precedência de operação entre poços, representando cenários de cam-

pos de petróleo onde exista alguma hierarquia de poços produtores. Novamente, resultados numéricos

mostram que os algoritmos são bastante eficientes e produzem soluções de boa qualidade.

Neste momento da pesquisa foi percebido que o algoritmo de Programação Dinâmica desen-

volvido não era facilmente adaptável quando novas restrições eram incluídas na formulação básica, e

desde então passamos a buscar uma solução para P( /0) utilizando Programação Linear Inteira Mista
(ou MILP - Mixed Integer Linear Programming), mostrada no Capítulo 5. O problema original é

transformado em um problema linear por partes e desigualdades válidas são produzidas e incluídas

na formulação, de modo a torná-la mais “apertada” e acelerar o processo de solução. A eficiência

deste método é comprovada através de experimentos numéricos.



1. Introdução 9

Visto que na abordagem MILP a inclusão de restrições é tratada com naturalidade, passamos a

estudar a solução de um problema mais completo, cuja formulação foi denominada P5( /0), onde são
acrescentadas restrições impostas por limites nas instalações de superfície. No Capítulo 6 são apre-

sentados os resultados obtidos. Mais uma vez, são apresentadas famílias de desigualdades válidas que

são capazes de acelerar o processo de solução quando introduzidas na formulação, o que é mostrado

através de experimentos numéricos.

O Capítulo 7 se refere às considerações finais do trabalho, e algumas direções para pesquisas

futuras são apresentadas.



Capítulo 2

Fundamentos

Neste capítulo, apresentamos alguns conceitos básicos do domínio da otimização, bem como o

paradigma da Programação Dinâmica, conceitos de funções lineares por partes e de teoria poliedral.

O leitor familiarizado com estes tópicos pode proceder diretamente ao Capítulo 3.

2.1 Otimização

A Otimização é a área da Matemática Aplicada que se concentra em calcular valores ótimos para

variáveis de decisão de acordo com algum critério de avaliação, ao mesmo tempo que satisfazem

restrições de um modelo matemático. A solução de um problema de otimização normalmente pos-

sui duas fases: a primeira consiste em transformar o problema em um modelo, e posteriormente

implementar um algoritmo capaz de encontrar uma solução adequada para este modelo. A lin-

guagem utilizada para expressar os problemas de maneira declarativa é conhecida como Programação

Matemática [41]. Os elementos de um modelo em Programação Matemática são:

Variáveis de decisão : elementos cujos valores definem uma solução para o problema, e.g., quanti-

dades produzidas ou recursos utilizados.

Função objetivo : uma função das variáveis de decisão, que deve ser maximizada ou minimizada,

e.g., minimizar custos, reduzir número de homens/hora, maximizar lucros.

Restrições : um conjunto de funções que define o espaço factível de soluções, e.g., limites para

recursos, restrições operacionais de um processo de produção, limitações físicas e técnicas.



2. Fundamentos 11

Um problema geral de otimização pode ser escrito em Programação Matemática como:

Minimize f (x)

Sujeito a: g(x) ? 0

h(x) = 0

x ? Rn

onde f : Rn ? R é a função objetivo, g : Rn ? Rp e h : Rn ? Rq são restrições que limitam o espaço

de soluções factíveis, e x é o vetor das variáveis de decisão.

Formulado o problema, o próximo passo é encontrar um algoritmo eficiente para o cálculo da

solução ótima. Alguns tipos de problema de otimização, como por exemplo os problemas de Progra-

mação Linear, possuem algoritmos bastante eficientes para sua solução (método Simplex e método de

ponto interior). Porém, existem problemas para os quais não existem algoritmos capazes de encontrar

uma solução ótima com a mesma eficiência, como é o caso de alguns problemas de Programação In-

teira pertencentes à classe NP-difícil. A seguir apresentamos o paradigma da Programação Dinâmica,

bastante utilizado para a criação de algoritmos que resolvem problemas desta classe.

2.2 Programação Dinâmica

Uma das técnicas mais poderosas para a solução de problemas de otimização é quebrá-los em

partes menores e mais fáceis de resolver, e posteriormente compor a solução do problema original a

partir da solução destes subproblemas. Sempre que é possível quebrar um problema em instâncias

menores do mesmo problema, o uso de um algoritmo recursivo se torna aparente. A Programação

Dinâmica (PD) é um dos paradigmas de projeto de algoritmos que se baseia em quebrar problemas

em problemas menores. Tipicamente remove-se um elemento do problema, resolve-se o problema

menor, e então utiliza-se a solução deste problema menor para adicionar o elemento novamente de

maneira apropriada.

Algoritmos gulosos, que tomam a melhor decisão local a cada passo, ocasionalmente encontram

ótimos globais para certos problemas. Algoritmos de busca exaustiva, que enumeram todas as possi-

bilidades e selecionam a melhor, por definição encontram sempre o ótimo global, porém normalmente

a um custo muito alto. A Programação Dinâmica combina as duas técnicas, sistematicamente con-

siderando todas as possíveis decisões e selecionando aquela que prova ser a melhor. Armazenando

as consequências de todas as possíveis decisões até o momento, a quantidade de trabalho total é mi-

nimizada. A maior limitação da Programação Dinâmica é o número de soluções parciais que devem

ser armazenadas. A ordem dos elementos do problema também é importante. Alterar esta ordem

significa mudar o problema. Porém, uma vez que esta ordem seja fixada, algoritmos PD são bastante

eficientes.



2. Fundamentos 12

A seguir mostramos um pequeno exemplo, com o objetivo de tornar mais claro o princípio de

funcionamento deste tipo de algoritmo. A Programação Dinâmica é uma ferramenta que tem sido

aplicada com sucesso a um tipo de problema de otimização chamado de “problema da mochila”

(knapsack problem) [22]. Diversos problemas de importância estratégica têm uma “mochila” como

subproblema, como por exemplo o procedimento de geração de colunas em problemas de corte e

empacotamento. Outras vantagens do algoritmo PD serão explicitadas mais adiante.

2.2.1 Programação Dinâmica para o Problema da Mochila

Imagine um alpinista que deve organizar sua mochila com vários itens de seu interesse ao escalar

uma montanha, sendo que cada item possui um peso e um valor, e a mochila possui uma capacidade

limitada. O desejo do alpinista é maximizar a utilidade (ou valor) dos itens colocados em sua mochila,

sem ultrapassar a capacidade de peso suportada por ela. Este problema é conhecido como o problema

da mochila (knapsack problem, KP), e pode ser formulado da seguinte maneira:

KP : z = Maximizar
n
?
j=1

c j x j

Sujeito a:
n
?
j=1

a j x j ? b

x j ?{0, 1}, j = 1, . . . , n

(2.1)

onde x j assume valor 1 se o item j vai para a mochila, e 0 caso contrário, c j é o valor do item j, e

os coeficientes {a j}
n
j=1 e b são inteiros positivos representando respectivamente o peso do item j e a

capacidade da mochila, com a j ? b, j = 1, . . . , n.

Seja KPk(?) o subproblema correspondente ao problema original KP restrito aos k primeiros itens
( j = 1, . . . , k), para uma mochila de capacidade ?:

KPk(?) : fk(?) = Maximizar
k
?
j=1

c jx j

Sujeito a :
k
?
j=1

a jx j ? ?

x j ?{0, 1}, j = 1, . . . , k .

(2.2)

Resolver o problema original KP significa obter a solução ótima para KPn(b), ou seja, o valor z =

fn(b).

O problema KPk(?) possui 2 casos base, de solução trivial:

• KPk(0) para k = 1, . . . , n, pois se a capacidade é zero nenhum item vai para a mochila e, por-

tanto, fk(0) = 0 para k = 1, . . . , n;



2. Fundamentos 13

• KP0(?) para ? = 0, . . . , b, pois se temos 0 itens a considerar, nenhum item vai para a mochila, e
portanto f0(?) = 0 para ? = 0, . . . , b.

Consideremos agora a solução do conjunto de subproblemas que consideram apenas o primeiro

item, variando a capacidade da mochila (?) de 0 até b. Claramente, cada um destes subproblemas
possui apenas 2 possibilidades de soluções ótimas, x?1 = 0 ou x

?
1 = 1, ou seja, o item 1 fica fora da

mochila ou dentro dela. Considerando cada caso, temos:

• Se x?1 = 0, então concluímos que a solução ótima satisfaz f1(?) = f0(?), ou seja, o item 1 não
agrega valor à função objetivo e não ocupa espaço na mochila, portanto a solução do problema

é a solução correspondente ao problema que considera 0 itens e espaço ?, que já está resolvido;

• Se x?1 = 1, então concluímos que a solução ótima satisfaz f1(?) = c1 + f0(??a1), ou seja,
colocamos o item 1 na mochila ocupando espaço a1 e agregando valor c1 à função objetivo, e

somamos o valor ótimo do problema com 0 itens e capacidade ??a1, que já foi resolvido.

Isto nos leva a uma recursão que permite calcular fk(?) em termos dos subproblemas já resolvidos,
ou seja, os valores de fs(u) com s &amp;lt;k e u ? ?. Generalizando o caso acima:

1) Se x?k = 0, então concluímos que a solução ótima satisfaz fk(?) = fk?1(?);

2) Se x?k = 1, então concluímos que a solução ótima satisfaz fk(?) = ck + fk?1(??ak), para ak ??.

Combinando os casos (1) e (2), obtemos a seguinte recorrência:

fk(?) = max{ fk?1(?), ck + fk?1(??ak)} . (2.3)

Definindo-se os valores iniciais como f0(?) = 0 para ? ? 0 e fk(0) = 0 para k = 1, . . . , n, pode-
se utilizar a recorrência (2.3) para calcular sucessivamente os valores de f1, f2, . . . , fn para todos os

valores inteiros de ? = 1, . . . , b.

A questão que resta é como encontrar a solução ótima (ou seja, quais itens vão para a mochila)

associada ao valor ótimo fn(b). Podemos manter um indicador pk(?) que assume valor 0 se fk(?) =
fk?1(?), e valor 1 caso contrário. Portanto para definir qual item vai para a mochila, basta observar
os valores de pk(?) da seguinte maneira:

• se pn(b) = 0, então como fn(b) = fn?1(b), definimos x
?
n = 0 e continuamos o processo com o

valor fn?1(b);

• se pn(b) = 1, então fn(b) = cn + fn?1(b?an), definimos x
?
n = 1 e repetimos este procedimento

para fn?1(b?an);



2. Fundamentos 14

Tabela 2.1: Valores de fk(?) e de pk(?) para uma instância do problema da mochila

f0 f1 f2 f3 f4 p1 p2 p3 p4
? = 0 0 0 0 0 0 0 0 0 0

1 0 0 7 7 7 0 1 0 0
2 0 10 10 10 10 1 0 0 0
3 0 10 17 17 17 1 1 0 0
4 0 10 17 17 17 1 1 0 0
5 0 10 17 17 24 1 1 0 1
6 0 10 10 25 31 1 1 1 1
7 0 10 17 32 34 1 1 1 1

• após n iterações, obteremos a solução ótima.

Calculando o número de operações necessárias para obtermos z = fn(b), verificamos que o cálculo de

fk(?) para ? = 0, 1, . . . , b e k = 1, . . . , n necessita de um número constante de operações. O algoritmo
possui tempo de execução ?(nb), sendo portanto pseudo-polinomial.

Reproduzimos agora um exemplo numérico extraído de [42], com o objetivo de tornar mais claros

os conceitos apresentados nesta seção. Considere a instância de KP:

z = Maximizar 10x1 + 7x2 + 25x3 + 24x4
Sujeito a: 2x1 + x2 + 6x3 + 5x4 ? 7

x1, x2, x3, x4 ?{0, 1}

Os valores de fk(?) e pk(?) são mostrados na Tabela 2.1. Os valores de f0(?) e de fk(0) são obtidos
de imediato, enquanto que as outras colunas são preenchidas de cima para baixo utilizando a re-

cursão fk(?) = max{ fk?1(?), ck + fk?1(??ak)}. Por exemplo, f2(7) = max{ f1(7), 7 + f1(7?1)} =
max{10, 7 + 10} = 17, e como o valor de f2(7) é dado pelo segundo termo da maximização, fazemos

p2(7) = 1. O valor ótimo é z
? = f4(7) = 34.

Para obter a solução ótima x?, basta percorrer a tabela P, iniciando em p4(7). Como p4(7) = 1,

x?4 = 1. p3(7?5) = p3(2) = p2(2) = 0 e portanto x
?
3 = x

?
2 = 0. p1(2) = 1, e portanto x

?
1 = 1. Sendo

assim, a solução ótima é x? = (1, 0, 0, 1).

2.3 Linearização por Partes

Seja uma função contínua f (y) e pi = (ai, f (ai)) para i = 0, . . . , k um conjunto de pontos conhe-

cidos desta função, com ai &amp;lt;ai+1, i = 0, . . . , k?1. Podemos aproximar f (y) por um conjunto de



2. Fundamentos 15

segmentos lineares, passando pelos pontos pi, conforme ilustra a Figura 2.1. Qualquer função con-

tínua de uma variável pode ser aproximada por uma função linear por partes, sendo a qualidade da

aproximação dependente do tamanho dos segmentos lineares.

Seja f? (y) a aproximação linear de f (y). A seguir, apresentamos três modelos que podem ser

utilizados para representar f? (y) [13].

2.3.1 Modelo com pesos por ponto (Modelo I)

Nesta primeira abordagem, ilustrada pela Figura 2.1 são utilizadas variáveis reais (ou pesos) ?i.
Qualquer a0 ? y ? ak pode ser escrito como:

y =
k

?
i=0

?iai ,
k

?
i=0

?i = 1 , ? = (?0, . . . , ?k) ? Rk+1+ .

Os ?i não são únicos, mas se ai ?y?ai+1 e ?i + ?i+1 = 1 para algum i?{0, . . . , k?1}, então obtemos
f? (y) = ?i f (ai) + ?i+1 f (ai+1). Em outras palavras,

f? (y) =
k

?
i=0

?i f (ai),
k

?
i=0

?i = 1, ? ? Rk+1+ .

Se pelo menos dois dos ?i’s são positivos, e se ? j e ?k são positivos, então k = j?1 ou k = j + 1.
Esta condição pode ser modelada utilizando-se variáveis binárias xi para i = 1, . . . , k (com xi = 1 se

ai?1 ? y ? ai e xi = 0 caso contrário), e as restrições

?0 ? x1
?i ? xi + xi+1 i = 1, . . . , k?1

?k ? xk
k

?
i=1

xi = 1

x ? Bk .

Note que se x j = 1, então ?i = 0 para ?i /?{ j?1, j}.

Funções lineares por partes que são convexas (côncavas) podem ser minimizadas (maximizadas)

utilizando Programação Linear, pois as inclinações dos segmentos são crescentes (decrescentes).

Porém, se a função não é côncava nem convexa, variáveis binárias são necessárias para selecionar

o segmento correto para um dado valor de y [31].



2. Fundamentos 16

a0 a1 a2 a3 a4

?0

?1

?2

?3

?4

x1 x2 x3 x4

y

f / f?

f (y)

f? (y)

Figura 2.1: Linearização por partes para o modelo por pesos

2.3.2 Modelo com pesos sequencial (Modelo II)

Neste modelo, escrevemos y como:

y = a0 + ?1 + . . . + ?k

onde 0 ? ?i ? ai ?ai?1, i = 1, . . . , k.

Desejamos representar um dado y que pertence a uma região r da função. Então ?i assume os
valores:

?i =

?

?

?

?

?

ai ?ai?1 se i &amp;lt;r

y?ai se i = r

0 se i &gt; r

Variáveis inteiras xi são utilizadas para selecionar as regiões anteriores a y. Assim, se considerar-

mos que y pertence a uma região r:

xi =

{

1 se i &amp;lt;r

0 se i ? r

Portanto, a formulação deste modelo pode ser escrita como:

y =a0 +
k

?
i=1

?i (2.4a)

f? (y) = f (a0) +
k

?
i=1

f (ai)? f (ai?1)
ai ?ai?1

?i (2.4b)



2. Fundamentos 17

a0 a1 a2 a3 a4

?1

?2

?3

?4

x1 x2 x4

y

f / f?

f (y)

f? (y)

Figura 2.2: Linearização por partes para o modelo sequencial

com as seguintes restrições:

?1 ? a1 ?a0 (2.5a)

?i ? (ai ?ai?1)xi?1 i = 2, . . . , k (2.5b)

?i ? (ai ?ai?1)xi i = 1, . . . , k?1 (2.5c)

?k ? 0 (2.5d)

?i ? R i = 1, . . . , k (2.5e)

xi ? B i = 1, . . . , k?1 (2.5f)

Note que em (2.5c) está implícita a condição ?i ? 0, pois ?i ? (ai ?ai?1)xi ? 0, onde xi ?{0, 1}
e ai &gt; ai?1. Observe também que em (2.5f) não é necessário definir xk, pois se x pertencer à última

região (k), xi = 1, ?i ?{1, . . . , k?1}.

Em [33] uma comparação entre os Modelos I e II é apresentada. Uma transformação do Modelo I

para o espaço de variáveis de decisão do Modelo II é realizada, e prova-se que o Modelo II está estri-

tamente contido nesta transformação. Além disso, este trabalho mostra que nos vértices do poliedro

correspondente à relaxação linear do Modelo II as variáveis x são sempre inteiras. Ou seja, um pro-

blema de otimização cuja função objetivo seja linearizada utilizando o Modelo II pode ser resolvido

por meio de programação linear. Neste aspecto, o Modelo II é considerado muito melhor que o Mo-

delo I. Entretanto, sob o aspecto didático, o Modelo I é mais intuitivo que o II, devido ao significado

de suas variáveis de decisão e simplicidade das restrições. Em [33], uma formulação que transforma

o Modelo II no espaço de variáveis de decisão de I é proposta, mas suas restrições continuam pouco

intuitivas. Então surge em [37] uma formulação simples com variáveis de decisão semelhantes às do

Modelo I e com as características poliedrais do Modelo II, mostrada a seguir.



2. Fundamentos 18

a0 = 0 a1 = 1 a2 = 2 a3 = 3 a4 = 4

?L1

?R1 ?
L
2

?R2 ?
L
3

?R3 ?
L
4

?R4

x1 x2 x3 x4

1

2

3

4

5

6

y

f / f?

f (y)

f? (y)

Figura 2.3: Linearização por partes para o modelo de Sherali

2.3.3 Modelo de Sherali (Modelo III)

Na formulação proposta em [37], são utilizadas duas variáveis de peso para cada região da li-

nearização: ?Li é o peso do ponto à esquerda da região e ?
R
i é o peso do ponto à direita. Também

são empregadas variáveis xi inteiras que selecionam a região. Esta formulação é mais geral que as

anteriores, pois permite também linearizar funções descontínuas1 .

y =
k

?
i=1

[ai?1?Li + ai?
R
i ] (2.6a)

f? (y) =
k

?
i=1

[ f (ai?1)?Li + f (ai)?
R
i ] (2.6b)

com restrições

?Li + ?
R
i = xi i = 1, . . . , k (2.7a)

k

?
i=1

xi = 1 (2.7b)

?Li , ?
R
i ? 0 i = 1, . . . , k (2.7c)

?Li , ?
R
i ? R i = 1, . . . , k (2.7d)

xi ? B i = 1, . . . , k (2.7e)

Na Figura 2.3 vemos uma ilustração deste modelo. Para exemplificar, tomemos y = 2, 7, que

implica i = 3. De (2.7b) e (2.7e), x3 = 1 e x1 = x2 = x4 = 0. De (2.6a), (2.7a), (2.7c) e (2.7d),

?Li = ?
R
i = 0 para i = 1, 2, 4, ?

L
3 = 0, 3 e ?

R
3 = 0, 7.

1Em [37] é mostrado que quando f (y) é contínua, este modelo é equivalente ao modelo anterior.



2. Fundamentos 19

Para calcular f? (y) utilizamos (2.6b): f? (y) = f (a2)?L3 + f (a3)?
R
3 = 2·0, 3 + 6·0, 7 = 4, 8.

Do exemplo apresentado, (2.7a) e (2.7b) são escritas matricialmente como A?z = b?,

?

?

?

?

?

?

?

?

1 1 ?1 0 0 0 0 0 0 0 0 0

0 0 0 1 1 ?1 0 0 0 0 0 0

0 0 0 0 0 0 1 1 ?1 0 0 0

0 0 0 0 0 0 0 0 0 1 1 ?1

0 0 1 0 0 1 0 0 1 0 0 1

?

?

?

?

?

?

?

?

z =

?

?

?

?

?

?

?

?

0

0

0

0

1

?

?

?

?

?

?

?

?

zT =
[

?L1 ?
R
1 x1 ?

L
2 ?

R
2 x2 ?

L
3 ?

R
3 x3 ?

L
4 ?

R
4 x4

]

Desejamos mostrar que A? é totalmente unimodular. Podemos desconsiderar as colunas correspon-

dentes às variáveis ?, pois estas possuem apenas uma linha diferente de zero [31]. A matriz resultante
(colunas de x) corresponde a uma matriz de incidência [42], que é totalmente unimodular. Assim, a

matriz A? também é totalmente unimodular.

As restrições (2.7c) a (2.7e), na forma xi ? 0 e xi ? 1 para todo i = 1, . . . , k, implicam em iden-

tidades que são concatenadas à matriz A?, e não afetam sua unimodularidade. Note também que

as restrições de igualdade podem ser transformadas em desigualdades (?T z = ?0 =? ?T z ? ?0 e
?T z ? ?0). Assim, a matriz de restrições para esta formulação é totalmente unimodular.

A conseqüência é que o poliedro desta formulação é mínimo, ou seja, ele corresponde ao fecho

convexo das soluções, e em todos os seus vértices as variáveis x são inteiras. Assim, problemas de

otimização formulados de acordo com o Modelo III podem ser resolvidos utilizando programação

linear.

2.4 Definições de Poliedro e Dimensão

Apresentamos aqui alguns resultados sobre Teoria Poliedral [20], [31], com o objetivo de fami-

liarizar o leitor com este assunto.

Definição 2.1 Um conjunto de pontos x1, x2, . . . , xk ? Rn é linearmente independente se a única

solução para ?ki=1 ?ixi = 0 é ?i = 0 para i = 1, 2, . . . , k.

Definição 2.2 Um conjunto de pontos x1, x2, . . . , xk ?Rn é afim independente se a única solução para

?ki=1 ?ixi = 0 e ?
k
i=1 ?i = 0 é ?i = 0 para i = 1, 2, . . . , k.

Definição 2.3 Seja S = {x1, x2, . . . , xk} um conjunto de pontos em Rn. O fecho convexo de S é o

conjunto de pontos conv(S) = {?ki=1 ?ixi : ?
k
i=1 ?i = 1, xi ? S, ?i ? R e ?i ? 0, para i = 1, 2, . . . , k}.



2. Fundamentos 20

Definição 2.4 Um poliedro P ? Rn é um conjunto de pontos que satisfaz um número finito de de-

sigualdades lineares, ou seja, P = {x ? Rn : Ax ? b}, onde (A, b) é uma matriz m×(n + 1).

Proposição 2.1 O fecho convexo dos elementos inteiros de P = {x ? Rn : Ax ? b} é também um

poliedro, ou seja, conv(P?Zn) = {x ? Rn : A?x ? b?} para alguma matriz A? e algum vetor b?.

Definição 2.5 Um poliedro P ? Rn é limitado se existe ? ? R1+ tal que P ?{x ? R
n : ?? ? x j ?

? para j = 1, . . . , n}. Um poliedro limitado é denominado politopo.

Definição 2.6 Um poliedro P tem dimensão n, denotado por dim(P) = n, se o número máximo de

pontos afim independentes em P é n + 1.

Definição 2.7 Um poliedro P ? Rn possui dimensão cheia se dim(P) = n.

Se P não possui dimensão cheia, então pelo menos uma de suas desigualdades aix ? bi é satisfeita

na igualdade por todos os pontos de P, onde ai corresponde à linha i da matriz A. Sejam M =

{1, 2, . . . , m}, M= ={i ? M : aix = bi para todo x ? P}, e M
? ={i ? M : aix &amp;lt;bi para algum x ? P}=

M\M=. Sejam (A=, b=), (A?, b?) as linhas correspondentes de (A, b), formando os conjuntos de

igualdades e desigualdades da representação (A, b) de P, ou seja, P ={x ?Rn : A=x = b=, A?x? b?}.

Note que se i?M?, então (ai, bi) não pode ser escrito como combinação linear das linhas de (A
=, b=).

2.5 Descrição de Poliedros através de Facetas

Dado um poliedro P ={x ?Rn : Ax?b}, analisamos nesta seção quais das desigualdades aix ?bi
são necessárias para descrever P e quais podem ser descartadas.

Definição 2.8 A desigualdade ?T x ? ?0 ou (?, ?0) é denominada uma desigualdade válida para P se
for satisfeita por todos os pontos de P.

Definição 2.9 Se (?, ?0) é uma desigualdade válida para P e F? = {x ? P : ?T x = ?0}, F? é denom-
inada uma face de P, e dizemos que (?, ?0) representa ou induz F?. Uma face F? é dita própria se
F? 6= /0 e F? 6= P.

A face F? representada por (?, ?0) é não-vazia se e somente se max{?T x : x ? P} = ?0. Quando
F? é não-vazia, dizemos que (?, ?0) suporta P.

Definição 2.10 Uma face F de P é uma faceta de P se dim(F ) = dim(P)?1.

Teorema 2.1 Seja P um poliedro descrito por {x ? Rn : Ax ? b e Cx = d}, onde Ax ? b não pos-

sui nenhuma igualdade implícita e C possui posto completo. Esta descrição do poliedro é não-

redundante, ou seja, a remoção de uma desigualdade ou igualdade resulta em um poliedro diferente

de P, se e somente se toda desigualdade Ax ? b define uma faceta para P.



2. Fundamentos 21

Definição 2.11 Dizemos que uma desigualdade ?T x ? ?0 domina outra desigualdade ?T x ? ?0, ou
seja, ?T x ? ?0 é mais forte que ?T x ? ?0, se existir ? &gt; 0 tal que ? ? ?? e ?0 ? ??0.

Algumas vezes é possível obter desigualdades mais fortes, ou até mesmo facetas, a partir de faces

de um poliedro P. Um processo bastante utilizado para este fim é o li f ting. Considere a desigualdade

válida ?T x??0 para P?Rn, e F? a face definida por esta desigualdade. Considere outra desigualdade
válida para P, ?T x ? ?0, que define a face F?. A desigualdade ?T x ? ?0 é um li f ting da desigualdade
?T x ? ?0 se:

1. F? ? F?;

2. dim(F?) &amp;lt;dim(F?) ? dim(P)?1 .

2.5.1 Caracterização de Facetas

Descrevemos agora duas técnicas utilizadas para provar que desigualdades válidas definem facetas

para um dado poliedro: construção direta e verificação da maximalidade. Suponha que o poliedro

P = {x ? Rn : Ax ? b}? Rn possui dimensão cheia, e que a desigualdade ?T x ? ?0 pertence ao
conjunto de desigualdades que definem P (portanto uma desigualdade válida).

Construção direta

Para provar que a desigualdade válida ?T x ? ?0 define uma faceta para P utilizando a técnica
da construção direta, é necessário encontrar um conjunto de vetores S ? P afim independentes com

cardinalidade igual a dim(P), tal que cada elemento de S satisfaz a desigualdade ?T x ? ?0 na igual-
dade. Assim, a face F definida por ?T x = ?0 teria dimensão igual a dim(P)?1 e portanto (?, ?0)
definiria uma faceta para P. Caso o poliedro não possua dimensão cheia, primeiro deve-se verificar

que ?T x ? ?0 não é uma igualdade implícita. Isto pode ser feito encontrando-se um vetor x? ? P tal
que ?T x? &amp;lt;?0.

Verificação da maximalidade

Esta técnica consiste em provar que a face F? de P ? R
n induzida por (?, ?0) não está contida em

nenhuma outra face de P, ou seja, provar que F? é máxima. Seja ?T x ? ?0 uma desigualdade válida
para P, tal que F? ? F?. Se ?T x ? ?0 pode ser expressa como um múltiplo escalar não negativo de
?T x ? ?0, então (?, ?0) define uma faceta para P. Caso P não possua dimensão cheia, deve-se provar
que (?, ?0) não é uma igualdade implícita, e também garantir que (?, ?0) e (?, ?0) diferem não apenas
de um múltiplo escalar positivo, mas também de uma combinação linear das equações implícitas para

P.



2. Fundamentos 22

2.6 Desigualdades Válidas para o Problema da Mochila

Utilizaremos aqui a mesma instância do problema da mochila apresentada na Seção 2.2. A rela-

xação linear de KP é apresentada abaixo:

LKP : z = Maximizar 10x1 + 7x2 + 25x3 + 24x4
Sujeito a: 2x1 + x2 + 6x3 + 5x4 ? 7

0 ? x ? 1

Resolvendo LKP, obtemos a solução ótima x = (1, 1, 0, 0.8), com valor objetivo z = 36.2. A

desigualdade x1 + x2 + x4 ? 2 é válida para KP, pois somente 2 itens do conjunto {1, 2, 4} cabem na

mochila ao mesmo tempo (a mochila possui capacidade 7, e os pesos dos itens 1, 2 e 4 são 2, 1 e 5

respectivamente). Ao introduzir esta desigualdade na formulação, a solução ótima encontrada para

LKP é cortada, pois x1 + x2 + x3 = 2.8 &gt; 2. Sendo assim, obtemos um novo problema:

LKP1 : z = Maximizar 10x1 + 7x2 + 25x3 + 24x4
Sujeito a: 2x1 + x2 + 6x3 + 5x4 ? 7

x1 + x2 + x4 ? 2

0 ? x ? 1

A solução de LKP1 é x = (0, 1, 0.1667, 1), com valor objetivo z = 35.1667. Seguindo o mesmo

raciocínio anterior, obtemos a desigualdade x2 + x3 + x4 ? 2, que corta a solução fracionária obtida,

pois x2 + x3 + x4 = 2.1667 &gt; 2. Introduzimos esta desigualdade válida em KP e obtemos a nova

relaxação linear:

LKP2 : z = Maximizar 10x1 + 7x2 + 25x3 + 24x4
Sujeito a: 2x1 + x2 + 6x3 + 5x4 ? 7

x1 + x2 + x4 ? 2

x2 + x3 + x4 ? 2

0 ? x ? 1

cuja solução é x = (0.1429, 0.8571, 0.1429, 1), com valor objetivo z = 35. A desigualdade x1 + x2 +

x3 + x4 ? 2 é válida
2 para KP e corta a solução obtida, pois x1 + x2 + x3 + x4 = 2.1429 &gt; 2. Introdu-

2Note que esta desigualdade domina as desigualdades inseridas em LKP1 e LKP2.



2. Fundamentos 23

zimos esta desigualdade em KP e obtemos uma nova relaxação linear:

LKP3 : z = Maximizar 10x1 + 7x2 + 25x3 + 24x4
Sujeito a: 2x1 + x2 + 6x3 + 5x4 ? 7

x1 + x2 + x4 ? 2

x2 + x3 + x4 ? 2

x1 + x2 + x3 + x4 ? 2

0 ? x ? 1

A solução obtida é x = (0, 0.8, 0.2, 1), com valor objetivo z = 34.6. A desigualdade x3 + x4 ? 1 é

válida para KP e corta a solução obtida, pois x3 + x4 = 1.2 &gt; 1. Introduzimos esta desigualdade em

KP e obtemos a nova relaxação linear:

LKP4 : z = Maximizar 10x1 + 7x2 + 25x3 + 24x4
Sujeito a: 2x1 + x2 + 6x3 + 5x4 ? 7

x1 + x2 + x4 ? 2

x2 + x3 + x4 ? 2

x1 + x2 + x3 + x4 ? 2

x3 + x4 ? 1

0 ? x ? 1

cuja solução é x = (1, 0, 0, 1), com valor objetivo z = 34. Como a solução obtida é inteira, conclui-se

que é a solução ótima para KP, ou seja, x? = (1, 0, 0, 1) e z? = 34 (a mesma solução obtida no Capítulo

2.2).

A introdução de desigualdades válidas é bastante utilizada nos programas comerciais de otimiza-

ção, além do pré-processamento da formulação (eliminar variáveis e restrições redundantes, de modo

a obter uma formulação mais compacta, que tipicamente pode ser resolvida mais rapidamente). A

idéia é examinar a formulação inicial P = {x : Ax ? b, x ? 0} com X = P?Zn, encontrar um conjunto

de desigualdades válidas Qx ? q para X , adicionar estas desigualdades na formulação original e obter

a nova formulação P? = {x : Ax ? b, Qx ? q, x ? 0} com X = P??Zn. Caso a relaxação linear de P?

não forneça uma solução inteira, podemos tentar encontrar a solução ótima através de um algoritmo

de otimização para P?, que é uma formulação mais “apertada”.

Um algoritmo exato bastante utilizado para este fim é chamado de Branch-and-Bound (B&amp;amp;B). Um

algoritmo B&amp;amp;B pode ser entendido como uma estratégia de divisão de um problema P em um con-

junto de subproblemas {SPk} de forma que a solução de P possa ser obtida através da combinação das

soluções dos subproblemas. De acordo com o algoritmo B&amp;amp;B, as divisões são feitas iterativamente,

sempre observando que os subproblemas devem ser mais fáceis de serem resolvidos do que o pro-

blema original, além de descartar subproblemas por meio de enumeração implícita, ou seja, garantir

de alguma forma que a solução ótima não é solução de um certo subproblema, e que portanto pode-



2. Fundamentos 24

mos descartá-lo. Na técnica conhecida como Cut-and-Branch, cortes são inseridos iterativamente na

relaxação até que novos cortes não possam ser gerados, e então é realizada uma nova busca B&amp;amp;B na

formulação resultante. Quando a geração de cortes é executada em algum nó da árvore de B&amp;amp;B, o

método recebe o nome de Branch-and-Cut.

2.7 Sumário

Neste capítulo foram apresentados conceitos básicos da área de otimização e o paradigma de Pro-

gramação Dinâmica (PD), cujo funcionamento foi ilustrado através de sua aplicação para a solução de

uma instância de um problema clássico de otimização conhecido como “problema da mochila” [22].

Foram apresentados também conceitos de funções lineares por partes e teoria poliedral. Apresenta-

mos um exemplo numérico de como as desigualdades válidas de um problema podem ser utilizadas

para facilitar (e em alguns casos encontrar) a solução do mesmo.



Capítulo 3

Solução de P( /0) Utilizando Programação
Dinâmica

Neste capítulo, apresentamos um modelo do problema de alocação de gás de elevação em lin-

guagem formal, e um algoritmo de Programação Dinâmica que resolve este problema. Apresentamos

também resultados de experimentos numéricos que comprovam a eficiência do algoritmo em termos

de tempo computacional e de qualidade da solução encontrada. Algumas comparações com exem-

plos publicados na literatura mostram que o desempenho de nosso algoritmo supera o desempenho

das soluções propostas até o momento.

3.1 Formulação do Problema

O problema estudado aqui visa encontrar a alocação ótima de uma taxa disponível de injeção

de gás de elevação para um grupo de poços, visando maximizar o lucro obtido com a venda dos

hidrocarbonetos extraídos. Este problema pode ser escrito da seguinte maneira:

P( /0) : J = Maximizar f =
N
?

n=1

(

po?no + pg?
n
g ? pw?

n
w

)

qnp ?
N
?

n=1
piq

n
i

Sujeito a:

qnp = q?
n
p(q

n
i ) n = 1, . . . , N

N
?

n=1
qni ? q

max
i

lnyn ? q
n
i ? unyn n = 1, . . . , N

yn ?{0, 1} n = 1, . . . , N

(3.1)

onde:



3. Solução de P( /0) Utilizando Programação Dinâmica 26

• N é o número de poços que produzem via gas-lift;

• qni é a taxa de injeção de gás alocada para o poço n;

• yn assume valor 1 se o poço n está ativo, e 0 caso contrário;

• qnp é a taxa de produção de fluidos do poço n, em função de q
n
i ;

• qmaxi é a taxa de injeção de gás disponível, sendo que a soma das taxas de injeção de gás dos N

poços não deve ultrapassar esta taxa;

• ln e un são as taxas de injeção mínima e máxima para o poço n, respectivamente;

• po e pg representam o lucro (preço de venda menos custos de processamento) obtido por vo-

lume de óleo e gás vendido, respectivamente;

• pw é o custo de tratamento da água
1;

• pi representa os custos de compressão, tratamento e injeção do gás;

• ?no, ?
n
g e ?

n
w são respectivamente as frações de óleo, gás e água

2 que compõe o fluxo de saída do

poço n, sendo ?no + ?
n
g + ?

n
w = 1.

O problema P( /0) pode ser facilmente adaptado para capturar algumas variações:

• A não-concavidade introduzida por um poço n que não responde imediatamente à injeção de

gás (qnp(q
n
i ) = 0 para algum q

n
i &gt; 0, poços dos tipos C e D, Figura 1.4) é automaticamente

eliminada devido à existência do limite inferior de injeção ln;

• Neste trabalho assumimos que qnp(0) = 0 para n = 1, . . . , N. No caso de existir um poço sur-

gente, ou seja, um poço para o qual qnp(0) 6= 0 (poços do tipo A, Figura 1.4), basta adicionar à

função objetivo sua contribuição Jns = (po?
n
o + pg?

n
g ? pw?

n
w)q

n
p(0), e substituir a função q

n
p(q

n
i )

por q?no(q
n
i ) = q

n
p(q

n
i )?q

n
p(0); a solução ótima q

n
i para n = 1, . . . , N não se altera com a adição da

constante Jns no valor de J e com a utilização de q?
n
o(q

n
i ), e portanto os algoritmos desenvolvidos

aqui são capazes de levar estes poços em consideração;

• Caso o problema de interesse seja a maximização da taxa de produção de óleo ao invés do lucro

obtido, basta fazer po = 1, e pg = pw = pi = 0.

1O descarte da água só pode ser feito dentro de determinadas especificações, regulamentadas por órgãos de controle do
meio ambiente, limitando a quantidade de poluentes como o teor de óleo e H2S nos efluentes aquosos [39].

2Se considerarmos que a pressão e a temperatura no separador forem constantes, podemos considerar estas frações
também constantes para um determinado poço.



3. Solução de P( /0) Utilizando Programação Dinâmica 27

Para completar a descrição do problema de otimização em Programação Matemática, é necessário

definir a relação entre qnp e q
n
i . O problema de maximização não pode ser resolvido se os da-

dos que caracterizam a produção dos poços via gas-lift, ou seja, as funções qnp = q
n
p(q

n
i ) não es-

tiverem disponíveis [15], [18], [19], [26]. Estes dados recebem o nome de curvas de desempenho

(Well Performance Curves, ou W PCs), e tipicamente possuem a forma mostrada na Figura 1.3.

Os dados para a construção das W PCs são obtidos através de simulações e testes de produção:

aplica-se um determinado número de taxas de injeção de gás em um determinado poço n, e o seu

fluxo de saída é direcionado a um separador de testes, obtendo assim um conjunto de k pontos

Qn = {(q
n,1
i , q

n,1
p ), (q

n,2
i , q

n,2
p ), . . . , (q

n,k
i , q

n,k
p )}, bem como as porcentagens de óleo, gás e água pro-

duzidas pelo poço, ?no, ?
n
g e ?

n
w. Dado um conjunto Q

n de pontos de desempenho de gas-lift, com

q
n, j
i &amp;lt;q

n, j+1
i para j = 1, . . . , k?1, foram utilizados três modelos de curvas

3 para representar as W PCs:

1) Uma função polinomial da forma q?np(q
n
i ) = ?

n
0yn + ?

n
1q

n
i + ?

n
2(q

n
i )

2 + ?n3(q
n
i )

3, definida pelas

constantes ?n0, ?
n
1, ?

n
2 e ?

n
3. A vantagem deste modelo é que o problema de ajuste de curvas

gerado é um problema de fácil solução. Sua desvantagem é a má qualidade de extrapolação

para pontos fora do intervalo [qn,1i , q
n,k
i ];

2) Uma função exponencial da forma q?np(q
n
i ) = An(2?e

?Bnq
n
i )?Cne

Dn q
n
i + Fn(1?yn), definida

pelas constantes An, Bn, Cn, Dn e Fn = Cn ?An. Esta função exponencial é uma boa aproxi-

mação para o comportamento típico de uma W PC, fornece bons dados de extrapolação, e sua

concavidade é garantida satisfazendo condições simples. Basta garantir que as constantes An
e Cn sejam positivas, pois sob estas condições sua derivada segunda assume valores negativos

para qualquer valor de qni ;

3) Uma função logarítmica da forma qnp(q
n
i ) = c

n
1yn + c

n
2q

n
i + c

n
3(q

n
i )

2 + cn4 ln(q
n
i + 1), definida pelas

constantes cn1, c
n
2, c

n
3 e c

n
4. Este modelo foi utilizado para comparar os resultados obtidos com o

algoritmo PD e os obtidos com o método de SQP proposto em [1].

Hipótese 3.1 Cada função qnp(q
n
i ) é uma função côncava tal que q

n
p(q

n
i ) ? 0 para q

n
i ? [ln, un].

Hipótese 3.2 po?no + pg?
n
g &gt; pw?

n
w para todo poço n, o que implica em ?n = po?

n
o + pg?

n
g ? pw?

n
w &gt; 0.

A Hipótese 3.1 é válida pois normalmente o comportamento do fluxo de saída de um poço em

função de sua taxa de injeção de gás possui o aspecto mostrado na Figura 1.3, ou seja, a função qp(qi)

é crescente até uma determinada taxa de saturação, quando os efeitos friccionais passam a ditar o

comportamento do fluxo, e qp(qi) passa a ser decrescente. A Hipótese 3.2 reflete o aspecto da viabi-

lidade econômica da explotação de um poço de petróleo, ou seja, caso o custo de tratamento da água

extraída supere os dividendos provenientes da venda dos hidrocarbonetos, o poço é economicamente

inviável, e portanto a hipótese é válida.

3Os métodos de ajuste de curvas utilizados para ajustar os modelos aos pontos em Qn encontram-se no Apêndice A.



3. Solução de P( /0) Utilizando Programação Dinâmica 28

Os valores de ?no, ?
n
g e ?

n
w podem ser escritos em termos da razão água-óleo (ou Water Cut, WC) e

da razão gás-líquido (ou Gas-Liquid Ratio, GLR), termos mais comuns na literatura. Definindo WC e

GLR como:

GLR =
?g

?o+?w
, WC = ?w?o

e sabendo que ?no + ?
n
g + ?

n
w = 1, obtemos as seguintes relações:

?o = 1(1+WC)(1+GLR) , ?w =
WC

(1+WC)(1+GLR) , ?g =
GLR

1+GLR .

Corolário 3.1 f é uma função côncava de qi = [q1i , . . . , q
N
i ] na região factível de P( /0).

Prova Como qnp é uma função côncava (Hipótese 3.1) e ?n é uma constante positiva para cada n
(Hipótese 3.2), fn = ?nqnp ? piq

n
i é uma função côncava e portanto f = f1 + . . . + fn é uma função

côncava de qi. ?

Proposição 3.1 P( /0) é NP-difícil.

Prova: O problema da mochila (knapsack problem, KP) é um problema NP-difícil e pode ser re-

duzido a P( /0). Seja IKP uma instância de KP consistindo de N itens, onde cn é o valor do n-ésimo item
e wn é o seu peso, e b é a capacidade da mochila. Gerando uma instância I de P( /0) com qmaxi = b,
ln = un = wn para todo n, ?no = 1, ?

n
g = ?

n
w = 0, po = 1 e pg = pw = pi = 0, q

n
p = yncn para cada

n (para a função polinomial, basta fazer ?n0 = cn e ?
n
1 = ?

n
2 = ?

n
3 = 0; para a função exponencial,

An = cn e Bn = Cn = Dn = 0; para a função logarítmica, c1 = cn e c2 = c3 = c4 = 0), uma solução

ótima z = {yn, q
n
i , q

n
p} para I é também uma solução ótima para IKP, ou seja, o n-ésimo item vai para

a mochila se e somente se yn = 1. ?

3.2 Solução de P( /0)

Apresentamos aqui um algoritmo para resolver P( /0). Nesta seção, refere-se a P( /0) como P, por
simplicidade. Como mostrado na Proposição 3.1, o problema P pertence à classe de problemas NP-

difíceis, o que significa que até hoje não existe e as evidências são de que não existirá algoritmo capaz

de fornecer uma solução para P em tempo polinomial no número de poços. Portanto, é necessário

desenvolver um algoritmo que seja capaz de fornecer uma solução aproximada, próxima da solução

ótima, e que o tempo exigido para o cálculo desta solução seja relativamente pequeno.

Para resolver P através de PD seria necessário resolver um número infinito de problemas, pois

qi é uma variável contínua [11]. Aqui, apresentamos um algoritmo PD que resolve PM, uma versão

aproximada de P, onde para cada poço n são alocadas wn unidades padrão de injeção de gás. Seja

? = qmaxi /M uma unidade padrão de taxa de injeção de gás, onde M é o número total de unidades



3. Solução de P( /0) Utilizando Programação Dinâmica 29

padrão disponíveis. O problema PM maximiza o lucro obtido, e é definido como:

PM : JM = Maximizar
N
?

n=1

[

(po?no + pg?
n
g ? pw?

n
w)q?

n
p ? piq

n
i

]

Sujeito a :

lnyn ? q
n
i ? min{un, wn?}yn n = 1, . . . , N

N
?

n=1
wn ? M

yn ?{0, 1} n = 1, . . . , N

wn ?{0, . . . , M} n = 1, . . . , N

(3.2)

onde a função q?np é a função que aproxima o comportamento da produção de fluidos do poço n em

função de qni e wn é o número de unidades padrão de taxa de injeção de gás alocado para o poço n.

A seguir desenvolvemos as recorrências para a solução de PM via PD, apresentamos o algoritmo

para a solução do problema e os resultados numéricos obtidos.

3.2.1 Recorrências

Limitando a taxa de injeção de gás disponível em m ?{0, . . . , M} unidades padrão, o problema

assume a seguinte formulação recursiva:

P?m,n : Fm,n = Maximizar (po?no + pg?
n
g ? pw?

n
w)q?

n
p ? piq

n
i

Sujeito a :

lnyn ? q
n
i ? min{un, m?}yn

yn ?{0, 1}

(3.3)

Pm,N : Jm,N = Fm,N

Pm,n : Jm,n = Maximizar (po?no + pg?
n
g ? pw?

n
w)q?

n
p ? piq

n
i + Jm?wn,n+1

Sujeito a :

lnyn ? q
n
i ? min{un, wn?}yn

yn ?{0, 1}

wn ?{0, ..., m}

(3.4)

3.2.2 Algoritmo PD para P( /0)

Das recorrências (3.3) e (3.4), conclui-se que PM ? PM,1 e consequentemente JM ? JM,1. A

definição destas recorrências torna possível a construção de um algoritmo PD:

Algoritmo PD para PM



3. Solução de P( /0) Utilizando Programação Dinâmica 30

Tabela 3.1: Parâmetros de uma instância de P( /0) com 6 poços.

n
1 2 3 4 5 6

?n0 0 0 0 0 0 0
?n1 42,2210 47,1210 45,7210 38,9210 37,7210 39,4210
?n2 0 0 0 0 0 0
?n3 -0,2549 -0,2649 -0,2749 -0,2449 -0,2549 -0,2649
?no 0,70 0,75 0,65 0,65 0,60 0,80
?ng 0,20 0,17 0,25 0,20 0,30 0,12
?nw 0,10 0,08 0,10 0,15 0,10 0,08
ln 3,65 3,65 3,65 3,65 3,65 3,65
un 10,00 10,00 10,00 10,00 10,00 10,00

Inicialização

Para m = 0, . . . , M

Calcule Jm,N
Recorrência

Para n = N ?1, . . . , 1

Para m = 0, . . . , M

Calcule Jm,n = max{Fwn,n + Jm?wn,n+1 : wn = 0, 1, . . . , m}

O algoritmo resolve PM em tempo ?(NM2) e demanda ?(NM) unidades de memória para ar-
mazenar a tabela de valores Jm,n. Esta tabela contém as soluções ótimas para uma família de proble-

mas, para q
dis p
i = 0, ?, 2? . . . , q

max
i , onde q

dis p
i é a taxa de injeção de gás disponível. Esta característica

do algoritmo possui grande apelo prático, pois uma situação comum em campos de produção de

petróleo são os casos de falha de um ou mais compressores de gás [23], o que faz com que a taxa

de injeção disponível diminua. Neste caso, uma solução quase-ótima para esta nova situação está

prontamente disponível. O algoritmo também pode armazenar uma tabela auxiliar Im,n para registrar

os valores ótimos de qni , semelhante ao indicador pk(?) do exemplo da Seção 2.2.1.

Para ilustrar o funcionamento do algoritmo, mostraremos a solução de um exemplo numérico sim-

ples. A Tabela 3.1 mostra os parâmetros utilizados. A instância consiste de 6 poços e utilizamos o mo-

delo polinomial q?np(q
n
i ) = ?

n
0 + ?

n
1q

n
i + ?

n
2(q

n
i )

2 + ?n3(q
n
i )

3 para ajustar as W PCs (modelo 1, Apêndice

A). Utilizamos também qmaxi = 40, po = 1, pg = 0, 6, pw = 0, 1 e pi = 0, 05. A Tabela 3.2 contém os

valores da função objetivo, e a Tabela 3.3 contém os valores ótimos de taxa de injeção de gás. Note

que a solução ótima é dada por JM,1.



3. Solução de P( /0) Utilizando Programação Dinâmica 31

Tabela 3.2: Tabela Jm,n, com destaque para a solução ótima JM,1 = J10,1.

n
m m? 1 2 3 4 5 6
0 0 0 0 0 0 0 0
1 4 144,5716 144,5716 130,3794 121,3910 121,3910 121,3910
2 8 274,9510 274,9510 251,7704 226,8989 224,8102 159,5714
3 12 398,3330 396,3421 357,2783 330,3181 262,9907 159,5714
4 16 519,7241 501,8499 460,6975 368,4985 295,2172 159,5714
5 20 625,2320 605,2691 509,2381 405,2128 295,2172 159,5714
6 24 728,6512 664,4729 547,4186 437,4394 295,2172 159,5714
7 28 787,8549 713,0135 584,1329 437,4394 295,2172 159,5714
8 32 836,3956 751,1940 616,3594 437,4394 295,2172 159,5714
9 36 882,0529 787,9083 616,3594 437,4394 295,2172 159,5714

10 40 920,2333 820,1349 616,3594 437,4394 295,2172 159,5714

3.3 Resultados Numéricos

Deseja-se agora verificar quão bem PM aproxima P e mostrar que o algoritmo é suficientemente

rápido para a aplicação em questão. Foram realizados 60 experimentos, variando o número de poços

(N = 6, 12, 24 e 48), o nível de discretização (M=10, 50, 100, 200, 500), e a taxa de injeção disponível

(três valores distintos de qmaxi ). Os valores objetivo JM encontrados pelo algoritmo em cada teste

foram comparados a um limite superior U B encontrado através de relaxação contínua e programação

côncava 4 (MINOS solver version 5.51 [27]).

A Tabela 3.4 mostra os resultados dos testes de qualidade de aproximação, onde a primeira coluna

contém os níveis de discretização, a segunda coluna representa a porcentagem média5 do limite supe-

rior U B alcançada pela solução JM (JM ×100/U B), e a terceira coluna mostra o tempo de execução

médio do algoritmo. Observa-se que a solução encontrada se aproxima bastante do limite superior

U B, a não ser quando o nível de discretização é muito pequeno (M = 10), e que o tempo de exe-

cução do algoritmo é relativamente baixo, alcançando a marca de 2 minutos para M = 500. Porém,

utilizando um nível de discretização M = 100, o tempo de execução cai para 5 segundos, enquanto a

qualidade da solução permanece praticamente a mesma. Em média, a solução levou 29,87s para ser

encontrada, e ficou a 5,94% do limite superior. Se desconsiderarmos o nível de discretização mais

grosseiro (M = 10), o tempo de solução médio sobe para 37,32s e a distância média da solução para o

limite superior cai para apenas 0,72%. O algoritmo foi implementado nas linguagens de programação

4A função que relaciona o fluxo de saída do poço e sua taxa de injeção de gás é uma função côncava no intervalo [0, un],
n = 1, . . . , N, garantindo assim a concavidade do problema quando a integralidade das variáveis y é relaxada. Isto permite
encontrar a solução ótima global da relaxação contínua, ou seja, um limite superior.

5Média das soluções das instâncias de mesmo M e diferentes N e qmaxi .



3. Solução de P( /0) Utilizando Programação Dinâmica 32

Tabela 3.3: Tabela auxiliar Im,n, com destaque para a alocação ótima de gás qi =
(7, 4251; 7, 6954; 7, 4406; 4, 0000; 4, 0000; 7, 0379).

m? q1i q
2
i q

3
i q

4
i q

5
i q

6
i

0 0,0000 0,0000 0,0000 0,0000 0,0000 0,0000
4 0,0000 4,0000 4,0000 0,0000 0,0000 4,0000
8 0,0000 4,0000 4,0000 4,0000 4,0000 7,0379

12 4,0000 4,0000 4,0000 4,0000 4,0000 7,0379
16 4,0000 4,0000 4,0000 4,0000 7,0173 7,0379
20 4,0000 4,0000 7,4406 7,2722 7,0173 7,0379
24 4,0000 7,6954 7,4406 7,2722 7,0173 7,0379
28 4,0000 7,6954 7,4406 7,2722 7,0173 7,0379
32 4,0000 7,6954 7,4406 7,2722 7,0173 7,0379
36 7,4251 7,6954 7,4406 7,2722 7,0173 7,0379
40 7,4251 7,6954 7,4406 7,2722 7,0173 7,0379

Tabela 3.4: Qualidade média da solução e tempo médio de execução do algoritmo com relação ao
nível de discretização M.

M JM /U B (%) Tempo de execução (s)
10 73,14 0,10
50 98,80 1,32

100 99,35 4,66
200 99,47 21,57
500 99,52 121,72

Média 94,06 29,87

C/C++, em uma estação de trabalho equipada com processador Intel Pentium III 800MHz, 196MB

de memória RAM, e sistema operacional GNU Linux.

Portanto, conclui-se que o algoritmo PD é capaz de fornecer soluções para o problema de alo-

cação bem próximas da solução ótima teórica, e que o seu tempo de execução é baixo. Uma carac-

terística importante do algoritmo é que o seu tempo de execução cresce linearmente com o número

de poços N. Uma possível deficiência seria o comportamento quadrático em M, que pode ser re-

solvido distribuindo a execução do algoritmo entre vários computadores. A Programação Dinâmica

é uma técnica naturalmente paralelizável, sendo que se a execução do algoritmo for distribuída entre

T unidades de processamento, seu tempo de execução diminuirá T vezes. Mesmo quando não se

dispõe de várias unidades de processamento, os experimentos mostraram que M não necessita ser

aumentado indefinidamente. Os resultados mostram que existe uma relação de compromisso entre a

qualidade da solução (que está intimamente relacionada ao nível de discretização M) e o tempo de

execução do algoritmo. Para as instâncias consideradas nos experimentos numéricos realizados, foi



3. Solução de P( /0) Utilizando Programação Dinâmica 33

Tabela 3.5: Resultados da alocação de gás de elevação, Economic Slope [18] e PD

qp (B/D) q
max
i (MMSCF/D) Ganho com PD (%)

Individual Economic Slope 10.004 3,33
PD 11.081 3,33 +10,77

Average Economic Slope 10.350 3,58
PD 11.134 3,58 +7,57

Economic Slope (gás limitado) 9.335 2,50
PD 10.782 2,50 +15,50

possível encontrar soluções muito próximas (menos de 1%) da solução ótima teórica com um nível

de discretização M=100 em um tempo bastante baixo, considerando os tempos altos (da ordem de

horas ou dias) normalmente envolvidos no ramo de extração de petróleo.

3.3.1 Comparações com Resultados Publicados

O desempenho do algoritmo PD é agora comparado a quatro exemplos publicados [18], [6], [40],

[1] e um software comercial [36]. Utilizamos os dados de W PCs fornecidos nestes trabalhos, e

aplicamos o algoritmo PD desenvolvido aqui para encontrar a alocação ótima das taxas de injeção de

gás. Nesta seção, MSCF/D é uma abreviação para mil pés cúbicos padrão por dia, e MMSCF/D é

uma abreviação para milhões de pés cúbicos padrão por dia, medidas comuns para volume de gás

injetado (as condições padrão são normalmente 60?F e 14.7 psia), e B/D significa barris por dia.

Em [18], o problema da alocação de gás de elevação foi resolvido utilizando as técnicas de “in-

dividual economic slope” e “average economic slope”, para situações de taxa de injeção de gás

disponível ilimitada e limitada, considerando 6 poços. A Tabela 3.5 mostra a comparação das soluções

obtidas através de PD com as soluções de [18]. Os resultados mostram que o algoritmo PD possui

melhor desempenho em todos os três cenários.

Em [6], o problema de alocação foi resolvido utilizando os métodos “equal-slope” e “Ex-In”,

para conjuntos de 5, 6 e 56 poços. A Tabela 3.6 mostra os resultados obtidos em [6] e utilizando PD.

Analisando estes resultados, observa-se que o algoritmo PD possui um melhor desempenho em todos

os testes.

Em [40] foram utilizados os dados fornecidos em [6], e um algoritmo de Programação Separável

(Separable Programming, ou SP) foi aplicado para otimizar a produção de óleo de um conjunto de 56

poços, com 22.500 MMSCF/D de taxa de injeção de gás disponível. Os resultados obtidos em [40]

são comparados aos obtidos através de PD (Tabela 3.7), e novamente o algoritmo desenvolvido no

presente trabalho mostra um melhor desempenho.



3. Solução de P( /0) Utilizando Programação Dinâmica 34

Tabela 3.6: Resultados da alocação de gás de elevação, Equal Slope, Ex-In [6] e PD

Poços qp (B/D) q
max
i (MSCF/D) Ganho com PD (%)

Ex-In 5 3.369,5 2.995,3
PD 5 3.396,0 2.995,3 +0,79

Equal Slope 5 3.400,3 3.000,0
PD 5 3.405,0 3.000,0 +0,16

Ex-In 6 3.629,0 4.427,7
PD 6 3.634,6 4.427,7 +0,15

Equal Slope 6 3.510,2 4.373,7
PD 6 3.628,3 4.373,7 +3,36

Ex-In 56 21.789,9 20.453,9
PD 56 23.325,7 20.453,9 +7,05

Equal Slope 56 21.265,0 22.508,0
PD 56 23.600,7 22.508,0 +10,99

Tabela 3.7: Resultados da alocação de gás de elevação, Separable Programming [40] e PD

qp (B/D) q
max
i (MSCF/D) Ganho com PD (%)

SP 22.632 22.500
PD 23.378 22.500 +3,30

Para comparar os algoritmo PD e o método de SQP proposto em [1], o ajuste das curvas W PCs

foram realizados com funções da forma qnp(q
n
i ) = c

n
1yn + c

n
2q

n
i + c

n
3(q

n
i )

2 + cn4 ln(q
n
i + 1). Adaptar o

algoritmo PD para trabalhar com estas funções é relativamente fácil, o que mostra que o algoritmo

pode ser modificado para tratar diferentes métodos de ajuste de curvas. Utilizando o método de

mínimos quadrados, as curvas logarítmicas foram ajustadas aos dados de desempenho contidos em [6]

e [18], obtendo assim as instâncias do problema utilizadas nesta comparação. Os resultados obtidos

com SQP e PD para os cenários onde não há poços com taxa de partida são mostrados na Tabela 3.8,

e a Tabela 3.9 contém os resultados para os cenários com poços que possuem taxa de partida. Estes

resultados mostram a força do algoritmo PD ao lidar com cenários onde decisões sobre ativação e

desativação de poços devem ser tomadas. As regras ad hoc propostas em [1] requerem intervenção

humana para decidir quais poços não surgentes serão ativados, e sendo assim podem resultar em

alocações sub-ótimas. Estas regras ad hoc consistem em retirar do problema de otimização (desativar)

poços para os quais foram alocados a mínima taxa de injeção possível, e então resolver o problema

novamente para os poços restantes. Porém, se existem m poços para os quais foram alocados a taxa

mínima, existem 2m possibilidades de ativação/desativação, tornando esta decisão bastante difícil. Em

nossa abordagem estas decisões são tomadas pelo próprio algoritmo, produzindo a solução ótima.

O desempenho do algoritmo PD foi também comparado ao do software GOAL, em um cenário



3. Solução de P( /0) Utilizando Programação Dinâmica 35

Tabela 3.8: Alocação de gás de elevação, cenário sem taxas de partida: comparação entre SQP [1] e
PD

Poços qp (B/D) q
max
i (MSCF/D) Ganho com PD (%)

SQP 5 537,21 84.950 -0,000
PD 537,21 84.950

SQP 13 7.708,03 22.484 -0,0008
PD 7.707,97 22.484

SQP 25 16.872,89 54.425 -0,009
PD 16.871,39 54.425

SQP 37 21.212,79 72.497 -0,005
PD 21.211,67 72.497

Tabela 3.9: Alocação de gás de elevação, cenário com taxas de partida: comparação entre SQP [1] e
PD

Poços qp (B/D) q
max
i (MSCF/D) Ganho com PD (%)

SQP 12 4.559,44 36.325 +68,36
PD 7.676,35 36.325

SQP 24 7.877,72 57.138 +39,74
PD 11.008,63 57.138

SQP 36 15.395,04 75.199 +20,24
PD 18.510,45 75.199

SQP 48 23.944,50 110.085 +12,66
PD 26.975,18 110.085

SQP 56 27.929,89 120.087 +10,54
PD 30.874,25 120.087

de 16 poços contido em [36]. Foram realizados quatro experimentos, os dois primeiros sob condições

de suprimento alto de gás de elevação, e os dois últimos sob condições de baixo suprimento. O

objetivo é a maximização do lucro obtido com a venda dos hidrocarbonetos extraídos. A Tabela 3.10

contém os resultados destes experimentos. O desempenho do algoritmo PD é levemente inferior ao

do GOAL para os cenários com grande disponibilidade de gás de elevação, enquanto sob condições

de baixa disponibilidade o algoritmo PD supera o desempenho do GOAL. O ganho com PD foi muito

menos pronunciado que o ganho mostrado na Tabela 3.9 pois naqueles cenários haviam poços com

taxa de partida, o que aumenta a natureza combinatória do problema e faz com que o algoritmo PD

proporcione melhores resultados. Em outras palavras, quanto maior o número de possibilidades de

ativação/desativação de poços, maior a necessidade de tratar o problema de maneira formal.



3. Solução de P( /0) Utilizando Programação Dinâmica 36

Tabela 3.10: Resultados de alocação de gás de elevação: comparação entre GOAL [36] e PD

Gás de elevação Lucro ($/D) qmaxi (MSCF/D) Ganho com PD (%)
GOAL Suprimento 87.135,34 7,5 -0,003

PD alto 87.133,06 7,5
GOAL Suprimento 80.842,29 5,0 -0,001

PD alto 80.841,42 5,0
GOAL Suprimento 70.563,58 1,6 +1,257

PD baixo 71.443,46 1,6
GOAL Suprimento 62.278,88 1,0 +0,998

PD baixo 62.900,72 1,0

3.4 Generalizações do Problema

Nesta seção, acrescentamos algumas características ao problema inicial P( /0) de modo a torná-lo
mais geral e representativo.

Quando o nível de confiança das medições obtidas nos testes de produção é conhecido, podemos

associar probabilidades aos coeficientes da função de aproximação, e a otimização de P( /0) seria
realizada sobre os valores esperados destes coeficientes. Este problema pode ser formulado como:

PE ( /0) : JE = Maximizar
N
?

n=1
(po?no + pg?

n
g ? pw?

n
w)q?

n
p ?

N
?

n=1
piq

n
i

Sujeito a :

q?np = f (q
n
i ) n = 1, . . . , N

N
?

n=1
qni ? q

max
i

lnyn ? q
n
i ? unyn n = 1, . . . , N

yn ?{0, 1} n = 1, . . . , N

(3.5)

onde os coeficientes da função q?np que representa o comportamento do poço n são valores esperados

dos coeficientes das curvas definidos no Apêndice A.

Na ausência de dados sobre a confiabilidade dos testes, a otimização pode ser realizada levando

em conta todas as ?(n) curvas obtidas com os testes de produção disponíveis para o poço n, e fornecer
as taxas de injeção de gás que maximizam o lucro no pior caso (baseado nas curvas de menor produ-



3. Solução de P( /0) Utilizando Programação Dinâmica 37

tividade), resultando no seguinte problema:

PW ( /0) : JW = Maximizar
N
?

n=1
min{(po?no + pg?

n
g ? pw?

n
w)q

n,k
p ? piq

n
i : k = 1, . . . , ?(n)}

Sujeito a :

qn,kp ? Qn n = 1, . . . , N , k = 1, . . . , ?(n)
N
?

n=1
qni ? q

max
i

lnyn ? q
n
i ? unyn n = 1, . . . , N

yn ?{0, 1} n = 1, . . . , N

(3.6)

onde Qn = {q
n,k
p (qni ) : k = 1, . . . , ?(n)} é um conjunto de funções q

n
p obtidas em ?(n) testes para o

poço n.

Corolário 3.2 PW ( /0) é NP-difícil.

É fácil ver que um algoritmo que resolve PW ( /0) resolve também PE ( /0). Fornecendo ?(n) = 1
curvas de desempenho para todos os n poços (ou seja, uma W PC por poço) ao algoritmo que resolve

PW (G), onde cada W PC representa o comportamento esperado do poço correspondente, o algoritmo

produzirá uma solução para PE (G).

3.4.1 Solução de PW ( /0)

A formulação de PW ( /0) é bastante similar à de P( /0), bastando considerar as curvas de menor
produtividade no cálculo da função objetivo. Da mesma forma que em P( /0), é necessário discretizar
a variável qni para que o problema possa ser resolvido através de Programação Dinâmica. Sendo

assim, o problema resultante PW M é formulado da seguinte maneira:

PW M : JW M = Maximizar
N
?

n=1
min{(po?no + pg?

n
g ? pw?

n
w)q?

n,k
p ? piq

n
i : k = 1, . . . , ?(n)}

Sujeito a :

q?n,kp = f (qni ) n = 1, . . . , N

k = 1, . . . , ?(n)
lnyn ? q

n
i ? min{un, wn?}yn n = 1, . . . , N

N
?

n=1
wn ? M

yn ?{0, 1} n = 1, . . . , N

wn ?{0, . . . , M} n = 1, . . . , N

(3.7)

onde as curvas q?n,kp são aproximadas seguindo um dos três modelos apresentados no Apêndice A.



3. Solução de P( /0) Utilizando Programação Dinâmica 38

Limitando a taxa de injeção de gás disponível em m?{0, . . . , M} unidades padrão, as recorrências

para a solução de PW M via PD são dadas por:

P?m,nW : F
m,n

W = Maximizar min {(po?
n
o + pg?

n
g ? pw?

n
w)q?

k,n
p ? piq

n
i : k = 1, . . . , ?(n)}

Sujeito a :

q?
n,k
p = f (qni ) k = 1, . . . , ?(n)

lnyn ? q
n
i ? min{un, m?}yn

yn ?{0, 1}

(3.8)

Pm,NW : J
m,N
W = F

m,N
W

Pm,nW : J
m,n
W = Maximizar min{(po?

n
o + pg?

n
g ? pw?

n
w)q?

n,k
p ? piq

n
i : k = 1, . . . , ?(n)}+ J

m?wn,n+1
W

Sujeito a :

q?n,kp = f (qni ) k = 1, . . . , ?(n)
lnyn ? q

n
i ? min{un, wn?}yn

yn ?{0, 1}

wn ?{0, ..., m}
(3.9)

Definidas estas recorrências, o algoritmo PD que resolve P( /0) apresentado na Seção 3.2.2 pode ser
utilizado para resolver PW ( /0). A solução de PW M é obtida em tempo ?(KNM2), onde K = max{?(n) :
n = 1, . . . , N} e demanda ?(MN) unidades de memória para armazenar a tabela de valores Jm,nW . Para
verificar o desempenho do algoritmo quando o número de W PCs é maior que 1, foram realizados

36 experimentos, variando o número de poços (N = 6, 12, 24 e 48), taxa de injeção disponível (três

valores de qmaxi ), e a variância das W PCs em torno de uma W PC média (10%, 50% e 100%). O nível

de discretização utilizado foi M = 100 e o número de curvas para todos os poços foi ?(n) = 10. Em
média o algoritmo levou 47,42s para encontrar a solução, e ficou a 0,49% do limite superior calculado

utilizando relaxação contínua e programação côncava [27].

3.4.2 Incertezas nas W PCs

Quando o nível de incerteza sobre as W PCs é muito alto, ou seja, quando o histórico de testes de

um poço mostra W PCs muito diferentes, o engenheiro de produção de petróleo pode desejar assumir

uma posição mais conservadora e basear a decisão sobre a quantidade de gás injetada em cada poço

nas curvas que representam o pior caso (menor produtividade).

Apesar de esta abordagem ser intuitivamente menos lucrativa, existem casos onde o algoritmo de

pior caso fornece melhores soluções do que as obtidas utilizando a média das curvas. Isto acontece



3. Solução de P( /0) Utilizando Programação Dinâmica 39

Tabela 3.11: Comparação entre desempenho do pior caso e caso médio
Teste 1 Teste 2

qmaxi Jw/Jr Jm/Jr Jw/Jr Jm/Jr
0,1 1,00 0,68 0,45 1,00
0,6 1,00 0,67 0,45 1,00
1,1 1,00 0,67 0,45 1,00
1,6 1,00 0,67 0,45 1,00
2,1 0,99 0,85 0,70 0,93
2,6 0,99 0,75 0,57 0,99
3,1 1,00 0,84 0,71 1,00
3,6 1,00 0,84 0,71 1,00
4,1 1,00 1,00 1,00 1,00

Média 1,00 0,77 0,61 0,99

quando é maior a probabilidade do comportamento real do poço ser representado pelas curvas de

menor produtividade.

Foram realizados alguns testes numéricos para ilustrar situações onde cada caso possui melhor

desempenho, de acordo com os seguintes passos: 1) 10 W PCs foram fornecidas para cada poço; 2) o

algoritmo foi executado para ?(n) = 10, encontrando as taxas de injeção ótimas qiw para o pior caso;
3) o algoritmo foi executado para as W PCs médias de cada poço, ou seja, ?(n) = 1, encontrando
as taxas de injeção ótimas qim; 4) uma das 10 W PCs é tomada aleatoriamente para representar o

comportamento real de cada poço, e o algoritmo é executado novamente para ?(n) = 1, obtendo a
solução ótima “real” Jr ; 5) utilizando qiw, qim, e as curvas que representam o comportamento real,

encontramos os valores objetivo “reais” que seriam obtidos com as taxas de injeção obtidas para o

pior caso (Jw) e para o caso médio (Jm); 6) as relações Jw/Jr e Jm/Jr são comparadas; 7) a taxa de

injeção disponível qmaxi é variada, e os passos 2 a 6 são repetidos.

Os testes foram realizados para valores de qmaxi variando de 0,1 a 4,1, e o sorteio das curvas do

passo 4 seguiram uma tendência para as curvas de pior desempenho no Teste 1, e uma tendência para

o caso médio no Teste 2. Os resultados obtidos são mostrados na Tabela 3.11. Como esperado, o

desempenho do pior caso é melhor no Teste 1, pois a probabilidade do comportamento real do poço

ser representado pelas piores curvas é maior, e o desempenho do caso médio é melhor no Teste 2,

pois a probabilidade do poço se comportar de acordo com as médias históricas das W PCs é maior.

Esta probabilidade pode ser inferida pelo engenheiro de produção, baseada nos históricos de testes,

cabendo a ele a decisão de quando fornecer uma ou múltiplas W PCs ao algoritmo. Nos experimentos

aqui realizados, observou-se que quanto maior a taxa de gás disponível, mais os desempenhos se

aproximam, pois o aspecto combinatório do problema torna-se menos relevante. No caso extremo,

onde existe gás disponível para operar todos os poços (qmaxi = 4, 1), os desempenhos se igualam.



3. Solução de P( /0) Utilizando Programação Dinâmica 40

3.5 Desigualdades válidas para P( /0)

As similaridades entre P( /0) e o problema da mochila permite que as propriedades combinatórias
deste último (em particular, famílias de desigualdades válidas que induzem facetas) sejam estendidas

ao domínio de P( /0). A seguir, estendemos as desigualdades de cobertura para o problema da mochila
e seu processo de lifting para P( /0) [31], [42].

Seja X = {(qi, y) ? R
N ×BN : (qi, y) satisfaz as restrições de (3.1)} o conjunto de soluções fac-

tíveis para P( /0) e seja P = conv(X ) o poliedro correspondente ao fecho convexo de X . Seja ainda
N = {1, . . . , N} o conjunto de índices dos poços.

Proposição 3.2 Se ln &amp;lt;un ? qmaxi para cada n, então dim(P ) = 2N.

Prova:. Seja sn(q?ni , y?n) o elemento de P obtido quando yn = y?n, yk = 0 para todo k 6= n, q
n
i = q?

n
i , e

qki = 0 para todo k 6= n. Seja S = {sn(ln, 1), sn(un, 1) : n = 1, . . . , N}. Claramente, S é um conjunto

de 2N elementos linearmente independentes de P . Como 0 ? P , P possui 2N + 1 soluções afim

independentes e, portanto, dim(P ) = 2N. ?

No restante da seção, assumimos que as condições da Proposição 3.2 são satisfeitas.

Definição 3.1 Um conjunto C ? {1, . . . , N} é uma cobertura se ?
n?C

ln &gt; q
max
i e para cada n ? C,

?
k?C?{n}

lk &amp;lt;q
max
i .

Corolário 3.3 O poliedro PC = {(qi, y) ? P : yn = 0,?n ? N ?C} induzido por uma cobertura C

tem dimensão dim(PC) = 2|C|.

Proposição 3.3 Se C é uma cobertura, então

?
n?C

yn ?|C|?1 (3.10)

é uma desigualdade válida para PC. Além disso, a face FC ={(qi, y) ? PC : ?
n?C

yn = |C|?1} induzida

pela desigualdade de cobertura possui dimensão dim(FC) = 2|C|?1.

Prova: (Validade) Se ?
n?C

yn = |C| para alguma solução (qi, y) ? PC, então ?
n?C

qni ? ?
n?C

ln &gt; q
max
i , o

que significa que a solução é infactível, contradizendo a hipótese.

(Dimensionalidade) Seja ?
n?C

(?nyn + µnqni ) ? ?o uma desigualdade válida para P induzindo uma

face máxima F? ={(q
n
i , yn)?PC : ?

n?C
(?nyn + µnqni ) = ?o} de PC tal que FC ?F?. O desenvolvimento a

seguir mostra que a desigualdade que induz FC difere da desigualdade que induz F? por uma constante

multiplicativa positiva.



3. Solução de P( /0) Utilizando Programação Dinâmica 41

Primeiro, mostramos que µn = 0 para todo n ?C. Para cada n ?C execute as seguintes operações:

seja (q?i, y?) = (0, 0) um elemento de PC; defina Cn = C?{ j} para algum j ? C, j 6= n; e faça y?k = 1

e q?ki = lk para todo k ? Cn. Claramente a solução resultante (q?i, y?) ? FC. Seja (q?i, y?) = (q?i, y?) porém

com q?ni = min{un, q
max
i ? ?

k?Cn?{n}
lk}. Como (q?i, y?), (q?i, y?) ? FC, as seguintes equações devem ser

satisfeitas para que (q?i, y?) e (q?i, y?) pertençam a F?:

?
k?Cn

?ky?k + ?
k?Cn

µk q?
k
i = ?o

?
k?Cn

?ky?k + ?
k?Cn

µk q?
k
i = ?o

Subtraindo a primeira equação da segunda, obtemos µn(q?
n
i ? q?

n
i ) = 0. Como ?

k?Cn
lk &amp;lt;q

max
i e ln &amp;lt;un,

(q?ni ? q?
n
i ) &gt; 0 e portanto µn = 0. Aplicando este raciocínio para cada elemento de C, conclui-se que

µn = 0 para cada n ?C.

Agora, mostramos que ?n = ?k para cada par n, k ? C. Seja Cn = C?{k} e defina (q?i, y?) como:
q?

j
i = l j e y? j = 1 para cada j ? Cn. Seja Ck = C ?{n} e (q?i, y?) definido como: q?

j
i = l j e y? j = 1 para

cada j ?Ck. Claramente, (q?i, y?), (q?i, y?) ? FC e portanto as equações a seguir devem ser satisfeitas se

(q?i, y?), (q?i, y?) ? F?:

?
j?Cn

? j y? j = ?o

?
j?Ck

? j y? j = ?o

Subtraindo a segunda igualdade da primeira, obtemos ?ny?n ??ky?k = 0 ? ?n = ?k. Segue da solução
(q?i, y?) que ?

j?Cn
? jy? j = ?o ? ?

j?Cn
? j = ?o ?(|C|?1)?n = ?o. Fazendo ?o = |C|?1, deduz-se que ? j =

1 para todo j ? C. Portanto, ?
n?C

yn ?|C|?1 induz uma face máxima FC de PC, ou seja, dim(FC) =

2|C|?1. ?

De acordo com a Proposição 3.3, a desigualdade válida induzida por uma cobertura C definiria

uma faceta se a cobertura englobasse todos os poços, i.e., C = N . Uma maneira de fortalecer a

desigualdade de cobertura é aumentá-la com os poços cujos limites inferiores de injeção de gás são

maiores ou iguais ao limite inferior de cada poço em C. Mais precisamente, a cobertura estendida

E(C) = C?{n ? N ?C : ln ? lk para todo k ?C} induz a desigualdade de cobertura estendida:

?
n?E(C)

yn ?|C|?1 (3.11)

que é válida para P . A desigualdade de cobertura estendida (3.11) é válida pois qualquer elemento

i de E(C)?C pode substituir qualquer elemento j de C, ou seja, ?n?(C?{ j})?{i} ln ? ?n?C ln &gt; qmaxi .
A desigualdade de cobertura estendida domina a desigualdade de cobertura pois qualquer ponto que

viola (3.10) também viola (3.11), mas um ponto que viola (3.11) pode não violar (3.10).



3. Solução de P( /0) Utilizando Programação Dinâmica 42

Outra maneira de fortalecer desigualdades válidas é o princípio chamado de lifting [31], [42],

onde uma desigualdade válida de PC = P ?{(qi, y) ? R
N ×BN : yn = 0, n ? N ?C} pode ser es-

tendida para se tornar válida para P . Iniciando com uma sequência ordenada s = ? j1, . . . , jL? dos

itens de N ?C, o procedimento de lifting adiciona à desigualdade, uma a uma, as variáveis cor-

respondentes aos elementos de s. Para adicionar a variável do primeiro poço, por exemplo, o pro-

cedimento produz a desigualdade ?
n?C

yn + ? j1 y j1 ? |C|? 1 que é válida para PC?{ j1}, onde ? j1 =

|C|?1?max{ ?
n?C

yn : (qi, y) ? PC?{ j1}, y j1 = 1}. A desigualdade resultante induz uma face FC?{ j1}

de PC?{ j1} tal que dim(FC?{ j1}) ? dim(FC) + 1. Se a solução do problema que calcula ? j1 atinge seu
máximo em q

j1
i &gt; l j1 , então pode-se mostrar que dim(FC?{ j1}) = dim(FC) + 2. Os passos descritos

acima podem ser aplicados sistematicamente aos elementos restantes de s até que a desigualdade

válida de lifting:

?
n?C

yn +
L

?
k=1

? jk y jk ?|C|?1 (3.12)

seja obtida. A desigualdade resultante é válida para P e pode induzir uma de suas facetas sob as

condições expostas acima.

Há uma maneira simples para calcular limites inferiores ?n para os fatores de lifting ?n dos
elementos n ? N ?C. Para k ?{0, . . . ,|C|}, seja C(k) ? C um subconjunto tal que |C(k)| = k e

min{ln : n ? C(k)}? max{ln : n ?C?C(k)} se k &gt; 0, em outras palavras, C(k) é o subconjunto de

C com os k elementos que requerem as taxas de injeção mais altas para sua operação. Seja também

q(C?) = ?n?C? ln para qualquer C? ?C. Para n ? N ?C, podemos definir o limite inferior ?n como:

?n = Maximizar k ?{0, . . . ,|C|}
Sujeito a : ln ? q(C(k))

Assim, substituindo os fatores de lifting ?n em (3.12) por seus limites inferiores ?n, obtemos a de-
sigualdade de cobertura fortalecida estendida:

?
n?C

yn + ?
n?E(C)?C

?nyn ?|C|?1 (3.13)

que também é válida para P . Note que (3.13) pode ser mais forte que (3.11) porém mais fraca que

(3.12).

3.6 Sumário

Neste capítulo, foram desenvolvidos algoritmos de Programação Dinâmica para a solução do pro-

blema de alocação ótima de gás de elevação para uma determinada taxa disponível de injeção de gás,

considerando poços com taxa de partida e múltiplas curvas de desempenho de gas-lift (W PCs). O



3. Solução de P( /0) Utilizando Programação Dinâmica 43

desempenho destes algoritmos mostrou-se bastante satisfatório quando avaliado através de experi-

mentos numéricos e comparações com exemplos da literatura, onde foi constatado que são capazes

de fornecer soluções quase-ótimas em tempo relativamente baixo. Os resultados desta seção foram

publicados em [11], [28], [9], [29].



Capítulo 4

Solução Recursiva de P(G)

Neste capítulo acrescentamos uma restrição ao problema estudado no capítulo anterior, e de-

nominamos P(G) o problema resultante. Suponhamos que por algum motivo técnico ou estratégico

existam restrições de precedência de ativação/desativação entre os poços, e.g., se o poço i estiver ativo

então um certo poço j também deve estar ativo. Estas restrições de precedência podem ser represen-

tadas por um grafo acíclico G, onde o conjunto dos vértices V (G) representa os poços e o conjunto

das arestas E(G) representa as restrições de precedência. Quando este grafo forma uma floresta,

chamamos o problema de otimização resultante de P(F) (Seção 4.2), e quando G é um grafo acíclico

geral, denotamos o problema por P(G) (Seção 4.3).

4.1 Formulação do Problema

O problema PW (G) de alocação de uma taxa de injeção de gás de elevação disponível q
max
i com

restrições de precedência de ativação e considerando a curva de menor produtividade no caso de

múltiplas W PCs, pode ser escrito da seguinte maneira:

PW (G) : JW = Maximizar
N
?

n=1
min{(po?no + pg?

n
g ? pw?

n
w)q

n,k
p ? piq

n
i : k = 1, . . . , ?(n)}

Sujeito a :

qn,kp ? Qp n = 1, . . . , N , k = 1, . . . , ?(n)
lnyn ? q

n
i ? unyn n = 1, . . . , N

N
?

n=1
qni ? q

max
i

yi ? y j ?(i, j) ? E(G)

yn ?{0, 1} n = 1, . . . , N

(4.1)

onde:



4. Solução Recursiva de P(G) 45

• Qp = {q
n,k
p (qni ) : k = 1, . . . , ?(n)} é um conjunto de funções q

n
p obtidas em ?(n) testes para o

poço n. Para cada poço n e teste k, a função qn,kp é aproximada por uma função q?
n,k
p que assume

uma das formas definidas no Apêndice A;

• G = (V, E) é um grafo acíclico direcionado cujos vértices representam os poços (V ={1, . . . , N})

e cujas arestas representam restrições de precedência sobre a operação dos poços, ou seja,

(i, j) ? E significa que o poço j deve estar ativo se i estiver ativo e portanto j precede i.

Assim como no capítulo anterior, um algoritmo que resolve PW (G) resolve também PE (G), bas-

tando fazer ?(n) = 1 para n = 1, . . . , N e definir os coeficientes de qn,kp como os valores esperados
destes coeficientes. Além disso, as Hipóteses 3.1 e 3.2 continuam sendo válidas para esta formu-

lação, bem como o Corolário 3.1.

A proposição a seguir afirma que o problema P(G) é NP-difícil no sentido forte [16]. Isto significa

que não existe algoritmo que seja capaz de encontrar uma solução ótima para este problema em tempo

pseudo-polinomial, a não ser que a classe de problemas P seja igual à classe NP.

Proposição 4.1 PW (G) é NP-difícil no sentido forte.

Prova: Podemos mostrar que PW (G) é NP-difícil no sentido forte através de uma redução do pro-

blema da mochila parcialmente ordenado (partially ordered knapsack problem, [16], [17]). Uma

instância IK do problema da mochila parcialmente ordenado é dado por um conjunto finito U , uma

ordem parcial ? de U , para cada u ?U um peso s(u) ? Z+ e um valor v(u) ? Z+, e valores inteiros

positivos b e k.

Existe U ??U tal que se u ?U ? e u?? u, então u? ?U ?, e tal que ?u?U? s(u) ? b e ?u?U? v(u) ? k?

A resposta algorítmica a esta questão constitui o problema da mochila parcialmente ordenado.

Uma instância IK pode ser reduzida a uma instância IP de PW (G) da seguinte maneira. Assuma,

sem perda de generalidade, que U = {1, . . . , N}. Seja qmaxi = b, e para cada n ? U faça ?(n) = 1,
ln = un = s(u), q

n
p = yuv(u) (para a função polinomial, basta fazer ?

n
0 = v(u) e ?

n
1 = ?

n
2 = ?

n
3 = 0;

para a função exponencial, An = v(u) e Bn = Cn = Dn = 0; para a função logarítmica, c1 = v(u) e

c2 = c3 = c4 = 0). Defina ?no = 1 e ?
n
g = ?

n
w = 0 para cada n, e faça po = 1, pg = pw = pi = 0. Seja

G = (V, E) onde V = U e (u, u?) ? E se e somente se u? ? u. Então uma solução SP para IP tem valor

objetivo maior ou igual a k se e somente se existir U ? ?U com as propriedades desejadas, em outras

palavras, u ?U ? se e somente se yu = 1. ?

A seguir apresentamos o algoritmo PD para PE (F ) e o algoritmo recursivo para PE (G), bem

como resultados numéricos que comprovam a eficiência destes algoritmos. Optamos por resolver a

versão PE do problema por ser mais simples que PW , e no final do capítulo indicamos como podem

ser resolvidos os problemas PW (F ) e PW (G). As próximas seções utilizam a seguinte notação ao

referir-se a um grafo G:



4. Solução Recursiva de P(G) 46

• ?+(u) = {v : (u, v) ? E(G)} é o conjunto de vértices diretamente acessíveis por u;

• ??(u) = {v : (v, u) ? E(G)} é o conjunto de vértices que podem alcançar u diretamente;

• d+(u) = |?+(u)| é o grau de saída do vértice u;

• d?(u) = |??(u)| é o grau de entrada de u;

• SG(u) = {v : existe um caminho em G de u para v} é o conjunto de descendentes de u no grafo

G;

• S+G (u) = SG(u)?{u};

• root(G) = {u : d?(u) = 0} é o conjunto das raízes de G.

4.2 Solução de P(F)

Nesta seção, além da taxa disponível para injeção de gás de elevação, os poços em PE (F) es-

tão acoplados por restrições de ativação impostas pelas arestas de uma floresta F . Para decompor

PE (F) de forma ótima em uma série de problemas côncavos desacoplados, um para cada poço, seria

preciso saber a distribuição ótima das taxas de injeção de gás que satisfazem as restrições de pre-

cedência. Nossa abordagem lida primeiro com a questão da distribuição de gás, discretizando a taxa

disponível em M unidades padrão, ? = qmaxi /M, e então trata as restrições de precedência através da
ordem topológica induzida pela floresta F . Da mesma forma que no cenário sem restrições de pre-

cedência, a enumeração explícita de todas as alocações factíveis pode ser impraticável. Em particular,

uma chamada para o algoritmo C#(F ) definido abaixo computa o número de ativações de poços que

respeitam as restrições induzidas por um grafo do tipo floresta F em tempo linear1.

Algoritmo C#(F )

1) Se |V (F )| = 1 então

2) retorne 2

3) Se |root(F )| = 1 então

4) retorne 1 + C#(F [V (F)?root(F )])

5) w ? 1

6) Para cada u ? root(F ) faça

7) w ? w?C#(F [SF (u)])

8) retorne w

1O algoritmo C#(F) pode ser facilmente aumentado para enumerar todas as ativações factíveis.



4. Solução Recursiva de P(G) 47

Proposição 4.2 C#(F ) calcula corretamente o número de ativações de poços que atende às restrições

impostas por um grafo direcionado do tipo floresta F .

Prova: (Por indução na cardinalidade n de V (F )). Para n = 1 o número reportado por C# é claramente

correto. Para n ? 2, dois casos devem ser considerados: (caso 1) se |root(F )| = 1, então C#(F) com-

puta a ativação da raiz de F somada a todas as ativações factíveis de F[V (F)?root(F )] quando a raiz

não está ativa, o que é corretamente calculado pela hipótese de indução; (caso 2) se |root(F )|= m?2,

então seja F = T1 ? . . .?Tm, onde Tj, j = 1, . . . , m, são as sub-árvores com raízes nos vértices que

aparecem em root(F ); como os poços que estão em uma sub-árvore são independentes daqueles que

estão em outras sub-árvores, segue por hipótese de indução que o número de ativações é
m
?
j=1

C#(Tj),

que é precisamente o que o algoritmo C# calcula. ?

Uma versão não recursiva do algoritmo C#(F ) pode ser implementada para computar o número de

ativações de F com tempo de execução ?(n) onde n = |V|. Para tanto, basta produzir uma sequência
?k1, . . . , kn? dos vértices de F em ordem topológica reversa, ou seja, para todo k j ?V e todo ki ?S

+
F (k j)

tem-se i &amp;lt;j. Depois, calcula-se C#(ki) (número de ativações factíveis para a sub-árvore de F com

raiz em ki): para i = 1, . . . , n faça C#(ki) = 2 se ki é uma folha, caso contrário faça C#(ki) = 1 +

? j?S+F (ki)C#( j). Por fim, C#(F ) = ? j?root(F)C#( j).

4.2.1 Recursões

O problema PE (F ) pode ser aproximado através da alocação de valores discretos de unidades

padrão de injeção de gás. No restante desta seção, P é uma abreviação para PE (F ) e PM denota a

versão discretizada de P, onde ? = qmaxi /M representa uma unidade padrão de alocação de gás e M é
o número de unidades de injeção disponível. O problema PM é definido como:

PM : JM = Maximizar
N
?

n=1
(po?no + pg?

n
g ? pw?

n
w)q?

n
p ?

N
?

n=1
piq

n
i

Sujeito a :

q?np = f (q
n
i ) n = 1, . . . , N

lnyn ? q
n
i ? min{un, wn?}yn n = 1, . . . , N

N
?

n=1
wn ? M

yi ? y j ?(i, j) ? E(F)

yn ?{0, 1} n = 1, . . . , N

wn ?{0, . . . , M} n = 1, . . . , N

(4.2)

onde a função q?np é a função que aproxima o comportamento da produção de fluidos do poço n em

função de qni , utilizando um dos modelos de aproximação mostrados no Apêndice A, e wn é o número

de unidades padrão de taxa de injeção de gás alocado para o poço n.



4. Solução Recursiva de P(G) 48

Corolário 4.1 PM(G) é NP-difícil no sentido forte.

O algoritmo PD que será apresentado a seguir faz uso das soluções dos seguintes problemas

recursivos:

• Pym,R é a versão discretizada de P restrita aos poços que são descendentes dos elementos de

R ? V (F ) da floresta F , quando a taxa de injeção disponível for de m unidades padrão, e tal

que as árvores que possuem raízes nos vértices de R são disjuntas; cada poço r ? R deve estar

ativo se y = 1, caso contrário o poço pode ou não estar ativo, ou seja yr ? y para todo r ? R, e

a taxa disponível de injeção de gás é de m unidades padrão para todos os elementos de R e seus

descendentes, ?r?RSF (r); J
y
m,R é o valor ótimo da função objetivo de P

y
m,R.

• Pynm,n é a versão discretizada de P restrita ao poço n e seus descendentes em F , S
+
F (n), onde a

ativação do poço n é determinada por yn, e existem m unidades padrão de taxa de injeção de

gás para todos os poços em SF (n); J
yn
m,n é o valor ótimo da função objetivo para P

yn
m,n, podendo

assumir valor ?? caso m? não seja suficiente para ativar n e seus descendentes em F .

De acordo com a terminologia acima, a solução ótima de PM é a solução do problema P
0
M,root(F)

(JM = J
0
M,root(F )), que pode ser resolvido através das seguintes recursões:

Pynm,n : J
yn
m,n = Maximizar (po?no + pg?

n
g ? pw?

n
w)q?

n
p ? piq

n
i + J

yn
m?wn,?+(n)

Sujeito a :

q?np = f (q
n
i )

lnyn ? q
n
i ? min{un, wn?}yn

wn ?{0, . . . , m}

yn ?{0, 1}

(4.3)

P
y
m,R : J

y
m,R = 0 se R = /0

J
y
m,R = Maximizar max{J

k
wp,p

: k ? y , k ?{0, 1}}+ Jym?wp,R?{p}
Sujeito a :

p ? R

wp ?{0, . . . , m}

(4.4)

4.2.2 Algoritmo PD para P(F)

Para resolver as recursões (4.3)-(4.4), a ordem topológica imposta pelas arestas de F é utilizada,

ou seja, o conjunto de subproblemas {P
yn
m,n} pode ser resolvido a partir dos poços que compõem as

folhas de F , em direção às raízes de F , respeitando a ordem topológica.



4. Solução Recursiva de P(G) 49

Algoritmo PD para PM

Inicialização

Seja ? = (?1, . . . , ?N ) uma permutação de {1, ..., N} obedecendo uma ordem topológica
de F .

Recorrência

Para k = N, . . . , 1:

n ? ?k
Se d+(n) = 0 então:

Para m = 0, . . . , M:

Resolva Pynm,n para yn ?{0, 1}, obtendo J
yn
m,n

Senão:

Seja {r1, . . . , rd} = ?+(n), onde d = d+(n)
Seja J1m,{rd} ? J

1
m,rd

para m = 0, . . . , M

Para t = d?1 até 1:

Para m = 0, . . . , M:

Para wrt = 0, . . . , m:

Resolva P1m,{rt ,...,rd} com p = rt para obter J
1
m,{rt ,...,rd}

Seja J0m,{rd} ? max{J
0
m,rd

, J1m,rd} para m = 0, . . . , M

Para t = d?1 até 1:

Para m = 0, . . . , M:

Para wrt = 0, . . . , m:

Resolva P0m,{rt ,...,rd} com p = rt para obter J
0
m,{rt ,...,rd}

Para m = 0, . . . , M:

Para wn = 0, . . . , m:

Resolva Pynm,n para obter J
yn
m,n para yn ?{0, 1}

Fim

Finalização

Seguindo os passos do laço Senão acima, substituindo o conjunto {r1, . . . , rd} por root(F ),

onde d = |root(F )|, resolva Py
m,root(F)

para obter Jy
m,root(F )

para y ?{0, 1} e m = {0, . . . , M}.

A Figura 4.1 ilustra como o algoritmo resolve as recursões para um grupo de 6 poços e um grafo

de restrições de precedência simples. Para facilitar o entendimento da figura, denotamos o conjunto

de sub-problemas {Pynm,n : m = 0, . . . , M} de P
yn
n e, similarmente, o conjunto {P

y
m,R : m = 0, . . . , M} de

P
y
R. Estendendo a notação, temos J

yn
n = {J

yn
m,n : m = 0, . . . , M} e J

y
R = {J

y
m,R : m = 0, . . . , M}.



4. Solução Recursiva de P(G) 50

1

4

6

1

4

6

2 3

5

32

5

1 : P6 ? J62 : P5 ? J5

3 : P4 ? J44 : P3 ? J3

5 : P{5,6} ? J{5,6}
6 : P2 ? J2

7 : P{3,4} ? J{3,4}
8 : P{2,3,4} ? J{2,3,4}
9 : P1 ? J1

Árvore de Precedência Árvore de Sub-Problemas

Figura 4.1: Ilustração do algoritmo PD para P(F). O grafo da esquerda define as restrições de pre-
cedência de ativação dos poços. Para uma ordem topológica T = ?1, 2, 3, 4, 5, 6?, os conjuntos de
sub-problemas resolvidos e as tabelas geradas pelo algoritmo são mostrados na árvore da direita, que
indica a ordem na qual os problemas são resolvidos. Por exemplo, 5 : P{5,6} ? J{5,6} significa que o
conjunto de sub-problemas P y

{5,6} foi o quinto a ser resolvido para obter J
y
{5,6}, para y ?{0, 1}.

Duas questões relevantes que surgem na análise deste algoritmo dizem respeito ao número de

tabelas que o algoritmo necessita armazenar, e ao número de passos computacionais necessários para

o preenchimento das mesmas.

Considerando o número de tabelas, o algoritmo computará 2N tabelas J
yn
n (uma para cada n e yn) e

2
N
?

n=1
d+(n) tabelas J

y
R , duas para cada R

n
t = {rt , . . . , rd}?{r1, . . . , rd} = ?

+(n), t = 1, . . . , d = d+(n),

além de 2|root(F )| tabelas J yR onde R ? root(F ). Como cada tabela possui ?(M) elementos, juntas

elas ocuparão ?(2M(N +
N
?

n=1
d+(n) + |root(F )|)) ? ?(4MN) unidades de memória.

Sobre o número de passos computacionais, dividimos a solução dos subproblemas entre folhas

e não-folhas de F . Para um poço folha n, o custo para obter J ynn é da ordem de ?(M). O custo
computacional associado a um poço não-folha por sua vez é dividido entre o cálculo das tabelas J

y
R

e J yn . O primeiro é equivalente a resolver um problema PM( /0) com d+(n) “super-poços”2 , onde as
funções objetivo dos “super-poços” são induzidas pelos valores das tabelas já computadas, J yk para

k ? ?+(n); portanto, o cálculo de J yR termina em ?(d
+(n)M2) passos. O segundo cálculo, J

y
n pode ser

realizado em ?(M2) passos. No total, conclui-se que o tempo de execução do algoritmo é da ordem
de ?(4NM2).

2Um “super-poço”consiste de uma sub-árvore de poços com raiz em um filho particular do vértice n.



4. Solução Recursiva de P(G) 51

Tabela 4.1: Soluções de P(F) para uma instância de 6 poços, com qmaxi variável e M = 200.

qmaxi q
1
i q

2
i q

3
i q

4
i q

5
i q

6
i J

50 7.4251 7.6954 7.4406 7.2722 7.0173 7.0379 989.1743
40 6.8000 7.2000 6.8000 6.6000 6.2000 6.4000 977.9290
30 5.1000 5.7000 5.2500 4.6500 4.3500 4.9500 858.0924
20 0.0000 4.7000 4.2000 3.7000 3.7000 3.7000 609.6331
15 0.0000 3.9750 3.6750 0.0000 3.6750 3.6750 476.0638
13 0.0000 5.1350 0.0000 0.0000 3.7050 4.1600 396.1391
10 0.0000 0.0000 5.2000 0.0000 0.0000 4.8000 294.9611
7 0.0000 0.0000 7.0000 0.0000 0.0000 0.0000 177.9975

Para ilustrar o funcionamento do algoritmo, utilizamos a mesma instância de 6 poços apresentada

na Seção 3.2.2, e o grafo de restrições de precedência da Figura 4.1. A Tabela 4.1 mostra como a

solução varia para diversas taxas de injeção disponíveis qmaxi e um nível de discretização M = 200.

Para qmaxi = 50, existe gás suficiente para ativar todos os poços em seu ponto ótimo. É interessante

observar como os poços são desativados com a diminuição da taxa de injeção disponível. Note que,

por exemplo, o poço 3 é desativado quando a taxa disponível cai de 15 para 13, e volta a ser ativado

quando a taxa cai para 10. Isso ilustra como a natureza combinatória do problema pode fazer com

que as técnicas ad hoc normalmente utilizadas forneçam soluções sub-ótimas.

4.2.3 Resultados Numéricos

O algoritmo apresentado foi implementado em sistema operacional GNU Linux e linguagens de

programação C/C++, e então testado em uma série de 24 experimentos numéricos, variando o número

de poços, o nível de discretização e a estrutura das restrições de precedência. A Tabela 4.2 mostra

os resultados destes experimentos, contendo a razão JM/U B e o tempo de execução do algoritmo. O

valor JM = J
0
M,root(F ) representa a solução ótima encontrada pelo algoritmo PD, e U B representa um

limite superior para JM , obtido através de um programa de otimização convexa [27].

Os experimentos mostram que apesar de o algoritmo PD fornecer uma solução aproximada, esta

é bastante próxima do limite superior teórico, ou seja, o algoritmo PD para PM fornece soluções

bastante próximas das soluções ótimas em um período de tempo razoável, considerando as instâncias

utilizadas neste trabalho.



4. Solução Recursiva de P(G) 52

Tabela 4.2: Qualidade de aproximação e tempo de execução para PM(F)

Número de poços M JM/U B (%) Tempo de execução (s)
10 96,65 0,06

6 80 99,89 0,11
320 99,94 6,35
10 94,72 0,93

6 80 99,08 0,93
320 99,08 5,28
20 94,82 0,03

12 80 99,92 0,08
160 99,97 5,16
20 96,27 1,97

12 80 97,81 2,19
320 98,03 3,73
50 94,14 3,52

24 200 95,67 4,33
800 96,48 5,86
50 97,70 0,70

24 200 99,21 0,79
800 99,30 2,31
100 94,18 3,20

36 400 96,59 3,41
800 96,79 5,82
100 94,97 2,26

36 400 97,10 2,90
800 97,74 5,03

Média 97,21 2,79

4.3 Solução de P(G)

Esta seção trata da versão onde as restrições de precedência de ativação são representadas por um

grafo acíclico G. A solução do problema resultante segue a mesma linha dos problemas anteriores.

Ao invés de resolvermos P(G), resolvemos sua versão discretizada, PM(G), onde a taxa de injeção

de gás disponível é dividida em M unidades padrão ? = qmaxi /M, permitindo uma solução recursiva.
O algoritmo “quebra” PM(G) em subproblemas que são resolvidos recursivamente e cujas soluções

são armazenadas em uma estrutura de dados, posteriormente sendo integradas para obter a solução

do problema original.



4. Solução Recursiva de P(G) 53

4.3.1 Recursões

Antes de formular as recursões, descrevemos brevemente os problemas que são resolvidos recur-

sivamente pelo algoritmo e as tabelas produzidas. As recursões resolvem dois subproblemas:

• Pm(H) é a versão do problema original restrita aos poços contidos no conjunto V (H), as restri-

ções de precedência representadas por E(H), e uma quantidade de m unidades padrão de taxa

de injeção de gás, onde H é um subgrafo de G; Jm(H) denota o valor ótimo da função objetivo

para Pm(H), onde J (H) = {Jm(H) : m = 0, . . . , M} é a tabela com os valores objetivo para to-

dos os níveis de taxa de injeção de gás disponível; P (H) denota o conjunto de sub-problemas

{Pm(H) : m = 0, . . . , M}.

• Prm(H) é uma versão mais restrita de Pm(H) onde o poço r ? root(H) deve estar ativo; J
r
m(H)

representa o valor ótimo da função objetivo, que pode assumir valor ?? se a quantidade m? não
é suficiente para ativar r e seus descendentes em H ; J r(H) = {Jrm(H) : m = 0, . . . , M} é a tabela

com os valores objetivo para todos os níveis de taxa de injeção de gás disponível, enquanto

P r(H) = {Prm(H)} denota o conjunto de sub-problemas correspondentes.

Seguindo a notação acima, pode-se estabelecer as recursões:

Pm(H) : se E(H) = /0 :
Jm(H) = Maximizar ?

n?V (H)

[

(po?no + pg?
n
g ? pw?

n
w)q?

n
p ? piq

n
i

]

Sujeito a:

q?np = f (q
n
i ), ?n ?V (H)

wn ?{0, . . . , m}, ?n ?V (H)

?
n?V (H)

wn = m

lnyn ? q
n
i ? yn min{un, ?wn}, ?n ?V (H)

yn ?{0, 1}, ?n ?V (H)

se E(H) 6= /0 :
Jm(H) = max{J

r
m(H), Jm(H[V (H)?{r}])}, r ? root(H)

(4.5)



4. Solução Recursiva de P(G) 54

Prm(H) : se SH (r) = V (H) :

Jrm(H) = Maximizar ?
n?V (H)

[

(po?no + pg?
n
g ? pw?

n
w)q?

n
p ? piq

n
i

]

Sujeito a:

q?np = f (q
n
i ), ?n ?V (H)

wn ?{0, . . . , m}, ?n ?V (H)

?
n?V (H)

wn = m

ln ? q
n
i ? min{un, ?wn}, ?n ?V (H)

se SH (r) 6= V (H) :

Jrm(H) = Max J
r
k (H[SH (r)]) + Jm?k(H[V (H)?SH (r)])

S. a:

k ?{0, . . . , m}

(4.6)

Os algoritmos que resolvem as recursões acima são dados na próxima seção e utilizam duas

estruturas de dados globais: um dicionário D [12] para armazenar as tabelas J (H) e J r(H), e uma

ordem topológica T = ?t1, . . . ,tN? de G para guiar a solução recursiva de PM(G).

4.3.2 Algoritmo Recursivo para P(G)

Os algoritmos SolveJ(H) e SolveJ(H, r), que respectivamente calculam recursivamente as tabelas

J (H) e J r(H) são descritos abaixo. Para resolver PM(G), deve-se obter uma ordem topológica T =

?t1, . . . ,tN? dos vértices de G e inicializar a estrutura de dados global e fazer uma chamada para

SolveJ(G). Ao término da execução deste algoritmo, a solução para PM(G) pode ser obtida a partir

da tabela J (G) e das tabelas armazenadas em D.

Algoritmo SolveJ(H)

Se J (H) ? D então:

Retorne J (H)

Fim - Se

Se E(H) = /0 então:
Resolva Pm(H) para m = 0, . . . , M e produza J (H)

Armazene J (H) em D

Retorne J (H)

Senão:

r ? tk, onde k é o menor índice tal que tk ?V (H) (Note que r ? root(H))

J r(H) ? SolveJ(H, r)

J (Hr) ? SolveJ(Hr) onde Hr = H[V (H)?{r}]



4. Solução Recursiva de P(G) 55

Resolva Pm(H) para m = 0, . . . , M e produza J (H)

Armazene J (H) em D

Retorne J (H)

Fim - Se

Algoritmo SolveJ(H, r)

Se J r(H) ? D então:

Retorne J r(H)

Fim - Se

Se V (H) = SH (r) então:

Resolva Prm(H) para m = 0, . . . , M e obtenha J
r(H)

Armazene J r(H) em D

Retorne J r(H)

Senão:

Seja H1 = H[SH (r)];

J r(H1) ? SolveJ(H1, r)

Seja H2 = H[V (H)?SH (r)]

J (H2) ? SolveJ(H2)

Resolva Prm(H) para m = 0, . . . , M e produza J
r(H)

Armazene J r(H) em D

Retorne J r(H)

Fim - Se

A maneira como os algoritmos acima operam é ilustrada na Figura 4.2 para uma instância simples

de 6 poços. O grafo com as restrições de precedência de ativação dos poços é mostrado na raíz da

árvore de sub-problemas. O algoritmo segue a ordem topológica T = ?3, 1, 2, 4, 5? para decompor os

problemas em sub-problemas.



4. Solução Recursiva de P(G) 56

1

2 3

4 5

1

2

4 5

1

2

4 5

2

4 5

2

4 5

1

2 3

4 5

1

2

4

1

2

4

2

4

2

4

4

3

5

4 5

y1 = 0

y1 = 0

y1 = 1

y1 = 1

y2 = 0

y2 = 0y2 = 1

y2 = 1

y3 = 0
y3 = 1

P (1, 2, 3, 4, 5)

P 3(1, 2, 3, 4, 5)

P 3(3, 5)
P (1, 2, 4)

P 1(1, 2, 4)
P (2, 4)

P 2(2, 4)
P (4)

P (1, 2, 4, 5)

P 1(1, 2, 4, 5) P (2, 4, 5)

P 2(2, 4, 5)

P (4, 5)

Árvore de Sub-Problemas

Figura 4.2: Ilustração dos algoritmos recursivos que resolvem P(G). O grafo de restrições de pre-
cedência G possui 5 nós como ilustrado na raíz da árvore de sub-problemas. A ordem topológica
de G usada para guiar a solução é T = ?3, 1, 2, 4, 5?. Cada nó indica um conjunto de sub-problemas
resolvido pelo algoritmo: P (1, 2, 4) representa o conjunto de sub-problemas P (G[{1, 2, 4}]).



4. Solução Recursiva de P(G) 57

Devido à necessidade de armazenarmos as tabelas já computadas3 e da solução de um problema

equivalente a P( /0), quando E(H) = /0, conclui-se que o tempo de execução do algoritmo pertence a
O(|D|NM2), onde |D| é o número de tabelas armazenadas em D.

Uma chamada de SolveJ(G) pode levar tempo exponencial em algumas instâncias. Seja G um

grafo representando restrições de precedência de ativação onde V = {1, . . . , 2k + 1} e E = {(1, k +

2), (2, k + 3), . . . , (k, 2k + 1)}?{(k + 1, k + 2), . . . , (k + 1, 2k + 1)}. Para a ordem topológica T =

?1, 2, . . . , 2k + 1?, SolveJ(G) calcula ?(2k) tabelas distintas e consequentemente |D| ? ?(2k). Por
outro lado, o tempo de execução pode ser linear no número de poços se a ordem topológica iniciar

em k + 1, o que ilustra que o desempenho do algoritmo depende tanto de G como de sua ordem

topológica.

Apesar do desempenho desfavorável no pior caso, os tempos de execução do algoritmo para

PM(G) são comparáveis aos tempos de execução do algoritmo para PM(F), para as instâncias con-

sideradas neste trabalho. Os resultados dos experimentos numéricos que corroboram esta afirmação

são mostrados na próxima seção.

4.3.3 Resultados Numéricos

O algoritmo proposto foi implementado utilizando linguagens de programação C/C++ e estruturas

de dados (listas e dicionários) da biblioteca LEDA [25], em ambiente GNU Linux.

A qualidade com que PM(G) aproxima P(G), bem como seu desempenho em termos de tempo

computacional foram testados em 24 experimentos, variando o número de poços e a estrutura das

restrições de precedência de ativação representadas pelo grafo G. A Tabela 4.3 contém os resultados

destes experimentos, incluindo o número de poços, o tempo de execução do algoritmo, e a razão

JM/U B, sendo JM o valor objetivo encontrado pelo algoritmo PD e U B um limite superior calculado

através da relaxação das variáveis inteiras e programação côncava (MINOS solver, [27]).

Os resultados numéricos mostram que o algoritmo é capaz de fornecer soluções bem próximas

das soluções “ótimas”, em um tempo razoavelmente curto, para instâncias de tamanho pequeno e

médio.

3Se G = (V, E) onde V = {(1, . . . , 2k)} e E = {(1, k + 1), (2, k + 2), . . . , (k, 2k)}. Para uma ordem topológica T =
?1, k + 1, 2, k + 2, . . . , k, 2k?, uma chamada recursiva a SolveP(G) sem armazenamento de tabelas resolveria o problema
PM(H) restrito ao grafo H induzido por V (H) = {k, 2k} 3

K?1 vezes. Por outro lado, com o armazenamento de tabelas,
PM(H) é resolvido apenas uma vez.



4. Solução Recursiva de P(G) 58

Tabela 4.3: Qualidade de aproximação e tempo de execução para PM(G)

Número de poços M JM/U B (%) Tempo de execução
10 99,61 0,06

6 80 99,86 0,10
320 99,90 6,36
20 99,15 0,04

6 80 99,95 0,05
320 99,96 0,85
40 99,27 0,07

12 80 99,92 0,08
320 99,99 0,73
40 95,91 1,80

12 80 97,25 2,75
320 98,20 4,09
40 92,33 3,00

24 320 96,71 3,29
640 96,99 7,67
40 96,10 2,12

24 320 97,88 2,12
640 97,89 3,90
100 95,04 2,43

36 400 97,32 2,68
800 97,57 4,96
100 94,77 2,62

36 400 97,17 2,84
800 97,38 5,23

Média 97,51 2,49

4.4 Extensões

Nesta seção, indicamos como seria possível resolver os problemas PW (F ) e PW (G), e também

PM(G) quando o grafo G contém ciclos.

Os algoritmos para a solução de PW (F ) e PW (G) funcionariam seguindo os mesmos passos dos

algoritmos para PE (F) e PE (G) respectivamente, bastando substituir os valores de q?
n
p por Min{q?

n,k
p :

k = 1, . . . , ?(n)}, onde ?(n) é o número de W PCs disponível para o poço n. Isto causaria uma penali-
dade em termos de tempo computacional da ordem de K = max{?(n) : n = 1, . . . , N}, ou seja, o tempo
de execução de PW (F) pertenceria a ?(4KNM2), e o tempo de execução de PW (G) a O(K|D|NM2).

Consideremos agora o problema PM(G) quando o grafo G que representa as restrições de pre-

cedência contém ciclos. A seguir, mostramos um procedimento para resolver tal instância de P(G)

que invoca o algoritmo criado para resolver instâncias cujas restrições de precedência formam um



4. Solução Recursiva de P(G) 59

grafo acíclico. Primeiro, encontre os componentes fortemente conexos C1, . . . ,CK de G e defina aque-

les que contém mais de um poço como um “super-poço”. Como cada componente fortemente conexo

Ck terá todos seus poços ativos ou inativos, seu super-poço correspondente se comportará como um

único poço. Segundo, resolva uma família de problemas similares a P( /0) para cada super-poço, onde
todos seus poços estão ativos e para cada m ?{0, . . . , M}, produzindo uma tabela com as soluções

e armazenando-a no dicionário D. Terceiro, resolva um problema PM(G
?) onde os vértices de G?

correspondem aos elementos de {C1, . . . ,CK} e cujo conjunto de arestas induz um grafo acíclico.

Além do cálculo envolvendo os componentes conexos e o cálculo prévio de tabelas, os super-poços

devem ser tratados diferentemente quando o algoritmo apresentado na Seção 4.3 for utilizado para

resolver PM(G
?), ou seja, buscar um valor em uma tabela ao invés de resolver um problema associado

a um super-poço. Do procedimento esboçado aqui, pode-se concluir que seu tempo de execução é

provavelmente melhor que o tempo do algoritmo que trata de grafos acíclicos.

4.5 Sumário

Neste capítulo foram apresentados algoritmos recursivos e de Programação Dinâmica para a

solução do problema de alocação ótima de gás de elevação quando os comportamentos esperados

dos poços são conhecidos e existem restrições de precedência cuja representação forma uma flo-

resta (PE (F)) e um grafo acíclico (PE (G)). Através de experimentos numéricos, foi constatado que o

desempenho destes algoritmos é bastante satisfatório, e que são capazes de fornecer soluções quase-

ótimas em tempo relativamente baixo. Os resultados desta seção foram publicados em [11], [28], [9],

[29].



Capítulo 5

Solução de P( /0) Utilizando Programação
Linear Inteira Mista

Neste capítulo, adotamos uma abordagem diferente para a resolver o problema de alocação de

gás, ou seja, a linearização por partes das W PCs e a utilização de técnicas de solução baseadas em

Programação Linear Inteira Mista. Esta mudança ocorreu pois alterar os algoritmos de Programação

Dinâmica de modo a tratar novas restrições não é uma tarefa trivial. Além disso, as W PCs são nor-

malmente fornecidas como um conjunto de pontos, o que torna a linearização por partes um método

mais natural a ser adotado.

5.1 Linearização por Partes Aplicada a P

Inicialmente, relembramos o problema de alocação de gás de elevação sob a restrição de uma taxa

máxima de injeção:

P : Maximizar f =
N
?

n=1
fn(q

n
i , q

n
p)

Sujeito a :
N
?

n=1
qni ? q

max
i

qnp = q?
n
p(q

n
i ) n = 1, . . . , N

lnyn ? q
n
i ? unyn n = 1, . . . , N

yn ?{0, 1} n = 1, . . . , N

(5.1)

O problema P possui funções não-lineares e variáveis discretas, portanto pertence à classe de

problemas de Programação Não-Linear Inteira Mista, que figuram entre os problemas de otimização



5. Solução de P( /0) Utilizando Programação Linear Inteira Mista 61

mais difíceis de serem resolvidos. Procedimentos para encontrar limites superiores para a solução

ótima através da relaxação da integralidade das variáveis discretas podem dar origem a problemas

difíceis de Programação Não-Linear [5], e procedimentos de enumeração das soluções podem não ser

efetivos se não houverem limites apertados.

Assim, ao invés de resolver P diretamente, podemos linearizar por partes suas funções não-

lineares, transformando P em um problema de Programação Linear Inteira Mista. Através desta

reformulação, é possível calcular limites para as soluções através de procedimentos de Programação

Inteira, ferramentas já consolidadas e de grande potencial. Esta abordagem possui desvantagens,

como o aumento do número de variáveis discretas e a perda de acuracidade, porém os experimentos

realizados aqui mostram que os benefícios da formulação linear inteira mista superam os aspectos

negativos.

Antes de apresentar a formulação utilizando linearização por partes, algumas definições necessárias

ao desenvolvimento são dadas abaixo.

Definição 5.1 Qni = {q
n,0
i , q

n,1
i , . . . , q

n,?(n)
i } é o conjunto de taxas de injeção de gás para o poço n,

onde ?(n) é o número de taxas de injeção de gás para as quais o fluxo de saída é conhecido.

Definição 5.2 Qnp = {q
n,0
p , q

n,1
p , . . . , q

n,?(n)
p } é o conjunto de taxas de fluxo de saída para o poço n, tal

que qn,kp = qnp(q
n,k
i ) para k = 0, . . . , ?(n).

Hipótese 5.1 Para cada poço n ? N = {1, . . . , N}, qn,0i = q
n,0
p = 0, indicando que o primeiro ponto

operacional é a origem; q
n,k?1
i &amp;lt;q

n,k
i para k = 1, . . . , ?(n), significando que os valores de taxas

de injeção são distintos, qn,1i = ln e q
n,?(n)
i = un ? q

max
i , eliminando os valores de taxas de injeção

desnecessários (infactíveis).

Assim, podemos seguir as diretivas fornecidas em [37] e formular o problema de alocação ótima

de gás de injeção como um problema linearizado por partes:

Ppl : Maximizar f =
N
?

n=1

?(n)
?

k=2
( f n,k?1?Ln,k + f

n,k?Rn,k)

Sujeito a :
N
?

n=1
qni ? q

max
i

?Ln,k, ?
R
n,k ? 0 n = 1, . . . , N , k = 2, . . . , ?(n)

?Ln,k + ?
R
n,k = xn,k n = 1, . . . , N , k = 2, . . . , ?(n)

?(n)
?

k=1
xn,k = 1 n = 1, . . . , N

qni =
?(n)
?

k=2
(qn,k?1i ?

L
n,k + q

n,k
i ?

R
n,k) n = 1, . . . , N

xn,k ?{0, 1}, n = 1, . . . , N , k = 1, . . . , ?(n)

(5.2)



5. Solução de P( /0) Utilizando Programação Linear Inteira Mista 62

0

(q1i , q
1
p)

(q2i , q
2
p)

(q3i , q
3
p)

(q4i , q
4
p)

(q5i , q
5
p)

(q6i , q
6
p)

x1 x2 x3 x4 x5 x6

?L2
?R2 , ?

L
3

?R5 , ?
L
6

?R6

qi

qp

q1i q
2
i

q1p

q2p

q
?(n)
i

Figura 5.1: Ilustração da linearização por partes da função do fluxo de saída de um poço n utilizando
o modelo de Sherali (Seção 2.3.3).

onde:

• f n,k = fn(q
n,k
i , q

n,k
p ) é a contribuição para a função objetivo do poço n no ponto de operação

(q
n,k
i , q

n,k
p );

• ?n = {?Ln,k, ?
R
n,k : k = 2, . . . , ?(n)} é o conjunto de fatores que induzem a combinação convexa

dos elementos de Qn;

• xn = {xn,k : k = 1, . . . , ?(n)} é o conjunto de variáveis discretas que forçam a combinação
convexa de apenas dois elementos consecutivos de Qn; xn,k assume valor 1 se e somente se

qni = q
n,k?1
i ?

L
n,k + q

n,k
i ?

R
n,k e q

n
p = q

n,k?1
p ?Ln,k + q

n,k
p ?Rn,k , com exceção de xn,1 que assume valor 1

se e somente se qni = q
n
p = 0, ou seja, xn,k assume valor 1 se q

n
i ? [q

n,k?1
i , q

n,k
i ] e q

n
p ? [q

n,k?1
p , q

n,k
p ]

é aproximado linearmente neste dado intervalo pela combinação convexa de seus pontos ex-

tremos como mostra a Figura 5.1.

Para simplificar os desenvolvimentos a seguir, introduzimos a seguinte notação: ? =
SN

n=1 ?n;

x =
SN

n=1 xn; qi = {q
n
i : n = 1, . . . , N}; e K =

N
?

n=1
?(n). Utilizando esta notação, o espaço de soluções

factíveis pode ser representado pelo conjunto Xpl ={(x, ?, qi)?BK×R2(K?N)×RN : (x, ?, qi) satisfaz
as restrições de (5.2)}, onde B = {0, 1}.

É sabido que na minimização (maximização) de uma função convexa (côncava) linearizada por

partes, as variáveis x assumem valores inteiros naturalmente, i.e., os valores de ? diferentes de zero
são sempre consecutivos [31]. Isto permite que o problema seja simplificado mais uma vez, descar-

tando quase todas as variáveis x, sendo que apenas xn,1 para n = 1, . . . , N é necessária para determinar



5. Solução de P( /0) Utilizando Programação Linear Inteira Mista 63

se o poço está ou não ativo. Para o problema em questão, a função objetivo é separável porém não

côncava, devido à região não factível entre qni = 0 e q
n
i = l

n. No entanto, se a função objetivo de um

poço n for côncava dentro do intervalo [ln, un], o número de variáveis discretas pode cair de ?(n) para
apenas uma variável.

Examinando as restrições de Ppl , notamos que algumas variáveis de decisão podem ser eliminadas

da formulação, sendo substituídas pelas equações:

xn,1 = 1?
?(n)
?

k=2
xn,k n = 1, . . . , N (5.3)

?Rn,k = xn,k ??
L
n,k n = 1, . . . , N , k = 2, . . . , ?(n) (5.4)

qni =
?(n)
?

k=2
qn,ki xn,k + ?

?(n)
k=2

(

qn,k?1i ?q
n,k
i

)

?Ln,k n = 1, . . . , N (5.5)

Substituindo as variáveis de Ppl pelas respectivas equações (5.3)–(5.5) obtemos uma formulação mais

compacta:

Pcpl : Maximizar f =
N
?

n=1

?(n)
?

k=2

[

f n,k xn,k ?( f
n,k ? f n,k?1)?Ln,k

]

Sujeito a :
N
?

n=1

?(n)
?

k=2

[

qn,ki xn,k ?(q
n,k
i ?q

n,k?1
i )?

L
n,k

]

? qmaxi

?Ln,k ? 0 n = 1, . . . , N , k = 2, . . . , ?(n)
xn,k ??Ln,k ? 0 n = 1, . . . , N , k = 2, . . . , ?(n)
?(n)
?

k=2
xn,k ? 1 n = 1, . . . , N

xn,k ?{0, 1} n = 1, . . . , N , k = 2, . . . , ?(n)

(5.6)

Os vetores x e ?L podem representar vetores de variáveis da mesma forma que em Ppl , permitindo
que o espaço factível de Pcpl seja representado pelo conjunto Xcpl = {(x, ?L)? BK?N ×RK?N : (x, ?L)
satisfaz as restrições de (5.6)}.

5.2 Desigualdades Válidas

Um dos objetivos deste trabalho é fornecer uma formulação versátil de P e algoritmos simples

e eficientes que possam ser integrados a simuladores e software de controle de produção de hidro-

carbonetos. Neste sentido, analisamos o poliedro Pcpl = conv(Xcpl ) para identificar desigualdades

válidas que aceleram a busca branch-and-bound de algoritmos comerciais e não-comerciais. Para fa-

cilitar o entendimento do leitor, apresentamos uma instância com 6 poços na Tabela 5.1, e definimos

qmaxi = 6, 5. Estes dados serão utilizados para ilustrar os conceitos apresentados ao longo do texto.



5. Solução de P( /0) Utilizando Programação Linear Inteira Mista 64

Tabela 5.1: Níveis de injeção para uma instância de 6 poços, qmaxi = 6, 5.

qn,ki
n\k 1 2 3 4 5 6 ?(n)
1 0,5 2 3 4 5 6 6
2 1 2 3 4 5 5,5 6
3 1 2 3 4 5 6 6
4 1 2 3 4 4,5 5
5 1 2 3 3,5 4
6 1 2 3 4 5 5

A seguir, introduzimos a terminologia utilizada aqui e estabelecemos condições para que Pcpl
possua dimensão cheia.

• N = {1, . . . , N} é o conjunto dos índices dos poços. Para o exemplo da Tabela 5.1, N =

{1, 2, 3, 4, 5, 6};

• ? ={(n, k) : n = 1, . . . , N, k = 2, . . . , ?(n)} é o conjunto de todos os pares (n, k) =(poço, nível de
operação). No exemplo, ? ={(1, 2), . . . , (1, 6), (2, 2), . . . , (2, 6), (3, 2), . . . , (3, 6), (4, 2), . . . , (4, 5),
(5, 2), . . . , (5, 4), (6, 2), . . . , (6, 5)};

• ?n = {(n, k) ? ?} é o conjunto de todos os pares (n, k) =(poço, nível de operação) em ?
relativos ao poço n. Para n = 5, ?5 = {(5, 2), (5, 3), (5, 4)};

• ?(U ) =
S

n?U ?n para U ? N é a união dos conjuntos ?n para todos os poços n contidos no
conjunto U . Para U = {3, 4}, ?(U ) = {(3, 2), . . . , (3, 6), (4, 2), . . . , (4, 5)};

• ?(S) = ?(n,k)?S q
n,k?1
i onde S ? ? é a taxa de injeção mínima necessária para ativar todos os

poços n no intervalo k, sendo que o par (n, k) pertence a um conjunto S. Para S = {(1, 4), (2, 2),

(4, 4)}, ?(S) = q1,3i + q
2,1
i + q

4,3
i = 3 + 1 + 3 = 7;

• S(n, k) = S?{(n, k)} onde S ? ? são todos os pares (n, k) =(poço, nível de operação) do con-
junto S exceto o par (n, k). Para o conjunto S definido no item anterior, S(2, 2) ={(1, 4), (4, 4)};

• N(S) = {n : (n, k) ? S} para S ? ? é o conjunto dos índices dos poços n que possuem um par
(n, k) em S. Para S = {(1, 4), (2, 2), (4, 4)}, N(S) = {1, 2, 4}; e

• (n(S), k(S)) = arg max{qn,k?1i : (n, k) ? S} para S ? ? é o par (n, k) de S que necessita da
maior taxa de injeção de gás para ativar o poço n no nível mínimo do intervalo k. Para S =

{(1, 4), (2, 2), (4, 4)}, (n(S), k(S)) = arg max{q1,3i , q
2,1
i , q

4,3
i } = arg max{3, 1, 3} = (1, 4).

Proposição 5.1 Pcpl = conv(Xcpl ) possui dimensão cheia.



5. Solução de P( /0) Utilizando Programação Linear Inteira Mista 65

Prova: Seja Z ? R2(K?N) uma matriz cujas linhas sejam vetores incidentes zU ? Xcpl , cujas en-

tradas diferentes de zero correspondam aos elementos de U ?{xn,k, ?Ln,k : (n, k) ? ?}. Sejam z
{xn,k} e

z{xn,k ,?
L
n,k} para n = 1, . . . , N e k = 2, . . . , ?(n) as linhas de Z, todos elementos de Xcpl de acordo com a

Hipótese 5.1. Claramente, rank(Z) = 2(K ?N) e, como o vetor nulo pertence a Xcpl , concluímos que

conv(Xcpl ) possui dimensão cheia, ou seja, dim(conv(Xcpl )) = 2(K ?N). ?

Considerando que Pcpl possui uma estrutura semelhante ao problema da mochila [42], as de-

sigualdades de cobertura do problema da mochila podem ser reformuladas como desigualdades váli-

das para Pcpl , porém neste caso os elementos da cobertura consistem de pares de poços e níveis de

injeção (pares (n, k)). Os conceitos de cobertura e cobertura mínima nas variáveis x, assim como as

desigualdades válidas induzidas, são dadas a seguir.

Definição 5.3 Um subconjunto C ?? é uma cobertura1 se ?(C) &gt; qmaxi e m 6= n para todo (m, i), (n, j)?
C, (m, i) 6= (n, j).

Em palavras, C é uma cobertura se for um conjunto de pares (n, k) ? ? de poços distintos tal que a
taxa de injeção mínima necessária para ativar os poços em C nos níveis de operação k supera a taxa de

injeção disponível. Utilizando o exemplo da Tabela 5.1, C = {(1, 4), (2, 2), (4, 4)} é uma cobertura,

pois |C| = |N (C)| = 3 e ?(C) = 7 &gt; 6, 5 = qmaxi .

Definição 5.4 Um subconjunto C ? ? é uma cobertura mínima se:

i) C é uma cobertura; e

ii) ?(n, k)?C, ?(Q)? qmaxi onde Q = C(n, k) se k = 2 ou então Q = C(n, k)?{(n, k?1)} se k &gt; 2.

C é estritamente mínima se a desigualdade do item (ii) é estrita.

A cobertura C = {(1, 4), (2, 2), (4, 4)} é estritamente mínima, pois:

• para (n, k) = (1, 4), temos Q = C(1, 4)?{(1, 3)} ={(1, 3), (2, 2), (4, 4)} com ?(Q) = 6 &amp;lt;6, 5 =
qmaxi ;

• para (n, k) = (2, 2), temos Q = C(2, 2) = {(1, 3), (4, 4)} com ?(Q) = 6 &amp;lt;6, 5 = qmaxi ;

• para (n, k) = (4, 4), temos Q = C(4, 4)?{(4, 3)} ={(1, 4), (2, 2), (4, 3)} com ?(Q) = 6 &amp;lt;6, 5 =
qmaxi .

Seja ?C = {(n, j) : (n, k) ?C, j = 2, . . . , k} e seja PC = {(x, ?L) ? Pcpl : xn,k = ?Ln,k = 0, ?(n, k) ?
???C} a projeção de Pcpl no espaço de ?C. Utilizando a cobertura C acima, ?C = {(1, 2), (1, 3),
(1, 4), (2, 2), (4, 2), (4, 3), (4, 4)}.

1Note que qualquer cobertura C possui cardinalidade |C|? 2 de acordo com a Hipótese 5.1.



5. Solução de P( /0) Utilizando Programação Linear Inteira Mista 66

Corolário 5.1 dim(Pcpl ) = 2|?C|.

Proposição 5.2 Dada uma cobertura C, a desigualdade de cobertura

?
(n,k)?C

xn,k ?|C|?1 (5.7)

é válida para Pcpl .

Prova: Suponha que exista (x, ?L) em Pcpl que viola (5.7). Então,
N
?

n=1

?(n)
?

k=2
[qn,ki xn,k?(q

n,k
i ? q

n,k?1
i )?

L
n,k]

? ?
(n,k)?C

[q
n,k
i xn,k ?(q

n,k
i ?q

n,k?1
i )?

L
n,k] ? ?

(n,k)?C
q

n,k?1
i = ?(C) &gt; q

max
i o que contradiz a primeira re-

strição de (5.6) e, portanto, refuta a hipótese. ?

A desigualdade de cobertura induzida por C = {(1, 4), (2, 3), (4, 3)} é válida para Pcpl : x1,4 +

x2,2 + x4,4 ? 2.

Proposição 5.3 Se C é uma cobertura estritamente mínima, então FC = {(x, ?L) ? PC : ?
(n,k)?C

xn,k =

|C|?1} é uma face de dimensão cheia de PC.

A maximalidade de (5.7) obtida de uma cobertura estritamente mínima C, com respeito a PC,

pode ser demonstrada mostrando que uma desigualdade que induz uma face máxima F de PC, tal que

FC ? F , difere de (5.7) por uma constante multiplicativa. A princípio, a desigualdade de cobertura

(5.7) pode ser submetida a um procedimento de lifting exato para obter uma face de Pcpl de dimensões

maiores.

Um procedimento mais simples para fortalecer as desigualdades de cobertura consiste em adi-

cionar pares (n, k) que requerem mais recursos do que os pares contidos em C. Isto leva a uma

cobertura estendida e a desigualdade válida definida abaixo.

Definição 5.5 E(C) = {(n, j) : (n, k) ? C, j = k, . . . , ?(n)}?{(n, k) ? ? : qn,k?1i ? q
n(C),k(C)?1
i } é a

cobertura estendida de uma cobertura C.

Para nosso exemplo, E(C) = {(1, 4), (1, 5), (1, 6), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (4, 4), (4, 5)}?

{(3, 4), (3, 5), (3, 6), (5, 4), (6, 4), (6, 5)}. Note que (n(C), k(C)) = (1, 4) com q
n(C),k(C)?1
i = 3.

Proposição 5.4 Dada uma cobertura C, a desigualdade

?
(n,k)?E(C)

xn,k ?|C|?1 (5.8)

induzida por uma cobertura estendida E(C) é válida para Pcpl .



5. Solução de P( /0) Utilizando Programação Linear Inteira Mista 67

Note que se C não for mínima, então pode existir C??C tal que a desigualdade (5.8) induzida por

C é implicada por (5.8) induzida por C?.

Definição 5.6 Dada uma cobertura C e h ?{0, . . . ,|C|}, Ch denota o subconjunto de C tal que:

i) |Ch| = h; e

ii) max{qn,k?1i : (n, k) ?C?Ch}? min{q
n,k?1
i : (n, k) ?Ch} se 0 &amp;lt;h &amp;lt;|C|.

Para a cobertura exemplo,

• C0 = /0;

• C1 = {(4, 4)};

• C2 = {(1, 4), (4, 4)};

• C3 = {(1, 4), (2, 2), (4, 4)}.

Definição 5.7 Dada uma cobertura C, (n, k) ?C, e h ?{0, . . . ,|C|?1}, C(n, k)h denota um subcon-

junto de C(n, k) tal que:

i) |C(n, k)h| = h; e

ii) max{qm, j?1i : (m, j) ?C(n, k)?C(n, k)h}? min{q
m, j?1
i : (m, j) ?C(n, k)h} se 0 &amp;lt;h &amp;lt;|C|?1.

Para a cobertura C de nosso exemplo e (n, k) = (1, 4),

• C(1, 4)0 = /0;

• C(1, 4)1 = {(4, 4)};

• C(1, 4)2 = {(2, 2), (4, 4)}.

Uma maneira melhor de aumentar uma desigualdade de cobertura consiste em considerar as de-

mandas de recursos para obter fatores ?n,k ?{0, 1, . . . ,|C|?1}, (n, k) ? E(C)?C, ao invés de usar o
limite inferior trivial. Utilizando os resultados de [3], identificamos estes fatores e condições sob as

quais as desigualdades resultantes definem uma face máxima de Pcpl .

Teorema 5.1 A desigualdade

?
(n,k)??

?n,k xn,k ? ?0 (5.9)

onde ?0 é um inteiro positivo, é satisfeita por todo (x, ?L) ? Pcpl = conv(Xcpl ) se ? pode ser parti-
cionado em q + 1 subconjuntos ?h, h = 0, 1, . . . , q, 1 ? q ? ?0, tal que:



5. Solução de P( /0) Utilizando Programação Linear Inteira Mista 68

(i) ?n,k = h para todo (n, k) ? ?h, h = 0, 1, . . . , q;

(ii) S =
Sq

h=1 ?h é a extensão de uma cobertura mínima C, E(C) = S, tal que C ??1, e |C|= ?0 + 1;
e

(iii) o particionamento de ? se dá como segue:

?0 = ??S, onde ?C0 = ?0 ??(N(C)) e ?
C?
0 = ?0 ??

C
0 ;

?1 = S??
q
h=2?h, onde ?

C
1 = ?1 ??(N(C)) e ?

C?
1 = ?1 ??

C
1 ;

?h = ?Ch ??
C?
h , h = 2, . . . , q;

?Ch = {(n, k) ? ? : (n, i) ?C, ?(C(n, i)h?1) ? q
n,k?1
i ?q

n,i?1
i &amp;lt;?(C(n, i)h)},

h = 2, . . . , q; e

?C?h = {(n, k) ? ? : n ? N ?N(C), ?(Ch) ? q
n,k?1
i &amp;lt;?(Ch+1)}, h = 2, . . . , q.

Se as condições:

(iv) para todo (n, k) ?C, h = 0, 1, . . . , q, e para todo (n, j) ? ?Ch ,

?((C(n, k)?C(n, k)h)?{(n, j)}) &amp;lt;qmaxi , e (5.10a)

(v) para cada h = 0, 1, . . . , q, e para todo (n, k) ? ?C?h ,

?((C?Ch+1)?{(n, k)}) &amp;lt;qmaxi (5.10b)

forem satisfeitas, além de (i), (ii), e (iii), então (5.9) induz uma faceta de Pcpl .

Prova: (Validade) Suponha que exista z? = (x?, ??L) ? Xcpl que satisfaz (i), (ii), e (iii) mas viola (5.9).
Para qualquer z = (x, ?L)? Xcpl , seja Jl (x) = {(n, k) ? ? : xn,k = l}, l = 0, 1. Defina z? = (x?, ??L) como:

(1) x?n,k = x?n,k e ??Ln,k = ??
L
n,k caso não seja especificado por (2), (3), ou (4) abaixo.

(2) Seja ??C1 = ?
C
1 ?J1(x?)?C e ??

C
1 = {(n, k) ? C : (n, j) ? ??

C
1}. Faça as seguintes mudanças em

(x?, ??L):

– faça x?n,k = ??Ln,k = 0 para todo (n, k) ? ??
C
1 ; e

– faça x?n,k = ??Ln,k = 1 para todo (n, k) ? ??
C
1 .

Note que (x?, ??L) ? Xcpl e |?1 ?J1(x?)| = |?1 ?J1(x?)|.

(3) Seja {??Ch : h = 2, . . . , q} a família de subconjuntos tal que ??
C
h = ?

C
h ?J1(x?), h = 2, . . . , q. Seja

??C ?{(n, k) ?C?J0(x?) : n?N(C)?N(
Sq

h=2 ??
C
h )} o maior subconjunto tal que |??

C|?
q

?
h=2

(h?

1)|??Ch |. Faça as seguintes mudanças em (x?, ??
L):



5. Solução de P( /0) Utilizando Programação Linear Inteira Mista 69

– faça x?n,k = ??Ln,k = 0 para todo (n, k) ?
Sq

h=2 ??
C
h ;

– faça x?n,k = ??Ln,k = 1 para todo (n, k) ?{(m, j) ?C : m ? N(
Sq

h=2 ??
C
h )}; e

– faça x?n,k = ??Ln,k = 1 para todo (n, k) ? ??
C.

Note que (x?, ??L) permanece como elemento de Xcpl devido a (iii). Além disso, |??C| é máxima
pois, caso contrário, ?(J1(x?)) ? ?(J1(x?)) ? ?(C) &gt; qmaxi o que violaria a primeira restrição de
(5.6), contradizendo a hipótese.

(4) Seja {??C?h : h = 2, . . . , q} a família de subconjuntos tal que:

??C?h ? ?
C?
h ?J1(x?), h = 2, . . . , q, e (5.11a)

q

?
h=2

h|??C?h | ? ?0 + 1?|J1(x?)??1|. (5.11b)

A existência de tal família segue de

?
(n,k)??

?n,kx?n,k =
q

?
h=1

h|?h ?J1(x?)|

= |?1 ?J1(x?)|+
q

?
h=2

h|?h ?J1(x?)|

= |?1 ?J1(x?)|+
q

?
h=2

h|??Ch |+
q

?
h=2

h|?h ?J1(x?)???Ch |

= |J1(x?)??1|+
q

?
h=2

h|?h ?J1(x?)???Ch |

= |J1(x?)??1|+
q

?
h=2

h|?C?h ?J1(x?)| (5.12a)

&gt; ?0 [pois z? viola (5.9) de acordo com a hipótese] (5.12b)

? ?0 + 1 (5.12c)

De (5.12a)–(5.12c) segue que

q

?
h=2

h|?C?h ?J1(x?)| ? ?0 + 1?|J1(x?)??1|. (5.13)

Seja ??C? ?{(n, k) ?C?J0(x?)} o maior subconjunto tal que |??C?|?
q

?
h=2

h|??C?h |. Faça as seguintes

mudanças em (x?, ??L):

– faça x?n,k = ??Ln,k = 0 para todo (n, k) ?
Sq

h=2 ??
C?
h ; e

– faça x?n,k = ??Ln,k = 1 para todo (n, k) ? ??
C?.

Então segue que ?(J1(x?)) ? ?(J1(x?)) ? ?(C) &gt; qmaxi , violando a primeira restrição de (5.6) e
contradizendo a hipótese z? ? Pcpl .



5. Solução de P( /0) Utilizando Programação Linear Inteira Mista 70

(Maximalidade) Seja F? = {(x, ?L) ? Pcpl : ?(n,k)?? ?n,kxn,k = ?0} a face induzida por (5.9). Seja

?T x + ?T ?L = ?
(n,k)??

?n,kxn,k + ?
(n,k)??

?n,k?Ln,k ? ?0 (5.14)

uma desigualdade válida que induz uma face máxima F = {(x, ?L) ? Pcpl : ?T x + ?T ?L = ?0} de
Pcpl tal que F? ? F . No que segue, provamos que F? é máxima mostrando que (5.14) e (5.9) diferem

apenas de uma constante multiplicativa.

Tome qualquer (n, k) ? ?Ch , h ? {0, . . . , q}, onde (n, i) ? C. Seja z = z((C(n, i) ?C(n, i)h) ?
{(n, k)}) e seja z? idêntico a z, exceto por ??Ln,k = ?

L
n,k ??. Da condição (iv), z e z? pertencem a F?

para ? &gt; 0 suficientemente pequeno. Como F? ? F , z e z? devem satisfazer:

?
(l,t)??

?l,t xl,t + ?
(l,t)??

?l,t ?Ll,t = ?0 (5.15)

Subtraindo (5.15) utilizando z? de (5.15) utilizando z, deduzimos que ?n,k = 0.

Tome qualquer (n, k)? ?C?h , h ?{0, . . . , q}. Seja z = z((C?Ch+1)?{(n, k)}) e z? idêntico a z exceto
por ??Ln,k = ?

L
n,k ??. Da condição (v), z e z? pertencem a F? para ? &gt; 0 suficientemente pequeno. Para

que z e z? estejam em F , z e z? devem satisfazer (5.15). Como na dedução acima, podemos concluir que

?n,k = 0.

Até este ponto, mostramos que ?n,k = 0 para todo (n, k) ? ?.

Tome qualquer (n, i), (m, j) ? C. Seja z = z(C(m, j)) e z? = z(C(n, i)). Como z, z? ? F?, devem

pertencer a F e satisfazer (5.15). Assim, da mesma forma que nos desenvolvimentos acima, podemos

deduzir que ?n,i = ?m, j para todo (n, i), (m, j)?C. Então, podemos assumir sem perda de generalidade
que ?0 = |C|?1, o que implica ?n,k = 1 para todo (n, k) ?C.

Tome qualquer (n, k) de ?Ch ?C, h = 0, . . . , q, onde (n, i) ? C e seja z = z((C(n, i)?C(n, i)h)?
{(n, k)}). Da condição (iv), segue que z ? F? e deve satisfazer (5.15) para que F? ? F . Consequente-

mente, ?T x = ?0 ? ?(m, j)?C(n,i)?C(n,i)h ?m, j + ?n,k = ?0 ?|C|?1?h + ?n,k = |C|?1 ? ?n,k = h.

Tome qualquer (n, k) de ?C?h , h = 0, . . . , q, e seja z = z((C ?Ch+1)?{(n, k)}). Da condição (v),
z ? F? e deve satisfazer (5.15) para que F? ? F . Então, ?T x = ?0 ? ?(m, j)?C?Ch+1 ?m, j + ?n,k = ?0 ?
|C|?(h + 1) + ?n,k = |C|?1 ? ?n,k = h.

Dos desenvolvimentos acima, concluímos que ?n,k = h para cada (n, k) ? ?h, h = 0, . . . , q, e ?0 =
|C|?1. Então, (5.9) induz uma face máxima de Pcpl . ?

O Teorema 5.1 oferece uma maneira bastante simples de fortalecer uma cobertura mínima, pois

os fatores ?n,k podem ser calculados de maneira bastante trivial. Na verdade, os fatores ?n,k induzem
limites inferiores para os fatores de lifting ?n,k das variáveis (n, k) ? ???C. As relações dos fatores



5. Solução de P( /0) Utilizando Programação Linear Inteira Mista 71

de lifting ?n,k com seus limites inferiores ?n,k e limites superiores ??n,k serão abordadas nas seções
seguintes.

Continuando com nosso exemplo, temos que:

• q = |C|?1 = 2;

• ?C?2 = /0;

• ?C?1 = {(3, 4), (3, 5), (3, 6), (5, 4), (6, 4), (6, 5)};

• ?C2 = {(2, 5), (2, 6)};

• ?C1 = {(1, 4), (1, 5), (1, 6), (2, 2), (2, 3), (2, 4), (4, 4), (4, 5)};

• ?1 = ?C1 ??
C?
1 ={(1, 4), (1, 5), (1, 6), (2, 2), (2, 3), (2, 4), (3, 4), (3, 5), (3, 6), (4, 4), (4, 5), (5, 4),

(6, 4), (6, 5)};

• ?2 = {(2, 5), (2, 6)};

• S =
Sq

h=1 ?h =
S2

h=1 ?h = E(C);

• ?C0 = {(1, 2), (1, 3), (4, 2), (4, 3)};

• ?C?0 = {(3, 2), (3, 3), (5, 2), (5, 3), (6, 2), (6, 3)}.

Exemplificamos agora a verificação de que as condições (5.10a) e (5.10b) são válidas:

• Condição (5.10a) para (n, k) = (2, 2):

– h = 0: ??C0 = /0;

– h = 1: ??C1 = {(2, 2), (2, 3), (2, 4)}

? ?((C(2, 2)?C(2, 2)1 )?{(2, 2)}) = ?({(1, 4), (2, 2)}) = 3 + 1 = 4 &amp;lt;qmaxi
? ?({(1, 4), (2, 3)}) = 3 + 2 = 5 &amp;lt;qmaxi
? ?({(1, 4), (2, 4)}) = 3 + 3 = 6 &amp;lt;qmaxi ;

– h = 2: ??C2 = {(2, 5), (2, 6)}

? ?((C(2, 2)?C(2, 2)2 )?{(2, 5)}) = ?({(2, 5)}) = 4 &amp;lt;qmaxi
? ?({(2, 6)}) = 5 &amp;lt;qmaxi .

• Condição (5.10b):

– h = 0 e (n, k) = (3, 3): ?((C?C1)?{(3, 3)}) = ?({(2, 2), (4, 4)}?{(3, 3)}) = 1 + 3 + 2 =
6 &amp;lt;6, 5 = qmaxi ;



5. Solução de P( /0) Utilizando Programação Linear Inteira Mista 72

Tabela 5.2: Limites inferiores para os fatores de lifting, ?n,k.

(n, k) ?n,k = h
(1,5) 1
(1,6) 1
(2,3) 1
(2,4) 1
(2,5) 2
(2,6) 2
(4,5) 1
(3,4) 1
(3,5) 1
(3,6) 1
(5,4) 1
(6,4) 1
(6,5) 1

(n, k) ?n,k = h
(1,2) 0
(1,3) 0
(4,2) 0
(4,3) 0
(3,2) 0
(3,3) 0
(5,2) 0
(5,3) 0
(6,2) 0
(6,3) 0

– h = 1 e (n, k) = (6, 5): ?((C?C2)?{(6, 5)}) = ?({(2, 2)}?{(6, 5)}) = 1 + 4 = 5 &amp;lt;6, 5 =
qmaxi ;

– para h = 2, ?C?h = /0.

Repetindo o processo para todos os outros pares (n, k), verifica-se que as condições (5.10a) e (5.10b)

são válidas. A Tabela 5.2 contém os limites inferiores ?n,k para os fatores de lifting obtidos através
do processo acima, e a desigualdade válida correspondente é dada por:

x1,4 + x1,5 + x1,6 + x2,2 + x2,3 + x2,4 + x3,4 + x3,5 + x3,6+

x4,4 + x4,5 + x5,4 + x6,4 + x6,5 + 2x2,5 + 2x2,6 ? 2 .

Tome uma cobertura mínima C e seja ? = ?(N ?N(C))?E(C). Dizemos que C é uma cober-
tura forte se ? = /0 ou então ?(Q) ? qmaxi para Q = C(n(C), k(C))?{(n(?), k(?))}. Uma cobertura
estritamente mínima C é estritamente forte se ?(Q) &amp;lt;qmaxi . Note que existiria uma cobertura C

? tal

que E(C) ? E(C?) se C não fosse forte e, consequentemente, a desigualdade de cobertura estendida

(5.8) induzida por C? seria mais forte que (5.8) induzida por C. Note também que as condições (iv) e

(v) do Teorema 5.1 implicam que C é uma cobertura estritamente forte.

Condições necessárias e suficientes para que a desigualdade (5.8) induza uma faceta de Pcpl po-

dem ser estabelecidas. Uma das condições é que C deve ser uma cobertura estritamente forte. Apesar

de induzirem facetas, estas desigualdades são menos úteis que as desigualdades (5.9) cuja eficiência

será testada através de experimentos computacionais.



5. Solução de P( /0) Utilizando Programação Linear Inteira Mista 73

5.3 Lifting de Coberturas Mínimas

Seja C uma cobertura mínima e seja C? = {(n1, k1), . . . , (nT , kT )}? ??C um subconjunto orde-
nado dos pares que não aparecem em C. Seja também ? = {?n,k : (n, k) ?C?} o conjunto dos fatores
de lifting calculados resolvendo a sequência K ={Kt : t = 1, . . . , T} de problemas semelhantes a Pcpl ,

recursivamente definidos por:

Kt : zt = Maximizar ?
(n,k)?C

xn,k +
t?1
?
j=1

?n j,k j xn j ,k j

Sujeito a :

?
(n,k)??t

qn,k?1i xn,k ? q
max
i

?
(n,k)??t??n

xn,k ? 1 ?n ? N(?t )

xnt ,kt = 1

xn,k ?{0, 1} ?(n, k) ? ?t

(5.16)

para t = 1, . . . , T onde ?t = {(n j, k j) : j = 1, . . . ,t}?C e os coeficientes ?n j ,k j são definidos como:

?n j ,k j = |C|?1?z j, j = 1, . . . ,t ?1. (5.17)

Utilizamos agora nosso exemplo, com C = {(1, 4), (2, 2), (4, 4)}, C? = {(1, 5), (1, 6), (2, 3), (2, 4),

(2, 5), (2, 6), (4, 5), (3, 4), (3, 5), (3, 6), (5, 4), (6, 4), (6, 5), (1, 2), (1, 3), (4, 2), (4, 3), (3, 2), (3, 3), (5, 2),

(5, 3), (6, 2), (6, 3)}, e calculamos os fatores de lifting para os elementos em C?, na ordem apresen-

tada. Para ilustrar, apresentamos a seguir o problema K1 resolvido para a obtenção de ?1,5, onde
?1 = {(1, 4), (2, 2), (4, 4), (1, 5)}:

K1 : z1 = Max x1,4 + x2,2 + x4,4

Sujeito a :

3x1,4 + 1x2,2 + 3x4,4 + 4x1,5 ? 6, 5

x1,4 + x1,5 ? 1

x2,2 ? 1

x4,4 ? 1

x1,5 = 1

xn,k ?{0, 1},?(n, k) ? ?1

A solução do problema é z1 = 1, e portanto ?1,5 = |C|?1?z1 = 3?1?1 = 1. Continuando
o processo iterativo para os outros 12 pares (n, k) em C?, obtemos os fatores de lifting mostrados na

Tabela 5.3. Note que os fatores ?n,k encontrados são exatamente iguais aos fatores ?n,k encontrados



5. Solução de P( /0) Utilizando Programação Linear Inteira Mista 74

Tabela 5.3: Fatores de lifting exatos, ?n,k.

t (n, k) zt ?n,k
1 (1,5) 1 1
2 (1,6) 1 1
3 (2,3) 1 1
4 (2,4) 1 1
5 (2,5) 0 2
6 (2,6) 0 2
7 (4,5) 1 1
8 (3,4) 1 1
9 (3,5) 1 1
10 (3,6) 1 1
11 (5,4) 1 1
12 (6,4) 1 1
13 (6,5) 1 1

t (n, k) zt ?n,k
14 (1,2) 2 0
15 (1,3) 2 0
16 (4,2) 2 0
17 (4,3) 2 0
18 (3,2) 2 0
19 (3,3) 2 0
20 (5,2) 2 0
21 (5,3) 2 0
22 (6,2) 2 0
23 (6,3) 2 0

na seção anterior utilizando o Teorema 5.1 e mostrados na Tabela 5.2.

Proposição 5.5 Se C é uma cobertura mínima, C? ? ??C é um subconjunto ordenado, e os coefi-
cientes em ? são calculados através da solução da sequência de problemas K , então a desigualdade

?
(n,k)?C

xn,k + ?
(n,k)?C?

?n,kxn,k ?|C|?1 (5.18)

é válida para Pcpl .

Prova: (Por indução em t) Para a base, t = 1, existem duas possibilidades. Se xn1,k1 = 0, então

(5.18) se torna a desigualdade de cobertura (5.7), que é válida. Se xn1,k1 = 1, então (5.18) é válida se

?n1,k1 ?|C|?1?max{?(n,k)?C xn,k : s.a (5.16)} = |C|?1?z1 = ?n1,k1 por definição.

Para o passo de indução, t &gt; 1, existem também duas possibilidades. Se xnt ,kt = 0, então (5.18)

é válida por indução. Se xnt ,kt = 1, então (5.18) é válida se ?nt ,kt ? |C|?1?max{?(n,k)?C xn,k +
?t?1j=1 ?n j,k j xn j ,k j : s.a (5.16)} = |C|?1?zt = ?nt ,kt por definição. ?

O procedimento descrito acima é uma extensão do procedimento de lifting sequencial para Pcpl .

Os coeficientes ?n,k são fatores de lifting que dependem tanto de C como da ordem dos elementos
de C? ? ??C. Apesar do cálculo dos fatores em ? significar resolver problemas de complexidade
comparada a Pcpl , um limite superior ??n,k pode ser facilmente calculado para ?n,k .

Definição 5.8 Dada uma cobertura C, C?h é um subconjunto de C tal que h ?{0, . . . ,|C|}, |C?h| = h, e

min{qn,k?1i : (n, k)?C?C?h}?max{q
n,k?1
i : (n, k)?C?h} quando 0 &amp;lt;h &amp;lt;|C|, i.e., C?h é um subconjunto

dos h elementos mais “leves” de C.



5. Solução de P( /0) Utilizando Programação Linear Inteira Mista 75

Para o nosso exemplo, com C = {(1, 4), (2, 2), (4, 4)}, temos que C?0 = /0, C?1 = {(2, 2)}, C?2 =
{(1, 4), (2, 2)} e C?3 = {(1, 4), (2, 2), (4, 4)}.

Definição 5.9 Dada uma cobertura C, (n, k) ? C, e h ?{0, . . . ,|C|?1}, C?(n, k)h é um subconjunto

de C(n, k) tal que |C?(n, k)h| = h e min{q
m, j?1
i : (m, j) ? C(n, k)?C?(n, k)h}? max{q

m, j?1
i : (m, j) ?

C?(n, k)h} quando 0 &amp;lt;h &amp;lt;|C|?1, i.e., C?(n, k)h é um subconjunto dos h elementos mais “leves” de

C(n, k).

Para a cobertura C de nosso exemplo e (n, k) = (1, 4), temos que C?(1, 4)0 = /0, C?(1, 4)1 = {(2, 2)}
e C?(1, 4)2 = {(2, 2), (4, 4)}.

Seja ??n,k o valor de ?n,k se (n, k) = (n1, k1) e seja z
?
n,k o valor de K1.

Proposição 5.6 Dada uma cobertura mínima C e (n, k) ? ??C, ??n,k = |C|?1?z
?
n,k onde z

?
n,k pode

ser calculado como segue:

z?n,k =

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

h? = arg max {?(C?h) ? qmaxi ?q
n,k?1
i } se n ? N ?N(C)

h?{0,...,|C|?1}

h? = arg max {?(C?(n, i)h) ? qmaxi ?q
n,k?1
i } se (n, i) ?C

h?{0,...,|C|?1}

Prova: Se n ? N(C), então x? obtido quando x?m, j = 1 para todo (m, j) ? C?(n, i)h? ?{(n, k)}, onde

(n, i) ?C, e x?m, j = 0 para todo (m, j) ? ??C?(n, i)h? ?{(n, k)} é factível para K1 e seu valor objetivo
é z1 = |C?(n, i)h?| = h

? ? z?n,k. De fato, x
? é ótimo porque não pode haver solução factível com mais de

h? elementos de C iguais a 1, portanto z1 = z
?
n,k . Similarmente, pode-se provar que isto é satisfeito se

n ? N ?N(C). ?

Em nosso exemplo, para (n, k) = (1, 5), z?1,5 = arg max{?(C?(1, 4)h) ? 6, 5 ?q
1,4
i = 6, 5 ? 4 =

2, 5}? z?1,5 = 1 e portanto ?
?
1,5 = |C|?1?z

?
n,k = 3?1?1 = 1. Para (n, k) = (3, 6), z

?
3,6 = arg max

{?(C?h) ? 6, 5?q
3,5
i = 6, 5?5 = 1, 5}? z

?
3,6 = 1 e portanto ?

?
3,6 = 3?1?1 = 1. Procedendo da

mesma maneira para todos os pares (n, k), obtemos os limites superiores ??n,k mostrados na Tabela
5.4. Note que, para este exemplo, os limites inferiores ?n,k são iguais a ??n,k para todos os pares (n, k),
o que significa que ?n,k = ??n,k = ?n,k .

Note que ?n,k depende da cobertura C mas não da ordem C?. Seja C?t a ordem obtida de C
?

colocando um par (n, k) ? C? na t-ésima posição, e seja ?n,k(C?t ) o respectivo fator de lifting. É
evidente da estrutura do problema Kt que ?n,k(C?t ) é não-crescente em t e ?n,k(C

?
1) = ?

?
n,k. Portanto,

??n,k é um limite superior para o fator de lifting de xn,k para qualquer sequência ordenada C
? ? ??C,

i.e. ??n,k ? ?n,k .



5. Solução de P( /0) Utilizando Programação Linear Inteira Mista 76

Tabela 5.4: Limites superiores para os fatores de lifting, ??n,k.

(n, k) z?n,k ?
?
n,k

(1,5) 1 1
(1,6) 1 1
(2,3) 1 1
(2,4) 1 1
(2,5) 0 2
(2,6) 0 2
(4,5) 1 1
(3,4) 1 1
(3,5) 1 1
(3,6) 1 1
(5,4) 1 1
(6,4) 1 1
(6,5) 1 1

(n, k) z?n,k ?
?
n,k

(1,2) 2 0
(1,3) 2 0
(4,2) 2 0
(4,3) 2 0
(3,2) 2 0
(3,3) 2 0
(5,2) 2 0
(5,3) 2 0
(6,2) 2 0
(6,3) 2 0

5.4 Sobre os Fatores de Lifting

Agora, mostramos que os fatores ?n,k da desigualdade (5.9) são iguais ou diferem de no máximo
uma unidade dos limites superiores dos fatores de lifting ??n,k. Para estabelecer formalmente esta
relação entre limites inferior e superior dos fatores de lifting, seja ?Ch = I

C
h ?J

C
h a partição de ?

C
h

definida no Teorema 5.1, h = 0, . . . , q, onde (n, k) ? ?Ch pertence a I
C
h se:

?(C?(n, ?(n))|C|?h?1) + q
n,k?1
i ? q

max
i (5.19)

onde (n, ?(n)) ?C, e caso contrário (n, k) ? JCh . Similarmente, seja ?
C?
h = I

C?
h ?J

C?
h uma partição de ?

C?
h

definida no Teorema 5.1, h = 0, . . . , q, onde (n, k) ? ?C?h pertence a I
C?
h se:

?(C?|C|?h?1) + q
n,k?1
i ? q

max
i (5.20)

e caso contrário (n, k) ? JC?h . Seja I
C =

Sq
h=0 I

C
h , J

C =
Sq

h=0 J
C
h , I

C? =
Sq

h=0 I
C?
h e J

C? =
Sq

h=0 J
C?
h . Seja

também I = IC ?IC? e J = JC ?JC?. Note que as condições (5.19) e (5.20) são versões não estritas das

condições (iv) e (v) do Teorema 5.1.

Proposição 5.7 Para qualquer face de Pcpl = conv(Xcpl ) obtida através de lifting sequencial a partir

de uma cobertura mínima C,

??n,k =

?

?

?

?

?

?n,k, (n, k) ? I

?n,k + 1, (n, k) ? J



5. Solução de P( /0) Utilizando Programação Linear Inteira Mista 77

Prova: (Caso 1) Seja (n, k) ? ICh . Se h = 0, de (5.19) temos ?(C?(n, ?(n))|C|?h?1) + q
n,k?1
i ? q

max
i ?

?(C?(n, ?(n))|C|?1 ) ? qmaxi ?q
n,k?1
i onde (n, ?(n)) ?C e, portanto, da Proposição 5.6, z

?
n,k = |C|?1 ?

??n,k = h = ?n,k . Se h &gt; 0, então da definição de ?n,k:

?(C(n, ?(n))h?1) + q
n,?(n)?1
i ? q

n,k?1
i

e como C é uma cobertura,

qmaxi &amp;lt;?(C) = ?(C?(n, ?(n))|C|?h ) + ?(C(n, ?(n))h?1) + q
n,?(n)?1
i

? ?(C?(n, ?(n))|C|?h ) + q
n,k?1
i

Desta desigualdade e porque a condição (5.19) é satisfeita, deduzimos que:

?(C?(n, ?(n))|C|?(h+1)) ? q
max
i ?q

n,k?1
i &amp;lt;?(C?(n, ?(n))|C|?h)

e, da Proposição 5.6, concluímos que z?n,k = |C|?(h + 1) ? ?
?
n,k = h = ?n,k .

(Caso 2) Seja (n, k)? IC?h . Da definição de ?n,k temos que ?(Ch)?q
n,k?1
i e como C é uma cobertura

?(C?|C|?h) &gt; qmaxi ?q
n,k?1
i . Desta desigualdade e porque a condição (5.20) é satisfeita, segue que

?(C?|C|?(h+1)) ? q
max
i ?q

n,k?1
i &amp;lt;?(C?|C|?h)

e, portanto, da Proposição 5.6, z?n,k = |C|?(h + 1) ? ?
?
n,k = h = ?n,k.

(Caso 3) Seja (n, k) ? JC?h . Da definição de ?n,k temos que ?(Ch+1) &gt; q
n,k?1
i e como C é uma

cobertura ?(C?|C|?(h+2)) ? qmaxi ?q
n,k?1
i . Desta desigualdade e porque (5.20) não é satisfeita,

?(C?|C|?(h+2)) ? q
max
i ?q

n,k?1
i &amp;lt;?(C?|C|?(h+1))

e, da Proposição 5.6, z?n,k = |C|?(h + 2) ? ?
?
n,k = h + 1 = ?n,k + 1.

(Caso 4) Seja (n, k)?JCh . Da definição de ?n,k, ?(C(n, ?(n))h)+ q
n,?(n)?1
i &gt; q

n,k?1
i e como C é uma

cobertura segue que ?(C?(n, ?(n))|C|?(h+2)) ? qmaxi ?q
n,k?1
i . Desta desigualdade e porque a condição

(5.19) não é satisfeita, deduzimos que:

?(C?(n, ?(n))|C|?(h+2)) ? q
max
i ?q

n,k?1
i &amp;lt;?(C?(n, ?(n))|C|?(h+1))

e, da Proposição 5.6, concluímos que z?n,k = |C|?(h + 2) ? ?
?
n,k = h + 1 = ?n,k + 1. ?

Observe que JC0 = /0 se C é uma cobertura mínima e J
C
0 ?J

C?
0 = /0 se C é forte. O significado do

resultado acima é que parâmetros ?n,k da desigualdade (5.9) estão distantes no máximo de 1 unidade
do limite superior ??n,k, qualquer que seja a desigualdade (5.18) obtida através de lifting sequencial da
desigualdade de cobertura (5.7). Na verdade outro resultado pode ser estabelecido relacionando os



5. Solução de P( /0) Utilizando Programação Linear Inteira Mista 78

verdadeiros fatores de lifting ?n,k e os parâmetros ?n,k. Para qualquer desigualdade submetida a lifting
sequencial (5.9) obtida de uma cobertura mínima C e de acordo com qualquer ordem C????C, pode
ser mostrado que ?n,k = ?n,k para todo (n, k) ? I, e ?n,k ?{?n,k, ?n,k + 1} para todo (n, k) ? J.

Utilizamos agora nosso exemplo para ilustrar a Proposição 5.7 com dois elementos pertencentes

a ?Ch e ?
C?
h , (1, 4) e (5, 4) respectivamente:

?(C?(1, 4)1) + q
1,3
i = 1 + 3 = 4 ? 6, 5 = q

max
i ? (1, 4) ? I

C
1

?(C?1) + q
5,3
i = 1 + 3 = 4 ? 6, 5 = q

max
i ? (5, 4) ? I

C?
1

Repetindo o raciocínio para todos os pares (n, k) restantes, concluímos que J = /0, ou seja, ??n,k = ?n,k
para todo (n, k) ? ?, corroborando os resultados mostrados nas Tabelas 5.2, 5.3 e 5.4.

5.5 Resultados Numéricos

Esta seção contém os resultados de uma série de experimentos computacionais realizados com

o intuito de testar a eficiência das desigualdades de cobertura. As 16 instâncias do problema foram

obtidas variando o número de poços de 32 a 128 e a taxa disponível de injeção de gás. As W PCs

obedecem aos padrões tipicamente observados na prática. Com respeito à linearização por partes, as

W PCs foram aproximadas por 19 segmentos, i.e., ?(n) = 19 para cada n, e satisfazem as condições
impostas na Hipótese 5.1.

Para analisar o impacto das desigualdades de cobertura no desempenho de algoritmos comerciais

e não-comerciais, realizamos os seguintes passos para cada instância:

1) resolver a instância de Pcpl utilizando o ILOG CPLEX Version 9.0 (ILOG Inc., 2003);

2) resolver iterativamente a relaxação contínua de Pcpl com um resolvedor de PL (programação

linear), procurando repetidamente uma cobertura C e calculando fatores ?n,k de modo que a
desigualdade resultante (5.9) “corta” as soluções fracionárias, parando apenas quando um plano

de corte não for encontrado;

3) resolver a instância de Pcpl aumentada com estes cortes utilizando ILOG CPLEX; e

4) repetir os passos 1 a 3 mas desta vez utilizando o GNU MILP Solver [21], que realiza uma

busca branch-and-bound pura.

A Tabela 5.5 mostra os resultados obtidos dos experimentos conduzidos com o ILOG CPLEX.

Para cada instância, a tabela mostra o número de poços e a taxa disponível de injeção de gás de

elevação, o número de nós de branch-and-bound, número de iterações (operações de pivoteamento),



5. Solução de P( /0) Utilizando Programação Linear Inteira Mista 79

Tabela 5.5: Experimentos com ILOG CPLEX
sem cortes com cortes

N qmaxi nós iterações tempo (s) nós iterações tempo (s)
300 3.056 3.573 0,82 0 5 0,01
500 654 866 0,35 0 6 0,01

32 700 7.272 9.988 3,86 0 18 0,01
1100 8.050 1.329 4,53 0 27 0,02
1500 1.537 2.981 1,26 0 33 0,01

700 176.621 229.908 189,35 0 15 0,02
1100 770.838 1.173.700 1.161,95 0 18 0,03

64 2300 852.902 1.697.571 1.917,00 0 43 0,03
2700 230.089 449.970 523,01 0 50 0,04
3500 58.948 113.675 130,61 0 72 0,04
1100 22.724.941 28.296.248 73.949,20 0 24 0,05
1500 21.011.913 26.031.027 54.594,99 0 28 0,02

128 1900 18.514.993 23.204.919 47.346,40 0 35 0,05
3100 43.742.914 65.654.963 115.245,77 0 65 0,06
3500 18.769.706 31.618.407 53.069,40 0 76 0,05
7000 815.574 2.646.970 2.976,54 0 132 0,07

Média 7.980.625 11.321.005 21.944,69 0 40 0,03

e tempo computacional para duas formulações, Pcpl e Pcpl aumentada com as desigualdades (5.9).

Os experimentos foram realizados com uma estação de trabalho equipada com um microprocessador

Pentium IV de 2.5GHz, 1 GB de RAM, e com sistema operacional GNU/Linux.

Os resultados indicam que as desigualdades de cobertura podem reduzir o tempo computacional e

uso de memória drasticamente, demonstrando que podem acelerar a solução do problema de alocação

ótima de gás de elevação.

Normalmente, os resolvedores comerciais pre-processam a instância do problema de modo a for-

talecer sua formulação com cortes gerais e restrições lógicas. Sendo assim, repetimos os experimentos

citados acima utilizando desta vez um algoritmo de branch-and-bound puro. Nossa intenção era con-

firmar o mérito intrínseco das desigualdades de cobertura e avaliar o potencial de uso de um software

de domínio público. Realizamos os mesmos passos com exceção de que as instâncias de Pcpl , sejam

puras ou aumentadas com desigualdades de cobertura, foram resolvidas com o GNU MILP solver.

A Tabela 5.6 mostra os resultados destes experimentos. Os experimentos corroboram os resulta-

dos obtidos com CPLEX: os cortes baseados nas coberturas diminuíram expressivamente o número de

nós de branch-and-bound, bem como o tempo computacional. O processo de solução das instâncias

marcadas com “?” e sem cortes foi interrompido após aproximadamente 100 horas de processamento.



5. Solução de P( /0) Utilizando Programação Linear Inteira Mista 80

Tabela 5.6: Experimentos com GNU MILP solver
sem cortes com cortes

N qmaxi nós iterações tempo (s) nós iterações tempo (s)
300 18.855 17.335 25,79 1 11 0,03
500 2.661 2.632 3,52 1 18 0,03

32 700 16.415 19.524 31,81 1 22 0,03
1100 21.795 29.909 36,76 1 34 0,03
1500 5.349 7.833 7,99 1 47 0,04
700 336.797 414.087 4.963,70 1 22 0,10

1100 1.472.805 1.878.569 66.297,01 1 36 0,11
64 2300 1.894.961 3.394.994 99.381,49 1 77 0,12

2700 739.913 1.250.173 15.111,32 1 94 0,14
3500 264.577 523.835 3.070,23 1 126 0,15

1100? 29.676.288 48.484.213 384.948,77 1 36 0,16
1500? 29.565.486 49.945.930 389.406,36 1 47 0,16

128 1900? 28.452.225 45.765.938 357.409,19 1 60 0,17
3100? 28.584.317 45.797.646 357.409,52 1 99 0,18
3500? 28.412.763 45.673.329 356.700,35 1 111 0,19
7000 1.358.067 6.094.626 19.841,12 1 243 0,23

Média 9.426.454 15.581.285 128.415,30 1 68 0,12

5.6 Sumário

Neste capítulo, foi realizada a linearização por partes das funções não-lineares do problema de

alocação ótima de taxas de injeção de gás de elevação sob uma única restrição, i.e., a taxa máxima

disponível para injeção de gás. Através da análise deste novo problema foi possível encontrar famílias

de desigualdades válidas que mostraram-se muito eficientes na redução do tempo de resposta de

algoritmos comerciais e não-comerciais que resolvem problemas de otimização linear inteira mista.

Os resultados desta seção foram publicados em [8] e [30].



Capítulo 6

Solução de P5( /0) Utilizando
Programação Linear Inteira Mista

Neste capítulo, são inseridas novas restrições ao problema tratado no Capítulo 5, de modo a

torná-lo mais abrangente. Mais especificamente, abordamos a versão do problema de alocação ótima

de gás de elevação sob múltiplas restrições nas instalações de superfície, chamado P5( /0). Novamente,
as curvas de desempenho de gas-lift são linearizadas por partes (o Modelo I mostrado no Capítulo

2 é utilizado pois o Modelo III ainda não era de nosso conhecimento) e desigualdades válidas são

obtidas e introduzidas na formulação. A eficiência destas desigualdades na aceleração do processo de

solução é testada e comprovada através de experimentos numéricos.

6.1 Formulação do Problema

O problema P5( /0)1 de alocação ótima de uma taxa disponível de injeção de gás de elevação,
sujeito a restrições nas capacidades de separação, armazenamento e tratamento de fluidos é formulado

1O superscrito 5 denota o número de restrições representadas pela formulação.



6. Solução de P5( /0) Utilizando Programação Linear Inteira Mista 82

como:

P5( /0) : Maximizar f =
N

?
n=1

(po?no + pg?
n
g ? pw?

n
w)q

n
p ? piq

n
i (6.1a)

Sujeito a:

qnp = q?
n
p(q

n
i ), n = 1, . . . , N (6.1b)

N

?
n=1

qni 6 q
max
i (6.1c)

N

?
n=1

qnp 6 q
max
p (6.1d)

N

?
n=1

qno =
N

?
n=1

?noq
n
p 6 q

max
o (6.1e)

N

?
n=1

qng =
N

?
n=1

?ngq
n
p 6 q

max
g (6.1f)

N

?
n=1

qnw =
N

?
n=1

?nwq
n
p 6 q

max
w (6.1g)

lnyn 6 q
n
i 6 unyn, n = 1, . . . , N (6.1h)

yn ?{0, 1}, n = 1, . . . , N (6.1i)

onde:

• f é a função objetivo a ser maximizada;

• ?no, ?
n
g e ?

n
w são as frações produzidas de óleo, gás e água respectivamente, sendo que ?

n
o + ?

n
g +

?nw = 1;

• po e pg representam respectivamente o lucro obtido com a venda de cada unidade de volume de

óleo e gás, pw é o custo de tratamento por unidade de volume de água produzida, e pi representa

o custo da injeção de gás por unidade de volume por tempo;

• N é o número de poços que operam via gas-lift;

• qnp é a taxa de produção de fluidos de um poço n como função de q
n
i , onde q?

n
p(q

n
i ) é a W PC do

poço n;

• qni é a taxa de injeção de gás alocada para o poço n;

• qmaxi , q
max
p , q

max
o , q

max
g e q

max
w são respectivamente a taxa de injeção de gás disponível, a taxa

de produção total máxima (representando a capacidade de separação de fluidos), e as taxas

máximas de produção de óleo, gás e água (representando os limites de armazenamento e/ou

tratamento destes fluidos);



6. Solução de P5( /0) Utilizando Programação Linear Inteira Mista 83

• yn é uma variável binária que assume valor 1 se o poço n está ativo, e 0 caso contrário;

• ln e un são respectivamente os limites inferior e superior para a taxa de injeção do poço n,

impostos por questões técnicas ou estratégicas.

Dado um conjunto Qn = {(qn,0i , q
n,0
p ), . . . , (q

n,?(n)
i , q

n,?(n)
p )} de ?(n) + 1 pontos de W PC para cada

poço n = 1, . . . , N, com (qn,0i , q
n,0
p ) = (0, 0) e q

n,k?1
i &amp;lt;q

n,k
i para k = 1, . . . , ?(n), a W PC q?

n
p(q

n
i ) pode ser

representada como uma função linear por partes utilizando o Modelo I (Seção 2.3.1). Introduzindo

variáveis binárias x e variáveis contínuas ?, é possível representar qualquer ponto da função linear
por partes como:

xn,k =

{

1 se qn,k?1i 6 q
n
i 6 q

n,k
i

0 caso contrário
(6.2a)

qni = ?n,k?1q
n,k?1
i + ?n,kq

n,k
i (6.2b)

qnp = ?n,k?1q
n,k?1
p + ?n,kq

n,k
p (6.2c)

?n,k?1 + ?n,k = 1 (6.2d)

?n,k?1, ?n,k ? 0 (6.2e)

Linearizando as WPCs como mostrado nas equações (6.2a)–(6.2e) e ilustrado pela Figura 6.1, o

problema P5( /0) ou simplesmente P5 pode ser reformulado como um problema de programação linear



6. Solução de P5( /0) Utilizando Programação Linear Inteira Mista 84

inteira mista:

P5pl : Maximizar f =
N

?
n=1

fn(q
n
i , q

n
p) (6.3a)

Sujeito a:
N

?
n=1

qny ? q
max
y , y = i, p, o, g, w (6.3b)

Para n = 1, . . . , N :

?n,k ? 0, k = 0, . . . , ?(n) (6.3c)

?n,0 ? xn,1 (6.3d)

?n,1 ? xn,2 (6.3e)

?n,k ? xn,k + xn,k+1, k = 2, . . . , ?(n)?1 (6.3f)

?n,?(n) ? xn,?(n) (6.3g)
?(n)

?
k=0

?n,k = 1 (6.3h)

?(n)

?
k=1

xn,k = 1 (6.3i)

qni =
?(n)

?
k=0

qn,ki ?n,k (6.3j)

qnp =
?(n)

?
k=0

qn,kp ?n,k (6.3k)

qny = ?
n
y q

n
p, y = o, g, w (6.3l)

qni , q
n
p, q

n
o, q

n
g, q

n
w ? R (6.3m)

?n,k ? R, k = 0, . . . , ?(n) (6.3n)

xn,k ?{0, 1}, k = 1, . . . , ?(n) (6.3o)

onde:

• a função (6.3a) é a função objetivo a ser maximizada;

• a desigualdade (6.3b) representa as restrições nas instalações de superfície, i.e., os limites im-

postos pela taxa de injeção disponível (qmaxi ), capacidade de separação (q
max
p ), e armazena-

mento/tratamento de óleo, gás e água (qmaxo , q
max
g e q

max
w respectivamente);

• a restrição (6.3c) faz com que as variáveis ?n,k sejam não-negativas, enquanto (6.3d)-(6.3g)
forçam as variáveis ?n,k a serem consecutivas, e (6.3h) significa que sua soma deve ser igual a
um;



6. Solução de P5( /0) Utilizando Programação Linear Inteira Mista 85

0

(q1i , q
1
p)

(q2i , q
2
p)

(q3i , q
3
p)

(q4i , q
4
p)

(q5i , q
5
p)

(q6i , q
6
p)

x1 x2 x3 x4 x5 x6

?n,1
?n,2

?n,5

?n,6

qi

qp

q1i q
2
i

q1p

q2p

q
?(n)
i

Figura 6.1: Ilustração da linearização por partes da função do fluxo de saída de um poço n utilizando
o modelo de pesos por ponto (Seção 2.3.1).

• a equação (6.3i) significa que a taxa de injeção de gás para um poço n deve pertencer apenas a

um determinado intervalo k;

• as equações (6.3j) e (6.3k) definem a taxa de injeção de gás e a taxa de produção de um poço n

como a combinação convexa dos pontos discretos qn,ki e q
n,k
p respectivamente; e

• a equação (6.3l) expressa as taxas de óleo, gás e água produzidas pelo poço n como funções da

taxa de produção e de suas respectivas frações.

Para cada poço n ? N = {1, . . . , N}, os limites ln e un dados pela desigualdade (6.1h) podem ser

modelados definindo qn,1i = ln e q
n,?(n)
i = un, eliminando assim pontos que estejam fora da zona opera-

cional. Não existe taxa de injeção factível entre qn,0i = 0 e q
n,1
i , ou seja, xn,1 = 1 implica que ?n,0 = 1

e qni = 0, e portanto o poço n não recebe injeção de gás. Assumimos também que q
n,?(n)
i ? q

max
i

e que max{qn,kp : k = 1, . . . , ?(n)} 6 min{qmaxp ,
qmaxo
?no

,
qmaxg
?ng

,
qmaxw
?nw
} para todo n ? N , eliminando pontos

desnecessários.

Como citado no Capítulo 5, na maximização de uma função côncava linear por partes não é

necessário forçar que as variáveis x sejam inteiras, i.e., as variáveis ? diferentes de zero são sempre
consecutivas [31]. Sendo assim, o problema pode ser simplificado eliminando as variáveis binárias x

e resolvido de forma eficiente com algoritmos de programação linear. Para o problema P5pl , a função

objetivo é separável mas não-côncava devido à região infactível entre qn,0i e q
n,1
i . Além disso, a WPC

linearizada por partes não é necessariamente côncava. Contudo, se a função objetivo de um poço n

é côncava no intervalo [qn,1i , q
n,?(n)
i ], o número de variáveis discretas cai de ?(n) para 1. Em outras

palavras, xn,1 seria a única variável necessária, assumindo valor 1 se o poço n estivesse inativo, e caso



6. Solução de P5( /0) Utilizando Programação Linear Inteira Mista 86

contrário assumindo valor 0. As condições para que esta simplificação possa ser realizada são dadas

em [10], [7].

Uma formulação mais compacta de P5pl pode ser obtida eliminando as variáveis redundantes e

igualdades implícitas como segue:

xn,1 = 1?
?(n)

?
k=2

xn,k (6.4a)

?n,0 = xn,1 (6.4b)

?n,1 = 1??n,0?
?(n)

?
k=2

?n,k =
?(n)

?
k=2

(xn,k ??n,k) (6.4c)

qni =
?(n)

?
k=2

(

qn,1i xn,k + (q
n,k
i ?q

n,1
i )?n,k

)

(6.4d)

qnp =
?(n)

?
k=2

(

qn,1p xn,k + (q
n,k
p ?q

n,1
p )?n,k

)

(6.4e)

qny = ?
n
y

?(n)

?
k=2

(

qn,1p xn,k + (q
n,k
p ?q

n,1
p )?n,k

)

, y = o, g, w (6.4f)



6. Solução de P5( /0) Utilizando Programação Linear Inteira Mista 87

Substituindo as expressões (6.4a)–(6.4f) por suas variáveis correspondentes em P5pl , a seguinte for-

mulação compacta é obtida:

P5cpl : Maximizar f =
N

?
n=1

?(n)

?
k=2

( fn,1xn,k + ( fn,k ? fn,1)?n,k) (6.5a)

Sujeito a :

Para y = i, p, o, g, w : (6.5b)

N

?
n=1

?(n)

?
k=2

(

qn,1y xn,k + (q
n,k
y ?q

n,1
y )?n,k

)

6 qmaxy

Para n = 1, . . . , N :

?(n)

?
k=2

xn,k 6 1 (6.5c)

?(n)

?
k=2

xn,k ?
?(n)

?
k=2

?n,k &gt; 0 (6.5d)

?(n)

?
k=3

xn,k ?
?(n)

?
k=2

?n,k 6 0 (6.5e)

Para k = 2, . . . , ?(n)?1 :

?n,k 6 xn,k + xn,k+1 (6.5f)

?n,?(n) 6 xn,?(n) (6.5g)

Para k = 2, . . . , ?(n) :

?n,k &gt; 0 (6.5h)

?n,k ? R (6.5i)

xn,k ?{0, 1} (6.5j)

onde fn,k = fn(q
n,k
i , q

n,k
p ), q

n,k
o = ?noq

n,k
p , q

n,k
g = ?ngq

n,k
p e q

n,k
w = ?nwq

n,k
p , implicando em q

n,k
o + q

n,k
g + q

n,k
w =

(?no + ?
n
g + ?

n
w)q

n,k
p = q

n,k
p . Note que a desigualdade (6.5c), a restrição (6.5j) e a igualdade (6.4a)

garantem que xn,1 ?{0, 1} e, portanto, ?n,0 ?{0, 1} como definido na equação (6.4b). Além disso, a
desigualdade (6.5d) garante que ?n,1 ? 0, enquanto a desigualdade (6.5e) e a restrição (6.5j) garantem
que ?n,1 ? 1.

Os problemas de otimização P5, P5pl e P
5
cpl pertencem à classe de problemas NP-Difíceis

2 [16].

Portanto, não há e as evidências da literatura até o momento indicam que não haverá algoritmo capaz

de resolver P5 em tempo polinomial. Tempo computacional não é considerado um problema para a

indústria de petróleo atual, devido à dinâmica lenta do mercado e aos longos períodos entre testes dos

poços. No entanto, a tecnologia de medidores de pressão de fundo e sensores multifásicos está se

tornando mais avançada, indicando que o controle automático dos poços é uma tendência promissora.

2Isto pode ser mostrado via redução de um problema da mochila para P5, como nos capítulos anteriores.



6. Solução de P5( /0) Utilizando Programação Linear Inteira Mista 88

Sendo assim, algoritmos rápidos se tornam imperativos caso a otimização em tempo real se torne

necessária.

6.2 Desigualdades Válidas para P5( /0)

Para facilitar a leitura, esta seção apresenta um número limitado de resultados teóricos e não apre-

senta todas as demonstrações, visto que muitas delas seguem os mesmos moldes daquelas contidas

no Capítulo 5.

Para simplificar os desenvolvimentos a seguir, introduzimos a seguinte notação:

• xn = {xn,k : k = 2, . . . , ?(n)};

• x = {xn : n = 1, . . . , N};

• ?n = {?n,k : k = 2, . . . , ?(n)};

• ? = {?n : n = 1, . . . , N}; e

• K = ?Nn=1 ?(n).

Utilizando esta notação, o espaço de soluções factíveis pode ser expresso pelo poliedro P 5cpl = conv

{(x, ?) ? BK?N ×RK?N : (x, ?) satisfaz as restrições (6.5b)–(6.5h)}, onde B = {0, 1}. Dado um
conjunto de vetores X , conv{X} denota o conjunto de vetores que podem ser obtidos por combi-

nação convexa de um subconjunto finito de X , ou seja, conv{X} = {x : x = ?mj=1 ? jx j, x j ? X e ? j ?
0 para j = 1, . . . , m, e ?mj=1 ? j = 1}. Pode-se mostrar que o polidero P

5
cpl que representa a formulação

P5cpl possui dimensão cheia (dim(P
5
cpl ) = 2(K ?N)), i.e., não existem dependências lineares entre as

variáveis.

Para ilustrar os conceitos apresentados nesta seção, utilizaremos uma instância de 3 poços mostrada

nas Tabelas 6.1 a 6.3. Consideramos também que os seguintes valores limite: qmaxi = 10, q
max
p = 10,

qmaxo = 7, q
max
g = 1, 2 e q

max
w = 1.

A semelhança de P5pl com o problema da mochila [22] permite estender as desigualdades de

cobertura descobertas em [4] e [3], e obter desigualdades válidas para P 5cpl , adicionando-as à formu-

lação e acelerando o processo de solução. Os resultados a seguir são válidos para y = i, p, o, g e w

onde qn,ko = ?noq
n,k
p , q

n,k
g = ?ngq

n,k
p e q

n,k
w = ?nwq

n,k
p . Além disso, sejam:

• ? = {(n, k) : n = 1, . . . , N, k = 2, . . . , ?(n)} é o conjunto de todos os pares (poço, ponto de
operação). Em nosso exemplo, ? = {(1, 1), . . . , (1, 5), (2, 1), . . . , (2, 5), (3, 1), . . . , (3, 5)};



6. Solução de P5( /0) Utilizando Programação Linear Inteira Mista 89

Tabela 6.1: Poço 1

y ?1y q
1,1
y q

1,2
y q

1,3
y q

1,4
y q

1,5
y

i 1 2 5 7 10
p 3 3,3 3,4 4 2
o 0,7 2,1 2,31 2,38 2,8 1,4
g 0,2 0,6 0,66 0,68 0,8 0,4
w 0,1 0,3 0,33 0,34 0,4 0,2

Tabela 6.2: Poço 2

y ?2y q
2,1
y q

2,2
y q

2,3
y q

2,4
y q

2,5
y

i 1 2,8 4 6 10
p 1 2 5 7 10
o 0,8 0,8 1,6 4 5,6 8
g 0,1 0,1 0,2 0,5 0,7 1
w 0,1 0,1 0,2 0,5 0,7 1

Tabela 6.3: Poço 3

y ?3y q
3,1
y q

3,2
y q

3,3
y q

3,4
y q

3,5
y

i 2 4 8 9 10
p 1 3 10 4 6
o 0,8 0,8 2,4 8 3,2 4,8
g 0,1 0,1 0,3 1 0,4 0,6
w 0,1 0,1 0,3 1 0,4 0,6



6. Solução de P5( /0) Utilizando Programação Linear Inteira Mista 90

• ?y(S) = ?(n,k)?S min(q
n,k?1
y , q

n,k
y ) para S ? ? e y ?{i, p, o, g, w} é a mínima quantidade de re-

curso y necessária para ativar todos os pares (poço, ponto de operação) em S. Considerando

S = {(1, 5), (2, 4)} e y = i, temos ?i(S) = min(q
1,4
i , q

1,5
i ) + min(q

2,3
i , q

2,4
i ) = 7 + 4 = 11; e

• S(n, k) = S?{(n, k)} para qualquer S ? ?. Para S = {(1, 5), (2, 4)}, S(1, 5) = {(2, 4)}.

Definição 6.1 Um subconjunto Cy ? ? é uma cobertura-y se ?y(Cy) &gt; qmaxy e m 6= n para todo
(m, i), (n, j) ?Cy.

Em palavras, os pares (n, k) de uma cobertura-y pertencem a poços distintos e não podem ser

ativados simultaneamente pois excederiam a capacidade de recursos disponível. Uma cobertura-i

para nosso exemplo seria Ci = {(1, 5), (2, 4)}, pois ?i(Ci) = 11 &gt; 10 = qmaxi .

Definição 6.2 Uma cobertura-y Cy é mínima se, para todo (n, k)?Cy, ?y(Cy(n, k))?qmaxy e ?y(Cy(n, k)?
{(n, j)}) ? qmaxy para cada j 6= k tal que min(q

n, j?1
y , q

n, j
y ) &amp;lt;min(q

n,k?1
y , q

n,k
y ).

Continuando com o exemplo, Ci = {(1, 5), (2, 4)} é mínima pois:

• para (n, k) = (1, 5): ?i(Ci(1, 5)) = min(q
2,3
i , q

2,4
I ) = 4 ? 10 = q

max
i e ?i(Ci(1, 5)?{(1, j)}) ?

10 = qmaxi para j ?{2, 3, 4};

• para (n, k) = (2, 4): ?i(Ci(2, 4)) = min(q
1,4
i , q

1,5
I ) = 7 ? 10 = q

max
i e ?i(Ci(2, 4)?{(2, j)}) ?

10 = qmaxi para j ?{2, 3};

Seja qy(S)max = max{min(q
n,k?1
y , q

n,k
y ) : (n, k) ? S} a maior quantidade do recurso mínimo y re-

querido por um elemento de S ? ?.

Definição 6.3 Dada uma cobertura-y Cy, sua cobertura estendida é E(Cy) = EC(Cy)?EC?(Cy) onde

EC(Cy) = {(n, j) ? ? : (n, k) ? Cy, min(q
n, j
y , q

n, j?1
y ) ? min(q

n,k
y , q

n,k?1
y )} e EC?(Cy) = {(n, k) ? ? :

min(qn,k?1y , q
n,k
y ) ? qy(Cy)max}.

Utilizando os dados do exemplo, a cobertura estendida E(Ci) fica dividida em EC(Ci) = {(1, 5),

(2, 4), (2, 5)} e EC?(Cy) = {(3, 4), (3, 5)}. Note que Cy ? EC(Cy).

Proposição 6.1 Dada uma cobertura-y Cy, a desigualdade:

?
(n,k)?E(Cy)

xn,k ?|Cy|?1 (6.6)

é válida para P 5cpl .



6. Solução de P5( /0) Utilizando Programação Linear Inteira Mista 91

A desigualdade de cobertura baseada na cobertura estendida E(Ci) de nosso exemplo é:

x1,5 + x2,4 + x2,5 + x3,4 + x3,5 ? 1. (6.7)

Da mesma maneira que as coberturas-y para as variáveis x, coberturas-y e desigualdades válidas

podem ser obtidas para as variáveis ?.

Definição 6.4 Dada uma cobertura-y Cy, a cobertura-y estendida para as variáveis ? é definida por:

E?(Cy) = {(n, k) ? E(Cy) : k &amp;lt;?(n), (n, k + 1) ? E(Cy)}?

{(n, 1) : (n, 2) ? E(Cy)}?

{(n, ?(n)) ? E(Cy)}

Proposição 6.2 Dada uma cobertura-y Cy, a desigualdade:

?
(n,k)?E? (Cy)

?n,k 6 |Cy|?1 (6.8)

é válida para P 5cpl sendo que ?n,1 é substituída pela Equação (6.4c).

Desigualdades válidas podem ser fortalecidas se sujeitas ao procedimento de lifting [31], [42],

i.e., desigualdades podem ser estendidas para dimensões maiores incorporando as variáveis restantes.

Considere uma cobertura-y Cy e sua desigualdade válida ?(n,k)?Cy xn,k 6 |Cy|?1. Note que as variáveis
xn,k com (n, k) ? ??Cy não aparecem na desigualdade ou, em outras palavras, seus coeficientes são
zero. O processo de lifting da desigualdade consiste em calcular o máximo ?n,k(Cy) ? 0 para cada
variável xn,k , (n, k) ? ??Cy, tal que a desigualdade ?(n,k)?Cy xn,k + ?(n,k)???Cy ?n,k(Cy)xn,k 6 |Cy|?1
permanece válida para P 5cpl . A desigualdade de cobertura-y estendida (6.6) é uma maneira aproximada

para fortalecer desigualdades válidas3 . Os fatores de lifting ?n,k(Cy) dependem da cobertura Cy e da
ordem dos elementos de ??Cy.

O cálculo de fatores de lifting exatos ?n,k(Cy) é um problema difícil com complexidade com-
parável à solução do próprio P5cpl . Sendo assim, ao invés de calcular fatores exatos, propomos um pro-

cedimento heurístico para encontrar limites inferiores ?n,k(Cy) para os fatores exatos, 0 ? ?n,k(Cy) ?
?n,k(Cy). Um método prático para acelerar a busca por uma solução ótima para P5cpl pode ser obtido
utilizando os limites inferiores ?n,k(Cy) para fortalecer as desigualdades válidas de cobertura.

Definição 6.5 Seja Cy uma cobertura-y.

3O fator multiplicativo 1 é usado no lugar de ?n,k(Cy) para todo xn,k , (n, k)? E(Cy)?Cy , enquanto as variáveis restantes
são multiplicadas por zero.



6. Solução de P5( /0) Utilizando Programação Linear Inteira Mista 92

• Para h ?{0, . . . ,|Cy|}, Cy,h é um subconjunto de Cy tal que |Cy,h| = h e max{min(q
n,k?1
y , q

n,k
y ) :

(n, k) ?Cy?Cy,h}? min{min(q
n,k?1
y , q

n,k
y ) : (n, k) ?Cy,h} se 0 &amp;lt;h &amp;lt;|Cy|, i.e., Cy,h é o subcon-

junto com os h elementos mais “pesados” de Cy.

• Para (n, k)?Cy e h?{0, . . . ,|Cy|?1}, Cy,h(n, k) é um subconjunto de Cy(n, k) tal que |Cy,h(n, k)|=

h e max{min(q
m, j?1
y , q

m, j
y ) : (m, j) ? Cy(n, k)?Cy,h(n, k)} ? min{min(q

m, j?1
y , q

m, j
y ) : (m, j) ?

Cy,h(n, k)} se 0 &amp;lt;h &amp;lt;|Cy|?1, i.e., Cy,h(n, k) é o subconjunto dos h elementos mais “pesados”

de Cy(n, k).

Em nosso exemplo:

• Ci,0 = /0; Ci,1 = {(1, 5)}; Ci,2 = {(1, 5), (2, 4)};

• Ci,0(1, 5) = Ci,0(2, 4) = /0; Ci,1(1, 5) = {(2, 4)}; Ci,1(2, 4) = {(1, 5)}.

Definição 6.6 Dada uma cobertura Cy, o limite inferior ?n,k(Cy) para o fator de lifting de cada
(n, k) ? E(Cy)?Cy é obtido como segue:

• se n ? N ?N (Cy), então ?n,k(Cy) = max{h : min(q
n,k?1
y , q

n,k
y ) ? ?y(Cy,h)};

• se (n, i)?Cy, então ?n,k(Cy) = 1+ max{h : min(q
n,k?1
y , q

n,k
y )?min(q

n,i?1
y , q

n,i
y )??y(Cy,h(n, i))},

onde N (Cy) = {n : (n, k) ?Cy}.

Proposição 6.3 A desigualdade de cobertura-y estendida e fortalecida:

?
(n,k)?Cy

xn,k + ?
(n,k)?E(Cy)?Cy

?n,k(Cy)xn,k ?|Cy|?1 (6.9)

é válida para P 5cpl .

Prova: Sejam:

• C1y = {(n, k) ?Cy : xn,k = 1}, C
0
y = Cy ?C

1
y ,

• E 1,hC (Cy) = {(n, k) ? E(Cy)?Cy : n ? N (Cy), xn,k = 1, ?n,k(Cy) = h},

• EC?(Cy)
1,h(Cy) = {(n, k) ? E(Cy)?Cy : n /? N (Cy), xn,k = 1, ?n,k(Cy) = h},

• E 1C(Cy) =
|Cy|?1

S

h=1
E

1,h
C (Cy),

• E 1
C?
(Cy) =

|Cy|?1
S

h=1
E 1,h

C?
(Cy),



6. Solução de P5( /0) Utilizando Programação Linear Inteira Mista 93

• ?(n) = (n, k) ?Cy tal que (n, j) ? EC(Cy),

• ?1 = {(n, k) ?C0y : (n, j) ? E
1
C(Cy)},

• ??1 ?{(n, k) ? C0y ??1} é o subconjunto de máxima cardinalidade tal que |??1|? ?
(n,k)?E 1C (Cy)

(?n,k(Cy)?1),

• ?2 ? {(n, k) ? C0y ? (?1 ? ??1)} é o subconjunto de máxima cardinalidade tal que |?2| ?
?

(n,k)?E 1
C?
(Cy)

(?n,k(Cy))}.

Suponha que exista (x, ?) em P 5cpl que viola (6.9). Então,

N

?
n=1

?(n)

?
k=2

[qn,1y xn,k ?(q
n,k
y ?q

n,1
y )?n,k] ?

?
(n,k)??

min{qn,k?1y , q
n,k
y }xn,k ?

?y(C1y ) + ?y(E
1
C(Cy)) + ?y(E

1
C?(Cy)) ?

?y(C1y ) +
|Cy|?1

?
h=1

?
(n,k)?E

1,h
C (Cy)

?y(Cy,h(?(n))) + ?
(n,k)?E

1,h
C?

(Cy)

?y(Cy,h) ?

?y(C1y ) + ?y(?1) + ?y(??1) + ?y(??2) = ?(Cy) &gt; q
max
y

o que contradiz (6.5b) e, portanto, refuta a hipótese de que (x, ?) é factível. ?

Calcularemos agora os fatores ?n,k(Ci) do exemplo, com E(Ci)?Ci = {(2, 5), (3, 4), (3, 5)} e
Ci = {(1, 5), (2, 4)}:

• ?2,5(Ci) = 1 + max{h : min(q
2,4
i , q

2,5
y )?min(q

2,3
i , q

2,4
y ) ? ?i(Ci,h(2, 4))} = 1 + max{h : 6?4 ?

7} = 1 + 0 = 1 ;

• ?3,4(Ci) = max{h : min(q
3,3
i , q

3,4
i ) ? ?i(Ci,h)} = max{h : 8 ? ?i(Ci,h)} = 1 ;

• ?3,5(Ci) = max{h : min(q
3,4
i , q

3,5
i ) ? ?i(Ci,h)} = max{h : 9 ? ?i(Ci,h)} = 1 .

Sendo assim, a desigualdade de cobertura estendida e fortalecida para a cobertura Ci de nosso exemplo

fica exatamente igual à equação (6.7).

Os desenvolvimentos aqui podem ser substancialmente simplificados quando os elementos de

Qny = {q
n,0
y , . . . , q

n,?(n)
y } são estritamente crescentes, ou seja, se q

n,k
y &amp;lt;q

n,k+1
y para k = 0, . . . , ?(n)?

1. Claramente, esta propriedade é satisfeita pelos elementos de Qni para todo n ? N . Caso esta

propriedade seja satisfeita para todos os Qny , as desigualdades de cobertura-y obtidas são semelhantes

àquelas desenvolvidas para P( /0) no Capítulo 5.



6. Solução de P5( /0) Utilizando Programação Linear Inteira Mista 94

Da mesma maneira que para as variáveis x, limites inferiores para os fatores de lifting podem ser

obtidos para as variáveis ?. Seja ?1 = ??{(n, 1) : n ? N } e P(n, k) = {(n, k?1), (n, k), (n, k + 1)}?
?1.

Definição 6.7 Dada uma cobertura Cy, os limites inferiores ?n,k(Cy) para os fatores de lifting das
variáveis ? para cada (n, k) ? E?(Cy)?Cy são obtidos como segue:

• se n ? N ?N (Cy), então ?n,k(Cy) = max{h : min{q
n, j
y : (n, j) ? P(n, k)}? ?y(Cy,h)};

• se (n, i) ? Cy, então ?n,k(Cy) = 1 + max{h : min{q
n, j
y : (n, j) ? P(n, k)}?min(q

n,i?1
y , q

n,i
y ) ?

?y(Cy,h(n, i))}.

Com os limites inferiores dos fatores de lifting das variáveis ? calculados para os elementos de
E?(Cy)?Cy, uma desigualdade válida mais forte pode ser obtida.

Proposição 6.4 A desigualdade de cobertura-?-y estendida e fortalecida de Cy:

?
(n,k)?E?(Cy)?Cy

?n,k + ?
(n,k)?E?(Cy)?Cy

?n,k(Cy)?n,k 6 |Cy|?1 (6.10)

é válida para P 5cpl onde ?n,1 é substituído pela Equação (6.4c).

6.3 Resultados Numéricos

Nesta seção são apresentados experimentos numéricos realizados com o intuito de demonstrar a

eficiência dos planos de corte inseridos na formulação original.

Para instâncias do problema com 32 e 64 poços, introduzimos as desigualdades (6.1d)–(6.1g) com

restrições na capacidade de separação e nos limites de armazenamento/processamento de óleo, gás

e água. Os valores possíveis para qmaxi e q
max
p são baixo, médio, e abundante, mas os valores para

qmaxo , q
max
g , e q

max
w são baixo e médio para que o número de experimentos seja relativamente baixo.

Assim, o número total de experimentos para cada instância do problema foi 32 ×23 ×3 = 216, pois

realizamos um experimento sem cortes, um com cortes nas variáveis x, e outro incluindo os planos de

cortes nas variáveis ? para cada situação. Os resultados destes experimentos são mostrados na Tabela
6.4 para o cenário com 32 poços e na Tabela 6.5 para o caso com 64 poços. As entradas das tabelas

são as médias dos valores para qmaxo , q
max
g e q

max
w . Os planos de corte foram calculados utilizando a

heurística mostrada na Seção 5.5 e aplicada para cada restrição do tipo mochila (6.1c)–(6.1g). Os

resultados foram gerados utilizando o GNU solver [21] e um computador Pentium IV de 2.5GHz e

1GB de memória.



6. Solução de P5( /0) Utilizando Programação Linear Inteira Mista 95

Tabela 6.4: Impacto das coberturas-y na velocidade de solução para instâncias com 32 poços.

Sem cortes Com cortes-y em x Com cortes-y em ?
qmaxi q

max
p Iterações Nós Iterações Nós Iterações Nós

15.000 428.087 62.935 3.986 939 59 3
700 20.000 428.087 62.935 3.986 939 59 3

25.000 428.087 62.935 3.986 939 59 3
15.000 18.275 4.459 2.256 531 174 35

1.100 20.000 281.357 61.587 10.385 2.819 81 1
25.000 281.357 61.587 10.385 2.819 81 1
15.000 245 63 245 63 245 63

3.000 20.000 3.958 1.041 932 189 108 3
25.000 28.200 10.354 3.583 1.267 112 1

Média 210.850 36.432 4.416 1.167 109 13

Tabela 6.5: Impacto das coberturas-y na velocidade de solução para instâncias com 64 poços.

Sem cortes Com cortes-y em x Com cortes-y em ?
qmaxi q

max
p Iterações Nós Iterações Nós Iterações Nós

40.000 ?32.648.455 4.286.938 313.077 48.131 87 3
1.100 50.000 ?32.648.455 4.286.938 313.077 48.131 87 3

70.000 ?32.648.455 4.286.938 313.077 48.131 87 3
40.000 ?25.968.268 3.598.636 690.753 161.517 169 1

2.300 50.000 ?23.741.320 3.372.521 690.753 161.517 169 1
70.000 ?23.741.320 3.372.521 690.753 161.517 169 1
40.000 279 99 279 99 279 99

3.500 50.000 3.477 1.061 2.896 738 3.026 744
70.000 169.911 79.362 24.143 6.833 9.107 1.949

Média 19.063.326 2.587.223 337.645 70.734 1.464 311

Das Tabelas 6.4 e 6.5, é evidente que os planos de corte propostos reduzem drasticamente o

número de iterações (pivoteamentos de programação linear) e uso de memória dos algoritmos branch-

and-bound. As instâncias marcadas com “?” não foram resolvidas até o fim devido à demanda exorbi-

tante de recursos computacionais (o prodecimento de branch-and-bound foi abortado após aproxima-

damente uma semana de tempo de execução). Estas instâncias são resolvidas facilmente após inserir

na formulação as desigualdades de cobertura-y, especialmente se as coberturas-y estão nas variáveis

?.



6. Solução de P5( /0) Utilizando Programação Linear Inteira Mista 96

6.4 Sumário

Neste capítulo, foi proposta uma formulação linear por partes para o problema de alocação de

gás de injeção sob múltiplas restrições nas instalações de superfície, foi realizada uma análise do

modelo e demonstrada sua aplicação prática. Os experimentos numéricos utilizando o GNU solver

[21] mostraram que as desigualdades de cobertura-y podem tornar factíveis a otimização de instân-

cias médias e grandes utilizando software livre, o que de outra maneira seria excessivamente lento e

consumiria recursos computacionais elevados. Os resultados desta seção foram publicados em [10].



Capítulo 7

Conclusões

Quase todos os setores da economia mundial dependem da indústria do petróleo, e com a de-

manda sempre crescente deste combustível fóssil, existe uma busca também crescente de melhor

eficiência dos processos de produção, processamento e transporte de hidrocarbonetos. Técnicas de

elevação artificial que aumentam o fator de recuperação de um reservatório de petróleo são ampla-

mente utilizadas, e uma das técnicas mais utilizadas é a elevação artificial por injeção contínua de

gás, ou gas-lift. Sendo assim, a otimização da alocação de gás de elevação para poços de petróleo

desempenha um papel importante na eficiência de recuperação de um reservatório.

Os artigos encontrados na literatura confirmam esta tendência. Enquanto os estudos mais antigos

estavam mais focados na determinação das curvas de desempenho dos poços, as investigações mais

recentes abordam a operação ótima das instalações ao longo do tempo, lidando com mudanças nas

condições de operação e as oscilações do mercado. Este trabalho contribui para o estado da arte dos

sistemas de produção da indústria do petróleo, através da abordagem formal do problema da alocação

ótima de gás de elevação, i.e., dado um grupo de poços de petróleo e um conjunto de restrições, decidir

quais poços devem estar ativos e qual a taxa ótima de injeção de gás para cada poço de modo a obter

um desempenho global ótimo. Foi mostrado que o problema de otimização não-linear inteira mista

resultante (P( /0)) é uma generalização do problema da mochila (portanto um problema NP-Difícil), e
que captura todas as características dos problemas considerados em [15], [18] e [32].

Este documento foi organizado de modo a mostrar a evolução da complexidade dos problemas

abordados. Primeiramente, tratamos de resolver o problema mais simples contido na literatura,

onde há apenas a restrição da taxa disponível de injeção de gás. Foi obtido um algoritmo pseudo-

polinomial baseado na técnica de Programação Dinâmica que resolve uma versão discretizada de P,

onde unidades padrão de taxa de injeção de gás são alocadas entre os poços. Então, o problema foi

incrementado de modo a capturar restrições de ativação e desativação de poços, que podem surgir

por motivos técnicos ou estratégicos. Para esta versão mais complexa foi mostrado que não é pos-

sível desenvolver um algoritmo pseudo-polinomial, ou seja, o problema é NP-Difícil no sentido forte.



7. Conclusões 98

Apesar da natureza aproximada da solução recursiva, os resultados numéricos obtidos indicam que

estes algoritmos são capazes de obter soluções quase-ótimas. Porém, a inclusão de novas restrições

não é trivial.

Passamos então a utilizar outra abordagem, a linearização por partes das curvas de desempenho

de gas-lift. Esta abordagem elimina as não-linearidades do problema, dando origem a um problema

de otimização linear inteira mista, tornando mais flexível a introdução ou modificação de restrições,

além de possibilitar o uso de algoritmos eficientes de Programação Inteira para a obtenção de soluções

ótimas ou quase-ótimas. Esta estratégia foi sugerida pela primeira vez em [15], contudo, os autores

não tiraram proveito da estrutura do problema para criar algoritmos específicos para o problema

em questão, não considerando W PCs não-côncavas e tratando a ativação/desativação de poços de

maneira ad hoc. Nosso trabalho abordou estas questões de maneira mais formal. Foi mostrado que o

poliedro que descreve o espaço das soluções factíveis possui dimensão cheia quando são eliminadas as

igualdades contidas na formulação, e que para o caso de curvas de desempenho côncavas, apenas uma

variável inteira é necessária. Foram obtidas famílias de desigualdades válidas que são extensões das

desigualdades de cobertura para o problema da mochila, e que ao serem introduzidas na formulação

tornam mais rápida a busca de soluções ótimas por algoritmos de branch-and-bound e branch-and-

cut. Resolvemos novamente o problema básico com a restrição da taxa disponível de injeção de gás,

e também um problema mais completo, onde há múltiplas restrições que surgem devido a limitações

diversas.

Ambas as abordagens foram testadas contra experimentos publicados na literatura, mostrando-

se bastante eficientes. Os resultados deste trabalho representam excelentes ferramentas de suporte

à decisão de baixo custo, pois podem ser implementadas em plataformas de software livre, além de

poderem ser integradas a programas de simulação e controle.

7.1 Pesquisa Futura

A seguir, apontamos algumas lacunas deste trabalho que podem ser objeto de estudo em pesquisas

futuras.

1. Formulação de P5( /0) utilizando o modelo de Sherali: as desigualdades válidas obtidas para P5( /0)
foram obtidas baseadas na formulação mais intuitiva, chamada de Modelo I (Seção 2.3.1).

Porém, Padberg [33] mostra que este modelo não é o mais adequado. Os desenvolvimentos do

Capítulo 6 podem ser reformulados de modo a seguir o modelo de Sherali [37].

2. Frações de óleo, gás e água variáveis: uma simplificação da modelagem apresentada é a consi-

deração de frações constantes de óleo, gás e água produzidos por um determinado poço n, ?no,
?ng e ?

n
w respectivamente. Em situações reais, estas frações podem variar de acordo com a taxa



7. Conclusões 99

de injeção de gás qni , pois a variação de q
n
i corresponde a uma variação na pressão no fundo do

poço, o que por sua vez corresponde a uma variação nas frações de óleo e gás quando o petróleo

é saturado. Diminuir a pressão no fundo do poço (ou seja, aumentar a taxa de injeção de gás)

além de certos limites também pode elevar o contato óleo-água até a região dos canhonea-

dos, aumentando a produção de água devido ao efeito de conificação. A introdução de frações

variáveis em função de qni pode dar origem a um problema de maximização não-convexo. O

estudo de como as frações de óleo, gás e água produzidas por um poço variam em função da

taxa de injeção de gás neste poço, bem como os seus efeitos na formulação do problema e nos

algoritmos desenvolvidos para o cálculo de soluções ótimas será objeto de estudo.

3. Integração controle/otimização: outra direção que deve ser seguida é a integração das técnicas

de controle desenvolvidas em nosso grupo de trabalho [34] com as técnicas de otimização

apresentadas no presente trabalho. Este trabalho de integração faz parte de uma proposta de

dissertação de doutorado de um dos integrantes de nosso grupo de pesquisas, e deverá ser

realizado em conjunto. O produto final do trabalho de mestrado citado deverá ser um ambiente

gráfico de controle/otimização para o problema de elevação artificial via injeção contínua de

gás.

4. Estudo de W PCs acopladas: uma direção de pesquisa interessante é desenvolver formulações e

algoritmos para o caso onde a taxa de produção de um poço k dependa das taxas de injeção

de seus i poços vizinhos, ou seja, qkp = q
k
p(q

1
i , q

2
i , . . . , q

N
i ). Este modelo pode representar, por

exemplo, cenários onde existam poços injetores de água.



Apêndice A

Ajuste de Curvas

Dado um conjunto de pontos de desempenho de gas-lift Qn = {(qn,1i , q
n,1
p ), (q

n,2
i , q

n,2
p ), . . . , (q

n,k
i ,

qn,kp )}, com q
n, j
i &amp;lt;q

n, j+1
i para j = 1, . . . , k?1, aplicamos um método de ajuste de curvas e obtemos

expressões analíticas q?np(q
n
i ) que representam de forma aproximada a função q

n
p(q

n
i ). Neste trabalho,

foram utilizados três modelos de curvas:

1) Uma função polinomial da forma q?np(q
n
i ) = ?

n
0yn + ?

n
1q

n
i + ?

n
2(q

n
i )

2 + ?n3(q
n
i )

3, definida pelas

constantes ?n0, ?
n
1, ?

n
2 e ?

n
3. A vantagem deste modelo é que o problema de ajuste de curvas

gerado é um problema de fácil solução. Sua desvantagem é a má qualidade de extrapolação

para pontos fora do intervalo [qn,1i , q
n,k
i ];

2) Uma função exponencial da forma q?np(q
n
i ) = An(2?e

?Bnq
n
i )?Cne

Dn q
n
i + Fn(1?yn), definida

pelas constantes An, Bn, Cn, Dn e Fn = Cn ?An. Esta função exponencial é uma boa aproxi-

mação para o comportamento típico de uma W PC, fornece bons dados de extrapolação, e sua

concavidade é garantida satisfazendo condições simples. Garantindo que as constantes An e Cn
sejam positivas, garantimos também que a função q?np(q

n
i ) é uma função côncava, pois sob estas

condições sua derivada segunda assume valores negativos para qualquer valor de qni ;

3) Uma função logarítmica da forma qnp(q
n
i ) = c

n
1yn + c

n
2q

n
i + c

n
3(q

n
i )

2 + cn4 ln(q
n
i + 1), definida pelas

constantes cn1, c
n
2, c

n
3 e c

n
4. Este modelo foi utilizado para comparar os resultados obtidos com o

algoritmo PD e os obtidos com o método de SQP proposto em [1].

Para o primeiro caso (aproximação polinomial), o problema a ser resolvido é linear e portanto

bastante simples, gerando o ótimo global:

Min f =
k
?
j=1

[

?n0yn + ?
n
1q

n, j
i + ?

n
2(q

n, j
i )

2 + ?n3(q
n, j
i )

3 ?q
n, j
p

]2

S. a:

2?n2 + 6?
n
3q

n, j
i ? 0 , j = 1, . . . , k

(A.1)



A. Ajuste de Curvas 101

Encontrar os coeficientes An, Bn, Cn e Dn para o segundo método (aproximação exponencial)

significa resolver o seguinte problema de mímimos quadrados para cada poço n:

Min f =
k
?
j=1

[

An(2?e
?Bnq

n, j
i )?Cne

Dnq
n, j
i ?q

n, j
p + Fn(1?yn)

]2

S. a:

An ? 0

Cn ? 0

(A.2)

Fornecemos soluções iniciais factíveis e utilizamos algoritmos de otimização não linear [27] para

encontrar um ótimo local. As curvas encontradas passam por um processo de seleção gráfico e, para

cada conjunto Qn obtemos os coeficientes An, Bn, Cn e Dn. As curvas obtidas são côncavas para todo

o intervalo qni ? [0, un].

O terceiro método de ajuste de curvas (aproximação logarítmica) consiste em resolver o seguinte

problema para cada poço n:

Min f =
k
?
j=1

[

cn1yn + c
n
2q

n, j
i + c

n
3(q

n, j
i )

2 + cn4 ln(q
n, j
i + 1)?q

n, j
p

]2

S. a:

2cn3 ?
cn4

(1+q
n, j
i )

2
? 0 para j = 1, . . . , k

(A.3)

A resposta desse problema são as constantes cn1, c
n
2, c

n
3 e c

n
4. As curvas obtidas são côncavas na região

1

qi = [ln, un].

1Não é necessário garantir concavidade no intervalo qni ? [0, ln] pois não foi calculada a relaxação linear para este caso.



Apêndice B

Desigualdades Válidas para P(G)

Seja P (G) o poliedro correspondente ao fecho convexo das soluções factíveis para P(G) no qual

qnp é substituído pela sua função de q
n
i , i.e., X (G) = {(qi, y) ? R

N ×BN : sujeito às restrições de (4.1)}

e P (G) = conv(X (G)). Para os desenvolvimentos a seguir, a terminologia de grafos introduzida no

Capítulo 4 necessita ser estendida. Seja ?n = ?k?S(n) lk a mínima taxa de injeção necessária para
ativar o poço n e seus descendentes em G. Seja W (C) = ?n?CS(n) o conjunto de todos os poços que

precisam ser ativados para que os poços em C ? N = {1, . . . , N} sejam ativados.

Proposição B.1 Se G é um grafo acíclico, ln &amp;lt;un &amp;lt;qmaxi para todo n, e ?n &amp;lt;q
max
i para todo n ?

root(G), então P (G) = X (G) possui dimensão cheia, isto é, dim(P (G)) = 2N.

Prova: Seja L =?v1, . . . , vN? uma ordem topológica para G. A seguir mostramos que vetores unitários

para qni e yn podem ser obtidos sistematicamente, a partir de elementos de X (G), na ordem reversa de

L. Mais formalmente, o procedimento encontra vetores unitários para as variáveis associadas ao poço

vN , e então encontra um vetor unitário para o poço vN?1, e assim por diante até chegar ao poço v1. Os

passos do procedimento são descritos abaixo.

• Passo 1. Seja U = /0 o conjunto dos índices dos poços para os quais vetores unitários de suas
variáveis tenham sido obtidos. Faça k = N.

• Passo 2. Faça n = vk e seja z? = (q?i, y?)?X (G) a solução obtida fazendo y? j = 1 e q?
j
i = l j para cada

j ? S(n), além de y? j = 0 e q?
j
i = 0 para cada j 6? S(n). Seja z? = (q?i, y?) ? X (G) a solução obtida

fazendo y? j = 1 e q?
j
i = l j para cada j ? S

+(n), além de y?n = 1 e q?
n
i = min{un, q

max
i ?(?n ?ln)},

e y? j = 0 e q?
j
i = 0 para cada j 6? S(n). Note que as soluções z? e z? são idênticas em todas as

suas entradas, com exceção do poço n, mais precisamente q?ni &amp;lt;q?
n
i pois ?n &amp;lt;q

max
i . Por hipótese

de indução, podemos assumir que os vetores unitários foram obtidos para todas as entradas

diferentes de zero de z? a menos daquelas correspondentes ao poço n, pois estes poços são

precedidos pelo poço n na ordem topológica. Por combinação linear destes vetores unitários e



B. Desigualdades Válidas para P(G) 103

das soluções z? e z?, podemos obter vetores unitários para as variáveis qni e yn. Portanto, U pode

ser estendido para englobar o poço n, U ? U ?{n}. Se k = 1 então pare, senão decremente k

por 1 e repita a partir do Passo 2.

Neste ponto, U = {1, . . . , N}, o que significa que vetores unitários foram obtidos a partir de combi-

nação linear dos elementos de X (G) para todas as variáveis. Como a origem pertence a X (G), con-

cluímos que P (G) contém 2N + 1 elementos afim independentes, implicando em dim(P (G)) = 2N.

?

A partir deste ponto, assumimos que as condições da Definição B.1 são satisfeitas.

Definição B.1 Um conjunto C ?{1, ..., N} é uma cobertura para X (G) se:

• S(n)?C = {n} para cada n ?C;

• ?
n?C

?n &gt; qmaxi ;

• ?
n?C

?n ? lk &amp;lt;qmaxi para cada k ?C; e

Definição B.2 Seja PC(G) = {(qi, y) ? P (G) : yn = qni = 0} para todo n ? N ?W (C) o poliedro

obtido pela projeção de P (G) sobre o espaço das variáveis yn e q
n
i cujos índices pertencem ao con-

junto W (C), onde C é uma cobertura.

Corolário B.1 Se C é uma cobertura, então dim(PC(G)) = 2|W (C)|.

Proposição B.2 Se C é uma cobertura, então a desigualdade de cobertura

?
n?C

yn ?|C|?1 (B.1)

é válida para PC(G) e, além disso, a face FC = {(qi, y) ? PC(G) : ?
n?C

yn = |C|?1} induzida pela

desigualdade de cobertura possui dimensão dim(FC) = 2|W (C)|?1.

Prova:. (Validade) Se ?
n?C

yn = |C| para alguma solução (qi, y) ? X (G)?PC(G), então ?
n?W (C)

qni ?

?
n?C

?n &gt; qmaxi , mas isso significa que a solução é infcatível, contradizendo a hipótese.

(Dimensionalidade) Seja:

?
n?W (C)

(?nyn + µnqni ) ? ?o (B.2)

uma desigualdade válida geral para PC(G) induzindo a face máxima F? ={(qi, y)?PC(G) : ?
n?W (C)

(?nyn +

µnq
n
i ) = ?o tal que FC ? F?. A seguir provamos que FC é máxima mostrando que a desigualdade (B.1)



B. Desigualdades Válidas para P(G) 104

(que induz FC) difere da desigualdade (B.2) (que induz F?) por uma constante multiplicativa positiva.

A demonstração consiste em mostrar que ?n = 1 para todo n ? C, ?n = 0 para todo n ? W (C)?C,
µn = 0 para todo n ?W (C) e ?0 = |C|?1.

Primeiro, mostramos que µn = 0 para todo n ?C. Seja z? = (q?i, y?) obtido fazendo y?t = 1 e q?
t
i = lt

para todo t ?W (C?{k}), onde k ?C?{n}, e y?t = 0 e q?
t
i = 0 para todo t ? S(k). Claramente, z? ? FC

e ?
t?W (C)

q?ti = ?
t?C?{k}

?t &amp;lt;qmaxi . Similarmente, seja z? idêntico a z? a menos de q?
n
i = min{un, q

max
i ?

?
t?W (C)?{n}

q?ti}. Para z? e z? pertencerem a F?, (B.2) deve ser satisfeita na igualdade. Subtraindo (B.2)

calculada em z? de (B.2) calculada em z?, e levando em conta o fato que q?ni &gt; q?
n
i , pode-se concluir que

µn = 0. Repetindo os passos acima para os elementos restantes da cobertura, verifica-se que µn = 0

para todo n ?C.

Segundo, mostramos que µn = 0 para n ? W (C)?C, onde n ? S
+(l) para algum l ? C. Seja

z? = (q?i, y?) obtido fazendo y?t = 1 e q?
t
i = lt para todo t ? W (C ?{k}), onde k ? C ?{l}, e y?t = 0 e

q?ti = 0 para todo t ? S(k). Segue que z? pertence a FC e ?
t?W (C)

q?ti = ?
t?C?{k}

?t &amp;lt;qmaxi . Seja z? ? FC

idêntico a z?, exceto por q?ni que assume valor min{un, q
max
i ? ?

t?W (C)?{n}
q?ti}. Note que (B.2) deve ser

satisfeita na igualdade para z? e z? pois z?, z? ? F?. Subtraindo (B.2) calculada em z? de (B.2) calculada

em z?, e usando o fato de que q?ni &gt; q?
n
i , pode-se deduzir que µn = 0. Repetindo os passos acima para os

poços restantes, pode-se concluir que µn = 0 para todo n ?W (C)?C. Neste ponto, descobrimos que

a desigualdade que induz F? é da forma ?
n?W (C)

?nyn ? ?0.

Terceiro, mostramos que ?n = 0 para todo n ?W (C)?C. Isto, é mostrado por indução e explo-
rando a estrutura imposta pelas restrições de precedência. Seja L = ?v1, . . . , v|W (C)?C|? a permutação

dos elementos de W (C)?C tal que v j precede vk em uma ordem topológica de G se e somente se

j &gt; k. Em outras palavras, os elementos de W (C)?C são arranjados em L na ordem reversa da ordem

topológica. Pode ser mostrado por indução em l ?{1, . . . ,|W (C)?C|} que ?v1 = 0 (base de indução),
?v2 = 0 (passo de indução), e assim por diante até que a afirmação seja demonstrada. Omitimos a
base de indução e mostramos apenas o passo de indução. Para algum l ? 2, seja n = vl onde n ? S(k)

para algum k ? C. Seja z? = (q?i, y?) obtido fazendo y?t = 1 e q?
t
i = lt para todo t ? W (C ?{k})?S(n),

enquanto y?t = 0 e q?
t
i = 0 para todo t ? S(k)?S(n). Como y?k = 0 e y?t = 1 para todo t ? S(n) segue

que z? ? FC. Além disso, ?
t?W (C)

?t y?t = ?
t?W (C)?S(k)

?t y?t + ?
t?S(n)

?t y?t = ?0 para que z? pertença a F?. Por

indução, segue que ?t = 0 para todo t ? S(n)?{n}. Assim:

?
t?W (C)?S(k)

?t y?t + ?ny?n = ?0 (B.3)

Agora, seja z? ?FC igual a z?, com exceção de y?t = q?
t
i = 0 para todo t ? S(n). A equação (B.3) calculada

em z? deve ser satisfeita para que z? pertença a F?. Subtraindo (B.3) calculada em z? de (B.3) calculada

em z?, segue que ?n = 0. Repetindo os passos acima para l + 1, l + 2, . . . ,|W (C)?C|, podemos deduzir
que ?n = 0 para todo n ?W (C)?C, o que nos leva a concluir que a desigualdade (B.2) que induz F?



B. Desigualdades Válidas para P(G) 105

é da forma:

?
n?C

?nyn ? ?0 (B.4)

Quarto, é fácil verificar que ?n = ?k = ? para todo n, k ?C, n 6= k. Apenas produza dois elementos
de FC, um ativando o poço n mas não k, digamos z?, e outro que ativa k mas não n, digamos z?. Para ter

z?, z? ? F?, a desigualdade (B.4) deve ser satisfeita na igualdade se calculada em z? e z?. Subtraindo (B.4)

calculada em z? de (B.4) calculada em z?, concluímos que ?n = ?k. Consequentemente, ?0 = (|C|?1)?.

Fazendo ?0 = |C|?1 e ?n = 1 para todo n ?C, deduzimos que a desigualdade (B.1) induz uma
face máxima de PC(G). Portanto dim(FC) = 2|W (C)|?1. ?

De acordo com a Proposição B.2, a desigualdade induzida por uma cobertura C seria uma faceta

de P (G) se W (C) = N . Aplicando o princípio de lifting, é possível estender uma desigualdade de

cobertura para PU (G) = P (G)?{(qi, y) ? R
N ×BN : yn = 0 para todo n ? N ?U}, onde U = W (C),

e obter uma desigualdade válida para P (G). Como no procedimento de lifting mostrado para obter

desigualdades válidas para P (Seção 3.5), as variáveis associadas aos elementos de N ?U seriam

submetidas ao procedimento de lifting uma de cada vez. Seja s =? j1, . . . , jL? uma sequência ordenada

dos elementos de N ?U . Para fazer o lifting do primeiro elemento desta sequência, j1, e produzir a

desigualdade ?
n?C

yn + ? j1 y j1 ?|C|?1 que é válida para PU?{ j1}(G), o procedimento calcularia ? j1 =

|C|?1?max{ ?
n?C

yn : (qi, y) ? PU?{ j1}(G), y j1 = 1} resolvendo um problema relacionado a P(G).

A desigualdade resultante induz uma face FU?{ j1} de PU?{ j1}(G) tal que dim(FU?{ j1}) ? dim(FU ) +

1. Se existe uma solução ótima para o problema de calcular ? j1 tal que q
j1
i &gt; l j1 , então não seria

difícil mostrar que a face induzida possui dimensão dim(FU?{ j1}) = dim(FU ) + 2. Repetindo este

procedimento para os elementos restantes de s, pode-se produzir uma desigualdade mais forte, que

possivelmente induz uma faceta para P (G) chamada de desigualdade de cobertura com lifting:

?
n?C

yn +
L

?
k=1

? jk y jk ?|C|?1 (B.5)

A desigualdade (B.5) depende tanto da cobertura C como da ordem na qual os elementos de N ?U

sofrem o lifting. Como o cálculo dos fatores de lifting é difícil, pode-se tentar obter limites inferiores

?n para os fatores ?n. No que segue descrevemos uma maneira simples para calcular limites inferiores.
Um subconjunto E(C) ? N é uma cobertura estendida de C se:

1. C ? E(C);

2. para todos os pares distintos n, m ? E(C), S(n)?S(m) = /0; e

3. para cada n ? E(C)?C, ?n ? max{? j : j ?C}.



B. Desigualdades Válidas para P(G) 106

Então, pode ser mostrado que a desigualdade de cobertura estendida:

?
n?E(C)

yn ?|C|?1 (B.6)

é válida para P (G). Note que em (B.6) ?n = 1 para todo n ? E(C)?C enquanto ?n = 0 para todo n ?
N ?E(C). Como nos desenvolvimentos anteriores, podemos obter limites inferiores de dimensões

maiores para os fatores de lifting. Para k ?{0, . . . ,|C|}, seja C(k) ? C tal que |C(k)| = k e min{?n :
n ?C(k)}? max{?n : n ?C?C(k)} se 0 &amp;lt;k &amp;lt;|C|, ou seja, C(k) é o subconjunto de C que contém os
poços que possuem as maiores taxas mínimas de injeção para serem ativados. Seja também q(C?) =

?n?C? ?n para qualquer C? ?C. Para n ? E(C)?C, podemos definir um limite inferior ?n como:

?n = Max k ?{1, . . . ,|C|}
S. a : ?n ? q(C(k))

Substituindo os fatores de lifting ?n em (B.5) por ?n para n ? E(C)?C obtemos a desigualdade de
cobertura estendida e fortalecida:

?
n?C

yn + ?
n?E(C)?C

?nyn ?|C|?1 (B.7)

que é válida para P (G).



Referências Bibliográficas

[1] G. A. Alarcón, C. F. Torres, and L. E. Gómez. Global optimization of gas allocation to a group

of wells in artificial lift using nonlinear constrained programming. ASME Journal of Energy

Resources Technology, 124(4):146–164, 2002.

[2] M. Assayag, J. Formigli, and M. V. Coelho. Águas ultraprofundas no Brasil: Os próximos

passos para alcançar 3000 metros. Revista T&amp;amp;N Petróleo, Outubro 2000.

[3] E. Balas. Facets of the knapsack polytope. Mathematical Programming, 8:146–164, 1975.

[4] E. Balas and E. Zemel. Facets of the knapsack polytope from minimal covers. SIAM Journal on

Applied Mathematics, (34):119–148, 1978.

[5] D. P. Bertsekas. Nonlinear Programming. Athena Scientific, 1995.

[6] S. Buitrago, E. Rodríguez, and D. Espin. Global optimization techniques in gas allocation for

continuous flow gas lift systems. In Gas Technology Conference, Calgary, Canada, April 1996.

Paper SPE 35616.

[7] E. Camponogara and A. M. de Conto. Gas-lift allocation under precedence constraints:

piecewise-linear formulation and k-covers. In 44th IEEE Conference on Decision and Control,

2005.

[8] E. Camponogara and P. Nakashima. Optimizing gas-lift production of oil wells: piecewise linear

formulation and computational analysis. IIE Transactions, 38(2):173–182, 2006.

[9] E. Camponogara and P. H. R. Nakashima. Solving a gas-lift optimization problem by dynamic

programming. European Journal of Operational Research, 174:1220–1246, 2006.

[10] E. Camponogara and P. H. R. Nakashima. Optimal allocation of lift-gas rates under multiple

facility constraints: A mixed integer linear programming approach. ASME Journal of Energy

Resources Technology, 128:280–289, 2006.

[11] E. Camponogara and P. H. R. Nakashima. Applying dynamic programming to a gas-lift opti-

mization problem. In II Congresso de Pesquisa e Desenvolvimento em Petróleo e Gás, Rio de

Janeiro, RJ, 2003.



Referências Bibliográficas 108

[12] T. H. Cormen, C. E. Leiserson, and R. L. Rivest. Introduction to Algorithms. MIT Press, 1990.

[13] A. M. de Conto. Alocação ótima de gás de injeção em poços de petróleo: Restrições de pre-

cedência, linearização por partes e algoritmos. Master’s thesis, Universidade Federal de Santa

Catarina, 2006.

[14] M. J. Economides, A. D. Hill, and C. Ehlig-Economides. Petroleum Production Systems. Pren-

tice Hall, 1993.

[15] W. Y. Fang and K. K. Lo. A generalized well-management scheme for reservoir simulation.

SPE Reservoir Engineering, 11(2):116–120, May 1996. Paper SPE 29124.

[16] M. R. Garey and D. S. Johnson. Computers and Intractability: A Guide to the Theory of NP-

Completeness. W. H. Freeman and Company, 1979.

[17] O. H. Ibarra and C. E. Kim. Scheduling for maximum profit. Relatório Técnico 75-2, Universi-

dade de Minnesota, 1975.

[18] E. P. Kanu, J. Mach, and K. E. Brown. Economic approach to oil production and gas allocation

in continuous gas lift. Journal of Petroleum Technology, pages 1887–1892, October 1981. Paper

SPE 9084.

[19] K. K. Lo. Optimum lift-gas allocations under multiple production constraints. 1992. Paper SPE

26017.

[20] E. M. Macambira. Uma abordagem de programação linear inteira para o problema de clique

máxima com peso nas arestas. Master’s thesis, Departamento de Ciência da Computação,

IMECC, Universidade Estadual de Campinas, 1997.

[21] A. Makhorin. GNU Linear Programming Kit: Reference Manual. Department of Applied

Informatics, Moscow Aviation Institute, Moscow, Russia, 2003.

[22] S. Martelo and P. Toth. Knapsack Problems: Algorithms and Computer Implementations. John

Wiley &amp;amp; Sons, 1990.

[23] E. R. Martinez, W. J. Moreno, J. A. Moreno, and R. Maggiolo. Application of genetic algorithm

on the distribution of gas lift injection. In 3rd Latin American/Caribbean Petroleum Engineering

Conference, Buenos Aires, Argentina, April 1994. Paper SPE 24281.

[24] C. J. N. McKie, E. A. Rojas, N. M. Quintero, J. R. C. Fonseca, and N. J. Perozo. Economic

benefits from automated optimization of high pressure gas usage in an oil production system. In

SPE Production and Operations Symposium, Oklahoma, USA, 2001. Paper SPE 67187.

[25] K. Mehlhorn and S. Naher. LEDA: A Platform for Combinatorial and Geometric Computing.

Cambridge University Press, 1999.



Referências Bibliográficas 109

[26] H. Mukherjee and K. E. Brown. Improve your gas lift design. In SPE International Meeting on

Petroleum Engineering, Beijing, China, March 1986. Paper SPE 14053.

[27] B. H. Murtagh and M. A. Saunders. MINOS 5.5 User’s Guide. Systems and Optimization

Laboratory, Department of Operations Research, Stanford University, 1998.

[28] P. H. R. Nakashima and E. Camponogara. Otimização da alocação de gás de injeção para um

conjunto de poços operando via gas-lift. In Congresso Brasileiro de Automática, Gramado, RS,

2004.

[29] P. H. R. Nakashima and E. Camponogara. Optimization of lift-gas allocation with uncertainties

using dynamic programing. IEEE Transactions on Systems, Man, and Cybernetics – Part A, 36

(2):407–414, 2006.

[30] P. H. R. Nakashima and E. Camponogara. Alocação Ótima de taxas de injeção de gas-lift

utilizando programação linear inteira mista. Revista Petro &amp;amp; Química, 263:150–160, Agosto

2004.

[31] G. L. Nemhauser and L. A. Wolsey. Integer and Combinatorial Optimization. John Wiley &amp;amp;

Sons, 1988.

[32] N. Nishikiori, R. A. Redner, D. R. Doty, and Z. Schmidt. An improved method for gas lift

allocation optimization. In SPE 64th Annual Technical Conference and Exhibition, San Antonio,

USA, October 1989. Paper SPE 19711.

[33] M. Padberg. Approximating separable nonlinear functions via mixed zero-one programs. Op-

erations Research Letters, 27:1–5, 2000.

[34] A. Plucenio. Automação da produção de poços de petróleo operando com elevação artificial por

injeção contínua de gás. Master’s thesis, Programa de Pós-Graduação em Engenharia Elétrica,

Universidade Federal de Santa Catarina, 2003.

[35] J. D. Redden, T. A. G. Sherman, and J. R. Blann. Optimizing gas-lift systems. In 49th Annual

Fall Meeting of Petroleum Engineers of AIME, Houston, USA, October 1974. Paper SPE 5150.

[36] GOAL User Guide. Schlumberger Abingdon Technology Center, Oxon, United Kingdom, 2003.

[37] H.D. Sherali. On mixed-integer zero-one representations for separable lower-semicontinuous

piecewise-linear functions. Operations Research Letters, 28:155–160, 2001.

[38] S. S. Skiena. The Algorithm Design Manual. Springer Velag, 1998.

[39] J. E. Thomas. Fundamentos de Engenharia de Petróleo. Editora Interciência, 2001.

[40] P. Wang, M. Litvak, and K. Aziz. Optimization of production from mature fields. In 17th World

Petroleum Congress, Rio de Janeiro, Brasil, 2002.



Referências Bibliográficas 110

[41] H. P. Williams. Model Building in Mathematical Programming. John Wiley &amp;amp; Sons, 1999.

[42] L. A. Wolsey. Integer Programming. John Wiley &amp;amp; Sons, 1998.


</field>
	</doc>
</add>