<?xml version="1.0" encoding="utf-8"?>
<add>
	<doc>
		<field name="docid">BR-TU.05968</field>
		<field name="filename">10450_dissertacaof.pdf</field>
		<field name="filetype">PDF</field>
		<field name="text">Universidade de Aveiro 2011
Departamento de Electrónica, Telecomunicações e Informática
Luís Carlos Santos Ferreira
Sistema anti-roubo de viaturas via carjacking
Universidade de Aveiro 2011
Departamento de Electrónica, Telecomunicações e Informática
Luís Carlos Santos Ferreira
Sistema anti-roubo de viaturas via carjacking
Dissertação apresentada à Universidade de Aveiro para cumprimento dos requisitos necessários à obtenção do grau de Mestre em Engenharia Electrónica e Telecomunicações, realizada sob a orientação científica do Doutor António Ferreira Pereira de Melo, Professor Catedrático do Departamento de Electrónica, Telecomunicações e Informática da Universidade de Aveiro.
Dedico este trabalho aos meus pais pela enorme paciência que demonstraram ao longo de todos estes anos de estudos e aos meus colegas, vizinhos e amigos Hugo Cunha, Ludimar Guenda e Filipe Abrantes, pela ajuda valiosa e apoio que me deram durante os anos de desenvolvimento deste projecto.
Agradeço ainda ao Professor Doutor António Pereira de Melo, pela oportunidade de realizar um trabalho com uma forte componente prática e num ramo que me interessa tanto.
O júri
Presidente	Professor Doutor Tomás António Mendes Oliveira e Silva Professor associado do Departamento de Electrónica Telecomunicações e Informática da Universidade de Aveiro
Arguente	Professor Doutor Pedro António Amado Assunção Professor Coordenador da Escola Superior de Tecnologia e Gestão do Instituto Politécnico de Leiria
Orientador	Professor Doutor António Ferreira Pereira de Melo Professor Catedrático do Departamento de Electrónica Telecomunicações e Informática da Universidade de Aveiro
palavras-chave	ZigBee, sem fios, alarme, carjacking, carro, controlo de acessos
keywords	ZigBee, wireless, alarm, carjacking, car, access control
resumo	Nesta tese de mestrado pretende desenvolver-se um sistema anti-caijacking com características autónomas e praticamente sem necessidade de intervenção por parte do utilizador. Esse sistema incorpora registo e controlo de acessos.
abstract	In this thesis is developed a carjacking prevention system having autonomous capability and the ability of functioning without much user input. The system can also record and control the access to a preestablished area.
I.
Índice
I.	Índice................................................................................2
1.	Introdução............................................................................1
1.1.	Estrutura do documento...........................................................1
1.2.	Objectivos.......................................................................1
1.3.	Enquadramento....................................................................2
1.4.	Importância no mercado actual....................................................3
1.5.	Organização do projecto..........................................................4
2.	Base teórica das tecnologias utilizadas...............................................5
2.1.	Zigbee...........................................................................5
2.1.1.	Comparação com outras tecnologias sem fios.....................................7
2.1.2.	Vertentes de utilização,	a ZigBee Alliance.....................................7
2.1.3.	Porquê a opção por ZigBee neste projecto?......................................8
2.2.	SPI (Serial Peripheral Interface)................................................8
2.3.	I2C (Inter-Integrated Circuit)..................................................10
2.4.	ABS (Anti-lock Braking System)..................................................11
2.5.	Acelerómetros...................................................................13
3.	Execução prática.....................................................................15
3.1.	Escolha dos elementos electrónicos..............................................15
3.1.1.	Elementos comuns utilizados...................................................15
3.1.2.	Microprocessador (CPU)........................................................15
3.1.3.	Módulo de comunicação ZigBee..................................................16
3.2.	Ambiente de desenvolvimento.....................................................17
3.2.1.	Hardware de programação de microcontroladores PIC.............................17
3.2.2.	Preparação....................................................................18
3.2.3.	A Stack de comunicação daMicrochip............................................19
3.2.4.	Configuração utilizada........................................................19
3.3.	Software........................................................................21
3.4.	Os comandos / unidades identificadoras..........................................21
3.4.1.	Autonomia esperada............................................................23
3.5.	O módulo do carro...............................................................25
3.5.1.	Detecção de cartões...........................................................25
3.5.2.	Actuação na viatura...........................................................26
3.5.3.	Obtenção do sinal de ABS......................................................27
3.5.4.	O acelerómetro................................................................28
3.5.4.1.	Escolha do acelerómetro.....................................................28
3.5.5.	Registo de acessos............................................................30
3.5.6.	Gestão de sessões em detalhe..................................................31
3.6.	O módulo de programação.......................................................32
3.7.	A aplicação para Windows........................................................33
3.7.1.	Guia de utilização..........................................................33
3.8.	Interacção entre o módulo do carro, o módulo de programação e o software........38
3.8.1.	Teste da conectividade com o módulo de programação............................38
3.8.2.	Teste da conectividade com o carro............................................39
3.8.3.	Adicionar um cartão à base de dados do módulo do carro........................40
3.8.4.	Obter o número de cartões na base de dados do módulo do carro.................41
3.8.5.	Remover um cartão da base de dados do módulo do carro..........................42
3.8.6.	Obter ID de um cartão na base de dados do módulo do carro......................43
3.8.7.	Verificar estado de bloqueio do carro.........................................43
3.8.8.	Bloquear ou desbloquear carro.................................................44
3.8.9.	Acertar hora e data do módulo do carro........................................45
3.8.10.	Obter número de registos de acesso guardados em memória......................46
3.8.11.	Apagar registos de acesso....................................................47
3.8.12.	Obter registos de acesso..............................................47
4.	Resultados dos testes no terreno.............................................49
4.1.	Testes em viatura........................................................49
4.1.1.	O módulo do carro......................................................49
4.1.2.	Autonomia do cartão....................................................51
4.1.3.	Alcances medidos para os vários módulos................................51
5.	Conclusões...................................................................53
6.	Trabalho Futuro..............................................................55
6.1.	Desenvolver um método de evitar o replay dos dados transmitidos pelos comandos.55
6.2.	Implementar uma bateria de lítio de 3,6V e um controlador do processo de carga no cartão 55
7.	Outras aplicações............................................................57
II.	Bibliografia..............................................................59
III.	Apêndices.................................................................61
A.	Organização interna da memória não volátil do CPU...............................61
B.	Comandos implementados na interacção entre módulos........................62
C.	Esquemas eléctricos e PCBs................................................63
1.	Cartão..................................................................63
2.	Módulo do Carro.........................................................64
3.	Módulo de programação....................................................66
Lista de Figuras
Figura 1 - Diagrama de blocos do sistema projectado.................................................................1
Figura 2 - Número de casos de carjacking registados em Portugal entre 2005 e 2008...................................3
Figura 3 - Logo ZigBee..............................................................................................5
Figura 4 - Formato de trama ZigBee..................................................................................5
Figura 5 - Topologias de redes ZigBee...............................................................................6
Figura 6 - Logo ZigBee Alliance.....................................................................................7
Figura 7 - Esquema eléctrico de um sistema utilizando SPI...........................................................9
Figura 8 - Diagrama temporal exemplificativo da operação do SPI......................................................9
Figura 9 - Logo I2C.................................................................................................10
Figura 10 - Esquema eléctrico de um sistema utilizando I2C..........................................................10
Figura 11 - Diagrama temporal exemplificativo da operação do I2C....................................................10
Figura 12 - Símbolo do sistema ABS..................................................................................11
Figura 13 - Sensor de ABS...........................................................................................12
Figura 14 - Exemplo de variação da frequência do sinal de ABS com a velocidade do carro.............................12
Figura 15 - Exemplo de um sinal vindo de um sensor de ABS activo....................................................12
Figura 16 - Exemplo de utilização de acelerómetro em telemóvel para determinar orientação do ecrã...................13
Figura 17 - Microchip Pie 18F26K20..................................................................................15
Figura 18 - Microchip MRF24J40MA....................................................................................16
Figura 19 - IDE MPLAB...............................................................................................17
Figura 20 - PICkit 3................................................................................................17
Figura 21 - Stack MiWi da Microchip.................................................................................19
Figura 22 - Microsoft Visual Basic Express 2010.....................................................................21
Figura 23 - Reed Relay utilizado....................................................................................21
Figura 24 - Diagrama de blocos do comando...........................................................................22
Figura 25 - ID de identificação de cada cartão......................................................................22
Figura 26 - Bateria recarregável utilizada..........................................................................23
Figura 27 - Curva de carga da bateria...............................................................................24
Figura 28 - Microchip nano Watt XLP Ba ttery Life Estima tor v1.0...................................................24
Figura 29 - Diagrama de estados do sistema gestor do bloqueio do carro; A verde está destacado o estado de partida..26
Figura 30 - Circuito utilizado para obter sinal de ABS de sensor passivo............................................27
Figura 31 - Circuito utilizado para obter sinal de ABS de sensor activo.............................................28
Figura 32 - Acelerómetro utilizado (ADXL327)........................................................................29
Figura 33 - Diagrama de estados do registador de acessos; A verde escuro está destacado o estado de partida.........30
Figura 34 - Formato de um registo de acesso guardado na memória externa.............................................30
Figura 35 - Gestão de sessões em detalhe com exemplo de sessão do cartão 3..........................................31
Figura 36 - Vector de sessão no estado inicial (sem sessões iniciadas)..............................................31
Figura 37 - Vector de sessão imediatamente após detecção do cartão 2................................................32
Figura 38 - Vector de sessão imediatamente antes do final de sessão do cartão 2.....................................32
Figura 39 - Janela principal da aplicação...........................................................................33
Figura 40 - Iniciar o trabalho na aplicação.........................................................................34
Figura 41 - Escolher ficheiro de log para a aplicação...............................................................34
Figura 42 - Ecrã inicial da aplicação depois de testes de conectividade.............................................35
Figura 43 - Adicionar cartão........................................................................................35
Figura 44 - Cartão adicionado com sucesso...........................................................................36
Figura 45 - Carro desbloqueado com sucesso..........................................................................36
Figura 46 - Acertar hora do módulo do carro.........................................................................37
Figura 47 - Exemplo de registo de acessos...........................................................................37
Figura 48 - Exemplo de comunicação entre aplicação de programação e carro...........................................38
Figura 49 - Teste de conectividade com o	programador (falha)........................................................38
Figura 50 - Teste de conectividade com o	programador (sucesso)......................................................39
Figura 51 - Teste de conectividade com o	carro (falha)..............................................................39
Figura 52 - Teste de conectividade com o carro (sucesso)............................................................40
Figura 53 - Adicionar cartão (falha)................................................................................40
Figura 54 - Adicionar cartão (sucesso)..............................................................................41
Figura 55 - Obter número de cartões na base de dados do carro (sucesso).............................................41
Figura 56 - Obter número de cartões na base de dados do carro (falha)...............................................42
Figura 57 - Remover cartão da base de dados do módulo do carro (sucesso)............................................42
Figura 58 - Remover cartão da base de dados do módulo do carro (falha)..............................................42
Figura 59 - Obter ID de cartão armazenado na base de dados do módulo do carro (sucesso).............................43
Figura 60 - Obter ID de cartão armazenado na base de dados do módulo do carro (falha).............................43
Figura 61 - Obter estado de bloqueio do carro (sucesso)...........................................................44
Figura 62 - Obter estado de bloqueio do carro (falha).............................................................44
Figura 63 - Bloquear viatura (sucesso)............................................................................44
Figura 64 - Desbloquear viatura (sucesso).........................................................................45
Figura 65 - Bloquear viatura (falha)..............................................................................45
Figura 66 - Desbloquear viatura (falha)...........................................................................45
Figura 67 - Acertar hora do módulo do carro (sucesso).............................................................46
Figura 68 - Acertar hora do módulo do carro (falha)...............................................................46
Figura 69 - Obter número de registos de acesso guardados em memória (sucesso)......................................46
Figura 70 - Apagar registos de acesso (sucesso)...................................................................47
Figura 71 - Apagar registos de acesso (falha).....................................................................47
Figura 72 - Obter 10 registos de acesso (sucesso).................................................................47
Figura 73 - Obter 10 registos de acesso (falha)...................................................................48
Figura 74 - Módulo do carro na placa branca montado no carro para testes..........................................49
Figura 75 - Relé automóvel utilizado para bloqueio e desbloqueio da viatura.......................................50
Figura 76 - Pinout de um MCP1407 na package TO-220-5..............................................................50
Figura 77 - Esquema eléctrico do módulo de cartão de identificação................................................63
Figura 78 - PCB do módulo do cartão de identificação (3,32x4,48cm)................................................63
Figura 79 - Fotos do cartão utilizado para testes.................................................................64
Figura 80 - Esquema eléctrico do módulo de carro..................................................................64
Figura 81 - PCB do módulo do carro (6,72x5,25 cm).................................................................65
Figura 82 - Foto do módulo do carro utilizado em testes...........................................................65
Figura 83 - Esquema eléctrico do módulo de programação............................................................66
Figura 84 - PCB do módulo de programação (2,83x2,75cm)............................................................66
Figura 85 - Fotos do módulo de programação utilizado..............................................................67
Lista de tabelas
Tabela 1 - Comparação entre ZigBee, Wi-Fi e Bluetooth..............................................................7
Tabela 2 - Exemplos de funções MiApp e MiMAC.......................................................................20
Tabela 3 - Tabela de caracteres ASCII possíveis para ID dos cartões................................................23
Tabela 4 - Tabela de estados possíveis do módulo do carro em função dos leds indicadores...........................49
	Lista de Acrónimos
ABS	Anti-lock Braking System
ACK	Acknowledge
AES	Advanced Encryption Standard
CPU	Central Processing Unit
CSMA/CA	Carrier Sense Multiple Access with Collision Avoidance
DIP	Dual Inline Package
EEPROM	Electrically-Erasable Programmable Read-Only Memory
SMD	Surface Mount Device
I2C	Inter-Integrated Circuit
IDE	Integrated Development Environment
MAC	Medium Access Control
MIPS	Milhões de Instruções Por Segundo
NACK	Not Acknowledge
OPAMP	Operational Amplifier (AMPOP em português)
PAN	Private Area Network
RAM	Random Access Memory
ROM	Read-Only Memory
RFID	Radio-Frequency Identification
SPI	Serial Peripheral Interface
USB	Universal Serial Bus
WDT	Watchdog Timer
1.	Introdução
1.1.	Estrutura do documento
Este documento está dividido em 6 capítulos e 3 secções.
O primeiro capítulo visa dar uma introdução ao que será tratado, abordando a problemática do carjacking, os objectivos deste projecto e o espaço existente no mercado para um producto deste tipo.
No segundo são enunciadas as bases teóricas para uma melhor compreensão do que é mencionado nos capítulos seguintes.
No terceiro está documentada toda a execução prática do projecto, desde a escolha dos componentes a detalhes sobre os quatro componentes base do projecto (cartões, módulos de programação e do carro e software).
No quarto capítulo estão os resultados da montagem do projecto num carro real.
Por fim, nos quinto, sexto e sétimo capítulos abordo as conclusões do projecto, o trabalho que se poderá fazer no futuro para desenvolver mais o projecto e que outras aplicações serão possíveis com o hardware criado ou com pequenas modificações ao mesmo.
As secções incluem o Índice, a Bibliografia e os Apêndices onde estão os esquemas eléctricos e as PCBs de todo o hardware realizado.
1.2.	Objectivos
Com este projecto pretendo desenvolver uma solução simples e barata para combater o “carjacking”. Não será uma solução que evite que os ladrões tentem roubar um carro deste modo, mas sim uma solução que evite que eles vão muito longe após terem praticado o acto.
PIC	Bateria
18F26k20 recarregável 3V
Unidade de comando portátil
ZigBee
EEPROM PIC
25AA1024 18F26k20
Módulo do carro
Bateria	RTC
recarregável 3V	DS1307
!&gt;J era'
CO
0&gt;
0&gt;
Figura 1 - Diagrama de blocos do sistema projectado
Será um sistema de funcionamento autónomo, baseado em tecnologia ZigBee e com poucos requisitos técnicos para ser operado, que pode ser instalado num grande número de viaturas actualmente a circular nas nossas estradas.
Funcionará ainda como registador de acessos ao veículo, permitindo ao dono verificar quem e quando esteve no interior do mesmo, via uma aplicação simples para Windows, desde que quem tenha acesso ao veículo carregue um cartão de identificação associado à viatura. A viatura não estará operacional sem a presença deste cartão a bordo.
A aplicação servirá de base para toda a programação do sistema montado no veículo, oferecendo um leque alargado de funcionalidades:
•	Adicionar cartões (utilizadores);
•	Remover cartões;
•	Forçar o Bloqueio ou desbloquear a viatura;
•	Consultar o registo de acessos à viatura com horas de entrada e saída da mesma.
1.3.	Enquadramento
O termo carjacking não é de origem portuguesa (não estando incluído no nosso dicionário), sendo antes um derivado de um termo utilizado anteriormente para referência a uma tomada de posse forçada de um avião, o chamado hijacking. Com o aumento do número de manobras semelhantes em veículos automóveis, nasceu este nome, uma adaptação do termo original à nova realidade.
É um fenómeno que teve origem nos Estados Unidos na década de 80, altura em que os primeiros casos ficaram registados, mas apenas em 1992 foi declarado crime federal naquele país. Chegou a Portugal em 2003, tendo sido notícia em vários blocos noticiosos que muitas vezes deram conta da violência de que os condutores são alvo.
Pode-se então definir carjacking como o roubo de uma viatura automóvel com o recurso ou não a armas de fogo, sem o consentimento do dono da mesma.
É importante referir que o roubo apenas é considerado carjacking quando o proprietário da viatura está nas imediações da mesma, mas que tanto pode acontecer com o dono dentro (parado nuns semáforos, por exemplo) ou fora (parou apenas para ir buscar alguma coisa a algum lado e deixou a viatura desprotegida) da mesma. São aqueles casos, portanto, em que o ladrão não tem de recorrer a nenhuma artimanha para fazer o carro andar, normalmente ele já está pronto a arrancar.
Pode, então, acontecer em qualquer lado e, quase sempre, quando o dono da viatura menos espera:
•	Parques de estacionamento;
•	Bombas de gasolina;
•	Acessos à residência/saídas de garagem;
•	Caixas de multibanco;
•	Locais despovoados e/ou com pouco iluminação;
•	Cruzamentos ou entroncamentos com semáforos.
Carjacking é um crime normalmente praticado com violência proporcional ao nível de resistência que os ocupantes da viatura proporcionem ao ladrão. No entanto, há casos em que, mesmo que não seja oferecida resistência, a violência é utilizada na mesma.
O perfil do ladrão estabelecido pelas autoridades indica que são normalmente pequenos grupos com armas de fogo e idades entre os 20 e 25 anos, não toxicodependentes mas com residência em bairros suburbanos violentos das grandes cidades. O roubo transferiu-se para carjacking devido à evolução tecnológica dos sistemas anti-roubo das viaturas que passaram a estar baseados em técnicas de identificação via RFID, que dificultam ou mesmo impossibilitam o furto de uma viatura sem acesso à respectiva identificação electrónica, normalmente via chave ou cartão.
Os alvos preferenciais são mulheres e idosos, com carros equipados com caixa de velocidades manual (por serem mais fáceis de operar) e o mínimo de ocupantes.
Segundo os registos da Polícia Judiciária portuguesa, em 2004 e só na zona de Lisboa ocorreram 178 crimes do género. No entanto, e segundo este órgão de segurança, apenas foram contabilizadas as ocorrências em que o prevaricador se apodera da viatura durante um tempo significativo e para proveito
próprio, ficando de fora os casos em que o condutor apenas é forçado a realizar uma acção que favoreça o ladrão, como ir a uma caixa de multibanco levantar dinheiro.
Na Figura 2 é visível a evolução dos casos de carjacking no nosso país entre os anos 2005 e 2008, notando-se uma tendência para o aumento de incidências.
Figura 2 - Número de casos de carjacking registados em Portugal entre 2005 e 20081
1.4.	Importância no mercado actual
Existem actualmente no mercado, essencialmente quatro tipos de soluções para este problema associado ao “carjacking’”'.
a)	Localização após roubo;
b)	Bloqueio remoto após roubo;
c)	Bloqueio no local por realização de alguma acção dentro da viatura;
d)	Bloqueio automática após a não detecção de algum objecto identificador dentro da viatura.
Todas estas técnicas têm vantagens e desvantagens.
No caso a) e no caso b) (muitas vezes as duas soluções são utilizadas em simultâneo, permitindo a localização e bloqueio remoto da viatura), tem de ser o condutor a avisar a entidade que lhe disponibilizou o serviço de que foi alvo de roubo, para que a mesma proceda à localização ou bloqueio da viatura.
O caso c) pode ser problemático em situações mais perigosas e rápidas. Se os ladrões estiverem dispostos a magoar alguém para atingir o fim a que se propuseram e se a pessoa dentro do carro tentar alguma acção que não permita que a viatura saia do local, a situação pode-se complicar e levar a que alguém se magoe. É a solução menos desejada já que exige que o condutor tome parte activa durante o roubo, o que poderá ser visto como uma provocação por parte dos ladrões. Evita-se o roubo mas podem-se perder vidas, o que não é de todo desejado.
Já na solução d) o processo de roubo acontece e não é evitado, os ladrões levam o carro que se imobilizará uns metros ou uns minutos depois. O sistema desliga a viatura e não permite que esta se volte a ligar sem que alguma acção que apenas o condutor conheça seja efectuada. O problema desta solução é a distância ou o tempo em que o carro vai parar, se for demasiado perto ou cedo o condutor corre o risco de encarar com um ladrão furioso por o seu roubo não ter funcionado, o que será um problema ainda maior.
Os três primeiros casos estão sujeitos ainda à utilização de dispositivos de bloqueio às comunicações sem fios, que evitam que o carro receba ou transmita informação para o exterior. A solução
1 http://www.in.pt/multimedia/infografia.aspx7content id=1039614
d), em que se enquadra o projecto desenvolvido, tem a vantagem de funcionar ao contrário, o carro bloqueia se não receber instrucções para não bloquear, o que invalida a utilização de tais dispositivos.
Todas estas soluções têm, no entanto, um problema em comum: o preço elevado.
Nos dois primeiros casos esse custo é óbvio, para além do aparelho e instalação, o dono da viatura fica muitas das vezes preso a uma subscrição anual ou mensal.
Nos casos c) e d) é o custo do aparelho e instalação que normalmente são o maior entrave à instalação destes sistemas. Por exemplo, a instalação de um sistema de bloqueio automático da viatura pode facilmente ascender às centenas de euros, sendo ainda necessário adquirir identificadores extra para todas as pessoas que pretendam utilizar a viatura, com cada um a poder custar mais de €100.
É aqui que entra o sistema que nos propusemos desenvolver, espera-se que venha a ter um custo bastante inferior a ofertas baseadas em outras tecnologias já no mercado.
1.5.	Organização do projecto
Um dos grandes objectivos deste projecto é criar algo simples, pelo que não seria razoável criar uma miríade de componentes que lhe adicionassem demasiada complexidade.
Assim, são 4 os componentes base:
•	Cartão de identificação;
•	Módulo do carro;
•	Módulo programador;
•	Software para Windows.
As funcionalidades específicas e detalhes de cada componente estão explicitados mais à frente neste documento.
2.	Base teórica das tecnologias utilizadas
Neste capítulo abordarei sucintamente as bases tecnológicas e protocolos de comunicação que utilizo no projecto. São eles ZigBee, SPI, I2C, ABS e acelerómetros.
2.1.	Zigbee
ZigBee
Figura 3 - Logo ZigBee
O ZigBee é um standard de comunicações sem fios criado em 2004 (especificação 1.0, em 2003 já havia sido lançada uma especificação preliminar e em 2007 foi actualizada) com o objectivo de ser uma alternativa barata e simplificada do Wi-Fi (que se baseiam em IEEE 802.11) em situações bastante particulares e do Bluetooth num leque mais abrangente de situações.
É claramente virado para redes de controlo que não necessitam de uma grande largura de banda e onde funções avançadas de poupança de energia são obrigatórias, principalmente em nós remotos que não fiquem ligados permanentemente a uma fonte de energia robusta e capaz de os alimentar indefinidamente.
Foi projectado em cima da especificação IEEE 802.15.4 e oferece uma panóplia de funções de gestão de redes, que incluem a formação de uma rede, atribuição de endereços aos indivíduos dessa rede, reencaminhamento, troca de mensagens e descoberta de dispositivos pertencentes à rede.
A norma em si foi criada em cima da especificação 802.15.4 que define as camadas físicas e MAC (Medium Access Control). O 802.15.4 foi criado especificamente para aplicações que requeiram pouca largura de banda e consumos de energia muito baixos, sendo por isso ideal para o ZigBee.
Na norma está definido um sistema de detecção e prevenção de colisões (CSMA/CA - Carrier Sense Multiple Access with Collision Avoidance, acesso múltiplo com verificação de portadora e prevenção de colisões) e segurança que pode ir até AES (AdvancedEncryption Standard) de 128 bits com prevenção de repetições indesejadas (o chamado replay de tramas enviadas anteriormente, por dispositivos não autorizados).
O ZigBee opera em 27 canais de frequência distintos, com a gama a depender da frequência base de operação. Existe 1 canal para a frequência de 868MHz (de uso europeu), 10 canais para os 915MHz (de uso americano) e 16 canais para os 2,4GHz (de uso global). Nos 2,4GHz que serão utilizados neste projecto, cada canal está separado de 5MHz.
Uma trama ZigBee tem o seguinte formato:
•&lt;-2 Bytes 1 Byte
4 a 20 Bytes
n Bytes
2 Bytes-
Frame
Control
Sequence Number
Address
Data Payload
Frame Check
Sequence
X
X
Figura 4 - Formato de trama ZigBee
Uma rede ZigBee pode assumir várias topologias, exemplificadas na Figura 5:
•	Estrela - Dispositivos periféricos ligam-se ao coordenador, com toda a informação a passar por ele;
•	Árvore - Dispositivos periféricos ligam-se entre eles, podendo-se formar mais de um caminho entre dois pontos; “Cabeça” da rede é o coordenador e todos os nós (elementos da rede) têm apenas um caminho até ele;
•	Mesh (mistura entre estrela e árvore) - Idêntica à topologia em árvore só que cada nó poderá ter mais do que uma ligação para o coordenador;
•	P2P - Apenas dois dispositivos que comunicam entre si.
Árvore
Figura 5 - Topologias de redes ZigBee
Mesh
Existem 3 tipos diferentes de dispositivos em redes ZigBee, por ordem de funcionalidade:
•	Coordenadores - Essenciais em todas as redes ZigBee (excepto em redes P2P em que dois dispositivos quaisquer podem comunicar entre si sem necessidade de um gestor de rede), é o centro de toda a rede; Entre as suas funções estão o controlo e transmissão dos parâmetros da rede, a gestão dos nós da rede e a distribuição de mensagens na rede;
•	Routers - Servem para estender o alcance de uma rede, assumindo funções de reencaminhamento de tráfego;
•	Dispositivos finais - Aqueles que, regra geral, comunicam com o mundo exterior, podendo representar módulos de comunicação com capacidade de fazer medições do meio, receptores e comandos de televisão, entre outros.
No âmbito deste projecto todos os dispositivos foram configurados como coordenadores, isto é, todos têm conhecimento prévio sobre os parâmetros de funcionamento da rede (como o canal em que devem transmitir). Esta opção foi tomada tendo em conta a funcionalidade pretendida, esperar que os dispositivos se configurassem numa rede automática de cada vez que fossem iniciados seria um dispêndio de tempo e energia que, por exemplo, nos cartões de identificação seria prejudicial ao tempo de vida da bateria utilizada.
2.1.1. Comparação com outras tecnologias sem fios
	ZigBee	Wi-Fi	Bluetooth
Velocidade	20, 40 e 250kbps, dependendo da frequência de operação	Até 600Mbps	Até 3Mbps
Alcance (com antena normal, não direccional)	Até 100 metros	Até 100 metros	Até 10 metros
Frequência de operação	868MHz, 915MHz, e 2,4GHz	2,4 e 5 GHz	2,4GHz
Complexidade (Hardware e Software)	Baixa	Muito Alta	Alta
Consumo de energia	Muito baixo (mW)	Alto (W)	Médio (centenas de mW)
Tabela 1 - Comparação entre ZigBee, Wi-Fi e Bluetooth
O ZigBee não é o standard de comunicações sem fios mais avançado tecnologicamente, não é nem o mais rápido nem o que oferece o maior alcance. É sim uma especificação bastante centrada num propósito bem definido e que não tem grandes pretensões fora desse mercado.
É bastante mais lento do que tanto o Wi-Fi como o Bluetooth, mas oferece a possibilidade de operar com um consumo baixíssimo de energia, a rondar os mW, que é no mínimo centenas de vezes inferior ao consumo proporcionado pelo Bluetooth.
Entre outras diferenças importantes para o Bluetooth, a tecnologia mais perto em termos de funcionalidade, estão o número de dispositivos que cada rede pode ter (8 no Bluetooth, até 64 bits de endereços no ZigBee, se ignorarmos o facto de o tempo de circulação de cada pacote pelos nós da rede limitar este número) e o tempo de entrada numa determinada rede (segundos no Bluetooth, dezenas de milissegundos no ZigBee).
2.1.2.	Vertentes de utilização, a ZigBee Alliance
Apesar de ser uma tecnologia recente, o ZigBee tem sido bastante promovido pela ZigBee
7	.	.	.
Alliance , existindo já perfis de utilização para as mais variadas situações.
ZigBee Alliance
Figura 6 - Logo ZigBee Alliance
Esses perfis são desenvolvidos e definem standards de utilização que permitem que a tecnologia seja integrada mais facilmente no mercado.
2 http://www.zigbee.org/
Exemplos desses perfis são:
•	Building Automation - Controlo remoto de edifícios comerciais;
•	Remote Control - Controlos remotos avançados;
•	Smart Energy - Controlo e regulação remota de consumo de energia;
•	Health Care - Monitorização remota de dados vitais;
•	Home Automation - Automação de casas de privados;
2.1.3.	Porquê a opção por ZigBee neste projecto?
Com tanta oferta de dispositivos de comunicação sem fios no mercado, a escolha de uma tecnologia que cumprisse todos os requisitos para o que era pretendido poderia ser complicada.
No entanto, a decisão de criar um sistema à volta do ZigBee tornou-se óbvia logo nas primeiras etapas do desenvolvimento do projecto.
Para além das diferenças apontadas na comparação com outras tecnologias realizada na secção
2.1.1,	o ZigBee tem ainda a vantagem de ser uma tecnologia emergente e com um grande potêncial na área do controlo remoto com recurso a pilhas como fonte de energia.
Por ser uma especificação bastante centrada nesse propósito, está a começar a tomar o lugar de outras tecnologias em vários dispositivos de controlo. O caso dos controlos remotos das televisões de mais alta gama, por exemplo, que já oferecem funcionalidades extra graças à criação de um canal de comunicação bidireccional entre a televisão e o comando que não era possível com os normais infravermelhos. Este foi um mercado em que o Bluetooth entrou mas nunca vingou, muito devido à sua falta de funcionalidades exclusivas.
Também foi ponderada a utilização de módulos convencionais de 433MHz ou menos, encontrados em praticamente todos os controlos remotos de garagens e até nos comandos convencionais dos carros. Também se pensou em utilizar módulos RFID passivos (cujos cartões de identificação são muito baratos mas os leitores dos mesmos são bastante dispendiosos), no entanto, os parâmetros que levaram à escolha do ZigBee foram o potencial de evolução que ainda tem e a flexibilidade que oferece.
Será fácil adicionar funcionalidades extra ao comando desenvolvido, como por exemplo realizar acções no carro sem ser preciso estar dentro dele ou utilizar o mesmo cartão para aceder a vários espaços, e isto sem adicionar nenhum hardware ao sistema e sem aumentar exageradamente o preço do produto.
2.2.	SPI (Serial Peripheral Interface)
O SPI é um protocolo de comunicação série (os bits são enviados apenas numa linha, uns a seguir aos outros), síncrono (há uma linha de relógio comum entre todos os dispositivos) e capaz de operar em modo full-duplex (podem ser enviados dados ao mesmo tempo que se recebe, sem prejuízo de velocidade, há uma linha dedicada para cada tipo de tráfego).
Num barramento SPI existe a noção de Master e Slave. O Master é aquele que requisita ou envia dados para o Slave, e também aquele que controla a linha de relógio. Todas as transmissões de dados no barramento ocorrem com o pedido do Master a um dos Slaves ligados ao mesmo.
Figura 7 - Esquema eléctrico de um sistema utilizando SPI
A comunicação entre os vários dispositivos é efectuada recorrendo a 4 ligações:
•	SDI - Serial Data In - Ligação onde circulam os dados provenientes dos outros dispositivos ligados ao barramento; Partilhada entre todos os dispositivos do barramento;
•	SDO - Serial Data Out - O mesmo que a anterior mas onde circulam os dados enviados pelo dispositivo para o barramento; Também é partilhada entre todos os dispositivos.
•	CLK - Relógio - Ligação partilhada por todos os dispositivos e que contém a informação do relógio para sincronismo;
•	SS - Slave Select - Selecciona o dispositivo pretendido para transmitir ou receber dados, controlada pelo dispositivo Master do barramento; Cada dispositivo tem um Slave Select próprio e apenas um Slave Select pode estar activo em todos os instantes.
O SPI pode atingir as dezenas de Mbps, estando apenas dependente da velocidade de cada um dos
dispositivos ligados ao barramento.							
1	2	3	4	5	6	7	8	9	10
CLK	-ni						
SS	\
SDI x	x x x :
SDO x	:
Figura 8 - Diagrama temporal exemplificativo da operação do SPI
Com o diagrama temporal da Figura 8 fica claro o método simples de funcionamento do barramento SPI. Quando o Master pretende transmitir informação, é ele que controla o barramento de relógio, indicando aos Slaves quando devem colocar informação na sua linha de entrada de dados.
Na mesma figura é ainda visível a característica full-duplex do barramento, pormenor que permite que o Master e os Slaves recebam e transmitam dados ao mesmo tempo.
2.3.	I2C (Inter-Integrated Circuit)
Figura 9 - Logo I2C
2
O I C é também um protocolo de ligação série e síncrono mas, ao contrário do SPI, é apenas halfduplex (os dados circulam apenas num sentido, apenas há uma linha para transmissão e recepção de dados), o que significa que é mais lento e complexo de implementar.
Figura 10 - Esquema eléctrico de um sistema utilizando I2C
As duas linhas envolvidas na comunicação são:
•	SDA - Serial Data - Linha por onde passa toda a informação, tanto de entrada como de saída de um dispositivo;
•	SCL - Serial Clock - Linha responsável pelo sincronismo entre Master e Slave.
Ambas as linhas precisam de resistências de pull-up (entre a linha e o rail positivo da alimentação), uma vez que os dispositivos apenas estão permitidos a puxar a linha a zero ou a deixá-la flutuar, o que eleva a linha à tensão de alimentação. Este desenho tem a vantagem de apenas necessitar de duas ligações que são partilhadas por todos os dispositivos, sendo o endereçamento uma parte da iniciação da comunicação, contra a selecção do Slave Select apropriado no SPI.
Antes de cada troca de dados entre dois dispositivos, o Master coloca na linha de dados o endereço para onde se destinam os dados que se seguem, cabendo aos Slaves detectar esse endereço e fazer a correspondência com o seu. Todos os dispositivos ligados ao barramento recebem os bits de endereçamento e tomam uma decisão sobre o que fazer a seguir.
Caso haja uma correspondência, o Slave já sabe que os dados são para ele. Estão definidos 7 bits de endereçamento no I C (dos quais 16 endereços estão reservados), o que significa que é possível endereçar até 112 dispositivos com apenas 2 fios. No SPI seriam necessárias 112 linhas dedicadas de Slave Select para o mesmo efeito.
1	23456789	10
SDA
SCL Start \__/ B1 \_____/B2\	/Bn\____/ Stop
2
Em termos de velocidades o I C pode atingir os 3,4Mbps, mas a maioria dos dispositivos fica-se pelos 100kbps ou 400kbps. Também aqui existe a noção de Master e Slave, sendo mais uma vez o Master que se encarrega de iniciar e terminar toda e qualquer transmissão de dados.
Existem três instantes básicos na comunicação com este protocolo, explicitados na Figura 11:
•	Start - Início da comunicação entre o Master e os Slaves, é marcado com a passagem da linha SDA de High para Low enquanto SCL está em High;
•	Stop - Fim da comunicação entre o Master e o Slave, é marcado com a passagem da linha SDA de Low para High com o SCL em High;
•	Troca de informação - Master ou Slave colocam a informação em SDA com o SCL em Low; SCL é pulsado (de Low para High e de novo para Low) indicando que os dados estão estáveis na linha SDA; Master ou Slave lêem o bit em SDA.
2.4.	ABS (Anti-lock Braking System)
Figura 12 - Símbolo do sistema ABS
O ABS é um sistema de segurança activo introduzido nos automóveis de produção em massa nos anos 80. As suas origens datam dos anos 20, quando começou a ser desenvolvido para utilização na aviação. Nos anos 70 apareceu pela primeira vez, como um extra bastante caro, em automóveis de produção. Foi necessário que Robert Bosch pegasse no que existia e desenvolvesse o conceito até praticamente ao nível que temos hoje em que é standard em quase todos os carros.
Com o passar dos anos o sistema foi sendo aperfeiçoado e optimizado para aproveitar as cada vez maiores capacidades de processamento encontradas num carro, para além de ter ficado cada vez mais pequeno no que a sensores e actuadores diz respeito.
O princípio de funcionamento é bastante simples. Existe um sensor na roda que disponibiliza informação sobre o estado de movimento da mesma. Esse sensor é excitado por exemplo por um castelado (uma espécie de roda dentada, em destaque na Figura 13) que gera nele uma onda de tensão com uma frequência proporcional à velocidade de rotação da roda.
Figura 13 - Sensor de ABS3
Essa frequência depende directamente da velocidade da viatura, do número de dentes que o fabricante colocou nesse sistema em particular, do tamanho da jante e da altura do pneu.
Figura 14 - Exemplo de variação da frequência do sinal de ABS com a velocidade do carro
Existem dois tipos de sensores nos carros actuais:
•	Passivos - Não precisam de alimentação e geram uma onda sinusoidal com arcadas positivas e negativas (Figura 14); Também são chamados de sensores inductivos; O valor de pico não é fulcral para a detecção dos impulsos, como explicarei mais à frente.
•	Activos - Necessitam de alimentação por parte do controlador de ABS (entre 5V e 12V) mas geram um sinal limitado entre, normalmente, 0,64V e 1,93V de máximo e mínimo, respectivamente (Figura 15); A especificação diz ainda que estes valores não podem ir abaixo de 1,29V de máximo e acima de 0,97V de mínimo; Um exemplo destes sensores são os sensores por efeito de Hall3 4 5.
3	http://www.2carpros.com/articles/how-abs-anti-lock-brakes-work
4	http://www.volkspage.net/technik/ssp/ssp/SSP 264 d2.pdf
5	http://www.picoauto.com/tutorials/bmw-braking-issues.html
O método como o computador central do carro (centralina) actua nas rodas em caso de detecção de algum problema não é significativo para o desenvolvimento deste projecto.
2.5.	Acelerómetros
Por definição, um acelerómetro é um dispositivo electromecánico capaz de fazer corresponder um sinal eléctrico a uma aceleração. Essa aceleração poderá ser estática, no caso da aceleração da gravidade, ou dinâmica, causada por movimentos ou vibrações.
Têm muitas aplicações em vários aparelhos à venda hoje em dia. Uma delas está nos telemóveis (Figura 16) onde permitem, entre outras coisas, detectar a inclinação do ecrã face à Terra e colocar a imagem do mesmo na posição correcta. São também utilizados em discos rígidos de portáteis para detecção de acelerações bruscas, permitindo que o disco se proteja em caso de queda.
Figura 16 - Exemplo de utilização de acelerómetro em telemóvel para determinar orientação do ecrã
Existem vários métodos de funcionamento:
•	Piezoeléctricos;
•	Piezoresistivos;
•	Variação de capacidade;
•	Bolhas de ar quente;
•	Luz.
A saída do acelerómetro pode ser digital, analógica ou as duas simultaneamente.
No primeiro caso existe um barramento de saída, normalmente baseada num protocolo série, que permite que o utilizador leia os valores de aceleração dos registos internos do acelerómetro.
Se o interface for analógico será necessário recorrer a uma ADC com um número de canais pelo menos igual ao número de eixos do acelerómetro, já que a informação da aceleração de cada eixo será colocada em uma saída específica em formato analógico.
3.	Execução prática
Como apontado anteriormente (1.5), foi necessário desenvolver quatro componentes para o
sistema:	•	Comando; •	Módulo do carro; •	Módulo programador; •	Software de programação para Windows.
3.1.	Escolha dos elementos electrónicos
Na escolha de todos os elementos foi tido em conta o ambiente onde estes terão de operar, todos os elementos do módulo do carro existem em packages com especificações de temperatura adequadas para funcionamento no interior de uma viatura (no mínimo de -40 a 85°C).
Não foi utilizado um kit de desenvolvimento, o processo de desenvolvimento de todos os componentes passou por uma fase em placa branca e só depois foi desenvolvida a PCB final.
3.1.1.	Elementos comuns utilizados
Existem dois elementos base que todos os componentes do sistema possuem em comum:
•	Microprocessador;
•	Módulo de comunicação ZigBee.
3.1.2.	Microprocessador (CPU)
O processador escolhido para ser utilizado em todos os componentes do sistema foi um PIC18F26K206 da Microchip, a funcionar com o relógio interno a 16Mhz.



Figura 17 - Microchip PIC 18F26K20
6	http://www.microchiD.com/wwwDroducts/Devices.aspx?dDocName=enQ26332
A partir deste momento utilizarei a sigla CPU para me referir a este elemento em particular.
As razões para a escolha deste microcontrolador foram as seguintes:
•	São bastante baratos (menos de €5) e fáceis de obter;
•	Oferecem possibilidades de poupança de energia que os concorrentes não conseguem oferecer, nomeadamente o menor consumo de energia em modo Sleep (parte do processador desligado, apenas com as funções vitais a funcionar) que foi possível encontrar;
•	Tem um relógio interno com uma velocidade interessante (16MHz), o que evitou a utilização de cristais extra em todos os módulos; A velocidade de relógio do processador é importante que seja próxima dos 20MHz (a frequência de trabalho dos módulos ZigBee) de modo a que, principalmente no cartão, se evitem tempos de espera por informação na comunicação entre os dois elementos; Não convém que seja muito superior a 20MHz porque seria um desperdício de energia, o processador tornar-se-ia excessivamente rápido e o módulo ZigBee não seria capaz de acompanhar;
•	O comprimento de palavra (8 bits) é suficiente para o projecto, uma vez que não será necessário efectuar cálculos complexos nem, geralmente, utilizar variáveis com tamanho superior; Adicionalmente, a performance deste tipo de processadores em cálculos que requeiram variáveis com mais bits é mais do que suficiente, e os protocolos SPI e I C funcionam com transmissões de 8 bits.
•	Existe numa grande variedade de configurações de pinos (com e sem pinos, DIP e SMD), o que facilitou o desenvolvimento e debug de todas as aplicações, para além de permitir que o produto final fique o mais pequeno possível sem ser preciso repensar tudo de novo;
•	Tem capacidade de processamento (até 16 MIPS, Milhões de Instruções Por Segundo) e memória interna suficiente (1KByte) para este projecto, excepção feita no caso do módulo do carro em que é necessário guardar o registo de acessos, aí o sistema exigiu a presença de uma EEPROM externa com mais capacidade (1Mbit).
•	Eu estou mais familiarizado com os microprocessadores da Microchip;
3.1.3.	Módulo de comunicação ZigBee
As comunicações ZigBee são levadas a cabo também por módulos da Microchip, exemplares do MRF24J40MA7 (Figura 18) que é um módulo com antena incorporada criado à volta do transceiver MRF24J408 também da Microchip.
Figura 18 - Microchip MRF24J40MA
7	http://www.microchip.com/wwwproducts/Devices.aspx?dDocName=en535967
8	http://www.microchip.com/wwwproducts/Devices.aspx?dDocName=en027752
As razões para a escolha foram as seguintes:
•	A Microchip fornece toda a stack de comunicação ZigBee com funções de transmissão e recepção de mensagens entre nós em modo broadcast, o necessário para o projecto;
•	São bastante baratos (cerca de €8 por unidade) e fáceis de obter, estando disponíveis em vários distribuídores;
•	Contêm todos os componentes necessários à sua operação (cristais, antena e adaptação para a antena);
•	Oferecem excelentes níveis de consumo de energia (na zona dos mW), permitindo ainda que o CPU coloque o transceiver em modo Sleep para poupança de energia extra;
•	São capazes de um alcance suficiente para a função que desempenharão neste projecto (cerca de 2 metros para os cartões e dezenas de metros para o programador).
3.2.	Ambiente de desenvolvimento
3.2.1.	Hardware de programação de microcontroladores PIC
Uma vez que foram utilizados produtos da Microchip, faz todo o sentido que sejam utilizadas ferramentas daMicrochip para o desenvolvimento do projecto.
Figura 19 - IDE MPLAB
Figura 20 - PICkit 3
Para a programação dos CPUs foi utilizado o programador PICkit 39 10(Figura 20), que se encontra perfeitamente integrado no MPLAB (v8.56 foi a utilizada, Figura 19), o IDE de desenvolvimento para microcontroladores PIC da Microchip. O compilador utilizado foi o C18w na sua edição para estudantes, o compilador para PICs 18F também da Microchip e também ele perfeitamente integrado no IDE.
A conjugação PICkit 3, MPLAB e C18 permite, entre outras coisas, compilação do programa escrito e programação imediata do CPU, tudo na mesma aplicação, acelerando bastante o processo de desenvolvimento, e também debug do código dentro do próprio CPU, com visualização do estado de todos os registos e execução instrução a instrução do código.
9	http://www.microchip.com/stellent/idcplg?IdcService=SS GET PAGE&amp;amp;nodeId=1406&amp;amp;dDocName=en538340
10	http://www.microchip.com/stellent/idcplg?IdcService=SS GET PAGE&amp;amp;nodeId=1406&amp;amp;dDocName=en010014
3.2.2.	Preparação
Os passos para ter o ambiente de desenvolvimento a funcionar e o sistema pronto a compilar/programar código do utilizador são os seguintes:
1.	Instalar MPLAB;
2.	Instalar C18;
3.	Incorporar C18 no MPLAB;
4.	Instalar PICkit 3;
5.	Seleccionar o programador no MPLAB.
De seguida é necessário fazer o download da stack de comunicação fornecida pela Microchip11, que incorpora todas as funções necessárias para utilizar eficientemente os módulos ZigBee e até ficheiros de teste que permitem testar a comunicação entre módulos remotos.
Este foi o ponto de partida para este projecto e onde foram dados os primeiros passos e realizados os primeiros testes com tecnologia ZigBee.
Os ficheiros do projecto inicial que foi utilizado podem ser encontrados, depois de devidamente instalada a stack de comunicação, na pasta “Basic Demos/Simple Example”. Aí existem duas pastas, uma para cada nó da rede, mas apenas é necessário utilizar uma, o código é o mesmo para os dois nós que serão criados, a não ser que o hardware utilizado ou a conexão entre o CPU e o módulo ZigBee seja diferente, aí será conveniente utilizar o código de cada pasta para cada nó individual.
Para colocar esta demonstração a funcionar é necessário editar apenas um ficheiro de nome “HardwareProfile.h”, que contém as definições da montagem de hardware realizada pelo utilizador.
Caso se esteja a utilizar um kit de desenvolvimento da Microchip de entre as quatro possíveis (PICDEMZ, PIC18_EXPLORER, EXPLORER16 ou EIGHT_BIT_WIRELESS_BOARD) o processo de configuração resume-se à remoção do comentário apropriado nas seguintes linhas do ficheiro:
#define PICDEMZ
//#define PIC18EXPLORER
//#define RXPLORRR16
//#define EIGHT BIT WIRELESS BOARD_____________________________________________________
É importante não esquecer de comentar as linhas dos kits de desenvolvimento não utilizados. Após este passo e se o hardware estiver todo montado devidamente, estará tudo pronto a funcionar.
Caso o utilizador não utilize um kit de desenvolvimento daqueles quatro, o caso deste projecto, será necessário efectuar o processo de configuração manualmente.
Para simplificar, optou-se por simular o hardware encontrado no kit PICDEMZ, por ser o que mais se assemelhava à montagem que se pretendia utilizar. Basta então ir à secção destinada a esse kit no ficheiro e alterar a configuração de pinos do CPU para que corresponda exactamente à montagem do utilizador. A parte que interessa do ficheiro está entre:
#if defined(PICDEMZ)
#endif
Depois de configurados os pinos, é só ligar à alimentação e testar a montagem. É importante não esquecer que para testar a comunicação sem fios são precisos dois módulos operacionais. Este programa de testes assume isso mesmo, que o utilizador montou dois circuitos com a mesma configuração e com o mesmo programa carregado nos dois CPUs.
11	httD://www.microchiD.com/stellent/idcplg?IdcService=SS GET PAGE&amp;amp;nodeId=2680&amp;amp;dDocName=en547784
Quando tudo estiver a funcionar, o programa implementa a utilização de dois botões para transmissão de mensagens entre os dois nós de dois métodos distintos: broadcast e unicast. O primeiro transmite a mesma mensagem para todos os nós no raio de alcance e o segundo transmite apenas para o primeiro nó que for detectado e que se encontre na lista de endereços do CPU.
O utilizador pode confirmar o funcionamento do sistema de dois modos. Ligando um dos CPUs a um computador através de uma porta RS232 e lendo o que o CPU escreve ou simplesmente pela observação dos dois leds incluidos na montagem, que se acendem e apagam com a recepção de cada mensagem, sendo um led dedicado às mensagens unicast e outro às broadcast.
3.2.3.	A Stack de comunicação da Microchip
A Microchip disponibiliza de modo gratuito a stack de comunicação para utilizar com os seus módulos sem fios. Para a realização deste projecto optei pela stack MiWi, que fornece funções de transferência de informação entre dois dispositivos de um modo simples e rápido, permitindo configurar todos os parâmetros do módulo de comunicação utilizado como potência de transmissão, velocidade e canal de operação, entre outros.
Esta stack está organizada da forma esquematizada na Figura 21. Faz uso dos módulos da Microchip permitindo a sua configuração através das extensões MiMAC e utiliza uma camada de abstracção extra para o desenvolvimento da aplicação chamada MiApp.
Figura 21 - Stack MiWi da Microchip12
O utilizador raramente terá de fazer uso directo das extensões MiMAC, a não ser que seja necessário um grande controlo sobre o protocolo de comunicação, as extensões MiApp fornecem um nível de abstracção dessa camada e fazem uso das suas extensões.
O utilizador terá apenas de desenvolver a camada aplicação, que fica num nível de abstracção acima da camada MiApp e que fará uso das funções disponibilizadas nas camadas abaixo.
3.2.4.	Configuração utilizada
De entre os protocolos disponibilizados na stack de comunicação, foi escolhido o MiWi P2P, por ser o mais simples de utilizar e permitir a troca de mensagens entre dispositivos de um modo directo. Neste projecto não serão utilizadas as funções de criação/adesão a redes do ZigBee, uma vez que a
12	http://www.microchip.com/stellent/idcplg?IdcService=SS GET PAGE&amp;amp;nodeId=2664&amp;amp;param=en520414
maioria do tempo o cartão de identificação não estará no alcance do módulo do carro e o processo de adesão à rede criada pelo mesmo significaria um maior consumo de energia por parte do cartão.
A stack de comunicação escolhida é seleccionada no ficheiro ConfigApp.h removendo o comentário na seguinte instrução:
#defne PROTOCOL P2P
No entanto, continuará a ser utilizado o conceito de rede privada (PAN, Private Area Network), só que todos os módulos estarão na mesma rede, configurada no programa que se carrega para o CPU. A stack MiWi P2P utiliza uma identificação de rede com 4 Bytes, o que significa que poderão existir até 65.536 redes distintas, entre as quais não há troca de mensagens.
Esse parâmetro é configurado também no ficheiro ConfigApp.h na seguinte instrução:
■■define MY PAN ID 0x1234
No programa tem ainda de ser configurado o canal de operação. O módulo MRF24J40MA opera a 2,4GHz e por isso tem disponíveis os canais de 16 a 31, segundo a configuração do mesmo.
Foram realizados testes de comunicação que revelaram que a mudança de canal não alterava significativamente a prestação do módulo, mesmo num regime de funcionamento com mais do que uma rede Wi-Fi a operar numa frequência próxima. Por isso mesmo, optou-se por um canal intermédio, o 25. Esse canal é configurado com a instrução seguinte na aplicação do utilizador:
MiApp SetChannel(25);
Na Tabela 2 estão alguns exemplos das funções disponibilizadas nas camadas MiApp e MiMAC.
MiMAC		MiApp	
MiMAC_Init()	Iniciar módulo ZigBee	MiApp_ProtocolInit()	Configuração inicial do protocolo de comunicação
MiMAC_SetPower()	Definir potência de transmissão	MiApp_SetChannel()	Definir canal de operação
MiMAC_PowerState()	Colocar o módulo ZigBee num estado de consumo de energia	MiApp_BroadcastPacket()	Transmitir conteúdo do buffer de transmissão
Tabela 2 - Exemplos de funções MiApp e MiMAC
3.3.	Software
Figura 22 - Microsoft Visual Basic Express 2010
Para desenvolver o software para PC foi utilizado o Microsoft Visual Studio Express 2010. Este IDE de desenvolvimento da Microsoft permite criar aplicações em Visual Basic para Windows com alguma facilidade, incluindo desde logo bibliotecas para comunicação com a porta de série e para o desenho de interfaces gráficos, dois pontos essenciais para este projecto.
Para além disso existe uma versão para estudante que foi utilizada e que possui grande parte das funcionalidades da versão profissional.
3.4.	Os comandos / unidades identificadoras
O primeiro componente que irei documentar é o comando. No sistema desenvolvido está previsto que possam ser adicionados ao módulo central (a colocar no carro) até 9 comandos identificadores, que podem servir para identificar até 9 utilizadores diferentes perante o sistema de controlo de acessos.
Tem como funções:
•	Identificar um utilizador perante o módulo do carro;
•	Desbloquear o carro em caso de bloqueio.
E é constituído por 3 componentes base:
• CPU;
•	Módulo de comunicação ZigBee;
•	Reed relay.
Os primeiros dois já foram apresentados, o reed relay é um componente que tem como função permitir desbloquear o carro com o comando após um bloqueio.
Figura 23 - Reed Relay utilizado
Trata-se de um interruptor normalmente aberto que pode ser fechado submetendo-o a um campo magnético. Quando o utilizador aproximar um íman do lado do comando indicado para o efeito, este interruptor fecha e o comando transmite um código diferente do habitual, que será discutido já de seguida.
Arranque
Não
Enviar código de identificação
			
Acordar ZigBee		&lt;		Acordar CPU
Sim
Enviar código de desbloqueio
Adormecer ZigBee
WDT terminou?
Não-
Adormecer CPU
Activar Watchdog
Timer (WDT)
V

&gt;

4
Figura 24 - Diagrama de blocos do comando
A função dos comandos é notificar o carro da sua presença na área, pelo que este apenas transmite o seu código para todos os receptores. Quando o módulo do carro recebe uma ID que esteja armazenada na sua base de dados, é aberta ou continuada uma sessão dedicada a esse cartão. Essa sessão tem um tempo de vida de aproximadamente 1 minuto, após o qual essa sessão expira e o módulo do carro toma as medidas necessárias para evitar que o carro continue a movimentar-se.
A transmissão desse código por parte do cartão processa-se de 5 em 5 segundos, um tempo que representa um compromisso entre a duração da bateria pretendida e as necessidades de refrescamento da sessão do cartão perante o carro.
A ID (identificação) de cada cartão é única e permite que o módulo do carro saiba o que fazer em situação de presença, para além do registo de acesso.
Essa ID tem a seguinte forma:
1 Byte de comando
7 Bytes de identificação
e identificação
X X X X X X X	X
Figura 25 - ID de identificação de cada cartão
Cada ‘X’ representa um caracter alfanumérico pertencente ao conjunto {[A...Z],[0...9]}, e cujos códigos ASCII possíveis estão representados na Tabela 3.
Tendo em conta que o último bit da ID utilizada para identificar cada cartão serve para desbloquear a viatura após bloqueio, o número de cartões que poderá ser criado sem reutilizar códigos de identificação será o seguinte:
max-Cartões = 267 x 13 « 1011
São utilizados 7 caracteres de entre qualquer um dos representados na Tabela 3 e mais um caracter de entre todos os caracteres da Tabela 3 tabela com o último bit a zero (que são 13), uma vez que a variante com o bit a um será utilizada para desbloquear a viatura.
Caso a viatura chegue ao estado de bloqueada, o comando, via reed relay, e o software de programação são os únicos meios de desbloqueio da mesma.
No caso do software o desbloqueio é trivial, é só escolher a operação de desbloqueio no programa. Caso não seja possível aceder a um computador com o programa instalado, foi criado um sistema redundante para o efeito, baseado no reed relay do cartão de identificação mencionado em cima.
X	Código ASCII	Último Bit
A	0x41	1
B	0x42	0
C	0x43	1
D	0x44	0
E	0x45	1
F	0x46	0
G	0x47	1
H	0x48	0
I	0x49	1
J	0x4A	0
K	0x4B	1
L	0x4C	0
X	Código ASCII	Último bit
M	0x4D	1
N	0x4E	0
O	0x4F	1
P	0x51	0
Q	0x52	1
R	0x53	0
S	0x54	1
T	0x55	0
U	0x56	1
V	0x57	0
W	0x58	1
X	0x59	0
X	Código ASCII	Último bit
Y	0x5A	1
Z	0x5B	0
0	0x30	0
1	0x31	1
2	0x32	0
3	0x33	1
4	0x34	0
5	0x35	1
6	0x36	0
7	0x37	1
8	0x38	0
9	0x39	1
Tabela 3 - Tabela de caracteres ASCII possíveis para ID dos cartões
3.4.1.	Autonomia esperada
É importante que os comandos tenham uma autonomia interessante (centenas de dias), de modo a evitar situações constrangedoras caso a bateria do comando deixe de ter energia suficiente para que este anuncie a sua presença, o que levaria a um desligar da viatura sem necessidade. Optamos por utilizar baterias recarregáveis do tipo CR2032.
Figura 26 - Bateria recarregavel utilizada
O circuito de carregamento utilizado foi um simples regulador de tensão de 3,3V com uma resistência limitadora de corrente (R10) entre o mesmo e a bateria de modo a evitar o sobreaquecimento da mesma quando em carga, o datasheet da bateria não explicitava restrições ou métodos de carregamento específicos e apresentava a curva de carga da Figura 27.
Charge voltage (V)
Figura 27 - Curva de carga da bateria
Com a poupança de energia em mente, os componentes do comando foram escolhidos de modo a serem bastante eficientes e poupados. O CPU é uma unidade nanoWatt XLP da Microchip, o que significa que é um dos que menos energia consome de toda a gama da empresa, e o módulo ZigBee controlar a potência de transmissão e dispõe de um modo Sleep de baixo consumo.
Para projectar a autonomia estimada do comando foi utilizado o Microchip nanoWattXLP Battery Life Estimator v1.0 (Figura 28), uma aplicação da Microchip criada para o efeito. Foi medida a corrente de transmissão de um cartão e obtido o valor de cerca de 10-12mA para cada transmissão, tendo sido esse o valor introduzido na aplicação.
Para a bateria recarregável escolhida para alimentar o circuito, este programa anuncia uma autonomia em funcionamento contínuo do sistema de 231 dias. A corrente de pico no instante de transmissão do código por parte do cartão ultrapassa a corrente que uma bateria destas será capaz de debitar, pelo que foi adicionado um condensador de apoio à mesma para aliviar a carga na pilha nestas situações.
Figura 28 - Microchip nanoWattXLPBattery Life Estimator v1.0
13	httD://www.microchiD.com/stellent/idcplg?IdcService=SS GET PAGE&amp;amp;nodeId=2680&amp;amp;dDocName=en545243
É importante ter em atenção que o programa tem em conta que o CPU funcionará até aos 1,8V, o que não é o caso do circuito do nosso cartão, uma vez que o módulo ZigBee deixa de funcionar abaixo dos 2,4V. Isto significa que a autonomia não será tão grande quanto este programa anuncia.
No entanto, aparenta ser satisfatória e poderá duplicar se forem utilizadas duas pilhas do mesmo tipo. No entanto, e para não aumentar demasiado o volume do produto final, optei por utilizar apenas uma pilha e fazer uso de outra estratégia para aumentar o tempo de vida útil da bateria.
Para o efeito foi adicionado um botão de on/off ao comando, que permite que o utilizador desligue o comando quando estiver longe da viatura e este não seja preciso. Deste modo o comando apenas consumirá energia durante o período em que o dono esteja perto do carro. Esse botão apenas desactiva o circuito, a pilha pode ser recarregada mesmo com o botão desligado.
Se o dono utilizar o comando durante 8 horas por dia, estamos a falar num aumento da autonomia de 3 vezes (cerca de 2 anos), uma vez que o comando ficará operacional apenas um quarto do dia.
Adicionalmente, o comando poderá ser ligado a qualquer porta USB de qualquer computador para recarregar a bateria, sendo para isso utilizada uma porta mini-USB no comando. Esta facilidade adicional permite que a pilha do comando dure praticamente durante o tempo de vida da viatura.
3.5.	O módulo do carro
De longe o componente mais complexo de todo o sistema ao nível de software, o módulo do carro é o componente mais importante de todo o sistema, é dele que depende o sucesso ou não dos algoritmos aplicados para detectar uma situação de carjacking.
Tem como funções:
•	Detectar a presença de cartões na vizinhança;
•	Actuar na viatura em caso de não detecção de nenhum cartão;
•	Registar a presença de cada cartão na base de dados, para verificação posterior.
E é constituído por até 5 componentes base:
•	CPU;
•	Módulo de comunicação ZigBee;
•	Relógio - RTC (Real-Time Clock) da Maxim com cristal incluído e comunicação por I2C, cuja função é fornecer a data para o registo de acessos; É o único elemento alimentado pela bateria recarregável colocada neste módulo, todos os outros não estão alimentados quando o utilizador desliga a viatura.
•	EEPROM externa - Memória não volátil de 1Mbit da Microchip com comunicação SPI;
•	Acelerómetro (opcional) - Dispositivo com capacidade de detectar acelerações.
3.5.1.	Detecção de cartões
Cada comando identificador tem uma ID associada a si, ID essa que é transmitida periodicamente para todos os receptores no alcance. Quando recebe uma transmissão com 8 Bytes, o módulo do carro sabe automaticamente que é de um cartão de identificação, o sistema foi projectado para que não haja outro tipo de comunicação que envolva a troca de 8 Bytes de informação.
Recebida a ID do comando, resta compará-la com as IDs armazenadas na memória não volátil interna do CPU, cuja organização pode ser consultada no apêndice 0.
Ficou definido no firmware do módulo do carro que o sistema apenas pode armazenar 9 IDs de cartões no seu interior, mais uma vez este número é um compromisso entre o espaço disponível na memória do mesmo e as condições reais em que o sistema será utilizado, 9 cartões de identificação serão suficientes na esmagadora maioria das situações.
De modo a poupar esta memória, que tem um limite de escrita baixo quando comparado com a memória volátil (RAM), a informação dos cartões apenas é alterada quando acontece alguma alteração digna de registo (remoção ou adição). Para fazer as comparações entre as IDs recebidas e as armazenadas é utilizada uma cópia da informação dos cartões que se encontra na RAM.
3.5.2.	Actuação na viatura
No diagrama de estados da Figura 29 estão representados os tipos de actuação que foram implementados, bem como em que situações são utilizados.
O sistema verifica constantemente se há sessões iniciadas (Figura 29). Se houver significa que o carro não está bloqueado e que também não é para bloquear, uma vez que um cartão válido está no raio de alcance e tem sessão iniciada no módulo do carro.
Se não houver, existem três opções distintas de actuação.
As linhas a tracejado representam as hipóteses possíveis, das quais apenas uma estará activa num determinado sistema.
Figura 29 - Diagrama de estados do sistema gestor do bloqueio do carro; A verde está destacado o estado de partida
O módulo do carro está constantemente a medir distância, tempo ou a actividade do acelerómetro incluído, actuando quando um evento pré-definido acontecer. O tipo de eventos a que o carro responde será uma opção pré-montagem, o que significa que cada sistema apenas actuará de um dos modos mencionados de seguida, e que essa opção será feita no hardware.
Por exemplo, ou se desliga o carro após a distância pretendida ou após um certo tempo, não os dois ao mesmo tempo. No entanto, para evitar que o carro pare imediatamente após ter sido detectado movimento, é utilizado o mesmo temporizador da versão apenas com base no tempo para contar o tempo a partir da detecção de movimento, esta é a única ocasião em que são utilizados dois métodos em simultâneo.
Cada linha a tracejado representa umas das hipóteses para decidir quando desactivar o carro.
•	Por distância - É utilizado o sinal de ABS para medir distâncias, o que significa que nem todos os carros poderão implementar esta forma de actuação;
•	Por tempo - O CPU do módulo do carro conta o tempo passado após o fecho da última sessão, bloqueando a viatura no final do tempo pré-estabelecido (2 minutos); A contagem dos tempos é realizada apenas quando a viatura estiver em funcionamento; Caso o condutor desligue a mesma, a contagem continuará assim que esta seja ligada novamente.
•	Por movimento e tempo - O acelerómetro incluído no módulo do carro (caso seja requerido para o funionamento) permite determinar quando o veículo se começou a mover após o fim da última sessão iniciada, altura em que se começa a contar o tempo para o bloqueio da viatura (2 minutos).
Isto significa que o caso da actuação por distância, o carro parará após uma distância programável, função do número de impulsos de ABS por segundo (directamente relacionados com a dimensão do pneu e com o carro em questão) mais no máximo 1 minuto, se tiver sido prolongada ou iniciada uma sessão no momento antes do furto da viatura.
No caso da actuação por tempo passa-se a mesma coisa, o carro parará no máximo 3 minutos depois de se ter deixado de detectar um cartão.
O método mais difícil de implementar numa viatura será o do acelerómetro, uma vez que implica que a sessão termine e que haja uma aceleração para que o sistema actue, algo que eventualmente acontecerá numa travagem ou num arranque mais rápido, mas que não pode ser previsto exactamente quando irá acontecer.
Este método terá mais uso na adaptação deste sistema à protecção de outros objectos como malas, que serão brevemente abordados na secção de outras utilizações para o sistema, mais à frente.
3.5.3.	Obtenção do sinal de ABS
Uma vez que existem dois tipos de sensores de ABS, foi necessário desenvolver acondicionadores de sinal para ambos.
No caso dos sensores passivos (sinal gerado é analógico, sinusoidal e possui arcadas negativas e positivas de igual amplitude) o circuito utilizado para obter o sinal digital para ser medido no CPU foi o da Figura 30.
Figura 30 - Circuito utilizado para obter sinal de ABS de sensor passivo
A saída do opamp será saturada positiva nas arcadas positivas e zero nas arcadas negativas, dando ao CPU a possibilidade de obter o número de impulsos. É simples perceber agora porque é que a amplitude do sinal sinusoidal não é decisiva no bom funcionamento do circuito de detecção. O opamp saturará para um dos lados assim que uma das entradas se torne maior do que a outra, não precisando este valor de ser muito elevado para que tal aconteça.
Para os sensores activos (sinal entre 0,97V e 1,29V, no mínimo), o sinal já é digital, só lhe falta um pouco de ganho para ficar dentro da escala que o CPU utiliza (cada impulso é contado quando o sinal passar de 1,65V, que é metade da tensão de alimentação). Optei por um ganho perto de 1,5, que colocará o mínimo no máximo em 1,455V e o máximo no mínimo em 1,935V. O circuito utilizado foi o da Figura 31.
Figura 31 - Circuito utilizado para obter smal de ABS de sensor activo
A saída do opamp será uma onda idêntica à de entrada, amplificada do seguinte valor de ganho. F^=1 + 22fc = 1457/7
vSensor
Antes da instalação do sistema será necessário saber que tipo de sensor é utilizado no carro e ainda fazer uma estimativa para o cálculo do número de impulsos por volta, valor que terá de ser programado no módulo do carro para ser utilizado posteriormente no cálculo da distância percorrida.
A programação desse valor é feita na constante ABS_MAX que se encontra no ficheiro abs.h contido na pasta “Microchip/Include” do código criado durante este projecto:
#ifndefABS_MAX
#define ABSMAX NUMERO
#endif
3.5.4.	O acelerómetro
O acelerómetro é utilizado para detectar o movimento da viatura.
3.5.4.1.	Escolha do acelerómetro
As forças a que está submetido uma viatura comum raramente excedem 1-2g numa utilização normal, podem surgir forças maiores em travagens muito fortes em viaturas com pneus de alta gama e suspensão desportiva, mas isso raramente acontece numa estrada pública.
Por isso foi escolhido um acelerómetro com uma gama de medição de +/-2g, da Analog Devices, uma unidade ADXL327, representada na Figura 32, passível de ser alimentado a 3,3V e com saídas analógias para medição com a ADC do CPU.
u u
15	14
ADXL327
XOUT
NC
YoüT
NC
Figura 32 - Acelerómetro utilizado (ADXL327)
Quando não houver nenhuma sessão iniciada, o módulo do carro faz uma medição inicial da posição dos três eixos do acelerómetro, servindo esses valores de referência para as medições seguintes.
Após essa medida inicial, o sistema continua a efectuar medidas sucessivas até detectar uma variação em qualquer dos eixos.
Essa variação foi configurada para assinalar variações de % de g (% da aceleração da gravidade, 0,25g), um valor que foi considerado adequado tendo em conta a aceleração normal de uma viatura.
Por exemplo, um carro que acelere até aos 100Km/h (27,7m/s) em 10 segundos, acelera a uma força que é dada pela equação seguinte:
7(m/s)
aceleração =-----
9
Z1J
10"	2,77	9
----=------= 0,28a, com lg = 9,8m/s2
9,8	9,8	y y	'
Na travagem as forças a que o carro está submetido são ainda maiores, pelo que não deverá haver problemas na detecção que se espera efectuar.
Esses 0,25g, com a ACD de 10 bits do CPU configurada com a maior escala (0-3,3V, 0-1.024) e com o acelerómetro a fazer corresponder 1g com 420mv, correspondem a cerca 33 divisões da mesma, como justificado nas expressões seguintes.
3,2mV por divisão da escala da ADC
420	1
—— = 105m7 para — g
105
yy = 32,8 divisões da escala da ADC
Após detecção de movimento (Figura 29), começa a contagem dos 2 minutos para o bloqueio do carro, e a partir daqui o sistema comporta-se como se estivesse a funcionar apenas com tempo, o que significa que pode passar para o estado de sessão inicada se algum cartão válido for detectado.
3.5.5.	Registo de acessos
O módulo do carro possui uma EEPROM externa ao CPU com 1Mbit (128KBytes) de capacidade. Esta memória é utilizada pelo CPU via SPI e será utilizada para armazenar o registo de acessos ao carro.
Figura 33 - Diagrama de estados do registador de acessos; A verde escuro está destacado o estado de partida
Em cada detecção validada de cartão (com correspondência na base de dados de cartões) que o módulo do carro faça, é sempre feita uma verificação de existência de sessão iniciada anteriormente por parte desse cartão.
Quando um cartão é detectado, caso exista uma sessão já aberta por esse cartão, a mesma é estendida por mais 1 minuto, sem ser feito um novo registo de acesso. Este detalhe permitiu poupar imenso a memória externa e criar uma noção de verdadeira sessão. Caso não exista sessão aberta desse cartão, é adicionado um novo registo de acesso com a marca de entrada.
Sempre que uma sessão termina ou é iniciada, é adicionado um registo de acessos na memória externa. Este registo inclui a data e hora, o número do cartão envolvido e ainda o tipo de registo. Cada registo ocupa 32 bits na memória externa, tendo sido dividido da seguinte forma.
◄---------------------------------------------------------------------32 bits-----------------------------------------------------------------►
------------Registol----------------------------Registo2----------------------------Registo3----------------------------Registo4------------►
◄-------#	◄---------Dia
► Mes&amp;lt;
Ano
►	Hora	&lt;
◄Ek
Minuto
Figura 34 - Formato de um registo de acesso guardado na memória externa
Significado dos campos:
•	# (4 bits) - Número do cartão a que se refere o registo;
•	Dia (5 bits), Mês (4 bits), Ano (7 bits), Hora (5 bits) e Minuto (6 bits) - Data e hora de registo;
•	E (1 bit) - Tipo de registo (entrada ou saída).
Os valores de cada campo podem ser obtidos realizando operações elementares sobre os 32 bits. No entanto, a comunicação com a memória externa processa-se Byte a Byte, o que significa que é preciso ler os 32 bits em 4 etapas e juntar os dados depois.
•	# = Regis to 1 &gt;&gt; 4
•	d i a = ( R e g is t o 1 &amp;amp;. 0 x0 F)&amp;lt;&amp;lt;1 | ( R e g is to 2 &gt;&gt; 7)
•	m e s = ( R e g i s t o 2 &amp;amp;. 0 x 7 8) &gt;&gt; 3
•	ano = ( R e g is to 2 &amp;amp;. 0x 0 7 )&amp;lt;&amp;lt;4 |	( R e g is t o 3	&gt;&gt; 4)
•	Fo r a = ( R e g is t o 3 &amp;amp;. 0x 0 F)&amp;lt;&amp;lt;1	| ( R eg is to 4	&gt;&gt;	7 )
•	mi nu to = ( R e g is to 4 &amp;amp;. 0x 7F) &gt;&gt;	1
•	tip o = R e g is to 4 &amp;amp;. 0x 0 1
O processo de gravação de um registo é precisamente o inverso, pegar nos campos e separá-los devidamente nos 4 registos prontos para gravação.
•	R e g is to 1	= ( #&amp;lt;&amp;lt;4) | ( d ia &gt;&gt; 1)
•	R e g is to 2	= ( d i a&amp;lt;&amp;lt;7) | (mes&amp;lt;&amp;lt;3 ) |	(	ano &gt;&gt;	4)
•	R e g i s t o 3	= ( an o&amp;lt;&amp;lt;4) | ( F o r a &gt;&gt; 1 )
•	R e g i s t o4	= ( F or a&amp;lt;&amp;lt;7 ) | (m inu t o&amp;lt;&lt;	1 )	|	t i p	o
Com cada registo a ocupar 32 bits, significa que será possível armazenar até 32.768 registos de acessos nos 131.072 Bytes da EEPROM externa, um número bastante satisfatório.
3.5.6.	Gestão de sessões em detalhe
Timer tem um período T= 0,13 segundos
Cartão 3 inicia
sessão
Início, sem sessões iniciadas
9 posições, uma para cada cartão
Figura 35 - Gestão de sessões em detalhe com exemplo de sessão do cartão 3
Timeout0	Timeout1	Timeout2	Timeout3	Timeout4	Timeout5	Timeout6	Timeout7	Timeout8
0	0	0	0	0	0	0	0	0
Figura 36 - Vector de sessão no estado inicial (sem sessões iniciadas)
A gestão de sessões foi realizada recorrendo a um vector com 9 posições (esquematizado na imagem de cima e na Figura 35) colocado na RAM do CPU, uma para cada cartão que é possível instalar. O valor por defeito de cada elemento desse vector é 0 (zero), valor esse que é também utilizado para indicar que ainda não foi iniciada nenhuma sessão.
TimeoutO Timeoutl Timeout2 Timeout3			Timeout4	Timeout5	Timeout6	Timeout7	Timeout8
0 1	0	0	0	0	0	0	0
Figura 37 - Vector de sessão imediatamente após detecção do cartão 2
Assim que o cartão seja detectado a primeira vez (sem ter sessão iniciada), o valor do elemento correspondente à posição onde a ID desse cartão está guardada em memória é incrementado.
A partir do momento em que esse valor deixa de ser 0 (zero), o timer 3 do CPU está programado para o incrementar e verificar o seu valor em cada overflow, na sua função de interrupt.
Caso o mesmo comando seja detectado novamente, o valor da posição dedicada a esse comando no vector de sessão será colocado a 1, indicando que a sessão acabou de ser reiniciada.
Se passado o minutos definido o comando não for detectado novamente, a sessão é terminada e é guardado o registo na memória externa.
Essa detecção é feita recorrendo a uma constante (TIMEOUT_MAX) com o número de vezes que o timer 3 tem de fazer overflow para corresponder a 1 minuto de contagem.
TimeoutO	Timeoutl	Timeout2	Timeout3	Timeout4	Timeout5	Timeout6	Timeout7	Timeout8
0	916	0	0	0	0	0	0	0
Figura 38 - Vector de sessão imediatamente antes do final de sessão do cartão 2
O timer 3 conta até 65.536 (16 bits) e foi configurado com um prescaller de 8, o que lhe dá um período de relógio efectivo de:
T = 16Mhz = 7fÃH~z = 0,1315
4 x 8 x 216
O que significa que para obter uma contagem de tempo de 1 minuto é preciso que o timer conte até ao final da sua escala o seguinte número de vezes:
2 x 60
TIMEOUT MAX =----------= 458
0,131
Para assinalar o final de sessão de um cartão, a posição do vector de sessão dedicada a esse cartão é colocada a 0 (zero), tal como está indicado na Figura 25, e o timer 3 deixa de incrementar esse valor.
3.6.	O módulo de programação
O módulo de programação permite configurar o módulo do carro de um modo simples e prático, sem ser preciso mexer ou ligar alguma coisa à viatura.
Este módulo faz a ponte sem fios entre o software de programação desenvolvido e o módulo do carro, funcionando como um interpretador de comandos por porta de série do lado do software e como receptor de respostas do lado do módulo do carro.
Este módulo é constituído pelos seguintes componentes:
•	CPU;
•	Módulo de comunicação ZigBee;
e
Conversor USB-RS232 (USB-Série) com regulador de 3,3V para alimentação do circuito.
Para tornar o módulo o mais simples possível, foi escolhido um conversor USB-Série capaz de alimentar o circuito, evitando que seja necessária alimentação externa extra.
As funcionalidades do módulo de programação são as seguintes:
•	Acertar a hora do módulo do carro;
•	Adicionar cartões;
•	Remover cartões;
•	Forçar bloqueio da viatura;
•	Desbloquear viatura;
•	Consultar registo de acessos;
•	Apagar registo de acessos.
Todas estas funções estão estritamente ligadas ao software desenvolvido para Windows, pelo que serão descritas na secção 3.7.
O esquema eléctrico e a PCB deste componente podem ser encontrados no apêndice III.C.3.
3.7.	A aplicação para Windows
Para simplificar o processo de configuração do módulo do carro, foi desenvolvida uma aplicação para o sistema operativo Windows em Visual Basic. Esta aplicação comunica com o módulo de programação via RS232 e este fica encarregue de enviar os comandos de programação e receber as respostas do carro, comunicando posteriormente o que recebeu ao software.
As funcionalidades do software estão directamente ligadas às funcionalidades do módulo de programação, sendo exactamente as mesmas, já descritas na secção 3.6.
3.7.1.	Guia de utilização
Depois de instalada a aplicação no computador, ao executá-la surge o ecrã da Figura 39.
Figura 39 - Janela principal da aplicação
Depois de ligado o módulo de programação ao PC, é necessário clicar em Ficheiro-&gt;Iniciar, como se pode observar na Figura 40.
Figura 40 - Iniciar o trabalho na aplicação
De seguida é pedido que se escolha um ficheiro de log (Figura 41), onde ficará registada toda a actividade da aplicação, para mais tarde poder ser revista caso seja necessário. O ficheiro de logo tem de ser um ficheiro de texto, o conteúdo gerado durante a utilização do programa será anexado a qualquer outro conteúdo que o ficheiro já tenha.
Figura 41 - Escolher ficheiro de log para a aplicação
Após o período inicial de configuração, a aplicação estará pronta para começar a funcionar, sendo este (Figura 42) o primeiro ecrã que o utilizador encontrará em caso de sucesso dos testes de conectividade iniciais, tanto com o módulo de programação como com o módulo do carro.
Caso algum destes testes falhe, será pedido ao utilizador que tome medidas para corrigir o erro, sendo possível repeti-los a qualquer altura na aplicação.
Figura 42 - Ecrã inicial da aplicação depois de testes de conectividade
O passo seguinte é adicionar um cartão ao módulo do carro, para isso basta carregar no botão adicionar ou na barra de menu em Cartões-&gt;Adicionar. Surge no ecrã uma nova janela para o utilizador introduzir a ID inscrita no cartão (Figura 43). Esta ID será a ID que identificará o cartão perante o carro e será única de cada cartão. A introdução terá de ser feita com o teclado, daí a necessidade de os caracteres utilizados nestas IDs serem acessíveis deste modo.
Figura 43 - Adicionar cartão
Após ter introduzido a ID do cartão (a aplicação corrige automaticamente as letras minúsculas, a ID é constituída apenas por letras maiúsculas e números), quando carregar no botão adicionar a operação
de envio para o carro terá lugar. Caso a operação seja bem sucedida, o utilizador verá o ecrã da Figura 44. Neste caso adicionei o cartão com a ID ‘ABCDEFGH’, aquele que utilizei para testes. Destacar o facto de o último Byte da ID introduzida ser uma das que termina com um bit a zero, estando dentro do estipulado.
Figura 44 - Cartão adicionado com sucesso
Nesta altura o cartão ainda não terá nenhum efeito sobre o carro (a não ser que o método de actuação escolhido tenha sido o tempo, nesse caso o cartão desbloqueará a viatura sem nenhuma acção do utilizador e o passo seguinte é redundante), uma vez que este se encontra bloqueado, como é indicado nas figuras anteriores pela bola vermelha no canto superior direito. É portanto necessário, caso seja essa a vontade do utilizador, desbloquear o carro.
Figura 45 - Carro desbloqueado com sucesso
O carro encontra-se agora no estado de espera, sem nenhuma sessão iniciada, o seu estado seguinte depende do tipo de sistema que estiver instalado, com acelerómetro, ABS ou tempo. Se o sistema apenas actua baseado no tempo, se dentro de 2 minutos não for detectado um cartão o carro volta a ser bloqueado, sendo desbloqueado quando detectar novamente um cartão.
De seguida convém acertar a hora do módulo do carro, só para garantir que os registos de acesso ficam com a hora correcta. Essa operação pode ser executada escolhendo a opção respectiva no menu Carro-&gt;Acertar Hora (Figura 46).
Figura 46 - Acertar hora do módulo do carro
Está tudo pronto a funcionar, o carro começará a registar os acessos como descrito no ponto 3.5.5 e a gerir as sessões de acordo com o definido no ponto 3.5.6. Os registos de acessos podem ser consultados ou apagados clicando no menu respectivo na barra de menu.
Na está um exemplo de um registo de acessos com 3 acessos registados para o cartão na posição 1, uma sessão de 1 minuto já terminada e outra sessão com início mas ainda sem fim.
Figura 47 - Exemplo de registo de acessos
3.8.	Interacção entre o módulo do carro, o módulo de programação e o software
Como mencionado anteriormente, o módulo de programação e o software comunicam através de uma porta de série, e o módulo de programação envia e recebe os dados para o carro via ZigBee.
De um modo simples, para um comando que requeira um ACK (acknowledge, resposta positiva), a comunicação processa-se do seguinte modo:
Carro
Aplicação
Programador
-----exemplo---------------1 T
Receber Comando
Enviar Resposta
-------ACK--------------1
Figura 48 - Exemplo de comunicação entre aplicação de programação e carro

De notar dois factores importantes:
•	Os comandos trocados entre os vários módulos são case-sensitive, o que significa que é diferente enviar um ‘a’ ou um ‘A’, por exemplo;
•	As linhas a tracejado indicam comunicação sem fios via ZigBee.
Outra convenção estabelecida durante a descrição dos processos de comunicação foi a seguinte:
•	ACK - Resposta é um ‘s’;
•	NACK - Resposta é um ‘n’.
Sempre que o módulo à espera de resposta receba um ‘n’ significa que ocorreu um erro. Em ambos os casos e na maioria das situações, foi ainda estabelecido que a seguir ao símbolo de ACK ou NACK virá o comando que gerou essa resposta, na mesma transmissão, permitindo assim confirmar o comando que está com problemas. Esta situação ficará mais clara de seguida, quando os comandos possíveis forem explicados em detalhe.
Uma lista simplificada de todos os comandos que foram implementados na aplicação e que são descritos de seguida pode ser encontrada no Apêndice III.B.
3.8.1.	Teste da conectividade com o módulo de programação
Eis o primeiro e mais simples exemplo real de um comando implementado na aplicação e no programador. Quando o utilizador carregar no botão para testar a conectividade com o módulo de programação, a aplicação envia para a porta de série o caracter ‘t’ e espera 2 segundos por uma resposta.

Aplicação
Programador
Se essa resposta vier (Figura 50), será certamente positiva (o programador não vai responder a dizer que não está contactável, como é óbvio). Se a resposta não vier (Figura 49), a aplicação assume que o programador não está contactável e informa o utilizador.

Aplicação
Programador
Figura 50 - Teste de conectividade com o programador (sucesso)
A resposta está no formato discutido anteriormente e pode dividir-se em duas sub-respostas:
•	‘s’ - A resposta foi positiva (ACK);
•	‘t’ - Ao comando de testar conectividade com o programador.
A principal causa de uma possível falha na resposta é uma falha na porta de série, seja por se ter escolhido a porta errada no software ou por o módulo não estar ligado convenientemente ao computador.
3.8.2.	Teste da conectividade com o carro
Passado o teste de conectividade com o programador, resta testar a conectividade com o módulo do carro. Esta operação já envolve uma resposta do módulo do carro, o que permite testar se o carro está ou não no raio de alcance do programador.
Quando o utilizador carregar no botão para testar a conectividade com o carro, a aplicação envia para a porta de série o caracter ‘c’, que é reencaminhado pela ligação sem fios para o módulo do carro. A aplicação espera de seguida 2 segundos por uma resposta.
Carro
Aplicação
Programador
Enviar		w.	Receber Comando
Comando			Reencaminhar
— —\
V
Não Recebe
Comando

X
Figura 51 - Teste de conectividade com o carro (falha)
Se não houver resposta (Figura 51), o carro estará ou fora de alcance ou com algum problema, não sendo possível distinguir entre as duas possibilidades sem analisar o módulo do carro.
Figura 52 - Teste de conectividade com o carro (sucesso)
Mais uma vez, a resposta estrá no formato escolhido:
•	‘s’ - A resposta foi positiva (ACK);
•	‘c’ - Ao teste de conectividade com o módulo do carro.
O carro responde afirmativamente ao pedido do programador (Figura 52) e este reencaminha essa resposta para a aplicação, que notifica o utilizador.
3.8.3.	Adicionar um cartão à base de dados do módulo do carro
Depois de ambos os testes anteriores terem sido completados com sucesso, a aplicação passa a permitir interagir com a informação que está armazenada no módulo do carro.
O passo seguinte numa primeira instalação do sistema é adicionar um cartão à base de dados, para que este possa servir como desbloqueador para o carro, evitando que este se bloqueie enquanto o possuidor do cartão estiver por perto.
Para adicionar um cartão o utilizador escolhe a opção para esse efeito na barra de menu da aplicação, que abre uma nova janela de seguida. Nessa janela o utilizador insere a ID que consta no cartão e clica em adicionar, dando-se início ao processo de adição do cartão.
A aplicação envia para o programador o comando ‘axxxxxxxx’, em que ‘xxxxxxxx’ representa os 8 Bytes da ID do cartão, que comunica ao carro a sua intenção de adicionar um novo cartão.
Carro
Aplicação
Programador
axxxxxxxx------------1
*
Receber Comando
Enviar Resposta
—na-------1
Figura 53 - Adicionar cartão (falha)
A aplicação mantém em memória o número de cartões instalados e as suas IDs e não permite que seja adicionado um novo cartão quando o número de cartões tiver atingido o máximo estipulado (9), mas se por algum motivo o utilizador tentar adicionar um décimo cartão, a resposta do módulo do carro será um NACK (Figura 53), e o cartão não será adicionado.
axxxxxxxx------------1
¥
Receber Comando
Enviar Resposta
—sa
Figura 54 - Adicionar cartão (sucesso)
Se a resposta for positiva (Figura 54), tanto a aplicação como o módulo do carro actualizam a base de dados de cartões e o número de cartões é incrementado.
3.8.4.	Obter o número de cartões na base de dados do módulo do carro
Sempre que se inicia a aplicação, e depois de testar a conectividade com ambos os módulos, é necessário saber quantos cartões estão guardados na memória do módulo do carro, por uma questão de sincronização.
Quando o utilizador escolhe a opção de obter número de cartões na aplicação, esta inicia a comunicação com o programador enviando o caracter ‘b’. O programador reencaminha a instrução para o carro via ZigBee e aguarda a resposta do carro. A aplicação espera durante 2 segundos antes de assumir que alguma coisa correu mal e mostrar um erro.
Em caso de sucesso (Figura 55), o carro responde com o comando ‘b#’, em que ‘#’ é o número de cartões instalados, um número entre 0 e 9. Neste caso não faz sentido haver ACK uma vez que é exigida uma resposta específica por parte do carro, o ACK pode ser substituído pela verificação da conformidade da resposta recebida com o que se esperava receber.
Aplicação	Programador	Carro

Figura 55 - Obter número de cartões na base de dados do carro (sucesso)
Caso algo aconteça que impossibilite o módulo do carro de enviar o número de cartões, este responderá com o NACK estabelecido (Figura 56), ‘nb’, que identifica que ocorreu um erro no processamento da instrução ‘b’.
Figura 56 - Obter número de cartões na base de dados do carro (falha)
3.8.5.	Remover um cartão da base de dados do módulo do carro
Remover um cartão é um processo idêntico ao de adicionar, só que em vez de enviar para o carro a string com a ID do cartão a remover, envia-se o número de identificação do cartão de entre os 9 possíveis. Uma vez que as bases de dados do carro e da aplicação são sincronizadas no arranque, os cartões estão nas mesmas posições em ambos os dispositivos.
A remoção do cartão é iniciada enviando para o carro o comando ‘r#’, em que ‘r’ identifica a instrução a executar e ‘#’ o número do cartão a remover. Em caso de sucesso (Figura 57) o módulo do carro responde com o ACK esperado.
Após o envio do comando a aplicação aguarda 2 segundos antes de decidir que ocorreu um erro na comunicação e que a remoção não aconteceu com sucesso.
Carro

Aplicação
Programador
Figura 57 - Remover cartão da base de dados do módulo do carro (sucesso)
i
Receber Comando Enviar Resposta
sr
Caso o número do cartão que se pretende remover seja inválido (não exista na base de dados), o módulo do carro responde com o NACK esperado (Figura 58).
Carro
Aplicação
Programador
Figura 58 - Remover cartão da base de dados do módulo do carro (falha)
—r#
Y
Receber Comando
Enviar Resposta
—nr
3.8.6.	Obter ID de um cartão na base de dados do módulo do carro
Obter a ID de um cartão em particular é um processo idêntico ao de remover um cartão na fase de envio de instrução para o carro, a diferença está na altura de receber a resposta.
Também neste caso não é necessária a recepção de um sinal de ACK, uma vez que a resposta do carro tem de vir num formato pré-determinado. Em caso de sucesso (Figura 59) a resposta será ‘ixxxxxxxx’ em que ‘i’ identifica que tipo de resposta é, e ‘xxxxxxxx’ é a ID do cartão escolhido.
Aplicação
Programador
7
Carro
r’
Figura 59 - Obter ID de cartão armazenado na base de dados do módulo do carro (sucesso)
Em caso de falha (Figura 60), a resposta serão um NACK com o formato esperado. Mais uma vez, a aplicação espera 2 segundos antes de declarar a operação como falhada e mostrar um erro.
Aplicação	Programador	Carro
■v	r
Figura 60 - Obter ID de cartão armazenado na base de dados do módulo do carro (falha)
A obtenção de todos os cartões armazenados no carro é um processo iterativo em que o software requisita uma ID de cada vez ao carro.
3.8.7.	Verificar estado de bloqueio do carro
A aplicação permite ainda verificar em que estado de bloqueio se encontra a viatura em qualquer instante, com um simples clicar num botão.
O comando para o efeito é ‘de’, enviado pela aplicação ao módulo programador e por este ao carro via ZigBee. Em caso de sucesso no processamento (Figura 61), a resposta será ou ‘c’ (closed) ou ‘o’ (open). A aplicação espera 2 segundos por uma resposta do carro.

-----de-----------1
-----c/o------------'
Figura 61 - Obter estado de bloqueio do carro (sucesso)
V
Receber Comando Enviar Resposta
Caso algo corra mal do lado do módulo do carro (Figura 62), a resposta será um NACK com o formato esperado.
Aplicação
Programador
Figura 62 - Obter estado de bloqueio do carro (falha)
—de—
—nd—
3.8.8. Bloquear ou desbloquear carro
Carro
r
i
Receber Comando Enviar Resposta
Para bloquear ou desbloquear o carro, os comandos são mais uma vez semelhantes, sendo agora esperado um ACK com identificação da operação que foi bem sucedida. A aplicação envia o comando para o programador e espera 2 segundos por uma resposta.
Em caso de sucesso (Figura 63 e Figura 64), o carro responde com o ACK esperado, que identifica o sucesso da operação e a operação efectuada.
Carro
Aplicação
Programador
Figura 63 - Bloquear viatura (sucesso)
—db----------------1
¥
Receber Comando
Enviar Resposta
sb-------------•
Figura 64 - Desbloquear viatura (sucesso)
- -dd- -
—sd—
i
Receber Comando Enviar Resposta
Caso não seja possível bloquear/desbloquear a viatura por algum motivo, o módulo do carro responde com o NACK esperado (Figura 65 e Figura 66).
Carro
Aplicação
Programador
Figura 65 - Bloquear viatura (falha)
- -db- -
—nb—
i
Receber Comando Enviar Resposta
Carro
Aplicação
Programador
Figura 66 - Desbloquear viatura (falha)
- -dd- -
—nd—
y
Receber Comando Enviar Resposta
3.8.9. Acertar hora e data do módulo do carro
Cada registo de acesso inclui a informação da data e data a que aconteceu o evento, daí a necessidade de incluir no módulo do carro um dispositivo que seja capaz de servir de relógio em tempo real, estando ali para o CPU obter a informação horária sempre que seja necessário registar algum evento.
Assim que o módulo do carro é ligado pela primeira vez, a hora inicia-se nas 00:00:00 de 01/01/00, sendo necessário proceder ao seu acerto.
O software inclui essa função, sendo apenas necessário escolhê-la para que a hora do módulo do carro seja acertada.
O comando utilizado para o efeito tem o formato:
‘h’ + hora + minuto + segundo + dia + mês + ano
Em que cada elemento é enviado num Byte de dados. A informação para cada campo é obtida do sistema operativo automaticamente.
h+data
—sh—
Figura 67 - Acertar hora do módulo do carro (sucesso)
i
Receber Comando Enviar Resposta
Em caso de sucesso (Figura 67) ou de falha (Figura 68) são recebidos os ACK ou NACK esperados com o formato definido, indicando o sucesso ou falha da operação à aplicação.
Aplicação
Programador
h+data
—nh—
Figura 68 - Acertar hora do módulo do carro (falha)
Carro
\x
i
Receber Comando Enviar Resposta
3.8.10.	Obter número de registos de acesso guardados em memória
Antes de se obterem os registos de acesso propriamente ditos, é necessário saber quantos registos estão guardados em memória, para evitar que a aplicação requisite registos que não existem ainda.
Carro
Aplicação
Programador
X7
-------Rn-----------------1 Y
Receber Comando Enviar Resposta
---Rn##----------•
Figura 69 - Obter número de registos de acesso guardados em memória (sucesso)
A aplicação envia o comando ‘Rn’ para o programador e este comando é reencaminhado para o carro que responde com ‘Rn##’, em que ‘##’ é um número de dois Bytes que representa o número de registos guardados. São precisos 15 bits para representar os 32.768 registos que podem ser guardados na memória, mas são enviados 16 bits uma vez que a transmissão entre módulos ZigBee se processa ao Byte.
Não está prevista uma resposta em caso de falha, uma vez que o número de registos de acessos é apenas um número que o CPU transmite para o programador, não é necessário ler nada de nenhum dispositivo externo que possa falhar.
3.8.11. Apagar registos de acesso
Na aplicação é também possível apagar os registos de acesso armazenados até então. O que o módulo do carro faz na realidade é reiniciar o contador de posição dos registos de acesso guardados, a informação continua lá mas será substituída na próxima passagem por lá, quando o número de registos começar a crescer.
Carro
Aplicação
Programador
Figura 70 - Apagar registos de acesso (sucesso)
- -Ra- -
- -sR- -
i
Receber Comando Enviar Resposta
O comando para o efeito é ‘Ra’, ao que o carro responderá com ‘sR’ em caso de sucesso (Figura 70) ou com ‘nR’ se alguma coisa falhar (Figura 71). Ambas as respostas estão dentro da estratégia de ACK e NACK escolhida anteriormente.
Carro
Aplicação
Programador
Figura 71 - Apagar registos de acesso (falha)
- -Ra- -
- -nR- -
3.8.12. Obter registos de acesso
i
Receber Comando Enviar Resposta
A obtenção dos registos de acesso é a operação que mais memória consome o CPU e representa também a maior transmissão de dados entre o módulo do carro e o programador.
A aplicação não pede ao carro todos os registos de acesso de uma vez, estes são pedidos em blocos de 10, organizados pela ordem em que foram sendo guardados na memória.
O comando para fazer o pedido de 10 registos é ‘Re##’ em que ‘##’ representa o número do registo de começo da leitura. São precisos 16 bits porque, mais uma vez, é necessário endereçar 32.768 registos diferentes.
Carro
Aplicação
Programador
------Re##----------.
- -Re###...###--------•
V
Receber Comando Enviar Resposta
Se a resposta for positiva (Figura 72), será enviado o comando ‘Re’ seguido de 60 Bytes na mesma transmissão. Esses 60 Bytes representam 10 registos de acesso, cada registo ocupa 6 Bytes da transmissão (#, dia, mês, ano, hora e minuto do registo).
Optei por enviar os dados de cada registo desta forma pela maior facilidade que existe em tratar dados binários no CPU do que na aplicação, se fossem enviados os dados como estão guardados na memória seriam utilizados 4 Bytes por registo.
São sempre enviados 60 Bytes de registos para o programador, mesmo que não existam 10 registos guardados na memória. Os registos que não existam vão com os bits todos a ‘1’, uma situação impossível para um registo verdadeiro e facilmente detectável pela aplicação.
Carro

Aplicação
Programador
r
----Re##--------------,
Y
Receber Comando Enviar Resposta
-----ne------------1
Figura 73 - Obter 10 registos de acesso (falha)
Em caso de falha (Figura 73), a resposta será um NACK formatado de acordo com o especificado.
4.	Resultados dos testes no terreno
De seguida apresento os testes realizados e os resultados dos mesmos para verificar o correcto funcionamento dos vários elementos do sistema.
4.1.	Testes em viatura
Os testes ao sistema foram realizados no meu carro, um Renault Clio II de 1999.
4.1.1.	O módulo do carro
Figura 74 - Módulo do carro na placa branca montado no carro para testes
Para tal foi utilizada a versão do módulo do carro ainda na placa branca e um cartão e um programador já com PCB completa. A razão da utilização do módulo ainda na placa branca teve a haver com a complexidade do mesmo, assim testou-se primeiro e só depois se fez a PCB, evitando-se a criação de várias revisões da mesma e poupando recursos.
A placa é alimentada pelo mesmo fio que vem da ignição, o que significa que, tal como se queria, o circuito do módulo do carro apenas será ligada quando o utilizador der à chave, continuando activo enquanto o carro se mantiver ligado.
	Led aceso	Estado do módulo e da viatura
Verde		O carro está operacional; O módulo tem um cartão com sessão iniciada.
Verde + Vermelho		O carro está operacional; Não existe nenhum cartão com sessão iniciada e a contagem decrescente para o bloqueio da viatura está a decorrer; A presença de um cartão válido fará o módulo passar para o estado de cima.
Vermelho		O carro está bloqueado; Não foi detectado nenhum cartão durante 2 minutos; É necessário recorrer ao software ou ao reed relay de um cartão previamente adicionado ao sistema para desbloquear a viatura.
Tabela 4 - Tabela de estados possíveis do módulo do carro em função dos leds indicadores		
Existem dois leds indicadores do que se está a passar em todo o instante, um verde e um vermelho. Na Tabela 4 estão indicados os estados possíveis desses leds e o seu significado.
A forma utilizada para desactivar a viatura na altura de bloqueio foi o desvio da linha de ignição (fio vermelho na Figura 74), facilmente acessível no meu carro mas que dificilmente seria opção num carro mais moderno.
Nesse caso será preferível contactar a própria marca para informações como proceder.
O corte dessa linha deliga imediatamente a viatura mas não corta energia ao restante sistema, o rádio continuou a trabalhar, por exemplo, e nos testes verificou-se que é perfeitamente seguro desligar a viatura deste tipo, os travões mantêm-se operacionais e o condutor poderá parar a viatura em perfeitas condições, sem se colocar a sua vida em risco e sem se arriscar causar um acidente.
Para efectuar a interrupção da linha de ignição foi utilizado um relé automóvel normalmente aberto, o que significa que sem o sistema montado o carro não arranca. A corrente que o relé necessitará de ser capaz de comutar ronda os 2A sensivelmente constantes, medidos na linha de ignição quando o carro está em funcionamento, por isso o relé de automóvel de 40A utilizado será mais do que suficiente.
Figura 75 - Relé automóvel utilizado para bloqueio e desbloqueio da viatura
A corrente de activação do relé também foi medida e ronda os 160mA, o que levou à necessidade de adição de um driver capaz de dissipar uma potência razoável, a utilização de transistores discretos de uso comum levaria à necessidade de adicionar um dissipador extra ao conjunto, tal a potência envolvida.
P = V x I = 127 * 0,16.4 = 1,9217
O driver escolhido foi o MCP1407 daMicrochip, por ser capaz de comutar uma corrente bastante alta (6A) e de dissipar uma potência aceitável na sua package TO-220-5. Para além disso, esta package permitiria a adição fácil de um dissipador caso fosse necessário, o que não se veio a verificar.
Figura 76 - Pinout de um MCP1407 napackage TO-220-5
Esse driver é ligado ou desligado pelo CPU, colocando +12V ou 0V aos terminais do relé e activando ou desactivando o mesmo, respectivamente.
Os resultados foram bastante interessantes e corresponderam às expectativas.
4.1.2.	Autonomia do cartão
Um dos aspectos que foi testado foi a autonomia do cartão. Não foi possível fazer testes extensivos à mesma mas os que se realizaram serviram para fazer uma estimativa.
A bateria recarregável do comando quando carregada fica com uma tensão de 3,3V. Verificou-se que a mesma perdia entre 20 e 50mV por dia com uma utilização moderada (cerca de 120 minutos com o comando activo, no restante tempo este foi desligado).
Tendo em conta que os elementos do cartão (CPU e módulo ZigBee) funcionam até 1,8V e 2,4V, respectivamente, conclui-se que o sistema se manterá a funcionar até a tensão na pilha descer de 2,4V. A perder 50mV por dia o comando terá então carga para 18 dias, o que fica longe dos meses calculados pelo programa da Microchip mas que é um valor aceitável para um primeiro protótipo funcional.
Testes posteriores revelaram um comportamento interessante. O ritmo de descarga da bateria mantém um nível semelhante quando o cartão está desligado (10-30mV por dia), o que significa que se poderá fazer alguma coisa para conter esta drenagem de energia que acontece mesmo quando o cartão não está a ser utilizado, e ganhar perto de 100% de capacidade se for possível reduzir as perdas nesta secção do cartão a zero com o mesmo desligado.
Infelizmente não foi possível realizar outra PCB para o cartão a tempo de colocar aqui os resultados mas penso que o problema está encontrado: o circuito de regulação de tensão que permite ligar os 5V do USB directamente ao cartão e que suporta o carregamento da pilha.
Como o cartão está neste momento, esse circuito mantém-se conectado á pilha mesmo quando o cartão é desligado de modo a permitir que a mesma possa ser recarregada em todas as ocasiões. Basta colocar o interruptor de modo a que se desligue completamente a pilha do circuito para evitar que ela drene com tanta facilidade para o circuito de carga. O prejuízo para a aplicação será o facto de o cartão passar a necessitar de estar ligado para que o processo de carga funcione.
Este problema seria bastante reduzido se tivesse sido utilizado uma bateria de lítio e um controlador de carregamento em circuito integrado. Os mais recentes têm baixíssimas correntes de retorno quando não estão a ser utilizados, o que praticamente acabaria com o problema.
4.1.3.	Alcances medidos para os vários módulos
Foram também testados os alcances do módulo de programação e do comando.
O módulo de programação, que serve para programar o módulo do carro, e o módulo do carro foram programados para emitir à potência máxima disponibilizada pelo módulo ZigBee (0dB) e oferecem um alcance de cerca 30-40 metros em campo aberto e de 10-20 metros com uma parede entre o módulo e o carro, isto com o módulo do carro já dentro da viatura.
Por outro lado, o comando foi programado para ter um alcance de cerca de 2 metros (-26dB) de modo a desbloquear a viatura apenas dentro desta. Na potência máxima seria possível interagir com o carro a 20-30 metros, o que não é desejado para este projecto por razões de autonomia. Quanto menor a potência de transmissão menor será a energia necessária para transmitir e o sistema assume que o utilizador desliga o carro quando sai dele, o que desliga o módulo do carro, e deixam de ser recebidas as transmissões do cartão de qualquer maneira.
5.	Conclusões
Os objectivos traçados inicialmente foram atingidos com relativo sucesso.
O sistema criado está de acordo com as especificações desejadas e funciona na prevenção do furto de viaturas após carjacking, como foi confirmado no teste numa viatura real.
Um dos pontos que ficou um pouco aquém das expectativas foi a autonomia, onde os cerca de 18 dias medidos ficaram bastante longe dos meses que eram esperados. Numa futura evolução da PCB dos cartões será possível corrigir este problema e a troca da pilha de 3V por uma bateria de lítio poderá ser bem-vinda se se confirmar que valha a pena.
6.	Trabalho Futuro
6.1.	Desenvolver um método de evitar o replay dos dados transmitidos pelos comandos
Talvez o maior problema que este sistema enfrentará caso seja adoptado para ser instalado em viaturas será a garantia de segurança.
O ZigBee proporciona encriptação até 128 bits e prevenção de ataques que utilizem o replay de comandos. No entanto, a utilização de prevenção de replay neste projecto não é possível nos termos em que o ZigBee o define, já que parte do pressuposto que os nós da rede comunicam uns com os outros e estão no raio de alcance uns dos outros sempre, algo que não acontece aqui.
Cada cartão de identificação é apenas um transmissor, recebe mas não reconhece como válida nenhuma transmissão porque foi programado para isso de modo a não dispender energia extra.
Isto significa que não há comunicação bidireccional entre os comandos e o módulo do carro. Como os comandos transmitem periodicamente o seu código, se a protecção de replay estivesse activa o número de controlo de cada frame transmitido continuaria a ser incrementado automaticamente no comando, mas só seria incrementado no módulo do carro se este recebesse a transmissão.
Assim que o cartão transmita algo que o módulo do carro não receba (quando o utilizador sai do carro), o módulo do carro perde o sincronismo e passa a rejeitar as mensagens recebidas, porque o número do frame não corresponde com o que tem armazenado, e esse comando ficaria inutilizado.
Uma forma de resolver esse problema seria permitir que o comando recebesse mensagens para actualização do número do frame transmitido e utilizar um algoritmo de encriptação em software.
No entanto, o tempo de vida da bateria seria drasticamente reduzido, não só pela necessidade de mais tempo de processamento para realizar a encriptação e decriptação mas também porque o módulo de comunicação precisaria de ficar activo algum tempo após ter transmitido o frame, de modo a receber a resposta do carro, tendo sido essa a razão pela sua não utilização neste projecto.
6.2.	Implementar uma bateria de lítio de 3,6V e um controlador do processo de carga no cartão
A tecnologia das baterias continua a evoluir a olhos vistos, ainda para mais agora com a chegada dos carros eléctricos ao mercado.
Seria interessante trocar a bateria CR2032 de 3V por uma bateria de lítio ultra-fina de 3,6V e por um circuito integrado que gerisse o carregamento da mesma. No entanto, estas baterias têm uma taxa de auto-descarga bastante superior às CR2032 (5% contra 0,08%, por exemplo), o que exigiria a realização de testes para verificar até que ponto seria viável a sua utilização e se trariam vantagens face às CR2032 no que à autonomia diz respeito.
Com estra troca, a opção de implementar o apontado em 6.1 seria bastante mais viável, pois a capacidade energéticas destas baterias é bastante superior à da bateria utilizada.
7.	Outras aplicações
O sistema desenvolvido neste projecto poderá ser utilizado em várias situações em que seja necessário o controlo e registo de acessos a um espaço.
Exemplos comuns são empresas, espaços comerciais e até casas de privados.
Outro exemplo de aplicação será em malas recorrendo a uma montagem com acelerómetro, que permitiria, por exemplo, soar um alarme caso seja detectado movimento numa altura em que este não estivesse previsto.
Neste caso o sistema poderia ser adaptado ligeiramente para um funcionamento mais simples. Por exemplo, o utilizador instalava o sistema numa mala de viagem que ia utilizar para viajar de comboio. À chegada à estação o utilizador pousava a mala e desligava o seu cartão de identificação.
Passado um tempo curto (teria de ser mais curto do que os 2 minutos utilizados para o carro), a mala ficaria num estado bloqueado e sensível a movimentos. Se alguém pegasse nela, seria activado um altifalante (chamado sereia) com um alarme sonoro, cuja intenção seria demover o ladrão.
Outra adaptação que poderia ser feita neste caso seria permitir que o cartão com a sua presença desbloqueasse o alarme, o que permitiria que tudo regressasse ao normal quando o utilizador voltasse a ligar o cartão para seguir viagem.
II.
Bibliografia
1.	Microchip. MPLAB C18 C Compiler User's Guide. www.microchip.com. [Online] 2005. http://ww1.microchip.com/downloads/en/DeviceDoc/MPLAB_User_Guide_51519c.pdf.
2.	—. MPLAB C18 C Compiler Libraries. www.microchip.com. [Online] 2002. http://ww1.microchip.com/downloads/en/devicedoc/mplab_c18_libraries_51297f.pdf.
3.	—.	PIC18F26K20.	www.microchip.com.	[Online]	2010.
http://www.microchip.com/wwwproducts/Devices.aspx?dDocName=en026332.
4.	—.	MRF24J40MA.	www.microchip.com.	[Online]	2008.
http://www.microchip.com/wwwproducts/Devices.aspx?dDocName=en535967.
5.	—.	MRF24J40.	www.microchip.com.	[Online]	2010.
http://www.microchip.com/wwwproducts/Devices.aspx?dDocName=en027752.
6.	—. AN1066 MiWi Wireless Networking Protocol Stack . www.microchip.com. [Online] 2010. http://www.microchip.com/stellent/idcplg?IdcService=SS_GET_PAGE&amp;amp;nodeId=1824&amp;amp;appnote=en5206 06.
7.	—. AN1283 Microchip Wireless (MiWi) Media Access Controller - MiMAC .
www.microchip.com.	[Online]	2009.
http://www.microchip.com/stellent/idcplg?IdcService=SS_GET_PAGE&amp;amp;nodeId=1824&amp;amp;appnote=en5440 32.
8.	—. AN 1204 Microchip MiWi P2P Wireless Protocol. www.microchip.com. [Online] 2010. http://www.microchip.com/stellent/idcplg?IdcService=SS_GET_PAGE&amp;amp;nodeId=1824&amp;amp;appnote=en5361 81.
9.	—. AN1284 Microchip Wireless (MiWi) Application Programming Interface - MiApp .
www.microchip.com.	[Online]	2009.
http://www.microchip.com/stellent/idcplg?IdcService=SS_GET_PAGE&amp;amp;nodeId=1824&amp;amp;appnote=en5440 39.
10.	—. AN1232 ZigBee 2006 Protocol Stack . www.microchip.com. [Online] 2008. http://www.microchip.com/stellent/idcplg?IdcService=SS_GET_PAGE&amp;amp;nodeId=1824&amp;amp;appnote=en5377 67.
III. Apêndices
A. ORGANIZAÇÃO INTERNA DA MEMÓRIA NÃO VOLÁTIL DO CPU
Endereço			Dados
0x00	-	0x07		ID1
0x08		0x0F	ID2
0x10		0x17	ID3
0x18		0x1F	ID4
0x20		0x27	ID5
0x28		0x2F	ID6
0x30		0x37	ID7
0x38		0x3F	ID8
0x40		0x47	ID9
	0x48		Número de cartões
	0x49		Estado da viatura
0x50	-	0x51	Ultima posição gravada do registo de acessos
0x52		0x53	Timeout ID1
0x54		0x55	Timeout ID2
0x56		0x57	Timeout ID3
0x58		0x59	Timeout ID4
0x5A		0x5B	Timeout ID5
0x5C		0x5D	Timeout ID6
0x5E		0x5F	Timeout ID7
0x60		0x61	Timeout ID8
0x62		0x63	Timeout ID9
0x64		0x65	Contador 2 minutos
	0x66		Estado do Acelerómetro
B. Comandos implementados na interacção entre módulos
Função	Comando enviado pela aplicação
Teste de conectividade com o módulo de programação	t
Teste de conectividade com o módulo do carro	c
Adicionar cartão à base de dados do módulo do carro	axxxxxxxx
Obter número de cartões na base de dados do módulo do carro	b
Remover cartão da base de dados do módulo do carro	r#
Obter ID de um cartão na base de dados do módulo do carro	i#
Verificar estado de bloqueio do carro	de
Bloquear carro	db
Desbloquear carro	dd
Acertar hora do módulo do carro	h+data
Obter número de registos de acesso guardados em memória	Rn
Apagar registos de acesso guardados em memória	Ra
Obter registos de acesso	Re##
C. Esquemas eléctricos e PCBs
1. Cartão
PIC18F26K20
_2
3
_5
6
RAO/ANO	I
RA1/AN1
RA2/AN2
RA3/AN3
RA4/T0CKI/C1OUT RA5/AN4/SS/C2OUT



OSC2/CLKOUT/RA6
INT0/FLT0/AN12/RB0
INT1/AN10/RB1
INT2/AN8/RB2
CCP2/AN9/RB3
KBI0/AN11/RB4
KBI1/PGM/RB5
KBI2/PGC/RB6
KBI3/PGD/RB7
OSC1/CLKIN/RA7
MCLR/VPP/RE3
T1OSO/T13CKI/RC0
T1OSI/CCP2/RC1 CCP1/RC2 SCK/SCL/RC3 SDI/SDA/RC4
SDO/RC5
TX/CK/RC6
RX/DT/RC7
Figura 77 - Esquema eléctrico do módulo de cartão de identificação
Figura 78 - PCB do módulo do cartão de identificação (3,32x4,48cm)
Figura 79 - Fotos do cartão utilizado para testes
2. Módulo do Carro
Figura 80 - Esquema eléctrico do módulo de carro
Figura 81 - PCB do módulo do carro (6,72x5,25 cm)
Figura 82 - Foto do módulo do carro utilizado em testes
3. Módulo de programação
PIC18F26K20
2
4
6
10
_9

RAO/ANO
RA1/AN1
RA2/AN2
RA3/AN3
RA4/T0CKI/C1OUT
RA5/AN4/SS/C2OUT
INT0/FLT0/AN12/RB0
INT1/AN10/RB1 INT2/AN8/RB2
CCP2/AN9/RB3
KBI0/AN11/RB4
KBI1/PGM/RB5
KBI2/PGC/RB6
KBI3/PGD/RB7
OSC2/CLKOUT/RA6
OSC1/CLKIN/RA7
MCLR/VPP/RE3
T1OSO/T13CKI/RC0
T1OSI/CCP2/RC1 CCP1/RC2 SCK/SCL/RC3 SDI/SDA/RC4
SDO/RC5
TX/CK/RC6
RX/DT/RC7
MCLR PGD PGC GND VDD
Figura 83 - Esquema eléctrico do módulo de programação
Figura 84 - PCB do módulo de programação (2,83x2,75cm)

Figura 85 - Fotos do módulo de programação utilizado
RIA
Estes anexos só estão disponíveis para consuita através do CD-ROM. Queira por favor dirigir-se ao baicão de atendimento da Bibiioteca.
Serviços de Documentação
Universidade de Aveiro</field>
	</doc>
</add>