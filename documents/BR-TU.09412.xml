<?xml version="1.0" encoding="utf-8"?>
<add>
	<doc>
		<field name="docid">BR-TU.09412</field>
		<field name="filename">14390_ERICK_WAKAMOTO_TAKARABE.pdf</field>
		<field name="filetype">PDF</field>
		<field name="text">
Erick Wakamoto Takarabe

Sistemas de Controle Distribuídos em

Redes de Comunicação

São Paulo
Agosto de 2009



Erick Wakamoto Takarabe

Sistemas de Controle Distribuídos em

Redes de Comunicação

Dissertação apresentada ao Programa de

Pós-Graduação em Engenharia Mecânica da

Escola Politécnica da Universidade de São

Paulo para obtenção do Título de Mestre

em Engenharia Mecânica.

Área de concentração:
Engenharia de Controle e Automação Mecâ-
nica

Orientador:
Prof. Dr. Newton Maruyama

São Paulo
Agosto de 2009



À minha família: berço e razão de tudo.



Agradecimentos

Primeiramente gostaria de agradecer aos meus pais por todo amor e carinho que foram

fundamentais para chegar até este presente momento, principalmente nas horas difíceis

(que não foram poucas!). E à Aline, Seu Tada, Dona Cris, Dri, Sato, Mirianzinha (Mari-

azinha), Ró e Clau por me acolherem como um membro desta linda família.

Não somente aos amigos que me acompanharam nesta etapa de minha vida, mas

também aos que estiveram nas anteriores, meu sincero muitíssimo obrigado! Me sinto

muito afortunado em dizer que o motivo de não citar seus nomes é que não haveria espaço

suficiente para todos eles.

Para os membros da banca de qualificação, Prof. Dr. Paulo Eigi Miyagi e Prof.

Dr. Fábio Gagliardi Cozman, fica meu agradecimento pelas críticas construtivas e minha

admiração pelas respectivas contribuições ao mundo da pesquisa. Sou grato também ao

meu orientador, Prof. Dr. Newton Maruyama, cujos ensinamentos foram muito além do

tema desta pesquisa.

Gostaria por fim de agradecer ao apoio da FAPESP através de minha bolsa de estudos.



"O homem que aos 50 anos vê o mundo do mesmo modo que via aos 20, perdeu 30 anos

de sua vida."(Muhammad Ali)



Resumo

Sistemas de controle distribuídos cujas malhas são fechadas através de uma rede de co-
municação são chamados de sistemas de controle distribuídos em redes de comunicação
(NCS - Networked Control System). Este tipo de arquitetura permite a divisão do sistema
de controle em módulos interconectados através da rede de comunicação, proporcionando
a divisão do processamento, a redução de custo e de peso, além de facilitar o diagnóstico
e manutenção do sistema e de aumentar a sua flexibilidade e agilidade; e por isso seu
emprego na indústria está se tornando comum (e.g., fly-by-wire e drive-by-wire). Porém,
a distribuição do processamento e a inserção de uma rede de comunicação aumenta a com-
plexidade da análise e do projeto deste tipo de sistema. Um dos fatores que contribui para
esse aumento da complexidade é a presença de atrasos aleatórios nos sinais de controle,
causados pela dinâmica do sistema computacional (conjunto de hardware e software) que
serve como plataforma para implementação do sistema de controle digital.

Este trabalho faz um estudo sobre este tipo de sistema sob a perspectiva destes sinais
com atrasos. Para isso, faz-se uso dos toolboxes para MATLAB: TrueTime e Jitterbug.
Através destas ferramentas, mostra-se a existência de uma relação de compromisso entre
o desempenho do controle e o desempenho do sistema computacional.

Através deste estudo, é proposto uma solução de um sistema de controle do tipo NCS
para um ROV (do inglês Remotely Operated Vehicle), modelado através de 6 equações
diferenciais desacopladas não-lineares. Este tipo de veículo tem uma relevância econômica
significativa para o Brasil, visto que é utilizado em operações de manutenção e instalação
de plataformas de extração do petróleo que está depositado em profundidades que variam
de mil a 2 mil metros. Para este NCS proposto, são utilizados controladores do tipo PI
com estrutura feedback-feedfoward cujos parâmetros de projeto são obtidos em função dos
atrasos inseridos pelo sistema computacional.

Palavras-chave: NCS, rede de comunicação, sistemas de controle distribuídos, True-
Time, Jitterbug, ROV.



Abstract

Distributed control systems wherein the control loops are closed through a communica-
tion network are called Networked Control Systems (NCSs). This type of architecture
allows the control systems division into modules interconnected through the communica-
tion network, providing the processing division, reduction of cost and weight, and faci-
litates the systems diagnosis and maintenance, and increases their flexibility and agility.
Therefore its use in industry is becoming common (eg, fly-by-wire and drive-by-wire).
However, the processing distribution and the communication network insertion increase
the system analysis and design complexity. One of the factors that contributes to this
increased complexity is the presence of random time delays, caused by the dynamics of
the computer system (set of hardware and software) used as a platform for digital control
system implementation.

This work deals with the networked control systems under these random time delays
view. For this, it is used two MATLAB toolboxes: Jitterbug and TrueTime. With these
tools, it is shown the existence of a relationship between the performance of control and
performance of computer system.

With this study, it proposed a solution of a NCS for a ROV (Vehicle Operated Remo-
tely), modeled by 6 differential nonlinear decoupled equations. This type of vehicle has
a significant economic relevance for Brazil, as it is used in maintenance and installation
of platforms for oil extraction deposited at depths ranging from thousand to 2 thou-
sand meters. For this proposed NCS are adopted PI controllers with feedfoward-feedback
structure whose parameters design are given in terms of delay inserted by the computer
system.

Keywords: ROV, NCS, network, distributed control, TrueTime, Jitterbug.



Lista de Figuras

1.1 Modelo de um NCS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2

1.2 Sistema de controle computadorizado composto por: um sistema de con-

versão Analógico-Digital (A/D); um sistema computacional (hardware e

software) onde é implementado o controlador em sua forma discreta; e um

sistema de conversão Digital-Analógico (D/A). . . . . . . . . . . . . . . . . 3

1.3 Múltiplas plantas sendo controladas por múltiplos controladores em um

sistema de processamento multitarefa. . . . . . . . . . . . . . . . . . . . . . 5

1.4 Diagrama de tempo dos ciclos de controle. . . . . . . . . . . . . . . . . . . 6

1.5 Transição de estado de processos. . . . . . . . . . . . . . . . . . . . . . . . 9

1.6 Estrutura de rede em camadas. . . . . . . . . . . . . . . . . . . . . . . . . 11

1.7 Diagrama de tempo para dois nós e um acesso aleatório à rede, onde: o

Caso 1 trata de uma situação sem colisão; o Caso 2 trata de uma situação

com colisão, onde o nó i tem maior prioridade; e o Caso 3 trata de uma

situação com colisão e sem prioridade, onde os dois nós retransmitem a

mensagem depois de um tempo aleatório. . . . . . . . . . . . . . . . . . . . 12

2.1 Modelo de um sistema com atraso em tempo contínuo, onde K(s) e G(s)

representam respectivamente o controlador e a planta. . . . . . . . . . . . . 15

2.2 Exemplo de um diagrama de Nyquist de um sistema de segunda ordem

com e sem atraso (WOLOVICH, 1994). . . . . . . . . . . . . . . . . . . . . . 16

2.3 Diagrama de blocos do modelo real GR(s) da planta do sistema, composto

pelo erro multiplicativo ?M (s) e pelo modelo nominal GN (s). . . . . . . . . 17

2.4 Ilustração qualitativa do comportamento típico de eM (?). . . . . . . . . . . 17



2.5 Diagrama de Nyquist mostrando a relação entre GN (j?), GR(j?) e eM (?).

Os círculos tracejados demarcam a área das trajetórias possíveis da curva

de GR(j?). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18

2.6 Diagrama de blocos com um sistema em tempo contínuo conectado aos con-

versores D/A e A/D, onde {uk} e {yk} são seqüências do sinal de controle
e do sinal de saída, respectivamente, tomados nos instantes de amostragem

kh; e Clock é sincronizador do do sistema computacional. . . . . . . . . . . 19

2.7 Diagrama de tempo do modelo do sistema com atraso, onde o sinal de

controle uk?1 atua por um período ?, e o sinal de controle uk atua por um

período h ? ?. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

2.8 Exemplo de um modelo Jitterbug de um sistema controlado por computador. 23

2.9 Exemplo de um modelo de tempo e a sua correspondente cadeia de Markov. 26

2.10 Biblioteca de blocos do TrueTime. . . . . . . . . . . . . . . . . . . . . . . . 28

2.11 Modelo TrueTime do sistema de controle de tempo real de um sistema

dinâmico. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29

2.12 Exemplo de um diagrama de escalonamento, que mostra os 3 estados das

tasks (escalonamento de tasks) ou dos nós da rede (escalonamento da rede),

através dos nível de amplitude i (inativo), i+0.25 (em preempção) e i+0.50

(em execução), com i = 1, . . . ,N, onde N é o números de tasks ou de nós

da rede. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31

2.13 Diagrama de bode do sistema com ? = 0 e ? = 21ms. . . . . . . . . . . . . 33

2.14 Resposta no tempo do sistema com e sem atraso ? = 21ms, com a planta

contínua (G(s)) e o controlador discreto (Kd(z)). . . . . . . . . . . . . . . 33

2.15 Densidade espectral do sinal de saída do sistema com e sem atraso ? =

21ms, obtido através do Jitterbug. . . . . . . . . . . . . . . . . . . . . . . 34

3.1 Comparação de desempenho do controle para os casos de controle contínuo,

controle discreto e NCS em função do período de amostragem adotado. . . 36

4.1 Resposta do motor CC para uma entrada degrau unitário. . . . . . . . . . 43



4.2 Diagrama de implementação do controlador PID adotado, onde ?ref (s) é

o sinal de referência, u(s) é o sinal de controle, ?(s) é o sinal de saída,

PI(s) é o termo proporcional e integral do controlador e D(s) e o termo

derivativo do controlador. . . . . . . . . . . . . . . . . . . . . . . . . . . . 43

4.3 Resposta do sistema em malha fechada dado pela Equação (4.2) para uma

entrada degrau. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45

4.4 Saída ? e sinal de controle Va para o sistema de controle discreto ideal. . . 46

4.5 Diagramas de Bode obtido através da função de transferência Gdcl(z) com

o h = 0.05s e alguns casos de atrasos. Observa-se também no diagrama a

freqüência de Nyquist (metade da freqüência de amostragem). . . . . . . . 48

4.6 Modelo SIMULINK do sistema com atraso. O atraso é representado por

um atraso de transporte na entrada da planta com um reconstrutor de

ordem zero. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 48

4.7 Resultado da simulação com o modelo SIMULINK da Figura 4.6 para os

casos com h = 0.05s e atrasos d = 0, 0.20h e 0.60h. . . . . . . . . . . . . . 48

4.8 Diagramas de Nyquist da função de malha aberta Ld(z) para 6 situações

distintas. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49

4.9 Saídas do sistema para h = 0.05s e d = 0.01s e para h = 0.026s e d = 0.03s. 50

4.10 Modelo de NCS utilizado nesta seção. . . . . . . . . . . . . . . . . . . . . . 50

4.11 Modelo TrueTime do sistema de controle do motor CC. . . . . . . . . . . . 51

4.12 Ilustração das grandezas analisadas neste estudo de caso e das tasks en-

volvidas no ciclo de controle. Nota-se que a task no controlador pode

apresentar um intervalo durante sua execução devido à preempção. . . . . 53

4.13 Diagramas de escalonamentos das tasks do controlador, destacando o in-

tervalo em que as tasks de controle em preempção são executadas. . . . . . 55

4.14 Diagrama de escalonamento da rede, destacando o intervalo em que ocorre

um aumento no tráfego da rede. . . . . . . . . . . . . . . . . . . . . . . . . 56

4.15 Distribuição das latências LkS . . . . . . . . . . . . . . . . . . . . . . . . . . 57

4.16 Distribuição das latências LkC . . . . . . . . . . . . . . . . . . . . . . . . . . 58



4.17 Distribuição dos intervalos de amostragem hk. . . . . . . . . . . . . . . . . 59

4.18 Saídas do sistema para h: 0.01s, 0.02s, 0.04s, 0.06s e 0.07s, obtidas com

TrueTime. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59

5.1 Modelo CAD de um ROV. . . . . . . . . . . . . . . . . . . . . . . . . . . . 62

5.2 Sistema de coordenadas para veículos marinhos, com 6 graus de liberdade

(FOSSEN, 1994). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63

5.3 Diagrama esquemático da arquitetura atual do sistema de controle do ROV. 66

5.4 Estrutura hierárquica do controle do veículo. As variáveis com índice ref

se referem aos valores de referência. . . . . . . . . . . . . . . . . . . . . . . 67

5.5 Posicionamento dos propulsores em relação ao referencial móvel (sistema de

coordenadas verde), considerando que o CG do ROV é o ponto de intersec-

ção dos planos de simetria. As forças axiais produzidas pelos propulsores

são representadas pelas flechas em vermelho. Os propulsores são identifi-

cados por números de 1 a 8. . . . . . . . . . . . . . . . . . . . . . . . . . . 67

5.6 Diagrama esquemático da possível arquitetura de controle do tipo NCS

para o VSOR. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69

6.1 Histogramas das latências do sensor das tasks de controle para o caso com

h = 400ms. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76

6.2 Histogramas das latências do controlador das tasks de controle para h =

400ms, para o Caso 1. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77

6.3 Histogramas dos intervalos de amostragem das tasks de controle para h =

400ms, para o Caso 1. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78

6.4 Carga na CPU em função do tempo para h = {400, 200, 130}ms, para o
Caso 1. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79

6.5 Histogramas das latências do sensor das tasks de controle para h = 130ms,

para o Caso 2. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81

6.6 Histogramas das latências do controlador das tasks de controle para h =

130ms, para o Caso 2. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 81



6.7 Histogramas dos intervalos de amostragem das tasks de controle para h =

130ms, para o Caso 2. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82

6.8 Carga na CPU em função do tempo para h = {400, 200, 130}ms, para o
Caso 2. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83

6.9 Diagrama de escalonamento das tasks do controle central para h = 130ms,

para o Caso 3. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85

6.10 Histogramas das latências do sensor das tasks de controle para h = 130ms,

para o Caso 3. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85

6.11 Histogramas das latências do controlador das tasks de controle para h =

130ms, para o Caso 3. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86

6.12 Histogramas dos intervalos de amostragem das tasks de controle para h =

130ms, para o Caso 3. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 86

6.13 Carga na CPU em função do tempo para h = {400, 200, 130}ms, para o
Caso 3. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87

6.14 Diagrama de escalonamento das tasks do controle central para h = 130ms,

para o Caso 4. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88

6.15 Histogramas das latências do sensor das tasks de controle para h = 130ms,

para o Caso 4. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89

6.16 Histogramas das latências do controlador das tasks de controle para h =

130ms, para o Caso 4. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89

6.17 Carga na CPU em função do tempo para h = {400, 200, 130}ms, para o
Caso 4. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 90

6.18 Histogramas dos intervalos de amostragem das tasks de controle para h =

130ms, para o Caso 4. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91

6.19 Custo J em função de ?i, para os Casos {1, 2, 3, 4}, considerando ?ni =
1rad/s, o que corresponde a h = 400ms. . . . . . . . . . . . . . . . . . . . 93

6.20 Custo J em função de ?i, para os Casos {1, 2, 3, 4}, considerando ?ni =
2rad/s, o que corresponde a h = 200ms. . . . . . . . . . . . . . . . . . . . 93



6.21 Custo J em função de ?i, para os Casos {1, 2, 3, 4}, considerando ?ni =
3rad/s, o que corresponde a h = 130ms. . . . . . . . . . . . . . . . . . . . 94

6.22 Resposta do sistema no tempo nos GLs surge, sway, heave e yaw conside-

rando wn1 = wn2 = wn3 = wn6 = 3[rad/s] para o Caso 4. . . . . . . . . . . 95

6.23 Resposta do sistema no GL surge para (?n1,?1) = {(1, 0.7), (2, 1.2), (3, 1.7)}
para o Caso 4. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96

6.24 Modelo do VSOR em realidade virtual. . . . . . . . . . . . . . . . . . . . . 96

6.25 Deslocamento no plano XY do veículo para (?n1,?1) = (1, 0.7), (?n2,?2) =

(1, 0.8), (?n3,?3) = (1, 0.8) e (?n6,?6) = (1, 0.9), para o Caso 1 e para o

Caso 4. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97

6.26 Deslocamento no plano XY do veículo para (?n1,?1) = (2, 1.2), (?n2,?2) =

(2, 1.0), (?n3,?3) = (2, 0.8) e (?n6,?6) = (2, 0.8), para o Caso 1 e para o

Caso 4. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 97

6.27 Deslocamento no plano XY do veículo para (?n1,?1) = (3, 1.7), (?n2,?2) =

(3, 1.3), (?n3,?3) = (2, 1.0) e (?n6,?6) = (2, 0.8), para o Caso 1 e para o

Caso 4. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98

A.1 Diagrama do sistema em malha fechada e em tempo contínuo. . . . . . . . 102



Lista de Tabelas

3.1 Parâmetros das redes de controle. . . . . . . . . . . . . . . . . . . . . . . . 40

4.1 Coeficientes do controlador PID em tempo discreto, dados em função do

método de aproximação. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45

4.2 Características das tasks do sistema. . . . . . . . . . . . . . . . . . . . . . 52

4.3 Critério ITAE aplicados aos resultados obtidos através do TrueTime. . . . 54

4.4 Resultados das simulações com o Jitterbug para o caso estudado, com h:

0.01s, 0.02s, 0.04s, 0.06s e 0.07s. . . . . . . . . . . . . . . . . . . . . . . . 61

5.1 Notações definidas pela SNAME (The Society of Naval Architects and Ma-

rine Engineers) utilizadas para veículos marinhos. . . . . . . . . . . . . . . 64

5.2 Sistema sensorial do ROV (AVILA; MARUYAMA; ADAMOWSKI, 2008). . . . . 66

6.1 Médias e desvios padrão dos intervalos de amostragem das tasks de controle

para h = 130ms, para o Caso 2. . . . . . . . . . . . . . . . . . . . . . . . . 82

6.2 Médias e desvios padrão da carga na CPU, para h = {400, 200, 130}ms,
para o Caso 3. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84

A.1 Dados do VSOR referentes aos GLs (AVILA, 2008). . . . . . . . . . . . . . 109



Lista de Abreviaturas

ROV Remotely Operated Underwater Vehicle

NCS Networked Control System

A/D Analógico-Digital

D/A Digital-Analógico

LQG/LTR Linear Quadratic Gaussian / Loop Transfer Recovery

CPU Central Processing Unit

STR Sistema de Tempo Real

RTOS Real-Time Operating System

FP Fixed Priority

RM Rate Monotonic

EDF Earliest Deadline First

FBW Fly by Wire

DBW Drive by Wire

MAC Media Access Cotnrol

CSMA/CD Carrier Sense Multiple Access with Collision Detection

CSMA/AMP Carrier Sense Multiple Access with Arbitration on Message Priority

FDMA Frequency Division Multiple Access

TDMA Time Division Multiple Access

WLAN Wireless Local Area Network



CSMA/CA Carrier Sense Multiple Access with Collision Avoidance

ZOH Zero-Order-Hold

MJLS Markov Jump Linear Systems

MSS Mean Square Stability

WCET Worst Case Execution Time

CAN Controller Area Network

FIFO First in, First out

VSOR Veículo Submarino Operado Remotamente

GL Grau de Liberdade



Lista de Símbolos

Os seguintes símbolos serão utilizados:

símbolo descrição

h Período de amostragem nominal

hk Intervalo de amostragem

Lkio Latência de entrada-saída

Lks Latência de amostragem

L Transformada de Laplace
H(t) Função de Heaviside

L(s) Função de malha aberta

S(s) Função de sensibilidade

?i(A) Autovalores de A

J Custo total do sistema obtido através do Jitterbug

P? (k) Probabilidade de um atraso de k? segundos

P(k?) Covariância do estado no instante k?

?y(?) Densidade espectral de uma saída y

ru(k) Função de covariância de y

LkS Latência do sensor

LkC Latência do controlador

?i Força/torque correspondente ao GL i

mi Inércia/massa virtual correspondente ao GL i

dLi Coeficiente de arrasto linear correspondente ao GL i

dQi Coeficiente de arrasto quadrático correspondente ao GL i

bi Modelo de distúrbio correspondente ao GL i

? Vetor de posicão/orientação do veículo no referencial inercial

? Vetor de velocidades do veículo no referencial móvel

?GL Vetor de forças/torques no veículo no referencial móvel





Conteúdo

1 Introdução 1

1.1 Contextualização: NCS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2

1.2 Sistema de tempo real (STR) . . . . . . . . . . . . . . . . . . . . . . . . . 7

1.3 Redes de comunicação . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

1.4 Objetivos e apresentação do trabalho . . . . . . . . . . . . . . . . . . . . . 13

2 Métodos de Análise 15

2.1 Método com o Modelo do Sistema com Atraso . . . . . . . . . . . . . . . . 19

2.2 Método com os Toolboxes Jitterbug e TrueTime . . . . . . . . . . . . . . . 22

2.2.1 Jitterbug . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22

2.2.2 TrueTime . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

2.3 Exemplo Introdutório . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

2.4 Conclusão . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34

3 Redes de Comunicação para Sistemas de Controle 35

3.1 Candidatas à rede de controle . . . . . . . . . . . . . . . . . . . . . . . . . 37

3.1.1 Ethernet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38

3.1.2 ControlNet . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38

3.1.3 DeviceNet (CAN) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39

3.2 Comparação entre as Candidatas . . . . . . . . . . . . . . . . . . . . . . . 40

3.3 Conclusão . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40



4 Estudo de Caso 42

4.1 O Sistema . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43

4.2 Análise com Modelo do Sistema com Atraso . . . . . . . . . . . . . . . . . 46

4.3 Simulação com o TrueTime . . . . . . . . . . . . . . . . . . . . . . . . . . 50

4.4 Análise com o Jitterbug . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60

4.5 Conclusão . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 61

5 O ROV 62

5.1 Modelo do VSOR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63

5.2 Arquitetura de Controle . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65

5.3 Estratégia de Controle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 70

5.4 Conclusão . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71

6 Resultados 73

6.1 Análise com o TrueTime . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74

6.1.1 Caso 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75

6.1.2 Caso 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80

6.1.3 Caso 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84

6.1.4 Caso 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87

6.2 Análise com o Jitterbug . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92

6.3 Simulações com o Modelo do ROV . . . . . . . . . . . . . . . . . . . . . . 94

6.4 Conclusões . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98

7 Conclusões 100

7.1 Sugestões para Trabalhos Futuros . . . . . . . . . . . . . . . . . . . . . . . 101

Anexo A -- Robustez de Sistemas SISO 102



Referências 105

Apêndice A -- Parâmetros do VSOR 109



1

1 Introdução

Sistemas de controle distribuído em redes de comunicação, ou conhecidos também como

Networked Control Systems (NCSs), estão atualmente em evidência, visto que proporcio-

nam aos sistemas de controle características como distribuição do processamento, redução

de custo e de peso, além de facilitar o diagnóstico e manutenção do sistema e de aumen-

tar a sua flexibilidade e agilidade (com relação a possíveis adaptações e modificações)

(WALSH et al., 2002). Estas características se tornam mais importantes à medida que a

complexidade dos sistemas de controle aumenta.

Um exemplo de um sistema de controle complexo é um ROV: veículo submergível

não-tripulado ligado a um navio na superfície através de um cordão umbilical tanto para

alimentação (energia) quanto para transmissão de dados. Fatores que contribuem para o

aumento desta complexidade são as suas restrições físicas e operacionais. Devido a estas

restrições, o controle deste tipo de veículo é realizado através de sistemas embarcados1 de

forma a minimizar o espaço ocupado, o peso e o consumo de energia.

Neste trabalho será estudado NCS com o intuito de propor soluções deste tipo para

o controle de um ROV. Para isso, o capítulo inicia com uma contextualização de NCSs

na Seção 1.1, apresentando seus componentes, seu histórico e os problemas envolvidos

do ponto de vista de controle. As Seções 1.2 e 1.3 apresentam a visão geral sobre dois

importantes componentes do NCS: o sistema operacional de tempo real e a rede de co-

municação.

1Um sistema embarcado é um sistema computacional dedicado projetado para uma ou algumas funções
específicas, geralmente em real-time (CATSOULIS, 2005).



1.1 Contextualização: NCS 2

1.1 Contextualização: NCS

Sistemas de controle distribuído cuja malha é fechada através de uma rede de comunicação

são chamados de NCSs, como visto na Figura 1.1. Este tipo de sistema apresenta uma

série de vantagens já citadas anteriormente. Porém, a distribuição do processamento e

a inserção de uma rede de comunicação aumentam a complexidade da análise e do seu

projeto. Além de envolver todas as dificuldades encontradas em uma implementação de

controle discreto (e.g., aliasing; problemas de aproximações; imprecisões numéricas), há

também o indeterminismo temporal (e.g. atrasos nos sinais) causados pela dinâmica do

sistema computacional2; além da possibilidade de perdas de dados, especialmente durante

a transmissão de mensagens pela rede de comunicação.

...

...

PlantaPlanta

ControladorControlador

AtuadorAtuador SensorSensor

Rede de comunicação

Figura 1.1: Modelo de um NCS.

O histórico de sistemas de controle distribuídos tem início em meados dos anos 70,

quando sistemas de controle computadorizado3 (Figura 1.2) foram divididos em módulos

de controle conectados entre si. Porém, estes módulos eram pouco dependentes uns dos

outros, sendo as tarefas relativas ao controle realizadas individualmente em cada módulo,

onde apenas alguns sinais de monitoramento eram compartilhados.

Com o desenvolvimento e a popularização das redes de comunicação como a Ethernet,

e redes de caráter industrial como Fieldbus, CAN-Bus, DeviceNet. etc., além das redes

wireless como Bluetooth e ZigBee, foi possível a descentralização dos sensores, processa-

dores e, conseqüentemente, o surgimento dos NCSs. Tais sistemas de controle possuem

2Neste trabalho, sistema computacional se refere ao conjunto de software e hardware sobre o qual o
sistema de controle é implantado.

3Sistema de controle computadorizado é composto basicamente por: um sistema de conversão
Analógico-Digital (A/D); um sistema computacional onde é implementado o controlador em sua forma
discreta; e um sistema de conversão Digital-Analógico (D/A).



1.1 Contextualização: NCS 3

Planta

Controlador

Sistema de controle computadorizado

D/A A/D

k ? 1

k ? 1
k ? 1

k ? 1 k

k
k

k k + 1

k + 1
k + 1

k + 1
t

t
t

t

u

u y

y

Figura 1.2: Sistema de controle computadorizado composto por: um sistema de
conversão Analógico-Digital (A/D); um sistema computacional (hardware e software)
onde é implementado o controlador em sua forma discreta; e um sistema de conversão

Digital-Analógico (D/A).

as seguintes características:

• processamento distribuído,

• sensores distribuídos,

• atuadores distribuídos,

• redes de comunicação,

• sistemas operacionais.

Atualmente, para a maior parte da comunidade de controle, o ciclo de controle (com-

posto basicamente pela amostragem do sinal de saída, cálculo do sinal de controle e

atuação sobre a planta) é realizado instantaneamente e nos instantes de amostragem

kh. Entretanto, esta simplificação pode não caracterizar bem a realidade do sistema de

controle computadorizado, pois é necessário um certo tempo para que este ciclo seja execu-

tado. E este tempo pode ainda variar de acordo com os atrasos introduzidos pelo sistema

computacional. O trabalho de Chow e Tipsuwan (2003) mostra experimentos onde os

atrasos deterioram o desempenho do sistema de controle computadorizado, conduzindo o

sistema para a região de instabilidade.

Portanto, novas abordagens são necessárias para fazer a análise e o projeto de NCSs.

Uma delas pode ser observada em Cervin (2003), onde é apresentada a metodologia de



1.1 Contextualização: NCS 4

co-design, na qual o projeto do sistema computacional e do sistema de controle são tra-

tados em conjunto. Este método vem apresentando bons resultados no que diz respeito à

melhora do desempenho de NCS, porém, sua implementação não é trivial, visto que exige

soluções no nível do kernel do sistema operacional.

Dentro do contexto clássico da teoria de controle, o objetivo principal do projeto

é obter um controlador K para gerar o esforço de controle u(t) de forma a fazer com

que o sistema dinâmico tenha um comportamento desejado. Numerosas técnicas de-

senvolvidas nas últimas décadas podem ser utilizadas para este fim, como por exemplo:

LQG/LTR (CRUZ, 1996), controle preditivo (CLARKE; MOHTADI; TUFFS, 1987), H? (POS-

TLETHWAITE, 1996), etc. Em qualquer uma dessas técnicas, obtém-se o controlador K

descrito através de uma equação diferencial ou ainda através de um sistema de equações

diferenciais descrevendo um espaço de estados (eventualmente controladores se reduzem

a constantes).

Para obter um sistema de controle computadorizado é necessário transformar as equa-

ções diferenciais do controlador K em equações de diferença. Para isto, utiliza-se a teoria

clássica de controle de tempo discreto: a Transformada Z (ÅSTRöM; WITTENMARK, 1997).

Uma descrição do controlador em espaço de estados em tempo discreto é representada

por

xk+1 = ?xk + ?ek, (1.1)

uk = ?Kxk, (1.2)

onde xk é o vetor de estados do controlador; e(k) é o vetor de erro do sistema; e u(k)

é o vetor do esforço de controle, todos tomados no instante kh com k = 0, 1, 2, . . . ,n.

Portanto para o correto funcionamento do sistema de controle computadorizado, todos os

sub-sistemas devem cumprir a meta estabelecida pelo período de amostragem nominal h,

ou seja, a cada período h devem ser realizados uma conversão A/D; um cálculo do esforço

de controle u(k); e uma conversão D/A.

Inicialmente esta meta não gerava tantos problemas, visto que os sistemas de con-

trole possuíam um caráter monolítico, com hardware e software implementados de forma

customizada. Posteriormente, a possibilidade de miniaturização de componentes levou ao

aparecimento de microcontroladores de baixo custo e com memória suficiente para rodar

um sistema operacional multitarefas (multitasking) onde os recursos computacionais são

compartilhados entre as tarefas (tasks) em execução (vide Figura 1.3). A partir de então



1.1 Contextualização: NCS 5

houve a possibilidade da implementação de várias malhas de controle simultâneas, gra-

ças a um gerenciamento dos recursos computacionais limitados (através de algoritmos de

escalonamento, por exemplo) de uma maneira mais eficiente.

A despeito dessa mudança, a teoria de controle discreto continua sendo utilizada da

mesma forma, e os usuários são obrigados a tentar fazer o software de maneira a cumprir a

meta para cada controlador, aumentando consideravelmente a sua complexidade. Quando

se aumenta o compartilhamento de recursos computacionais, aumenta-se a probabilidade

de indeterminismo temporal.

Nota-se então que vários fatores podem influenciar no desempenho do sistema de

controle multitarefas, como o poder de processamento e a carga da CPU, o período de

amostragem nominal requerido para cada controlador, o algoritmo de escalonamento de

processos, etc. Em geral, se os requisitos não são cumpridos, considera-se que os recursos

computacionais devem ser aumentados.

PlantaControlador D/A

A/D
11

22
33

nn

Sistema multitarefa Múltiplas plantas

Figura 1.3: Múltiplas plantas sendo controladas por múltiplos controladores em um
sistema de processamento multitarefa.

O intervalo entre a leitura das variáveis de entrada e a atuação do esforço de controle

é crucial para o desempenho do controle. As variações do tempo de execução do ciclo de

controle causadas pela dinâmica do sistema computacional podem levar a deterioração

substancial do desempenho do sistema de controle, como visto nos trabalhos de Nils-

son (1998), Cervin et al. (2003), Cervin (2003), Lincoln (2003), Årzèn e Cervin (2005),

Henriksson et al. (2006).

Os efeitos do indeterminismo temporal (exemplificado na Figura 1.4) no desempenho

do sistema de controle é de difícil avaliação. O tempo entre o início e o fim do ciclo de

controle pode ser modelado como um atraso na entrada do processo. O tempo entre o

instante de amostragem k e o início do ciclo de controle também tem um efeito negativo

no desempenho do sistema de controle que é mais acentuado em sistemas com freqüência

de amostragem menor e sistemas com menor margem de fase (HENRIKSSON, 2006). Nesse



1.1 Contextualização: NCS 6

(k ? 1)h kh (k + 1)h t

Instante de amostragem

Início do ciclo de controle

Fim do ciclo de controle

Ciclo de controle em execução

Figura 1.4: Diagrama de tempo dos ciclos de controle.

caso, mesmo pequenas variações no intervalo de amostragem podem causar instabilidade.

Uma análise dos efeitos de atrasos aleatórios e intervalos de amostragens em controle

ótimo foi apresentada por Davidson (1973).

E quando se trata de NCSs, deve-se considerar também o indeterminismo causado por

atrasos variáveis e possíveis perdas de dados durante a transmissão via rede, que dependem

basicamente do tipo de protocolo de comunicação e das condições do tráfego presente

na rede. Dentro deste contexto, a comunidade de sistemas de controle vem abordando

estes problemas, como nos trabalhos de Siljak (1991), Brockett (1995), Ooi et al. (1997),

Nilsson (1998), Wong e Brockett (1999). Tais trabalhos modelam as dinâmicas dos canais

de comunicação ou digitalização através de modelos determinísticos ou estocásticos.

Nos trabalhos de Montestruque e Antsaklis (2005a, 2005b, 2006) são abordados NCSs

utilizando modelos explícitos. Nesta abordagem, é utilizado um observador de estados

com o objetivo de reduzir o volume de informações no canal de comunicação. O sistema

de controle utiliza as estimativas provenientes do observador enquanto não recebe dados

através da rede. Condições de estabilidade do sistema são derivadas considerando diferen-

tes cenários como compensação de atraso, intervalos de atualização constantes e variáveis,

plantas não-lineares, erros de quantização, etc. A avaliação de desempenho é realizada

utilizando normas modificadas H2 e a teoria de lifting (YAMAMOTO; KHARGONEKAR,

1996), onde o sistema em tempo discreto é analisado como se fosse um sistema em tempo

contínuo.

Para análise e projeto de NCSs, estão em desenvolvimento no Department of Auto-

matic Control of Lund University dois toolboxes para MATLAB:

• Jitterburg (CERVIN; LINCOLN, 2006): torna possível a análise estatística do impacto
de latências, jitters, amostras perdidas, computações abortadas, etc. sobre o desem-

penho do sistema de controle,



1.2 Sistema de tempo real (STR) 7

• TrueTime (ANDERSSON; HENRIKSSON; CERVIN, 2007): simula o comportamento
de um sistema operacional de tempo real com redes de comunicação, utilizando

MATLAB / SIMULINK.

1.2 Sistema de tempo real (STR)

Uma definição de STR é dada por Gambier (2004):

"STR é um sistema computacional cujo correto funcionamento não depende

somente do resultado lógico da computação, mas também do tempo em que

os resultados são produzidos".

Ou seja, o sistema deve entregar o resultado correto dentro de um prazo específico, po-

dendo ser de alguns milisegundos a até segundos. Portanto conclui-se que um sistema de

controle computadorizado (inclusive um NCS) também é um STR.

Para cumprir a sua meta, o sistema deve ser capaz alocar os seus recursos computacio-

nais de forma que seu desempenho seja maximizado. Esta alocação de recursos é realizada

pelo Sistema Operacional de Tempo Real (RTOS -Real-Time Operating System), através

de uma operação denominada escalonamento de processos (FARINES; PRAGA; OLIVEIRA,

2000).

Para um STR, mais importante que a rapidez de cálculo é o conceito de previsibilidade.

A previsibilidade é o requisito básico no desenvolvimento de um STR. Um STR é dito

previsível quando, independentemente de variações que ocorrem em nível de hardware

e software, seu comportamento pode ser antecipado antes de sua execução. A garantia

de previsibilidade envolve análises complexas, visto que depende de conhecimentos da

carga computacional, da probabilidade de ocorrência de falhas (e.g., perda de dados),

dos tempos de computação4, do hardware envolvido, etc., que em geral são de caráter

não-determinísticos. Alguns autores analisam a previsibilidade de STR do ponto de vista

estocástico.

Os STRs podem ser classificados em dois tipos, do ponto de vista da segurança (sa-

fety):

4Tempo de computação (WCET - Worst Case Execution Time) é o tempo gasto, no pior caso, na
execução de códigos da aplicação.



1.2 Sistema de tempo real (STR) 8

• Soft real-time ou sistemas não-críticos: quando as conseqüências de uma falha devido
à perda de um deadline não é crítico para o funcionamento do sistema (e.g., perda

de um frame durante a execução de um vídeo);

• Hard real-time ou sistemas críticos: quando as conseqüências de uma falha devido
à perda de um deadline é crítico para o funcionamento do sistema (e.g., sistemas de

controle de vôo).

Um outro conceito importante em relação ao STR é o conceito de processo (também

chamado de task ). Processo pode ser definido como um programa em execução (DEITEL;

DEITEL; CHOFFNES, 2005). Como dito anteriormente, o RTOS deve assegurar que cada

processo receba uma quantidade suficiente de tempo de processamento. Porém, em qual-

quer sistema, o número de processos verdadeiramente executados em concorrência (em

paralelo) é obrigatoriamente igual ao número de processadores em um sistema. Portanto,

a qualquer dado instante, alguns processos podem ser executados, outros não. Durante o

seu tempo de vida um processo passa por uma série de estados distintos, que de forma

simplificada pode ser resumido em três estados:

• estado de execução, quando o processo é executado em um processador;

• estado de pronto, quando o processo poderia ser executado se houvesse um proces-
sador disponível;

• estado bloqueado, quando o processo está aguardando a ocorrência de um evento
(como a conclusão de entrada/saída, por exemplo) para prosseguir sua execução.

O RTOS mantém uma lista de prontos e uma lista de bloqueados. A transição de um

processo de uma lista para outra é representada na Figura 1.5. Quando um usuário executa

um programa, processos são criados e inseridos na lista de prontos. A lista de prontos é

organizada por prioridades, de modo que o próximo processo a receber o processador será

o primeiro da lista (o processo de maior prioridade). Quando o processo chega ao topo

da lista e há processador disponível, aquele processo é designado ao processador. Esta

transição é chamada de despacho do processo. Para evitar que qualquer um dos processos

monopolize o sistema, o sistema operacional estabelece um relógio de interrupção em

hardware (temporizador); se o processo não devolver o processador voluntariamente, a

interrupção gerada pelo temporizador faz com que este processo volte para lista de prontos.

Se um processo em execução iniciar uma operação de entrada/saída antes do temporizador



1.2 Sistema de tempo real (STR) 9

atuar, este processo vai para a lista de bloqueados, liberando o processador. Esta transição

é chamada de bloqueio do processo. Quando o evento pelo qual o processo espera é

concluído, este processo vai para a lista de pronto. Esta transição é chamada de despertar

do processo.

Execução

Pronto Bloqueado

D
es

pa
ch

o

T
em

po
ri
za

do
r

B
loqueio

Des
per

tar

Figura 1.5: Transição de estado de processos.

A estratégia utilizada pelo sistema operacional para escolher o processo que executa é

chamada de política de escalonamento. Através deste escalonamento de processos, o sis-

tema pode alocar mais eficientemente os recursos computacionais para satisfazer alguns

critérios de desempenho. Para o caso do RTOS, o sistema tem como objetivo garantir

a conclusão de cada processo dentro do seu prazo estabelecido. As políticas de esca-

lonamento podem ser preemptivas ou não-preemptivas. No caso de um escalonamento

não-preemptivo, uma vez que um processo obtém um processador, o sistema não pode

retirar este processador deste processo. No caso de escalonamento preemptivo, o sistema

pode retirar o processador, realizando o chamado chaveamento de contexto5. O escalo-

namento preemptivo é útil em sistemas nos quais processos de alta prioridade exigem

resposta rápida, como STRs (DEITEL; DEITEL; CHOFFNES, 2005). Algoritmos de escalo-

namento muitas vezes utilizam prioridades para determinar os processos que devem ser

executados. Quando cada processo possui uma prioridade estática, o escalonamento é

chamado de escalonamento por prioridade fixa (FP - fixed priority).

As políticas de escalonamentos utilizadas em STRs são chamadas de escalonamento

de tempo real. Estas políticas tem como objetivo fazer com que os processos gerem as

saídas corretas num determinado tempo. Os algoritmos de escalonamento de tempo real

5O sistema operacional realiza um chaveamento de contexto para interromper um processo em execução
e começa a executar o processo que está no topo da lista de prontos.



1.3 Redes de comunicação 10

mais utilizados são:

• escalonamento por taxa monotônica (RM - rate monotonic) - algoritmo de alter-
nância circular, preemptivo, por prioridade, que eleva a prioridade de um processo

linearmente com a freqüência com a qual ele deve executar;

• escalonamento por prazo-mais-curto-primeiro (EDF - earliest deadline first) - algo-
ritmo de escalonamento preemptivo que despacha primeiro o processo com o prazo

mais curto.

Sob o contexto de NCS, a execução dos processos relacionados ao controle introduz um

atraso, mesmo que mínimo, ao ciclo de controle; sendo que em alguns casos este atraso é de

caráter estocástico (CERVIN, 2003). Portanto a dinâmica do STR (ou mais precisamente

do RTOS) deve ser levada em consideração na análise do desempenho do NCS.

1.3 Redes de comunicação

As redes de comunicação foram introduzidas em sistemas de controle em meados da década

de 70 na indústria automobilística para promover a redução de custos com cabeamento e

a modularização de sistemas. Atualmente é crescente a incorporação de redes de comu-

nicação em sistemas de controle, como em aviões (o chamado fly by wire6 - FBW) e em

carros (o chamado drive by wire7 - DBW), por exemplo.

A maioria das redes de comunicação são organizadas como uma pilha de camadas ou

níveis, colocadas umas sobre as outras. O número de camadas, o nome, o conteúdo e a

função de cada camada diferem de uma rede para outra. No entanto, em todas as redes o

objetivo de cada camada é oferecer determinados serviços às camadas superiores, isolando

essas camadas dos detalhes de implementação desses recursos. Em certo sentido, cada

camada é uma espécie de máquina virtual, oferecendo determinados serviços à camada

situada acima dela.

A camada n de um nó da rede (conhecido também como host8) se comunica com a

camada n de outro nó. Coletivamente, as regras e convenções utilizadas nesse diálogo são

6fly by wire se refere ao uso de dispositivos eletrônicos em vez de mecânicos para interligar os comandos
do piloto aos atuadores de controle de vôo (TISCHLER, 1996).

7drive by wire é o dual do fly by wire para veículos terrestres.
8Host um dispositivo conectado a rede capaz de enviar e receber dados pelo canal de comunicação.



1.3 Redes de comunicação 11

conhecidas como o protocolo da camada n. Basicamente, um protocolo é um acordo entre

as partes que se comunicam, estabelecendo como se dará a comunicação. As entidades

que ocupam as camadas correspondentes em diferentes nós são chamadas pares (peers).

Os pares podem ser processos, dispositivos de hardware ou mesmo seres humanos. Em

outras palavras, são os pares que se comunicam utilizando o protocolo.

Na realidade, os dados não são transferidos diretamente da camada n de um nó para

a camada n de outro nó. Em vez disso, cada camada transfere os dados e as informações

de controle para a camada imediatamente abaixo dela, até ser alcançada a camada mais

baixa. Abaixo da camada 1 encontra-se o meio físico através do qual se dá a transmissão

física dos sinais de comunicação. Na Figura 1.6, a comunicação virtual é mostrada por

linhas tracejadas e a comunicação física por linhas contínuas.

Camada
n

Camada
n

Camada
1

Camada
1

Camada
2

Camada
2

Meio físico

Nó 1 Nó 2

Protocolo da

Protocolo da

Protocolo da

Camada n

Camada 2

Camada 1

Figura 1.6: Estrutura de rede em camadas.

Quando apenas um único canal está disponível, a determinação do próximo nó que

deve acessar o meio é mais complexa. Existem vários protocolos destinados a solucio-

nar o problema. Estes protocolos pertencem a subcamada chamada MAC (media access

control). Dentre estes protocolos, pode-se destacar:

• protocolo CSMA/CD - Carrier Sense Multiple Access with Collision Detection O
sistema identifica quando o meio físico está disponível e inicia a transmissão. Caso

haja uma colisão (dois nós tentando acessar o meio físico ao mesmo tempo), o

sistema a detecta e todas as transmissões são canceladas; e um sinal de colisão é



1.3 Redes de comunicação 12

  

 

 

 

Tempo

Tempo

Nó i

Nó j

Caso 1:
Sem colisão

Caso 2:
Com colisão

com prioridade

Caso 3:
Com colisão

sem prioridade

Figura 1.7: Diagrama de tempo para dois nós e um acesso aleatório à rede, onde: o
Caso 1 trata de uma situação sem colisão; o Caso 2 trata de uma situação com colisão,
onde o nó i tem maior prioridade; e o Caso 3 trata de uma situação com colisão e sem
prioridade, onde os dois nós retransmitem a mensagem depois de um tempo aleatório.

emitido. Os nós esperam um tempo aleatório para retransmissão das mensagens (ou

pacotes). Isto pode ser visualizado através do Caso 3 da Figura 1.7.

• protocolo CSMA/AMP - Carrier Sense Multiple Access with Arbitration on Message
Priority O sistema identifica quando o meio está disponível e inicia a transmissão.

Caso haja uma colisão, o sistema a detecta e permite que a mensagem de maior

prioridade continue sua transmissão. Se duas ou mais mensagens de maior prioridade

colidirem, é feita uma escolha aleatória da mensagem que completará a transmissão.

Isto pode ser visualizado através do Caso 2 da Figura 1.7.

• FDMA - Frequency Division Multiple Access A transmissão de cada nó é feita em
uma determinada banda, sendo independente uma da outra. Neste caso não há

colisões.

• TDMA - Time Division Multiple Access Este protocolo funciona de modo seme-
lhante ao FDMA, porém, cada nó tem 100% da banda disponível somente em de-

terminados períodos de tempo. Se a transmissão não for completada durante um

período, ele deve aguardar o próximo disponível.

• WLAN - Wireless Local Area Network Este protocolo é definido pela família de es-
pecificações IEEE 802.11, baseado no protocolo CSMA/CA (Carrier Sense Multiple

Access with Collision Avoidance). Cada nó avisa sobre a sua transmissão e o tempo



1.4 Objetivos e apresentação do trabalho 13

previsto para realizar a tarefa. Assim, os outros nós que pretendem enviar mensa-

gens esperam decorrer este tempo para então iniciar suas transmissões. Nota-se que

este método não impede que as colisões ocorram, mas as evita.

Nota-se que a rede de comunicação é uma potencial fonte de atrasos, e de maioria

estocásticos (NILSSON, 1998). Portanto informações sobre a rede de comunicação são

relevantes na avaliação do desempenho do NCS.

1.4 Objetivos e apresentação do trabalho

Neste trabalho, o objetivo é analisar sistemas de controle distribuídos em redes de co-

municação, mais precisamente a integração das dinâmicas do sistema computacional e do

sistema de controle, sob o ponto de vista de atrasos e do desempenho e estabilidade do

controle, com o intuito de obter uma solução de controle do tipo NCS para um ROV. Ar-

quiteturas semelhantes à esta são encontradas em ROVs comerciais, como por exemplo o

chamado Distributed Intelligence Control System, implementado no ROV Seaeye Falcon,

da Saab Technologies (SAAB, 2009).

No Capítulo 2 são apresentados dois métodos para análise do impacto dos atrasos em

sistemas de controle:

• utilizando um modelo de sistema com atraso e em tempo discreto, que permite fazer
a análise em freqüência do sistema para o pior caso de atraso (atraso constante);

• utilizando as ferramentas TrueTime e Jitterbug, que, em conjunto, analisam o im-
pacto de atrasos aleatórios sobre o sistema de controle através da teoria de Sistemas

Lineares com Saltos Markovianos (MJLS) e de uma função de custo que relaciona

energia na entrada e na saída.

No Capítulo 3 são apresentadas três candidatas para redes de comunicação para NCSs

(chamadas também de redes de controle), a saber: Ethernet, ControlNet e DeviceNet.

Cada qual com vantagens e desvantagens para sistemas de controle. Um resultado prático

apresentado é o uso da rede do tipo Ethernet em NCSs, apesar desta ser considerada

(teoricamente) não-determinística (característica necessária para redes de controle). E

foram comparados parâmetros relevantes para NCS das candidatas. Desta forma mostra-

se que a implementação de cada uma depende do contexto em que elas serão inseridas.



1.4 Objetivos e apresentação do trabalho 14

No Capítulo 4 é visto um caso semelhante ao apresentado no trabalho de Chow e

Tipsuwan (2003). É possível observar a deterioração do desempenho do NCS conforme

o aumento dos atrasos causados pelo sistema computacional. Ao final confirma-se que

existe uma relação de compromisso entre o desempenho do sistema computacional e o

desempenho do sistema de controle (LIAN; MOYNE; TILBURY, 2002), ou seja, conclui-se que

utilizar as informações do sistema computacional na avaliação do desempenho de NCSs

contribui para a obtenção de um equilíbrio entre o desempenho do sistema computacional

e o desempenho do controle.

No Capítulo 5 é apresentado o modelo matemático do ROV que será utilizado. Este

modelo é baseado no trabalho de Caccia, Indiveri e Veruggio (2000) e de Avila, Maruyama

e Adamowski (2008), onde os 6 graus de liberdade são desacoplados, sob a hipótese de

operações com baixas velocidades. É apresentada a estrutura de controle hierárquica

(CACCIA; VERUGGIO, 2000; SOUZA, 2003), onde níveis de controle superiores (e.g., guia-

gem) são responsáveis pela especificação de valores de referências para níveis de controle

inferiores (e.g., estratégia de controle). E por fim mostra-se a estratégia de controle utili-

zando um controlador do tipo PI com estrutura feedback-feedfoward, cujos parâmetros de

projeto são dados por ?i e ?ni .

No Capítulo 6 mostra-se como são obtidos os parâmetros ?i e ?ni ótimos para alguns

casos de atraso através do TrueTime e do Jitterbug. Estes parâmetros são utilizados

em simulações com um modelo do ROV em realidade virtual. Nestas simulações foram

realizadas simples tarefas de posicionamento do veículo. Como resultado observa-se que,

dado que o sistema é tipicamente estável, os efeitos do indeterminismo temporal pouco

afetam o desempenho do sistema de controle para esta determinada tarefa.

No Capítulo 7 constam as conclusões deste trabalho, bem como as sugestões para

trabalhos futuros.



15

2 Métodos de Análise

Na teoria clássica de controle discreto, o ciclo de controle (amostragem do sinal de saída,

cálculo do sinal de controle e atuação sobre a planta) é considerado ideal, ou seja, sua

execução ocorre instantaneamente nos instantes de amostragem kh, com k = 1, 2, . . .. Po-

rém na prática, em um sistema de controle computadorizado, este ciclo consome um certo

tempo para ser executado devido à dinâmica do sistema computacional. O objetivo deste

capítulo é apresentar os métodos utilizados para analisar como a interação da dinâmica

do sistema computacional e da dinâmica sistema de controle impactam no desempenho

do NCS.

+

-

Entrada

K(s) e??s G(s)

Saída

Figura 2.1: Modelo de um sistema com atraso em tempo contínuo, onde K(s) e G(s)
representam respectivamente o controlador e a planta.

Em uma primeira aproximação, o tempo de execução do ciclo de controle pode ser

representado por um atraso constante ? na entrada da planta (Figura 2.1). Assim, dado

um sistema SISO cuja resposta em malha aberta no tempo (sem atraso) seja representada

por uma função f(t), cuja Transformada de Laplace (L[f(t)]) é F(s), sua a resposta no
tempo com atraso é f(t??)H(t??), onde H(t) é a função degrau de Heaviside. Aplicando
novamente a Transformada de Laplace, a função de malha aberta do sistema com atraso

é dada por

L(s) = L[f(t ? ?)H(t ? ?)] = e??sF(s) (2.1)

(WOLOVICH, 1994). Sabendo que e?j? pode ser escrito como

e?j?? = cos ?? ? j sin ??, (2.2)



2 Métodos de Análise 16

onde

|e?j??| = 1,

?{e?j??} = ???.

Desta forma a magnitude e a fase do sistema em malha aberta com atraso são dadas por

20 log |L(j?)| = 20 log |F(j?)| (2.3)

?{L(j?)} = ??? + ?{F(j?)}. (2.4)

?1 + 0j

Re

Im

Com atraso
Sem atraso

Figura 2.2: Exemplo de um diagrama de Nyquist de um sistema de segunda ordem
com e sem atraso (WOLOVICH, 1994).

Portanto para este caso, o ganho da função de malha aberta não sofre alterações,

porém sua fase sofre um atraso proporcional à freqüência, piorando o desempenho do

controle em malha fechada principalmente em altas freqüências. O efeito deste atraso

pode ser visualizado no Diagrama de Nyquist da Figura 2.2, onde a curva da função de

malha aberta do sistema com atraso está mais próxima do ponto crítico (?1 + 0j) do que
a do sistema sem atraso.

Uma possível solução para o problema deste atraso é considerá-lo no projeto do con-

trolador através da inclusão de um erro de modelagem da planta do sistema. O diagrama

de blocos do novo modelo da planta GR(s) (chamado de aqui de "modelo real") é mos-

trado na Figura 2.3, onde há também o erro de modelagem ?M (s) (chamado aqui de erro

multiplicativo) e o modelo nominal da planta GN (s). Desta forma, tem-se que

GR(s) = [1 + ?M (s)]GN (s). (2.5)



2 Métodos de Análise 17

Admite-se que este erro multiplicativo possui um limite superior, de forma que

|?M (j?)| ? eM (?) ?? ? R. (2.6)

O comportamento típico de eM (?) é ilustrado qualitativamente na Figura 2.4. Este com-

portamento sugere que os modelos nominais são fiéis em baixas freqüências e grosseiros

em altas (CRUZ, 1996). A Figura 2.5 mostra a relação de GN (j?), GR(j?) e eM (?) atra-

vés do Diagrama de Nyquist, onde os círculos tracejados demarcam a área das trajetórias

possíveis da curva de GR(j?). O modelo matemático que deriva esta gráfico é detalahdo

no Anexo A.

+

+

U(s)
GN (s)

?M (s)

GR(s)

Y (s)

Figura 2.3: Diagrama de blocos do modelo real GR(s) da planta do sistema, composto
pelo erro multiplicativo ?M (s) e pelo modelo nominal GN (s).

eM (?)

?

1

Figura 2.4: Ilustração qualitativa do comportamento típico de eM (?).

Mesmo considerando o atraso proveniente do sistema computacional de forma apro-

ximada no projeto do controlador robusto, é necessário analisar com mais detalhes as

interações entre o sistema computacional e o sistema de controle de forma a aumentar a

confiabilidade do projeto do NCS. Para tanto, neste capítulo é apresentado na Seção 2.1

o método de análise que utiliza um modelo de sistema com atraso baseado na teoria clás-

sica de controle que permite fazer a análise em freqüência do sistema considerando o pior

caso de tempo para execução do ciclo de controle (maior atraso possível). Outro possível

método de análise é através dos toolboxes TrueTime (ANDERSSON; HENRIKSSON; CERVIN,

2007) e Jitterbug (CERVIN; LINCOLN, 2006), apresentado na Seção 2.2. Na Seção 2.3



2 Métodos de Análise 18

"Área"de GR(j?)

Re

Im

GN (j?)

eM (?)

Figura 2.5: Diagrama de Nyquist mostrando a relação entre GN (j?), GR(j?) e eM (?).
Os círculos tracejados demarcam a área das trajetórias possíveis da curva de GR(j?).

é apresentado um exemplo que permite mostrar e comparar as análises de um sistema

através dos dois métodos.



2.1 Método com o Modelo do Sistema com Atraso 19

2.1 Método com o Modelo do Sistema com Atraso

Como visto na seção anterior, o tempo de execução do ciclo de controle pode ser aproxi-

mado por um atraso de transporte do sinal de controle na entrada da planta através da

inserção de um termo exponencial para sistemas em tempo contínuo. Porém, para sis-

temas amostrados que utilizam um reconstrutor de ordem zero (ZOH - zero-order-hold ),

cujo sinal de controle é constante entre os instantes de amostragem, existe outra forma

para representar este atraso (ÅSTRöM; WITTENMARK, 1997), como será mostrado ao longo

desta seção.

{uk} {yk}u(t) y(t)

Clock

D/A A/DSistema

Figura 2.6: Diagrama de blocos com um sistema em tempo contínuo conectado aos
conversores D/A e A/D, onde {uk} e {yk} são seqüências do sinal de controle e do sinal

de saída, respectivamente, tomados nos instantes de amostragem kh; e Clock é
sincronizador do do sistema computacional.

Seja o sistema em tempo contínuo da Figura 2.6, cuja representação em espaço de

estados é
x?(t) = Ax(t) + u(t),

y(t) = Cx(t) + Du(t).
(2.7)

Seu estado no instante t, onde tk ? t ? tk+1, é dado por

x(t) = eA(t?tk )xk +

? t

tk

eA(t?s)Bu(s)ds, (2.8)

onde xk = x(tk). Como o sinal de controle é constante entre os instantes de amostragem,

tem-se que
x(t) = eA(t?tk )xk +

? t?tk
0

eAsds Buk

= ?(t, tk)xk + ?(t, tk)uk
, (2.9)

Se os conversores D/A e A/D estiverem perfeitamente sincronizados; os tempos das con-

versões forem desprezíveis; e o período de amostragem for constante, o modelo se torna



2.1 Método com o Modelo do Sistema com Atraso 20

invariante no tempo e é descrito por

xk+1 = ?xk + ?uk

yk = Cxk + Duk
, (2.10)

onde

? = eAh

? =

? h

0

eAsds B.

Para inserir um atraso constante ? neste modelo, parte-se da seguinte equação

x?(t) = Ax(t) + Bu(t ? ?).

Nesta representação, percebe-se que a atuação do controle no instante t é defasado de um

atraso ?. Assumindo que o atraso ? é menor que o período de amostragem nominal h, a

integração sobre um período de amostragem é dado por

xk+1 = e
Ahxk +

? (k+1)h

kh

eA((k+1)h?s
?)Bu(s? ? ?)ds?.

Esta integral pode ser dividida em duas integrais, de forma que

xk+1 = ?xk + ?0uk + ?1uk?1, (2.11)

onde
? = eAh,

?0 =
? h??

0
eAsds B,

?1 = e
A(h?? )

? ?

0
eAsds B.

(2.12)

Fisicamente isto pode ser interpretado como a soma do efeito do sinal de controle uk?1

atuando por um período ?, e o efeito do sinal de controle uk atuando por um período

h ? ? (Figura 2.7), entre dois instantes de amostragem. Adotando como vetor de estados

Xk =

[

xk

uk?1

]

,

obtém-se o espaço de estados em tempo discreto dado por

Xk+1 =

[

? ?1

0 0

]

Xk +

[

?0

I

]

uk,

yk =
[

C 0
]

Xk + Duk.

(2.13)



2.1 Método com o Modelo do Sistema com Atraso 21

Amostragem

y(t)

uk?1
uk

uk+1

(k ? 1)h kh (k + 1)h t

???

Figura 2.7: Diagrama de tempo do modelo do sistema com atraso, onde o sinal de
controle uk?1 atua por um período ?, e o sinal de controle uk atua por um período h ? ?.

Para os casos onde o atraso ? é maior do que h, do tipo

? = (d ? 1)h + ? ? 0 &amp;lt;? ? ? h, (2.14)

onde d = ??/h?, a Equação (2.11) pode ser escrita como

xk+1 = ?xk + ?0uk?(d?1) + ?1uk?d, (2.15)

onde ?0 e ?1 são dados pela Equação (2.12), substituindo-se ? por ? ?. Assim, o novo

sistema é dado por:
?

?

?

?

?

?

?

?

?

?

xk+1

uk?(d?1)
...

uk?1

uk

?

?

?

?

?

?

?

?

?

?

=

?

?

?

?

?

?

?

?

?

?

? ?1 ?0 · · · 0
0 0 I · · · 0
...

...
...

. . .
...

0 0 0 · · · I
0 0 0 · · · 0

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

?

xk

uk?d
...

uk?2

uk?1

?

?

?

?

?

?

?

?

?

?

+

?

?

?

?

?

?

?

?

?

?

0

0
...

0

I

?

?

?

?

?

?

?

?

?

?

uk. (2.16)

Através desta representação é possível fazer a análise em freqüência do sistema con-

siderando o pior caso do tempo de execução do ciclo de controle. Para isso, escreve-se o

sistema em espaço de estados da Equação (2.10) na forma de uma função de transferência

em tempo discreto

H(z) =
U(z)

Y (z)
= C[zI ? ?]?1? + D. (2.17)

Os pólos desta função de transferência são os autovalores de ?. A relação entre os pólos

de tempo discreto e de tempo contínuo é dado por

?i(?) = e
?i(A)h, (2.18)



2.2 Método com os Toolboxes Jitterbug e TrueTime 22

onde ?i(A) são autovalores de A e ?i(?) são os autovalores de ?. Esta mudança de

representação é chamada de mapeamento do plano-s no plano-z, quando z = exp (sh).

Portanto a análise em freqüência é obtida através da substituição de z = ej?h, onde ? é

a freqüência do sinal de entrada.

2.2 Método com os Toolboxes Jitterbug e TrueTime

Nesta seção será apresentado o método de análise que utiliza os toolboxes para MATLAB

que estão em desenvolvimento no Department of Automatic Control of Lund Univer-

sity: Jitterbug e TrueTime (CERVIN; LINCOLN, 2006; ANDERSSON; HENRIKSSON; CERVIN,

2007).

2.2.1 Jitterbug

No Jitterbug, o modelo do sistema de controle (chamado aqui de modelo Jitterbug) é

descrito por dois modelos paralelos: um modelo de sinal (Figura 2.8a) e um modelo de

tempo (Figura 2.8b). O modelo de sinal é dado por um conjunto de sistemas lineares em

tempo contínuo e em tempo discreto, conectados entre si. O modelo de tempo consiste

em um conjunto de "nós de tempo"que descreve quando diferentes sistemas de tempo

discreto devem ser atualizados durante o ciclo de controle.

Um exemplo de um modelo Jitterbug é mostrado na Figura 2.8, onde um sistema

de controle computadorizado é modelado por quatro blocos. A planta é descrita por

um sistema em tempo contínuo G(s), e o controlador é descrito por três sistemas em

tempo discreto H1(z), H2(z) e H3(z). O sistema H1(z) pode representar a amostragem

periódica, H2(z) pode representar o cálculo do sinal de controle, e H3(z) pode representar

a atuação. O respectivo modelo de tempo mostra que no início de cada ciclo de controle,

H1(z) deve ser executado primeiro. Então existe um atraso aleatório ?1, antes que H2(z)

seja executado, e um outro atraso aleatório ?2 antes que H3(z) seja executado. Os atrasos

consideram o tempo de cálculo, atrasos de escalonamento ou atrasos introduzidos pela

rede de comunicação.

Para o modelo de sinal, o sistema em tempo contínuo é descrito por

x?c(t) = Axc(t) + Bu(t) + vc(t)

y(t) = Cxc(t),



2.2 Método com os Toolboxes Jitterbug e TrueTime 23

G(s) H1(z)

H2(z)

H3(z)
u y

(a) Modelo de sinal.

1

2

3

H1(z)

H2(z)

H3(z)

?1

?2

(b) Modelo de tempo.

Figura 2.8: Exemplo de um modelo Jitterbug de um sistema controlado por
computador.

onde A, B e C são matrizes constantes, vc é um processo de ruído branco em tempo

contínuo com covariância R1c. O custo deste sistema é especificado como

Jc = lim
T ??

1

T

? T

0

(

xc(t)

u(t)

)T

Qc

(

xc(t)

u(t)

)

dt, (2.19)

onde Qc é uma matriz semidefinida positiva. E o modelo em tempo discreto é descrito

por

xd(tk+1) = ?xd(tk) + ?u(tk) + vd(tk)

y(tk) = Cxd(tk) + Du(tk) + ed(tk),

onde ?, ?, C e D são matrizes não necessariamente constantes. A covariância dos pro-

cessos de ruído branco em tempo discreto vd e ed é dado por

Rd = E

?

?

?

(

vd(tk)

ed(tk)

)(

vd(tk)

ed(tk)

)T
?

?

?

. (2.20)

O sinal de entrada u é amostrado quando o sistema é atualizado, e o estado xd e o sinal de

saída y são mantidos constantes entre as atualizações. O custo deste sistema é especificado

como

Jd = lim
T ??

1

T

? T

0

(

xd(t)

u(t)

)T

Qd

(

xd(t)

u(t)

)

dt, (2.21)

onde Qd é uma matriz semidefinida positiva.

O sistema completo é obtido através das conexões entre as entradas e saídas dos

sistemas em tempo contínuo e em tempo discreto. Formulações MIMO (multi-input e



2.2 Método com os Toolboxes Jitterbug e TrueTime 24

multi-output) são permitidas. O custo total é a soma dos custos de todos os subsistemas

J =
?

Jc +
?

Jd. (2.22)

Percebe-se que tanto Jc quanto Jd refletem uma relação de energia do sistema, ou seja,

um valor de J elevado indica uma melhor relação de energia na entrada e na saída do

sistema. Em outros termos, um custo elevado indica que o sistema se encontra próximo

da região de instabilidade, onde J ? ?.

No modelo de tempo, cada nó é associado com um ou mais sistemas em tempo discreto

que devem ser atualizados quando o nó se torna ativo. No instante zero, o primeiro nó

é ativo. O primeiro nó também pode ser declarado periódico, ou seja, a execução será

reiniciada neste nó a cada h segundos. Isto é útil para modelar controladores periódicos

e simplifica os cálculos dos custos. Cada nó é associado a um atraso ?, que deve ser

transcorrido antes que o próximo nó se torne ativo. Um atraso é descrito por uma função

densidade probabilidade discreta

P? = [ P? (1) P? (2) . . . ], (2.23)

onde P? (k) representa a probabilidade de ocorrência de um atraso de k? segundos. O

passo da discretização do tempo ? é uma constante especificada para todo o modelo.

O mesmo sistema discreto pode ser atualizado em vários nós de tempo. É possível

especificar diferentes equações de diferenças (i.e., diferentes matrizes ?, ?, C e D) nos

vários casos. Isto pode representar controladores com compensação de jitter.

O cálculo do custo total é realizado em três passos:

1. as funções de custo, o ruído em tempo contínuo e os sistemas em tempo contínuo

são discretizados utilizando um passo ?;

2. o sistema em malha fechada é então formulado como um Sistema Linear com Sal-

tos Markovianos (Markov Jump Linear Systems – MJLS), onde são usados nós de

Markov para representar o período entre os nós de execução;

3. a variância estacionária de todos os estados do sistema é calculado.

Inicialmente, os estados e os custos são considerados no tempo contínuo. Os estados

em tempo discreto são tratados como estados em tempo contínuo com dinâmica nula. Isto



2.2 Método com os Toolboxes Jitterbug e TrueTime 25

significa que o sistema total pode ser escrito como

x?(t) = Ax(t) + vc(t), (2.24)

onde x representa todos os estados do sistema e vc é um processo de ruído branco em tempo

contínuo com covariância Rc. Para modelar as mudanças em tempo discreto de alguns

estados quando um nó de tempo n é ativado, o estado é transformado instantaneamente

por

x(t+) = Enx(t) + en(t), (2.25)

onde en(t) é um processo de ruído branco em tempo contínuo com covariância Wn.

Para o primeiro passo, o sistema da Equação (2.24) é amostrado com um período ?,

obtendo-se

x(k? + ?) = ?x(k?) + v(k?), (2.26)

onde a covariância de v é R. A função de custo para todo o sistema é então definida por

J = lim
N??

1

N?

N?1
?

k=0

(xT (k?)Qx(k?) + q), (2.27)

onde

? = eA? (2.28)

R =

? ?

0

eA(??? )Rce
AT (??? ) d? (2.29)

Q =

? ?

0

eA
T tQce

At dt (2.30)

q = tr

(

Qc

? ?

0

? ?

0

eA(t?? )eA
T (t?? ) d? dt

)

. (2.31)

Para o segundo passo, o sistema é modelado como um MJLS (Figura 2.9), onde cada

estado de Markov representa o estado do sistema para cada atraso. Cada nó de tempo é

representado por um nó de Markov. Nós adicionais podem ser inseridos para representar

atrasos entre os nós de tempo. A covariância do estado P(k?) = E{x(k?)xT (k?)} pode
ser escrita na forma recursiva como

P(k? + ?) = ?P(k?)?T + R. (2.32)

Quando um novo nó de tempo é alcançado, os estados mudam de acordo com a Equa-



2.2 Método com os Toolboxes Jitterbug e TrueTime 26

t

1 1

1

1

1

2 2 2 2
2

P? = [ 0.2 0.4 0.1 0.3 ]

0.2 0.4

0.1

0.3

0 ? 2? 3?

Figura 2.9: Exemplo de um modelo de tempo e a sua correspondente cadeia de
Markov.

ção (2.25). E a covariância do estado é descrita por

P(k?+) = EnP(k?)E
T
n + Wn, (2.33)

onde Wn é a covariância do ruído en(k?) no nó n. Desta forma, define-se:

?n =

{

? se n é um nó intermediário,

En? se n é um nó de tempo.
(2.34)

Analogamente:

Rn =

{

R se n é um nó intermediário,

EnRE
T
n Wn se n é um nó de tempo.

(2.35)

Para o terceiro passo, toma-se ?n(k?) como a probabilidade do sistema estar no estado

de Markov n no instante k?, e Pn(k?) a covariância do estado se o sistema está no estado

de Markov n no instante k?. Então, seja ? a matriz de transição da cadeia de Markov,

tal que

?(k? + ?) = ??(k?). (2.36)

Portanto a covariância do estado é dada por

Pn(k? + ?) =
?

i

?ni?i(k?)(?nPi(k?)?
T
i + Rn), (2.37)



2.2 Método com os Toolboxes Jitterbug e TrueTime 27

e o custo no passo k é dado por

1

?

?

n

?n(k?)(tr(Pn(k?)Q) + q). (2.38)

O custo total é calculado sobre a discretização de um período, para sistemas periódicos.

Para sistemas periódicos, a ferramenta pode também calcular a densidade espectral

de todas as saídas. Isto pode ser usado para análise em freqüência do sistema em malha

fechada. A densidade espectral de uma saída y é definida como

?y(?) =
1

2?

?
?

k=??

ry(k)e
?j?k, (2.39)

onde ry(k) é a função de covariância de y. Esta função é computada como

ry(k) = E{y(t)yT (t)(t + kh)}
= E{Cx(t)xT (t + kh)CT }
= C?

|k|
P1(?)CT

, (2.40)

onde ? é a matrix de transição média sobre um período e P1(?) é a covariância estaci-
onária em um nó periódico. A densidade espectral retorna como um sistema linear F(z)

tal que ?y(?) = F(ej?).

A análise feita com o modelo com atraso apresentado na seção anterior é feita consi-

derando somente o pior caso de atraso. Já com o Jitterbug a análise é feita para casos

específicos de atrasos (ou mais precisamente, de distribuições de atrasos). O valor da

função de custo é utilizado como parâmetro de comparação de desempenho e estabilidade

do sistema de controle entre os diferentes casos analisados. A estabilidade aqui citada é

a estabilidade no sentido quadrático médio (Mean Square Stability – MSS).

Uma forma simples de interpretar a análise com o Jitterbug é que o desempenho e a

estabilidade do sistema de controle depende tanto do valor do atraso como também da

freqüência que ele ocorre, i.e., podem existir atrasos que deixam o sistema momentanea-

mente instável, porém ele se mantém estável na média. Portanto, este método é menos

conservador que o método de análise com o modelo com atraso.

Para cada análise com o Jitterbug, é necessário fornecer como dado de entrada as

distribuições dos atrasos para cada nó de tempo. Estas distribuições podem ser obtidas

através de experimentos ou simulações, como por exemplo através do TrueTime, toolbox

que será apresentado na próxima seção.



2.2 Método com os Toolboxes Jitterbug e TrueTime 28

2.2.2 TrueTime

O TrueTime é um toolbox para MATLAB/SIMULINK que permite a simulação do com-

portamento temporal de um kernel multi-tarefa de tempo real executando tasks de con-

trole, sendo possível acrescentar alguns modelos de redes de comunicação.

Figura 2.10: Biblioteca de blocos do TrueTime.

Esta ferramenta é composta por uma biblioteca de blocos TrueTime (Figura 2.10)

para SIMULINK, que se conectam a outros blocos do SIMULINK para formar os mo-

delos TrueTime, mostrado na Figura 2.11. O bloco TT-Kernel é dirigido a eventos e

executa códigos que modelam tasks. Os modelos de tasks são descritos por arquivos do

tipo "arquivo.m"(como por exemplo o Código 2.1), chamados de code functions. O code

function é dividido em segmentos, e cada segmento é composto basicamente por pequenas

tarefas, como por exemplo a leitura de sinais através do conversor A/D através da função

ttAnalogIn(). Uma das características dos code functions (ou das tasks) é o seu pior

caso de tempo de execução (exectime), ou simplesmente WCET1 (Worst Case Execu-

tion Time). Além do WCET, as tasks são caracterizadas pelo seu período nominal de

amostragem (para tasks periódicas), pelo seu deadline relativo e pela sua prioridade de

execução (para o caso de escalonamento por prioridades). Estes atributos são definidos

pelo usuário através do script de inicialização do TT-Kernel, chamado de initialization

script (como por exemplo o Código 2.2). Nele também é definido a política de esca-

lonamento de tasks utilizada por este kernel. Desta forma, as informações do sistema

computacional são inseridas na avaliação de desempenho do NCS.

1O WCET é o tempo máximo que uma task demora para ser executada em determinado sistema
computacional.



2.2 Método com os Toolboxes Jitterbug e TrueTime 29

Dos atributos listados, apenas o WCET não é definido no projeto do sistema com-

putacional. A estimativa do WCET é obtida a partir de medidas do tempo decorrido

para execução da task em questão. Outra maneira de obter esta estimativa é através

de ferramentas de análises de WCET (SANDELL, 2004), como aiT, Bound-T, SWEET e

Chronos; que estimam o número de ciclos de clock necessário para a execução da task,

através do seu código Assembler.

u

Reference
Generator

Out

Output

s  +s2

1000

Dynamic System

R

y

u

Computer

r

u

1

u
A/D

Interrupts

Rcv

D/A

Snd

Schedule

Monitors

P

TrueTime Kernel

Terminator2

Terminator1

Terminator

Schedule

Schedule

Ground2

Ground1

2

y

1

R

Figura 2.11: Modelo TrueTime do sistema de controle de tempo real de um sistema
dinâmico.



2.2 Método com os Toolboxes Jitterbug e TrueTime 30

Código 2.1: Exemplo de code function (Pcontroller.m) para um controlador

proporcional.

1 function [ exectime , da ta ] = P c o n t r o l l e r ( segment , da ta )

2 s w i t c h segment ,

3 c a s e 1 ,

4 r = t t A n a l o g I n ( 1 ) ; % L e i t u r a do s i n a l de r e f e r ê n c i a

5 y = t t A n a l o g I n ( 2 ) ; % L e i t u r a do s i n a l de s a í d a

6 da ta . u = da ta .K ?( r?y ) ; % C á l c u l o do s i n a l de c o n t r o l e
7 e x e c t i m e = 0 . 0 0 2 ; % Tempo de ex ecu ção d e s t a t a s k

8 c a s e 2 ,

9 ttAnalogOut ( 1 , da ta . u ) ; % Atuação do s i n a l de c o n t r o l e

10 e x e c t i m e = ?1; % Fim da t a s k
11 end

Código 2.2: Exemplo de initialization script (exampleInit.m)

1 function e x a m p l e I n i t ( argument )

2 t t I n i t K e r n e l ( 2 , 1 , ’prioFP’) ; % I n i c i a ç ã o do Kernel com

3 % p r i o r i d a d e f i x a

4 da ta . u = 0 ; % V alor es i n i c i a i s de

5 da ta .K = 2 ; % v a r i á v e i s

6 p e r i o d = 0 . 1 ; % Período da t a s k

7 p r i o = 5 ; % P r i o r i d a d e da t a s k

8 t t C r e a t e P e r i o d i c T a s k ( ’ctrl’ , o f f s e t , p e r i o d , p r i o ,

9 ’Pcontroller’ , da ta ) ; % Cria a t a s k p e r i ó d i c a

Para a análise do sistema com rede de comunicação, utilizam-se os blocos de rede

TrueTime. Estes blocos simulam o acesso ao meio e a transmissão de pacotes em uma

rede local (LAN). Os protocolos de rede suportados são:

• CSMA/CD, por exemplo Ethernet;

• CSMA/AMP, por exemplo CAN ;

• Round Robin, por exemplo Token Bus;

• FDMA;

• TDMA;

• Ethernet comutada;

• IEEE 802.11b/g (WLAN);



2.2 Método com os Toolboxes Jitterbug e TrueTime 31

• IEEE 802.15.4 (ZigBee).

É possível definir a taxa de transmissão, o tamanho mínimo da mensagem, os WCET’s

e a probabilidade de perda da mensagem durante a transmissão. Para o caso com rede

wireless, é possível estipular a potência de transmissão, o threshold do sinal receptor e o

limite de retransmissão.

Tempo

i

i + 0.25

i + 0.50
E

st
ad

o

Em execução

Em preempção

Inativo

Figura 2.12: Exemplo de um diagrama de escalonamento, que mostra os 3 estados das
tasks (escalonamento de tasks) ou dos nós da rede (escalonamento da rede), através dos
nível de amplitude i (inativo), i + 0.25 (em preempção) e i + 0.50 (em execução), com

i = 1, . . . ,N, onde N é o números de tasks ou de nós da rede.

O TrueTime fornece diagramas de escalonamento como exemplificado na Figura 2.12,

nos quais são observados três estados das tasks (ou processos) e/ou dos nós da rede, em

função do tempo. Os estados inativo, em preempção e em execução são representados,

respectivamente, por níveis de amplitude i , i + 0.25 e i + 0.50, com i = 1, . . . ,N, onde N

é o número de tasks ou de nós da rede. No estado inativo, a task ou o nó não requerem

recursos computacionais (memória, CPU, meio físico da rede); no estado de preempção,

eles aguardam a disponibilidade dos recursos; e no estado de execução, eles utilizam os

recursos. Através destes diagramas, pode-se avaliar o uso dos recursos computacionais,

detectando, por exemplo, o fenômeno de starvation2.

Além dos diagramas, o TrueTime fornece logs3 que fornecem informações sobre os

atrasos do sistema, que são utilizadas na análise com o Jitterbug (CERVIN et al., 2006).

Desta forma, a análise de desempenho do NCS não fica restrita ao caso de atraso constante,

ou mesmo à análise do pior caso.

2Starvation ocorre quando um processo nunca é executado ("morre de fome"), pois processos de
prioridade maior sempre o impedem de ser executado (TANENBAUM, 2003).

3Logs são registros de atividades das tasks.



2.3 Exemplo Introdutório 32

2.3 Exemplo Introdutório

Para exemplificar e comparar os métodos apresentados durante o capítulo, toma-se um

sistema com uma planta

G(s) =
4

s2 ? 4
e um controlador

K(s) =
0.894 104s2 + 4.21 104s + 3.586 104

s3 + 88.2s2 + 3896.0s ? 137.9
,

cuja forma em tempo discreto é

Kd(z) =
59.71z?1 ? 108.90z?2 + 49.45z?3

1.00 ? 1.13z?1 + 0.20z?2 ? 0.07z?3
,

com período de amostragem h = 30ms.

Utilizando o modelo do sistema com atraso, a planta é representada por

G?d(z) =
[

C 0
]

(

zI ?
[

? ?1

0 0

])?1 [

?0

0

]

+ D

onde

? =

[

1.002 0.120

0.030 1.002

]

?0 =

[

0.0090

0.0000

]

?1 =

[

0.0210

0.0004

]

.

O diagrama de Bode do sistema em malha fechada é visto na Figura 2.13. O compor-

tamento do sistema com atraso tem maior amplitude de oscilação, com freqüência de

ressonância ?n ? 8 rad/s. Utilizando a ferramenta TrueTime, é possível simular o sis-
tema composto pelo controlador discreto (Kd(z)) e pela planta contínua (G(s)) para o

caso com e sem atraso. O resultado é visto na Figura 2.14, que está de acordo com os

resultados obtidos no diagrama de Bode: movimento oscilatório de freqüência ?n.

Utilizando o toolbox Jitterbug e considerando os casos do sistema sem atraso e com

atraso constante, é possível obter os espectros de freqüência dos sinais de saída como

observado na Figura 2.15. Nota-se que este resultado apresenta certa semelhança com o



2.3 Exemplo Introdutório 33

10
-1

10
0

10
1

10
2

-20

-15

-10

-5

0

5

10

15

20

Freqüência [rad/s]

M
ag

n
it

u
d
e

[d
B

]
? = 0

? = 21ms

Figura 2.13: Diagrama de bode do sistema com ? = 0 e ? = 21ms.

0 0.5 1 1.5 2 2.5 3
0

0.5

1

1.5

2

2.5

0 0.5 1 1.5 2 2.5 3

-20

0

20

40

60

Tempo [s]

S
aí

d
a

C
on

tr
ol

e ? = 0

? = 0

? = 21ms

? = 21ms

Figura 2.14: Resposta no tempo do sistema com e sem atraso ? = 21ms, com a planta
contínua (G(s)) e o controlador discreto (Kd(z)).

apresentado na Figura 2.13, indicando a concordância entre estes dois métodos. Para o

caso sem atraso a função de custo tem valor J = 7.1687; e para o caso com ? = 21ms,

J = 9.9541, indicando que ambos os sistemas são estáveis no sentido quadrático médio

(J finito), porém o desempenho do sistema com atraso é pior. Neste simples caso, não foi

necessário utilizar o TrueTime para obter a distribuição do atraso, visto que foi adotado

como constante para permitir a comparação entre os métodos. Porém como explicado

anteriormente, o Jitterbug não se limita a fazer análise somente para casos com atraso

constante.



2.4 Conclusão 34

10
-1

10
0

10
1

10
2

-20

-10

0

10

20

30

40

Freqüência [rad/s]

M
ag

n
it

u
d
e

[d
B

]

? = 0

? = 21ms

Figura 2.15: Densidade espectral do sinal de saída do sistema com e sem atraso
? = 21ms, obtido através do Jitterbug.

2.4 Conclusão

Neste capítulo foram apresentados os métodos que serão utilizados neste trabalho para

analisar o desempenho de sistemas de controle quando estes sofrem efeitos de atrasos

aleatórios. O primeiro método envolve o uso de um modelo de um sistema com atraso,

que permite fazer a análise através das teorias clássicas de controle. Embora este método

seja mais simples, a análise é feita sempre considerando o pior caso de atraso, podendo

assim ser um tanto quanto conservador. Já o outro método envolve o uso de dois toolboxes

(TrueTime e Jitterbug) que, através das informações do sistema computacional fornecem

as distribuições dos atrasos aleatórios. Estas distribuições são utilizadas na análise esto-

cástica de desempenho e estabilidade do sistema com atrasos aleatórios através da teoria

de MJLS. Através de um exemplo foi possível verificar a eficácia e a concordância entre

os métodos.



35

3 Redes de Comunicação para

Sistemas de Controle

A arquitetura tradicional de redes de comunicação para sistemas de controle que vem

sendo implantada durante décadas é a do tipo ponto-a-ponto (peer-to-peer ), ou seja, um

cabo conecta o computador do controle central a cada sensor e atuador. Entretanto

o aumento da complexidade destes sistemas está empurrando este tipo de arquitetura

para o seu limite (LIAN, 2001). Assim, o sistema de controle ponto-a-ponto centralizado

vem sendo substituído por sistemas descentralizados através de uma rede de comunicação

comum à todos os seus componentes.

A introdução deste tipo de arquitetura pode aumentar a eficiência, a flexibilidade e

a confiabilidade destas aplicações integradas e reduzir os custos e o tempo de instalação,

de reconfiguração e manutenção. Entretanto, esta mudança introduz atrasos e perdas nas

transmissões dos sinais de controle.

Os sinais de controle em NCSs são transmitidos por pequenas porém freqüentes men-

sagens que trafegam entre inúmeros nós da rede. Em princípio, estas mensagens devem

respeitar os requisitos de tempo de STRs. Esta é a principal característica de redes

de comunicação utilizadas em sistemas de controle. Em outras aplicações de redes de

comunicação (e.g., Internet), o tamanho, a periodicidade das mensagens e o tempo de

envio/recebimento não são fatores críticos para a correta operação do sistema.

A adoção de redes de comunicação em sistemas de controle possibilita a distribuição

das funções de processamento e carga computacional entre algumas pequenas unidades de

processamento. Esta distribuição do processamento pode tornar o sistema mais robusto

visto que um sistema centralizado está sujeito à um único ponto de falha. Além disso,

a rede permite que o sinal proveniente de um sensor seja disponibilizado para vários

dispositivos ao mesmo tempo sem a necessidade de duplicação de sensores.



3 Redes de Comunicação para Sistemas de Controle 36

hA hB hC

A B C

Período de Amostragem

D
es

em
p
en

h
o

MenorMaior

M
el

h
or

P
io

r

NCS

Controle Discreto

Controle Contínuo

Sistema Instável

Sistema Estável
Desempenho Não-aceitável

Sistema Estável
Desempenho Aceitável

Figura 3.1: Comparação de desempenho do controle para os casos de controle
contínuo, controle discreto e NCS em função do período de amostragem adotado.

Como já visto, o objetivo principal do projeto de NCSs é garantir que, mesmo com

perdas e atrasos dos sinais de controle, o sistema atenda às suas especificações de de-

sempenho, que incluem margens de fase e de ganho, máximo sobressinal, erro em regime,

entre outros. E uma forma para atingir (parte) deste objetivo é analisar o efeito de atrasos

em NCS, como observado no Capítulo 2.

Uma forma de apresentar os resultados das análises é através de um gráfico seme-

lhante ao da Figura 3.1. Neste tipo de gráfico os desempenhos do sistemas de controle

são dados em função do período de amostragem adotado. Neste gráfico, especificamente,

são comparados três casos: sistema de controle em tempo contínuo, em tempo discreto e

NCS. No caso contínuo, o desempenho do sistema de controle é independente do período

de amostragem. Já para o caso discreto, percebe-se que um maior período de amostragem

degrada o desempenho do sistema de controle, podendo levar o sistema para região de

instabilidade. No caso de NCS, um maior período de período de amostragem também

degrada o desempenho do sistema de controle. Porém, com um menor período de amos-

tragem aumenta-se a carga na rede, aumentando assim a probabilidade de perdas e de

atrasos dos sinais de controle. Desta forma, um menor período de amostragem também

degrada o desempenho do sistema de controle.

Para realizar este tipo de análise, é necessário conhecer os fatores que impactam o

desempenho do sistema de controle e como variam em função da rede de comunicação

adotada. Este é o objetivo de trabalhos como Montestruque e Antsaklis (2005a), Lian

(2001) e Nilsson (1998) que analisam este comportamento através de modelos de redes de

comunicação. Os fatores que impactam no desempenho de sistemas de controle incluem:



3.1 Candidatas à rede de controle 37

• o atraso para acesso ao meio – tempo necessário para que o dispositivo tenha acesso
ao meio físico da rede;

• o tempo de transmissão – tempo necessário para que a mensagem percorra o meio
físico, que depende da velocidade de transmissão e do tamanho das mensagens;

• porcentagem de colisões – relação entre o número de mensagens que acessam o meio
físico ao mesmo tempo e o número total de mensagens;

• porcentagem de perda de mensagens – relação entre o número de mensagens que
não são transmitidas com sucesso e o número total de mensagens.

Para sistemas de controle, as candidatas à rede de comunicação precisam basicamente

atender a dois critérios principais: atrasos limitados e garantia de transmissão. Ou seja,

as mensagens devem ser transmitidas com sucesso em um tempo limitado. A perda de

mensagens e/ou atrasos na transmissão deterioram o desempenho de NCSs e até podem

torná-los instáveis (WALSH et al., 2002).

Assim, as redes de comunicação podem ser classificadas como: redes de controle e redes

de dados. A diferença entre as duas é que a rede de controle tem requisitos de tempo

real (o tempo de resposta pré-determinado deve ser obedecido) (LIAN, 2001). Além disso,

em redes de controle as mensagens são, geralemente, pequenas (em número de bits) e

periódicas; diferentemente de redes de dados, cujas mensagens são, geralmente, grandes

(em número de bits) e aperiódicas. O objetivo deste capítulo é apresentar as principais

candidatas a rede de controle (Ethernet, ControlNet e DeviceNet) mostrando as vantagens

e as desvantagens de sua implementação em NCSs, na Seção 3.1. Na Seção 3.2, são

comparados parâmetros relevantes para NCSs destas possíveis candidatas.

3.1 Candidatas à rede de controle

As principais candidatas à rede de comunicação para NCSs consideradas neste trabalho são

aquelas cuja implementação em sistemas de controle tem sido bem sucedida nos últimos

anos, a saber: Ethernet, ControlNet e DeviceNet. É importante salientar que não estão

sendo desconsiderados outros tipos de rede para uso em sistemas de controle, apenas

constata-se que os três tipos citados são os mais aplicados.



3.1 Candidatas à rede de controle 38

3.1.1 Ethernet

A Ethernet é tida como a solução mais prática para NCSs devido ao seu baixo custo, a sua

flexibilidade (e.g., facilidade de inclusão nós na rede) e a suas altas taxas de transmissão.

Em contrapartida, a natureza não-determinística do seu mecanismo de detecção de colisões

(CSMA/CD) é sua maior desvantagem para este tipo de implementação, ou seja, não há

garantias (teoricamente) com relação ao tempo de resposta.

Portanto, se os atrasos são não-determinísticos, por que considera-se a Ethernet

como uma candidata a rede de controle? Apesar de teoricamente os atrasos serem não-

determinísticos, na prática observa-se que, para redes Ethernet com poucos nós, as altas

taxas de transmissão proporcionam ao sistema atrasos relativamente pequenos (OTANEZ

et al., 2002).

Dado que neste tipo de rede, para cada colisão os nós esperam um tempo aleatório

para reenviar as mensagens, é natural relacionar o aumento do número de colisões (de-

corrente de um aumento do tráfego) com maiores atrasos e, conseqüentemente, com pior

desempenho do sistema de controle. O trabalho de (OTANEZ et al., 2002) mostra através

de relações empíricas que os atrasos são diretamente proporcionais a taxa de colisão na

rede. E da mesma forma, este mesmo trabalho também mostra que, para pequenas cargas

na rede, o desempenho do sistema de controle (medido pelo critério IAE) é diretamente

proporcional ao uso da rede (medido em relação à sua largura de banda).

Assim conclui-se que o uso da Ethernet em NCSs é possível, mesmo que os atrasos

envolvidos sejam de caráter não-determinísticos. Para tanto, é necessário que os atrasos

sejam minimizados através do uso mais eficiente da banda da rede e da diminuição das

colisões das mensagens no meio. Para isto, recomenda-se que o uso da rede não ultrapasse

25% da sua largura de banda (OTANEZ et al., 2002), em sistemas de controle. Outra

possibilidade é utilizar a chamada Ethernet Comutada (Switched Ethernet) que permite

uma conexão direta entre o nó emissor e o nó receptor, eliminando o problema de colisões

(KAPLAN, 2001).

3.1.2 ControlNet

A rede do tipo ControlNet é tida como determinística pois o tempo de espera de um nó

para envio da mensagem tem um limite máximo. Este tipo de rede utiliza o mecanismo

de detecção de colisão token bus, onde o nó com o token transmite a mensagem até que



3.1 Candidatas à rede de controle 39

esta acabe ou até que o seu período de transmissão acabe. Então o nó passa o token ao

seu sucessor lógico (não necessariamente seu "vizinho"físico). Se o nó não tem nenhuma

mensagem para transmitir, ele apenas passa o token para seu sucessor lógico. Neste tipo

de rede não ocorrem colisões, visto que só um nó pode transmitir de cada vez.

Portanto neste caso os atrasos são limitados, tornando a rede determinística. E mesmo

que o protocolo token bus seja eficiente e determinístico para altas cargas na rede, para

baixas cargas o desempenho da rede é menor quando comparado ao desempenho de redes

com outros protocolos. Em geral, quando há muitos nós na rede, uma porcentagem alta

do tempo de rede (tempo do processo de transmissão de mensagens) é consumida no

processo de transição do token entre os nós, para os casos de baixas cargas (KOUBIAS;

PAPADOPOULOS, 1995). Outro problema é a transmissão de mensagens grandes, visto

que estas para serem totalmente transmitidas precisam que o token passe algumas vezes

pelo nó emissor, aumentando consideravelmente o tempo de rede.

3.1.3 DeviceNet (CAN)

CAN é um protocolo de comunicação serial desenvolvido principalmente para aplicações

na indústria automotiva porém oferece bom desempenho em aplicações industriais de

tempo-crítico (LIAN; MOYNE; TILBURY, 2002). Este protocolo é otimizado para pequenas

mensagens e usa o mecanismo CSMA/AMP para controle de acesso ao meio. Neste caso,

o protocolo é orientado a mensagem, e cada mensagem tem uma prioridade específica que

é usada para ordenar o acesso ao meio em caso de colisões. No caso de dois nós iniciarem

a transmissão de suas mensagens ao mesmo tempo, aquele que tiver maior prioridade vai

dar seguimento no processo de envio. Com isso a transmissão não é interrompida.

A rede do tipo DeviceNet é de custo relativamente baixo e tem sido bem aceita em

aplicações industriais (LIAN; MOYNE; TILBURY, 2002). Além disso, a vantagem principal

deste tipo de rede para NCSs é o seu determinismo, visto que para mensagens de alta

prioridade, o atraso na transmissão pode ser garantido. Porém, a maior desvantagem

da rede CAN é sua baixa taxa de transmissão (máximo 500Kbps), que é menor do que

outros tipos de rede. Outro fator limitante para a sua aplicação é a distância física máxima

permitida entre os nós (menor do que em outros tipos de rede). E este tipo de rede não

é recomendada para transmissão de grandes mensagens.



3.2 Comparação entre as Candidatas 40

3.2 Comparação entre as Candidatas

Alguns parâmetros das candidatas são apresentados na Tabela 3.1. Segundo o trabalho

de Lian (2001), para pequenas mensagens (menor que 10bytes) a rede Ethernet precisa

de mais overhead 1 do que ControlNet e DeviceNet. Entretanto, para mensagens longas,

DeviceNet requer mais bits para transmitir a mesma informação.

Ethernet ControlNet DeviceNet
Tx. de transmissão [Mbps] 10 5 0.5

Máx. distância [m] 2500 1000 100
Máx. tamanho [byte] 1500 504 8
Máx. número de nós &gt; 1000 99 64

Tabela 3.1: Parâmetros das redes de controle.

O referido trabalho também apresenta o tempo de rede em função do tamanho das

mensagens. Conclui-se que o tempo de rede para DeviceNet é maior do que nas outras

redes, independentemente do tamanho das mensagens. Isto pode ser explicado pela sua

baixa taxa de transmissão. Para pequenas mensagens, o tempo de rede para ControlNet

é menor que para Ethernet. E esta situação se inverte para mensagens maiores. Isto é

justificado pelo tamanho dos respectivos overheads.

3.3 Conclusão

O aumento da complexidade de sistemas de controle distribuídos cria necessidades para a

implantação de novas soluções de rede de comunicação (diferentes de P2P) que aumentam

a eficiência, a flexibilidade, a confiabilidade, a robustez (contra falhas de hardware), etc

dos sistemas de controle. Porém, como visto ao longo deste capítulo, para implementação

em NCSs, as redes de comunicação (redes de controle) devem atender à requisitos de

tempo real, ou seja, o tempo de resposta pré-determinado deve ser obedecido.

Neste capítulo foram descritos três possíveis tipos de rede para NCSs: Ethernet,

ControlNet e DeviceNet. Cada qual com suas vantagens e desvantagens. Um resultado

prático visto foi o uso da Ethernet em NCSs, mesmo não sendo considerada (teoricamente)

uma rede de comunicação determinística. E comparou-se parâmetros relevantes para NCS

1A informação que acompanhada uma mensagem na rede para garantir sua transferência sem erros
para destino desejado.



3.3 Conclusão 41

das três candidatas: taxa de transmissão, máxima distância entre nós, tamanho máximo

dos pacotes e número máximo de nós. Portanto, com estes dados pode-se avaliar qual

tipo de rede é melhor para cada situação.



42

4 Estudo de Caso

Normalmente, o controlador é projetado e analisado em tempo contínuo. Atendendo

aos requisitos, o controlador é discretizado e analisado através de simulações. Nestas

simulações o sistema de controle discreto é considerado ideal, i.e., o ciclo de controle

(amostragem, cálculo do sinal de controle e atuação) é executado instantaneamente no

momento que a amostragem é efetuada. Esta pode ser uma aproximação válida para

sistemas onde o tempo de execução do ciclo é pequeno quando comparado ao seu período

de amostragem, de forma que não haja risco de perda de desempenho do sistema de

controle.

Porém, como observado no Capítulo 2, existem casos em que é necessário considerar

este tempo de execução no projeto do sistema de controle. O trabalho de Lian, Moyne e

Tilbury (2002) mostra a existência de uma relação de compromisso entre o desempenho

do controlador e o desempenho do sistema computacional, ambas em função do período

de amostragem nominal h. Um maior h tende a diminuir a carga computacional, pro-

movendo um melhor desempenho do sistema computacional. E um aumento no valor de

h tende a degradar o desempenho do controlador discreto. Portanto no desenvolvimento

do sistema de controle computadorizado, esta relação de compromisso deve ser levada em

consideração na escolha do período de amostragem nominal.

O objetivo deste capítulo é, através de um exemplo, mostrar esta relação de com-

promisso através dos métodos apresentados no Capítulo 2. Para isso, na Seção 4.1 é

apresentado o modelo da planta e o controlador PID, assim como sua representação em

equações de diferenças. Na Seção 4.2 é apresentada a análise com modelo com atraso.

Nas Seções 4.3 e 4.4, o sistema é analisado através dos toolboxes Jitterbug e TrueTime.

Na Seção 4.5 são apresentadas as conclusões obtidas com as análises realizadas ao longo

do capítulo.



4.1 O Sistema 43

4.1 O Sistema

Neste estudo de caso será analisado o controle de velocidade de rotação de um motor de

corrente contínua representado por

G(s) =
1.5

s2 + 0.6s + 4.55
=

5

(s ? (?0.3 + i2.11))(s ? (?0.3 ? i2.11))
, (4.1)

cuja resposta no tempo para uma entrada degrau é dada na Figura 4.1.

0 2 4 6 8 10 12 14 16 18
0

0.1

0.2

0.3

0.4

0.5

0.6

0.7

?
[r
a
d
/
s
]

Tempo[s]

Figura 4.1: Resposta do motor CC para uma entrada degrau unitário.

É adotado para este sistema um controlador do tipo PID, cujo diagrama de blocos é

apresentado na Figura 4.2.

+

-

+

-

?ref (s) u(s) ?(s)
PI(s)

D(s)

G(s)

Figura 4.2: Diagrama de implementação do controlador PID adotado, onde ?ref (s) é o
sinal de referência, u(s) é o sinal de controle, ?(s) é o sinal de saída, PI(s) é o termo

proporcional e integral do controlador e D(s) e o termo derivativo do controlador.

O sistema portanto é descrito por

?(s)

?ref (s)
=

G(s)PI(s)

1 + G(s)[PI(s) + D(s)]
, (4.2)



4.1 O Sistema 44

onde PI(s) refere-se ao termo proporcional e integral do controlador dado por

PI(s) = K

(

1 +
1

Tis

)

, (4.3)

D(s) refere-se ao termo derivativo dado por

D(s) =
KTds

1 + Tds
N

, (4.4)

enquanto que a função de malha aberta é dada por

L(s) =
G(s)PI(s)

1 + G(s)D(s)
. (4.5)

Para obter um sistema com amortecimento supercrítico e com uma resposta relativa-

mente rápida, adota-se:

• K = 72,

• Ti = 4,

• Td = 0.16,

• N = 32.

Desta forma, o sistema apresenta margens de ganho Kg = ? e de fase ? = 68.5?. A
resposta do sistema para entrada degrau no domínio do tempo (Figura 4.3) mostra que o

sistema atende aos requisitos, apresentando um tempo de subida1 Tr ? 0.26s.

A representação do controlador PID em tempo discreto através através de equações

de diferenças (ÅSTRöM; HäGGLUND, 1995) é dado por

Pk = Kek

Ik+1 = Ik + bi1ek+1 + bi2ek

Dk = adDk?1 ? bd(yk ? yk?1)
uk = Pk + Ik + Dk.

(4.6)

Nestas equações, Pk, Ik e Dk representam as ações proporcional, integral e derivativa,

respectivamente, do controlador no instante k. Os coeficientes bi1, bi2, ad e bd são dados

em função do período de amostragem h; dos parâmetros K, Ti, Td e N; e do método

1Geralmente, para sistemas superamortecidos, o tempo de subida é definido como o tempo requerido
para que a resposta passe de 10% a 90% do seu valor final.



4.1 O Sistema 45

0 0.1 0.2 0.3 0.4 0.5 0.6
0

0.2

0.4

0.6

0.8

1

1.2

1.4

 

 
?

[r
a
d
/
s
]

Tempo[s]

Figura 4.3: Resposta do sistema em malha fechada dado pela Equação (4.2) para uma
entrada degrau.

Diferenças
para frente

Diferenças
para trás

Tustin

bi1 0
Kh
Ti

Kh
2Ti

bi2
Kh
Ti

0 Kh
2Ti

ad 1 ? N hTd
Td

Td+N h
2Td?N h
2Td+N h

bd KN
KTdN
Td+N h

2KTdN
2Td+N h

Tabela 4.1: Coeficientes do controlador PID em tempo discreto, dados em função do
método de aproximação.

de aproximação utilizado (diferenças para trás, diferenças para frente, Tustin, etc.), como

observado na Tabela 4.1. O sinal de referência é rk e o sinal de erro é dado por ek = rk ?yk.

O próximo passo para a implementação de controlador em um sistema digital é a esco-

lha do período de amostragem h para o ciclo de controle. Existem diversas regras práticas

para esta escolha. Uma delas apresentada por Åström e Hägglund (1995), estabelece que

o período de amostragem h é tal que

h =
Tr
Nr
, (4.7)

onde Nr é o número de ciclos de controle por tempo de subida, e pertence ao intervalo de

4 a 10 ciclos. Para este caso, esta regra prática fornece o intervalo [0.026, 0.065]s para a

escolha do período de amostragem. Nesta escolha nota-se que existe um limite máximo

e um limite mínimo para h. Isto porque um período de amostragem longo prejudica a

reconstrução do sinal amostrado deteriorando o desempenho do controlador; e um período



4.2 Análise com Modelo do Sistema com Atraso 46

de amostragem muito curto aumenta a carga de utilização do sistema computacional

(ÅSTRöM; WITTENMARK, 1997), aumentando a probabilidade de atrasos na realização

de suas tarefas (WITTENMARK; NILSSON; TORNGREN, 1995). Deste fato, conclui-se que

há uma relação de compromisso entre desempenho do controlador e o desempenho do

sistema computacional. Porém, este limite mínimo dado pela regra prática não considera

diretamente as informações do sistema computacional sobre o qual o controlador será

implementado, podendo ser uma escolha conservadora ou inadequada. Um exemplo deste

fato pode ser observado no trabalho de Cervin et al. (2006), onde para alguns sistemas, o

período de amostragem mínimo dado pela regra prática torna o sistema instável.

Considerando que este sistema de controle discreto seja ideal, com período de amos-

tragem h = 0.05s e sem a presença de atrasos, a sua simulação através do SIMULINK

oferece a saída mostrada na Figura 4.4. Observa-se que o sistema se comporta da maneira

especificada no projeto. Portanto, neste caso o projeto do sistema de controle poderia

ser considerado satisfatório. Porém, como se mostrará nas próximas seções, a aproxima-

ção por um sistema ideal pode não ser suficiente para garantir um bom desempenho do

sistema de controle computadorizado.

0 1 2 3 4 5 6 7 8 9 10
?1

?0.5

0

0.5

1

 

 

 

0 1 2 3 4 5 6 7 8 9 10
?200

?100

0

100

200

Referência
Saída

Tempo[s]

Tempo[s]

?
[r
a
d
/
s
]

V
a
[V

]

Figura 4.4: Saída ? e sinal de controle Va para o sistema de controle discreto ideal.

4.2 Análise com Modelo do Sistema com Atraso

Assim como o modelo ideal, o modelo do sistema com atraso é uma aproximação do sis-

tema real pois ele também considera que a amostragem ocorre em um tempo infinitesimal

e exatamente nos instantes de amostragem kh. A diferença entre os modelos está no



4.2 Análise com Modelo do Sistema com Atraso 47

atraso introduzido para representar o tempo decorrido entre o cálculo do sinal de controle

e sua atuação no sistema, como mostrado na Figura 2.7.

A partir da Equação (4.2) e do modelo da planta com atraso

Gd(z) =
[

C 0
]

[

zI ?
[

? ?0

0 0

]]?1 [

?0

I

]

, (4.8)

tem-se a função de transferência do sistema em malha fechada em tempo discreto com

atraso

Gdcl(z) =
Gd(z)PI(z)

1 + Gd(z)[PI(z) + D(z)]
, (4.9)

onde PId(z) e Dd(z) são as funções de transferência que compõem o controlador PID em

tempo discreto. Com esta função de transferência, são obtidos os diagramas de Bode em

tempo discreto, ilustrados na Figura 4.5. Foram considerados três casos:

• h = 0.05s sem atraso;

• h = 0.05s com atraso d = 0.01s (d = 0.20h);

• h = 0.05s com atraso d = 0.03s (d = 0.60h).

Nestes diagramas observa-se que conforme o atraso aumenta o sistema em malha fechada

adquire um comportamento mais oscilatório; e para o caso com d = 0.03s o sistema apre-

senta uma freqüência de ressonância ?r ? 21.0 rad/s. Utilizando o modelo SIMULINK
da Figura 4.6, onde é introduzido um atraso de transporte na entrada da planta, estes

casos são simulados e os resultados são mostrados na Figura 4.7. Nota-se que, assim como

esperado, para um tempo de execução do ciclo de controle (ou atraso) pequeno (d = 0.01s)

em relação ao seu período de amostragem (h = 0.05s) o sistema se comporta de forma

semelhante ao sistema dito ideal (sem atraso); e para o caso com d = 0.03s, o sistema

oscila na freqüência natural amortecida.

Para fazer a análise em freqüência do sistema para diferentes períodos de amostragem

com alguns casos de atraso, parte-se das Equações (2.11), (2.12), resultando na função de

malha aberta em tempo discreto

Ld(z) =
Gd(z)PI(z)

1 + Gd(z)D(z)
.

Com esta função de malha aberta, são obtidos os diagramas de Nyquist em tempo discreto,

ilustrados na Figura 4.8. Nele são apresentados os resultados para os casos:



4.2 Análise com Modelo do Sistema com Atraso 48

-50

-40

-30

-20

-10

0

10

20

10
1

10
2

-540

-450

-360

-270

-180

-90

0

 Freqüência [rad/s]

M
ag

n
it

u
d
e

[d
B

]
F
as

e
[?

]

h = 0.05s sem atraso
h = 0.05s e d = 0.20h
h = 0.05s e d = 0.60h

Figura 4.5: Diagramas de Bode obtido através da função de transferência Gdcl(z) com
o h = 0.05s e alguns casos de atrasos. Observa-se também no diagrama a freqüência de

Nyquist (metade da freqüência de amostragem).

r, y
Referencia

Reconstrutor 

de ordem zero

PI (z)

_ PI _d.num {1}

_ PI _d.den {1} (

Motor DC

G.num {1}(s)

G. den {1}(s)

Delay de 

transporte

Ti

D(z)

_ D_ d. num {1} (

_ D_ d.den {1}(

Constant

delay

PID(z)

atraso G(s)

Figura 4.6: Modelo SIMULINK do sistema com atraso. O atraso é representado por
um atraso de transporte na entrada da planta com um reconstrutor de ordem zero.

0 1 2 3 4 5 6 7 8 9 10
?1.5

?1

?0.5

0

0.5

1

1.5

 

 

 

?
[r
a
d
/
s
]

Tempo[s]

Referência
h = 0.05s sem atraso
h = 0.05s e d = 0.01s
h = 0.05s e d = 0.03s

Figura 4.7: Resultado da simulação com o modelo SIMULINK da Figura 4.6 para os
casos com h = 0.05s e atrasos d = 0, 0.20h e 0.60h.



4.2 Análise com Modelo do Sistema com Atraso 49

• h = 0.026s sem atraso;

• h = 0.026s com atraso d = 0.01s;

• h = 0.026s com atraso d = 0.03s;

• h = 0.05s sem atraso;

• h = 0.05s com atraso d = 0.01s;

• h = 0.05s com atraso d = 0.03s.

Os valores aqui adotados para o período de amostragem foram obtidos pela regra prá-

tica dada pela Equação (4.7). A partir destes diagramas pode-se afirmar que o caso com

h = 0.05s e d = 0.01s apresenta um melhor desempenho do que o caso com h = 0.026s

e d = 0.03s. A resposta no tempo para estes dois casos são observados na Figura 4.9,

corroborando com a análise em freqüência. Ou seja, mostra-se que um sistema de controle

que apresenta um período de amostragem maior (no caso, h = 0.05s) pode ter um desem-

penho melhor quando comparado ao caso de com um período de amostragem menor (no

caso, h = 0.026s), dependendo do atraso presente neste sistema.

-1 -0.5 0 0.5
-1

-0.8

-0.6

-0.4

-0.2

0

0.2

0.4

0.6

0.8

1

Eixo Real 

E
ix

o
 

h = 0.026s sem atraso

h = 0.026s com atraso d = 0.01s

h = 0.026s com atraso d = 0.03s

h = 0.05s sem atraso

h = 0.05s com atraso d = 0.01s

h = 0.05s com atraso d = 0.03s

Figura 4.8: Diagramas de Nyquist da função de malha aberta Ld(z) para 6 situações
distintas.



4.3 Simulação com o TrueTime 50

0 1 2 3 4 5 6 7 8 9 10
?1.5

?1

?0.5

0

0.5

1

1.5

 

 

 

?
[r
a
d
/
s
]

Tempo[s]

Referência
h = 0.026s e d = 0.03s
h = 0.05s e d = 0.01s

Figura 4.9: Saídas do sistema para h = 0.05s e d = 0.01s e para h = 0.026s e
d = 0.03s.

4.3 Simulação com o TrueTime

Na seção anterior foi utilizado um modelo de sistema com atraso na análise em freqüência

de um sistema de controle computadorizado. Adotou-se como hipótese que o tempo entre

o início e o fim do ciclo de controle é definido como uma atraso constante. Porém, sob o

contexto de NCS esta hipótese simplificadora podem não ser suficiente (NILSSON, 1998).

Nesta seção mostrar-se-á como a presença de atrasos aleatórios influencia no desempe-

nho do NCS, concluindo que existe uma relação de compromisso entre o desempenho

do sistema de controle e o desempenho sistema computacional. Para tanto utiliza-se a

ferramenta TrueTime e o modelo de NCS observado na Figura 4.10.

Motor

Controlador
Nó

Extra

Va ?

1 task
periódica

1 task
aperiódica

1 task
aperiódica

1 task
periódica

1 task
periódica

Atuador Sensor

Rede de comunicação

Figura 4.10: Modelo de NCS utilizado nesta seção.

Nesta seção, o ciclo de controle é composto por uma seqüência de três etapas:



4.3 Simulação com o TrueTime 51

• amostragem (ou sensoriamento) e transmissão pela rede de comunicação;

• cálculo do sinal de controle e transmissão pela rede de comunicação;

• atuação do sinal de controle sobre a planta.

O modelo TrueTime (Figura 4.11) deste caso é composto por um NCS para controlar

a velocidade do motor CC através de uma rede de comunicação CAN. Nesta rede estão

conectados os nós do controlador, do atuador, do sensor e um nó extra que representa

outros nós ligados à rede e que não participam diretamente do ciclo de controle. Cada

nó é composto por um kernel-RT com política de escalonamento de tasks por prioridade

fixa.

r, y ; u
Step

Rede

snd1

snd2

snd3

snd4

rcv1

rcv2

rcv3

rcv4

No 4
(Sensor)

A/D Snd

No 3
(Controlador)

Rcv

r

Snd

No 2
(Atuador)

Rcv D/A

No 1
( )

RcvSnd

Motor DC

G.num {1}(s)

G.den {1}(s)

u
y

u

y
Disturbio

Display

20

Clock r, y

u

Figura 4.11: Modelo TrueTime do sistema de controle do motor CC.

Para este caso, adota-se um sistema de controle mono-rate, ou seja, com somente um

período de amostragem nominal h para o ciclo de controle. O ciclo de controle inicia no

sensor, onde uma task periódica faz a leitura do sinal de saída ? através do conversor

A/D e envia esta informação pela rede para o nó do controlador. Quando a mensagem

chega no controlador uma interrupção inicia uma task aperiódica que contém as equações

de diferenças do controlador PID. O sinal de controle então é calculado e enviado para

o nó do atuador. Quando a mensagem chega no atuador uma interrupção inicia a task

aperiódica que transforma a informação em sinal de controle Va através do conversor

D/A de ordem zero. Como o nó extra da rede, é inserida uma task extra no kernel

do controlador representando outras tasks que não participam diretamente do ciclo de

controle. Os atributos destas tasks são dados na Tabela 4.2.

De acordo com o trabalho realizado por Nilsson (1998), numa rede CAN, as mensagens

do sensor para o controlador e as mensagens do controlador para o atuador são formadas



4.3 Simulação com o TrueTime 52

Kernel Task Prioridade WCET Período Deadline

controlador
periódica 1 1s 4s –
aperiódica 2 0.005s – 100s

sensor periódica 2 0.003s h –
atuador aperiódica 2 0.003s – 100s
extra periódica 1 – 0.001s –

Tabela 4.2: Características das tasks do sistema.

por palavras que variam entre 64 a 128 bits, incluindo os bits de endereço e os bits de

controle. O trabalho de Chow e Tipsuwan (2003) indica que as mensagens do sensor para

o controlador são menores (em números de bits) do que as mensagens do controlador para

o atuador. Portanto, para este caso estipula-se:

• mensagens com prioridade 2 e 80 bits, do sensor para o controlador;

• mensagens com prioridade 3 e 120 bits, do controlador para o atuador;

• mensagens com prioridade 1 e 80 bits, do nó extra para ele mesmo.

As mensagens do nó extra são colocadas na rede de forma a ocupar cerca de 80% da banda

de forma aleatória, sendo definida para esta rede uma taxa de transferência de 80 Kbps,

com probabilidade nula de perda de dados.

As grandezas analisadas neste caso são definidas como:

• LkS - latência do sensor (tempo decorrido entre o início da amostragem e o início do
cálculo);

• LkC - latência do controlador (tempo decorrido entre o início do cálculo e o início da
atuação);

• hk - intervalo de amostragem (tempo decorrido entre o final de dois ciclos de controle
consecutivos).

Estas grandezas estão ilustradas na Figura 4.12.

São analisados cinco casos: h = 0.01s, 0.02s, 0.04s, 0.06s e 0.07s. Como no trabalho

de Lian, Moyne e Tilbury (2002), para avaliar o desempenho do NCS em cada caso,

utiliza-se o critério ITAE dado por

ITAE =

? tf

t0

t|e|dt, (4.10)



4.3 Simulação com o TrueTime 53

      

        

(k ? 1)h kh (k + 1)h

Início da task

Final da task

Execução da task

Sensor

Controlador

Atuador

LS

LC

hk

t

t

t

Figura 4.12: Ilustração das grandezas analisadas neste estudo de caso e das tasks
envolvidas no ciclo de controle. Nota-se que a task no controlador pode apresentar um

intervalo durante sua execução devido à preempção.

onde t0 e tf são os tempos inicial e final do período avaliado e e é a diferença entre o sinal

de referência e o sinal de saída. O critério ITAE é uma medida relativa entre desempenho

de sistemas de controle, visto que um valor ITAE maior (em relação a um valor ITAE

menor) indica que o sistema é relativamente menos estável que outro, de forma que valores

muito elevados indicam que o sistema tende a ser instável.

Considerando que os WCETs das tasks são independentes do período de amostragem

nominal, tem-se:

• o tempo de execução da task periódica no sensor ETS = 0.004s;

• o tempo de execução da task aperiódica no controlador ETC = 0.0065s.

Atribui-se valores relativamente altos para os deadlines das tasks aperiódicas para garantir

que sejam sempre executadas, respeitando assim a hipótese de não haver perda de dados.

Com estas definições, os casos são simulados. A partir destas simulações são obtidos

os diagramas de escalonamento das tasks do controlador e da rede, mostrados nas Figu-

ras 4.13 e 4.14, respectivamente. No diagrama de escalonamento das tasks, é observada

uma situação de preempção das tasks de controle. As tasks de controle em preempção

formam uma fila (FIFO-First In, First Out) e são executadas conforme disponibilidade



4.3 Simulação com o TrueTime 54

de recursos (ANDERSSON; HENRIKSSON; CERVIN, 2007). Quanto mais tasks entram na fila

de preempção, mais tempo é necessário para sua execução (destaque na Figura 4.13), o

que implica em maiores latências. E, juntamente com a execução desta fila, ocorre um

aumento do tráfego na rede (destaque na Figura 4.14), que tende a aumentar os atrasos

entre o envio e recebimento de mensagens. Assim fica evidente duas fontes de aumento

das latências: a preempção das tasks de controle e o aumento do tráfego da rede. Portanto

conclui-se que conforme aumenta o período de amostragem h:

• as latências LkS tendem a diminuir, aproximando-se de ETS = 0.004s;

• as latências LkC tendem a diminuir, aproximando-se de ETC = 0.0065s);

• os intervalos hk tendem a se aproximar do período de amostragem nominal h,

como observado nos histogramas nas Figuras 4.15, 4.16 e 4.17.

Portanto para maiores períodos de amostragem nominal h tem-se menores latências,

resultando em um melhor o desempenho do sistema computacional. Porém isto dificulta

a reconstrução do sinal, prejudicando o desempenho do sistema de controle. Além disso,

durante o período entre duas amostragens consecutivas (ou intersample), o sistema de

controle discreto opera em malha aberta, sendo sensível à distúrbios (ÅSTRöM; WITTEN-

MARK, 1997). Nas simulações são introduzidos distúrbios para observar esta sensibilidade

nos intersamples. As saídas obtidas nestas simulações são mostradas na Figura 4.18;

e sobre elas é aplicado o critério ITAE, resultando nos valores contidos na Tabela 4.3.

Percebe-se que o período de amostragem nominal muito curto ou muito longo resulta na

piora do desempenho do NCS. Isto porque o desempenho deste sistema depende tanto

do desempenho do sistema computacional (melhora com o aumento de h) quanto do de-

sempenho do sistema de controle (piora com o aumento de h). Esta conclusão também é

apresentada no trabalho de Lian, Moyne e Tilbury (2002), onde esta relação de compro-

misso é colocada em evidência.

h ITAE Sistema
0.01 8.997 1013 Instável
0.02 6.863 105 Estável
0.04 7.414 104 Estável
0.06 9.700 105 Estável
0.07 1.223 109 Instável

Tabela 4.3: Critério ITAE aplicados aos resultados obtidos através do TrueTime.



4.3 Simulação com o TrueTime 55

2 2.5 3 3.5 4 4.5 5 5.5 6
0

0.5

1

1.5

2

2.5

3

E
s
t
a
d
o

d
a
s
t
a
s
k
s

Tempo[s]

(a) h = 0.01s

2 2.5 3 3.5 4 4.5 5 5.5 6
0

0.5

1

1.5

2

2.5

3

E
s
t
a
d
o

d
a
s
t
a
s
k
s

Tempo[s]

(b) h = 0.02s

2 2.5 3 3.5 4 4.5 5 5.5 6
0

0.5

1

1.5

2

2.5

3

e
e

E
s
t
a
d
o

d
a
s
t
a
s
k
s

Tempo[s]

(c) h = 0.04s

2 2.5 3 3.5 4 4.5 5 5.5 6
0

0.5

1

1.5

2

2.5

3

E
s
t
a
d
o

d
a
s
t
a
s
k
s

Tempo[s]

(d) h = 0.06s

2 2.5 3 3.5 4 4.5 5 5.5 6
0

0.5

1

1.5

2

2.5

3

E
s
t
a
d
o

d
a
s
t
a
s
k
s

Tempo[s]

(e) h = 0.07s

Figura 4.13: Diagramas de escalonamentos das tasks do controlador, destacando o
intervalo em que as tasks de controle em preempção são executadas.

Portanto, para um período de amostragem nominal h dentro do intervalo [0.02, 0.06]s

o NCS é estável, segundo o critério ITAE. E segundo este mesmo critério, a escolha ótima

é h = 0.04s. As distribuições das latências obtidas serão utilizadas na análise com o

Jitterbug.



4.3 Simulação com o TrueTime 56

2 2.5 3 3.5 4 4.5 5 5.5 6
0

0.5

1

1.5

2

2.5

3

3.5

4

4.5

5

E
s
t
a
d
o

d
a
s

m
e
n
s
a
g
e
n
s

Tempo[s]

(a) h = 0.01s

2 2.5 3 3.5 4 4.5 5 5.5 6
0

0.5

1

1.5

2

2.5

3

3.5

4

4.5

5

E
s
t
a
d
o

d
a
s

m
e
n
s
a
g
e
n
s

Tempo[s]

(b) h = 0.02s

2 2.5 3 3.5 4 4.5 5 5.5 6
0

0.5

1

1.5

2

2.5

3

3.5

4

4.5

5

E
s
t
a
d
o

d
a
s

m
e
n
s
a
g
e
n
s

Tempo[s]

(c) h = 0.04s

2 2.5 3 3.5 4 4.5 5 5.5 6
0

0.5

1

1.5

2

2.5

3

3.5

4

4.5

5

E
s
t
a
d
o

d
a
s

m
e
n
s
a
g
e
n
s

Tempo[s]

(d) h = 0.06s

2 2.5 3 3.5 4 4.5 5 5.5 6
0

0.5

1

1.5

2

2.5

3

3.5

4

4.5

5

E
s
t
a
d
o

d
a
s

m
e
n
s
a
g
e
n
s

Tempo[s]

(e) h = 0.07s

Figura 4.14: Diagrama de escalonamento da rede, destacando o intervalo em que
ocorre um aumento no tráfego da rede.



4.3 Simulação com o TrueTime 57

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04 0.045 0.05
0

2

4

6

8

10

12

14

16

18

20

O
c
o
r
r
ê
n
c
ia

s
[%

]

L
k

S
[s]

(a) h = 0.01s

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04 0.045 0.05
0

2

4

6

8

10

12

14

16

18

20

O
c
o
r
r
ê
n
c
ia

s
[%

]

L
k

S
[s]

(b) h = 0.02s

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04 0.045 0.05
0

2

4

6

8

10

12

14

16

18

20

O
c
o
r
r
ê
n
c
ia

s
[%

]

L
k

S
[s]

(c) h = 0.04s

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04 0.045 0.05
0

2

4

6

8

10

12

14

16

18

20
O

c
o
r
r
ê
n
c
ia

s
[%

]

L
k

S
[s]

(d) h = 0.06s

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04 0.045 0.05
0

2

4

6

8

10

12

14

16

18

20

O
c
o
r
r
ê
n
c
ia

s
[%

]

L
k

S
[s]

(e) h = 0.07s

Figura 4.15: Distribuição das latências LkS.



4.3 Simulação com o TrueTime 58

0 0.002 0.004 0.006 0.008 0.01 0.012 0.014 0.016 0.018 0.02
0

2

4

6

8

10

12

14

16

18

20

O
c
o
r
r
ê
n
c
ia

s
[%

]

(a) h = 0.01s

0 0.002 0.004 0.006 0.008 0.01 0.012 0.014 0.016 0.018 0.02
0

2

4

6

8

10

12

14

16

18

20

O
c
o
r
r
ê
n
c
ia

s
[%

]

L
k

C
[s]

(b) h = 0.02s

0 0.002 0.004 0.006 0.008 0.01 0.012 0.014 0.016 0.018 0.02
0

2

4

6

8

10

12

14

16

18

20

O
c
o
r
r
ê
n
c
ia

s
[%

]

L
k

C
[s]

(c) h = 0.04s

0 0.002 0.004 0.006 0.008 0.01 0.012 0.014 0.016 0.018 0.02
0

2

4

6

8

10

12

14

16

18

20
O

c
o
r
r
ê
n
c
ia

s
[%

]

L
k

C
[s]

(d) h = 0.06s

0 0.002 0.004 0.006 0.008 0.01 0.012 0.014 0.016 0.018 0.02
0

2

4

6

8

10

12

14

16

18

20

O
c
o
r
r
ê
n
c
ia

s
[%

]

L
k

C
[s]

(e) h = 0.07s

Figura 4.16: Distribuição das latências LkC .



4.3 Simulação com o TrueTime 59

0 0.02 0.04 0.06 0.08 0.1 0.12 0.14 0.16 0.18 0.2
0

5

10

15

20

25

O
c
o
r
r
ê
n
c
ia

s
[%

]

hk[s]

(a) h = 0.01s

0 0.02 0.04 0.06 0.08 0.1 0.12 0.14 0.16 0.18 0.2
0

5

10

15

20

25

O
c
o
r
r
ê
n
c
ia

s
[%

]

hk[s]

(b) h = 0.02s

0 0.02 0.04 0.06 0.08 0.1 0.12 0.14 0.16 0.18 0.2
0

5

10

15

20

25

O
c
o
r
r
ê
n
c
ia

s
[%

]

hk[s]

(c) h = 0.04s

0 0.02 0.04 0.06 0.08 0.1 0.12 0.14 0.16 0.18 0.2
0

5

10

15

20

25

O
c
o
r
r
ê
n
c
ia

s
[%

]

hk[s]

(d) h = 0.06s

0 0.02 0.04 0.06 0.08 0.1 0.12 0.14 0.16 0.18 0.2
0

5

10

15

20

25

O
c
o
r
r
ê
n
c
ia

s
[%

]

hk[s]

(e) h = 0.07s

Figura 4.17: Distribuição dos intervalos de amostragem hk.

0 2 4 6 8 10 12 14 16 18 20
-2

-1.5

-1

-0.5

0

0.5

1

1.5

2

?
[r
a
d
/
s
]

Tempo[s]

Referência

h = 0.01

h = 0.02

h = 0.04

h = 0.06

h = 0.07

Figura 4.18: Saídas do sistema para h: 0.01s, 0.02s, 0.04s, 0.06s e 0.07s, obtidas com
TrueTime.



4.4 Análise com o Jitterbug 60

4.4 Análise com o Jitterbug

O modelo Jitterbug para este caso é semelhante ao modelo da Figura 2.8, onde H1(z) = 1,

H2(z) = PID(z) e H3(z) = 1 representam o nó do sensor, do controlador e do atuador,

respectivamente; e G(s) é o modelo do motor. O modelo de tempo é dado por ?1 e ?2,

que são LS e LC , respectivamente, obtidos na Seção 4.3. É inserido na saída da planta

um processo de ruído branco em tempo discreto com média nula e covariância R = 2?.

Este modelo é implementado através do Código 4.1 para o cálculo da função de custo do

desempenho do NCS.

Código 4.1: Script em MATLAB para o cálculo da função de custo do NCS através do

Jitterbug.

1 Tau_1 = load ( ’L_S’ ) ; % D i s t r i b u i ç ã o das l a t ê n c i a s de

amostragem

2 Tau_2 = load ( ’L_C’ ) ; % D i s t r i b u i ç ã o das l a t ê n c i a s de c á l c u l o

3 G = load ( ’Motor_CC’ ) ; % Plan t a

4 H1 = 1 ; % Amostrador

5 H2 = load ( ’Controlador’ ) ; % Con t r olador PID d i s c r e t o

6 H3 = 1 ; % Atuador

7 R = diag ( [ 0 2? pi ] ) ; % Covar iân cia do r u í d o na s a í d a da
p l a n t a

8 dt = 0 . 0 0 1 ; % Passo de d i s c r e t i z a ç ã o do tempo

9

10 N = i n i t j i t t e r b u g ( dt , h ) ; % I n i c i a l i z a ç ã o do J i t t e r b u g

11

12 N = a ddtiming no de (N, 1 , Tau_1 , 2 ) ; % Primeiro nó de tempo

13 N = a ddtiming no de (N, 2 , Tau_2 , 3 ) ; % Segundo nó de tempo

14 N = a ddtiming no de (N, 3 ) ; % T e r c e i r o nó de tempo

15

16 N = a d d c o n t s y s (N, 1 ,G, 4 ) ; % I n s e r ç ã o da p l a n t a

17 N = a d d d i s c s y s (N, 2 , H1 , 1 , 1 , [ ] , R) ; % Conexão do amostrador ao nó 1

18 N = a d d d i s c s y s (N, 3 , H2 , 2 , 2 , [ ] , R) ; % Conexão do c o n t r o l a d o r ao nó 2

19 N = a d d d i s c s y s (N, 4 , H3 , 3 , 3 ) ; % Conexão do at u ador ao nó 3

20

21 N = c a l c d y n a m i c s (N) ; % C á l c u l o das dinâmicas i n t e r n a s

22 J = c a l c c o s t (N) ; % Cáculo do c u s t o

Os resultados obtidos com o Jitterbug (Tabela 4.4) estão de acordo com os resultados

obtidos na seção anterior. Verifica-se que existe um intervalo para o período de amostra-

gem nominal do ciclo de controle ([0.02, 0.06]s) para o qual o NCS é estável; e existe um



4.5 Conclusão 61

ponto ótimo de operação (h = 0.04s).

h Custo J Sistema
0.01s ? Instável
0.02s 88.6 Estável
0.04s 71.0 Estável
0.06s 88.9 Estável
0.07s ? Instável

Tabela 4.4: Resultados das simulações com o Jitterbug para o caso estudado, com h:
0.01s, 0.02s, 0.04s, 0.06s e 0.07s.

4.5 Conclusão

Neste capítulo estudou-se o caso de um NCS utilizando os métodos apresentados no Ca-

pítulo 2. Os resultados obtidos com o modelo com atraso mostram que um sistema de

controle que apresenta um período de amostragem maior pode ter um desempenho me-

lhor quando comparado ao caso de com um período de amostragem menor, dependendo

do atraso presente neste sistema. Com os resultados obtidos com o TrueTime e o Jit-

terbug é possível estender esta afirmação, chegando à conclusão que existe uma relação

de compromisso entre o desempenho do sistema de controle e o desempenho do sistema

computacional com relação à escolha do período de amostragem nominal h, como também

mostra o trabalho de Lian, Moyne e Tilbury (2002). Foi apresentado um intervalo para

o período de amostragem nominal h (0.02s a 0.06s) no qual o NCS é estável, bem como

um ponto ótimo de operação (h = 0.04s).



62

5 O ROV

O objetivo deste capítulo é apresentar o modelo do ROV considerado neste trabalho

(Figura 5.1), além da arquitetura de controle e a estrutura de controle. A descrição deta-

lhada deste veículo (conhecido por VSOR – Veículo Submarino Operado Remotamente)

está contida no trabalho de Avila (2008).

Figura 5.1: Modelo CAD de um ROV.

Sob a hipótese de operações com baixas velocidades, o veículo pode ser modelado atra-

vés de 6 equações diferenciais desacopladas referentes aos seus 6 graus de liberdade (GLs),

como visto na Seção 5.1. Com relação ao controle do veículo, existem níveis hierárquicos

de controle, onde o nível superior gera sinais de referência para o nível imediatamente

inferior, como visto na Seção 5.2. Particularmete, este trabalho está focado no controle

de velocidade do veículo através controladores do tipo proporcional-integral (PI), como

visto na Seção 5.3.



5.1 Modelo do VSOR 63

5.1 Modelo do VSOR

Assim como em Fossen (1994), utiliza-se dois sistemas de coordenadas (o referencial iner-

cial e o referencial móvel) observados na Figura 5.2 para descrever os movimentos dos

veículos marinhos nos 6 graus de liberdade. O sistema de coordenadas fixo ao veículo

(OmXmYmZm) é o referencial móvel, e a origem Om é usualmente escolhida coincidente

ao centro de gravidade (CG) do veículo. O referencial inercial (O0X0Y0Z0) é tomado em

um ponto fixo na superfície da Terra. Usualmente, as variáveis de posição e orientação1

são descritas em relação ao referencial inercial; e as variáveis de velocidade (linear e an-

gular) e aceleração (linear e angular) em relação ao referencial móvel. Estas variáveis e

sua representação estão listadas na Tabela 5.1.

Referencial Móvel

Referencial Fixo
X0

Y0

Z0

Xm
Ym

Zm O0

Om

r0

u

p
q

v
r

w

Figura 5.2: Sistema de coordenadas para veículos marinhos, com 6 graus de liberdade
(FOSSEN, 1994).

Para definir a relação das variáveis no referencial móvel no referencial inercial, adotam-

se os vetores:

? = [?T1 ,?
T
2 ]

T ; ?1 = [x,y,z]
T ; ?2 = [?,?,?]

T .

? = [?T1 ,?
T
2 ]

T ; ?1 = [u,v,w]
T ; ?2 = [p,q,r]

T .

?GL = [?GLL
T
,?GLA

T
]T ; ?GLL = [X,Y,Z]

T ; ?GLA = [K,M,N]
T .

Estas notações serão utilizadas ao longo deste trabalho e estão de acordo com as encon-

1Em engenharia naval, a orientação é usualmente representada pelos Ângulos de Euler (FOSSEN, 1994).



5.1 Modelo do VSOR 64

GL Movimento
Forças e Velocidades Posições e

Momentos (linear e angular) Ângulos de Euler
1 Surge - translação em x X u x
2 Sway - translação em y Y v y
3 Heave - translação em z Z w z
4 Roll - rotação em x K p ?
5 Pitch - rotação em y M q ?
6 Yaw - rotação em z N r ?

Tabela 5.1: Notações definidas pela SNAME (The Society of Naval Architects and
Marine Engineers) utilizadas para veículos marinhos.

tradas em Fossen (1994). A velocidade de veículo no referencial inercial é dada por

??1 = J1(?2)?1, (5.1)

onde J1(?2) é composição de três rotações consecutivas dada por

J1(?2) =

?

?

?

?

cos ? cos ? ? sin ? cos ? + cos ? sin ? sin ? sin ? sin ? + cos ? cos ? sin ?
sin ? cos ? cos ? cos ? + sin ? sin ? sin ? ? cos ? sin ? + sin ? sin ? cos ?
? sin ? cos ? sin ? cos ? cos ?

?

?

?

?

.

(5.2)

Sua inversa é dada pela sua transposta (J?11 (?2) = J
T
1 (?2)).

Analogamente, tem-se que

??2 = J2(?2)?2, (5.3)

onde

J2(?2) =

?

?

?

?

1 sin ? tan ? cos ? tan ?

0 cos ? ? sin ?
0 ?sin ?

cos ?
cos ?
cos ?

?

?

?

?

. (5.4)

Porém, J?12 (?2) 6= JT2 (?2). A matriz inversa de J2(?2) é dada por

J?12 (?2) =

?

?

?

?

1 0 ? sin ?
0 cos ? cos ? sin ?

0 ? sin ? cos ? cos ?

?

?

?

?

. (5.5)

O modelo do VSOR é baseado nos modelos utilizados em Caccia, Indiveri e Veruggio

(2000) e em Avila (2008), onde os 6 GLs são representados por 6 equações diferenciais

desacopladas sob a hipótese de operações com baixas velocidades. Uma modelagem mais

completa, considerando o sistema acoplado, pode ser encontrado em Fossen (1994) e em



5.2 Arquitetura de Controle 65

Souza (2003), por exemplo.

Para os GLs Surge, Sway, Heave e Yaw, a equação é dada por

?i(t) = mix?i(t) + dLixi(t) + dQixi(t)|xi(t)| + bi, (5.6)

onde xi é a velocidade do veículo no GL i dado em relação ao referencial móvel; ?i é a

força/torque aplicada ao veículo no GL i; mi é a inércia/massa virtual2 referente ao GL

i; dLi é o coeficiente de arrasto linear e dQi é o coeficiente de arrasto quadrático referentes

ao GL i e bi é o modelo de distúrbio para o GL i.

Para veículos com geometria indefinida, do tipo open frame, os GLs Roll e Pitch são

basicamente estáveis, sendo estes modelados por

?i(t) = mix?i(t) + dQixi(t)|xi(t)| + BzB sin ? + bi, (5.7)

onde xi é a velocidade do veículo no GL i dado em relação ao referencial móvel; ?i é a

força/torque aplicada ao veículo no GL i; mi é a inércia/massa virtual referente ao GL i;

e o termo B é a resultante do empuxo e da força peso, zB é a altura referente ao centro

de flutuação e ? = ?,?.

Os valores das constantes citadas nesta seção estão contidos no Apêndice A.

5.2 Arquitetura de Controle

A arquitetura do sistema de controle do ROV utilizada atualmente é mostrada na Fi-

gura 5.3, também conhecida como arquitetura centralizada. Ela é composta basicamente

por dois módulos: o sistema computacional de superfície e o sistema computacional em-

barcado. O sistema computacional de superfície consiste de um laptop executando o

sistema operacional Windows XP, sendo responsável pelas tarefas de alto-nível. Ele se co-

munica com o sistema computacional embarcado através da rede com protocolo Ethernet

TCP/IP, usando um cabo 4-26 AWG. O sistema embarcado consiste numa placa padrão

PC-104 que executa o RTOS VxWorks da Windriver. Esta placa é composta por um

processador NS Geode de 300MHz, com baixo consumo de energia; portas A/Ds; portas

D/As; e portas seriais. Os programas são desenvolvidos e compilados no computador

de superfície através do sistema de desenvolvimento Windriver Tornado e enviados atra-

2Inércia virtual se refere à soma da inércia do veículo com a inércia resultante do fenômeno de massa
adicionada.



5.2 Arquitetura de Controle 66

Variável Sensor (fabricante) Precisão Taxa de aquisição Saída

Yaw Compasso TCM2 (PNI) ±1? 13Hz Digital
Roll e pitch Tilt Series 757 (Applied Geomechanics) ±2? 20Hz Analógica

Profundidade Sensor de pressão, MPX5100DP (Motorola) 3.5cm 20Hz Analógica
Taxa de yaw Fiber Optic Gyro, E-Core 2000 (KVH) Bias&amp;lt;2?/h 10Hz Digital

Altura Altímetro, PA200 (Tritech) 1mm 10Hz Digital
Aceleração linear Central inercial, VG700A (Crossbow) Bias&amp;lt;12mg 100Hz Digital

Velocidade angular Central inercial, VG700A (Crossbow) Bias&amp;lt;20?/h 100Hz Digital
Velocidade linear Sensor Doppler (NavQuest 600 Micro) 1mm/s 5Hz Digital

Tabela 5.2: Sistema sensorial do ROV (AVILA; MARUYAMA; ADAMOWSKI, 2008).

vés da rede Ethernet para o sistema embarcado. As informações sobre o movimento do

veículo são obtidas através de sensores listados na Tabela 5.2. Estas informações são

processadas e utilizadas no cálculo do sinal de controle. Este sinal de controle age sobre o

sistema através do sistema de propulsão, composto por oito propulsores modelo 1021 da

Tecnadyne Inc e seus respectivos drivers de acionamento.

Computador de
superfície

E
th

er
n
et

PC-104

Portas
A/Ds

Portas
seriais

Portas
D/As

Sensor de
pressão

Inclinômetro

Compasso

Central
inercial

Giroscópio
(taxa de yaw )

Driver do
propulsor 1

Driver do
propulsor 2

Driver do
propulsor 8

Sensor
Doppler

Figura 5.3: Diagrama esquemático da arquitetura atual do sistema de controle do
ROV.

O controle do veículo é estruturado hierarquicamente (CACCIA; VERUGGIO, 2000;

SOUZA, 2003), onde níveis de controle superiores são responsáveis pela especificação de

valores de referências para níveis de controle inferiores. Por exemplo, no caso de uma ta-

refa de posicionamento, o usuário (o operador humano ou um sistema autônomo) fornece

a posição/orientação desejada para o veículo ao nível de controle mais alto, chamado de



5.2 Arquitetura de Controle 67

"guiagem". A guiagem é responsável por controlar a trajetória do veículo que resultará

na desejada posição/orientação através da especificação de valores de referência de veloci-

dades para o próximo nível de controle, chamado de "estratégia de controle". A estratégia

de controle é responsável por controlar as velocidades do veículo através de especificação

de valores de referência de força/torque aplicados nos 6 graus de liberdade. O sistema

de propulsão é responsável por fornecer torque/força nos 6 graus de liberdade através do

controle dos propulsores. Esta hierarquia de controle pode ser vista na Figura 5.4. No

caso da arquitetura de controle atual, todos os níveis da estrutura hierárquica de controle

são implementados no sistema embarcado.

+ - + - + -

?ref ?ref ?GLref ?GL ?

?
Guiagem

Estratégia
de controle

Sistema de
propulsão ROV

Figura 5.4: Estrutura hierárquica do controle do veículo. As variáveis com índice ref
se referem aos valores de referência.

A guiagem e a estratégia de controle calculam o(a) torque/força em cada grau de

liberdade para realizar os movimentos definidos pelo usuário. Estes torques/forças dos

graus de liberdade precisam ser mapeados nas forças axiais dos propulsores. Isto é feito

através de uma matriz de alocação de empuxo, obtida em função do posicionamento dos

propulsores em relação ao referencial móvel (Figura 5.5).

          

          

          

12

3

4

5
67

8

a

b

d

e

?

(a) Vista superior do veículo.

c
f

(b) Vista frontal do veículo.

Figura 5.5: Posicionamento dos propulsores em relação ao referencial móvel (sistema
de coordenadas verde), considerando que o CG do ROV é o ponto de intersecção dos

planos de simetria. As forças axiais produzidas pelos propulsores são representadas pelas
flechas em vermelho. Os propulsores são identificados por números de 1 a 8.



5.2 Arquitetura de Controle 68

Seja Ti a força axial gerada pelo propulsor i, e considerando a simetria do veículo e o

posicionamento dos propulsores, as forças nos graus de liberdade são dadas por

X = (?T1 + T2 ? T6 + T7) sin (?); (5.8)

Y = (?T1 ? T2 + T6 + T7) cos (?); (5.9)

Z = ?T3 ? T4 ? T5 ? T8; (5.10)

K = (T1 + T2 ? T6 ? T7) cos (?)c + (?T3 + T4 ? T5 + T8)e; (5.11)

M = (T1 ? T2 + T6 ? T7) sin (?)c + (?T3 + T4 ? T5 + T8)d; (5.12)

N = (?T1 + T2 + T6 ? T7)
?
a2 + b2. (5.13)

Na forma matricial, tem-se que

?GL = B T, (5.14)

onde B é a matriz de controle e T =
[

T1 T2 T3 T4 T5 T6 T7 T8

]T

é o vetor de

propulsão. A matriz de controle é, portanto

B =

?

?

?

?

?

?

?

?

?

?

?

?

? sin (?) sin (?) 0 0 0 ? sin (?) sin (?) 0
? cos (?) ? cos (?) 0 0 0 cos (?) cos (?) 0

0 0 ?1 ?1 ?1 0 0 ?1
cos (?)c cos (?)c ?e e ?e ? cos (?)c ? cos (?)c e
sin (?)c ? sin (?)c ?d ?d d sin (?)c ? sin (?)c d

?
?
a2 + b2

?
a2 + b2 0 0 0

?
a2 + b2 ?

?
a2 + b2 0

?

?

?

?

?

?

?

?

?

?

?

?

. (5.15)

Percebe-se que a matriz de controle não é quadrada, visto que ela apresenta mais entradas

de controle (8) do que graus de liberdade (6), ou seja, há mais de uma forma de se obter

determinados(as) torques/forças nos GLs. Uma solução possível para fazer a alocação

de empuxo é utilizar a matriz pseudo-inversa de Moore-Penrose (FOSSEN, 1994), que

minimiza a energia inserida no sistema. Esta matriz, denominada matriz de alocação de

empuxo, é dada por

B† = BT (B BT )?1. (5.16)

Assim, o mapeamento dos(as) torques/forças dos GLs nas forças axiais dos propulsores é

dado por

T = B† ?GL. (5.17)

Uma possível arquitetura do tipo NCS para o ROV é mostrada na Figura 5.6. Nota-

se que o sistema embarcado é dividido em três módulos interligados através de rede



5.2 Arquitetura de Controle 69

de comunicação: o controle central, a fusão sensorial e o sistema de propulsão. Cada

módulo possui um núcleo de processamento. O controle central é responsável pela guiagem

e pela estratégia de controle. O sistema de propulsão é responsável pelo controle dos

propulsores. A fusão sensorial é responsável por adquirir e processar os sinais provenientes

dos sensores, disponibilizando para o sistema a estimação das variáveis de estado do veículo

(posição/orientação, velocidades e acelerações).

Arquiteturas deste tipo já são empregadas em ROVs comerciais, como o chamado

Distributed Intelligence Control System, implementado no ROV Seaeye Falcon, da Saab

Technologies (SAAB, 2009). Além disso, este tipo de arquitetura proporciona a distribui-

ção do processamento, a redução de custo e de peso, além de facilitar o diagnóstico e

manutenção do sistema e de aumentar a sua flexibilidade e agilidade (WALSH et al., 2002).

Razões estas para motivar o desenvolvimento deste tipo de arquitetura para o VSOR.

Computador de
superfície

E
th

er
n
et

Núcleo de
processamento

Núcleo de
processamento

Núcleo de
processamento

Rede

Portas
A/Ds

Portas
seriais

Portas
D/As

Sensor de
pressão

Inclinômetro

Compasso

Central
inercial

Giroscópio
(taxa de yaw )

Driver do
propulsor 1

Driver do
propulsor 2

Driver do
propulsor 8Sensor

Doppler

Controle

central

Fusão

sensorial

Sistema de

propulsão

Figura 5.6: Diagrama esquemático da possível arquitetura de controle do tipo NCS
para o VSOR.



5.3 Estratégia de Controle 70

5.3 Estratégia de Controle

O controle de velocidade (ou estratégia de controle) corresponde à malha de controle na

Figura 5.4 que recebe com entrada ?ref ? ? e fornece como saída ?ref . Neste trabalho, o
controle de velocidade do GL i é realizado através de um controlador PI com estrutura

feedback-feedfoward (CACCIA; VERUGGIO, 2000; SOUZA, 2003). Devido a não-linearidade

da equação que representa a dinâmica do GL i, os ganhos do controlador variam de acordo

com o ponto de operação.

Reorganizando os termos da Equação (5.6), tem-se a equação diferencial

x?i = ?
dLi
mi

xi ?
dQi
mi

xi|xi| ?
bi
mi

+
1

mi
?i, (5.18)

cuja linearização em torno do ponto de operação x?i fornece

x?i? = a(x
?
i )xi? +

1

mi
?i?, (5.19)

onde

a(x?i ) = ?
dLi
mi

? 2
dQi
mi

|x?i |, (5.20)

?i = ?i? + ?i, (5.21)

?i = dLix
?
i + dQix

?
i |x?i | + bi. (5.22)

Como pode ser observado, o sinal de controle ?i é composto por dois termos: o termo

feedback ?i? e o termo feedfoward ?i.

Como citado anteriormente, os GLs Roll e Pitch são em geral estáveis. Portanto, para

a linearização da Equação (5.7) considera-se que os ângulos ? e ? são próximos de zero.

Assim, o modelo linearizado para estes 2 GLs é dado também pela Equação (5.19), porém

excluindo-se o termo referente ao arrasto linear.

Desta forma, para cada ponto de operação desejado há uma função de transferência

de primeira ordem para cada GL, do tipo

Gi(s) =
1

mi

s ? a(x?i )
. (5.23)

Seja o controlador PI com estrutura

PIi(s) = KPi +
KIi
s
, (5.24)



5.4 Conclusão 71

onde KPi refere-se ao ganho proporcional e KIi refere-se ao ganho integral para o GL i.

Desta forma, a equação característica do sistema controlado em malha fechada é dada por

s2 +

(

1

mi
KPi ? a(x?i )

)

s +
1

mi
KIi. (5.25)

Seja a equação característica desejada para o sistema linearizado em malha fechada

dada por

s2 + 2?i?ni + ?
2
ni
,

onde ?i é o coeficiente de amortecimento para o GL i e ?ni a freqüência natural para o

GL i, ambos parâmetros de projeto. Por comparação, os ganhos do controlador são dados

por

KPi =
2?i?ni + a(x

?
i )

1
mi

, (5.26)

KIi =
?2ni

1
mi

. (5.27)

Na forma discreta, este controlador PI pode ser representado por

Pk = KPiek

Ik+1 = Ik + bi1ek+1 + bi2ek

bi1 = KIi
h
2

bi2 = KIi
h
2

uk = Pk + Ik.

(5.28)

Percebe-se que o termo integral é composto por uma integral numérica do sinal de erro,

considerando o passo constante (h constante). Ou seja, em uma situação real em que

este passo varia, o valor do sinal de controle pode não ser o valor esperado para um

determinado instante.

5.4 Conclusão

Neste capítulo foi descrito o ROV utilizado neste trabalho. Foi mostrada a modelagem da

dinâmica do veículo através de 6 equações diferenciais não-acopladas, considerando ope-

rações de baixas velocidades. O modelo cinemático relaciona as velocidades e posições/o-

rientações nos sistemas de coordenada inercial e móvel. Foram descritas a arquitetura de



5.4 Conclusão 72

controle atual e uma possível arquitetura do tipo NCS, além da matriz de alocação de

empuxo utilizada. E por fim mostrou-se a estratégia de controle utilizando um controla-

dor do tipo PI com estrutura feedback-feedfoward, cujos parâmetros de projeto são dados

por ?i e ?ni .



73

6 Resultados

O objetivo deste capítulo é utilizar o TrueTime e o Jitterbug no projeto dos controlado-

res apresentados no Capítulo 5; e, implementar estes controladores no modelo do ROV

descrito no Capítulo 5 para observar o seu comportamento no tempo.

Como visto no capítulo anterior, as constantes dos controladores (KPi e KIi ) foram

obtidas em função de dois parâmetros de projeto: ?i e ?ni . Estes parâmetros podem

ser obtidos a partir de requisitos de projeto, como tempo de subida, máximo sobre-sinal,

tempo de assentamento, etc. O que se mostrará ao longo do capítulo é que a escolha dos

valores destes parâmetros também dependem das condições do sistema computacional

utilizado. Por exemplo, supondo que para um dado sistema seja desejável uma resposta

rápida (menor constante de tempo), o que no caso corresponderia, para um dado valor

de ?, um valor de ?n maior. Porém, como visto no Capítulo 4, quanto menor a constante

de tempo do sistema, menor deve ser o período de amostragem nominal h para o ciclo

de controle. E também foi observado neste capítulo que, quanto menor o período de

amostragem, mais recursos computacionais são requeridos. Portanto, para uma situação

onde os recursos computacionais são consideravelmente limitados, a escolha de parâmetros

poderia ser inadequada para o caso de respostas rápidas.

Primeiramente são realizadas simulações com o TrueTime (Seção 6.1), sob algumas

hipóteses simplificadoras, para estimação das funções densidades probabilidade (FDPs)

dos atrasos inseridos pelo sistema computacional. Estas FDPs são utilizadas para criar

modelos de Sistemas Lineares de Saltos Markovianos. No Jitterbug, estes modelos são

utilizados no cálculo da função de custo, que por sua vez será utilizada para avaliar

qualitativamente o desempenho e a estabilidade (no sentido quadrático médio) para um

dado GL (Seção 6.2). Na Seção 6.3 é feita a análise temporal do comportamento do ROV

utilizando um modelo em realidade virtual do veículo.



6.1 Análise com o TrueTime 74

6.1 Análise com o TrueTime

O modelo TrueTime do ROV é semelhante ao utilizado no Capítulo 4, porém existem

agora 6 plantas a serem controladas, ou seja, existem 6 tasks de controle no controle

central.

Para as simulações são adotadas algumas hipóteses de forma a simplificar as análises:

• não há perda de dados,

• as amostragens ocorrem sempre nos instantes de amostragem kh;

• serão considerados apenas os atrasos referentes ao transporte dos dados pela rede e
ao escalonamento das tasks no controle central;

• as plantas são consideradas idênticas na forma de uma função de transferência de
primeira ordem.

Uma forma de escolha de período de amostragem nominal do ciclo de controle é

através da regra prática apresentada em Åström e Wittenmark (1997), na qual o período

de amostragem deve estar contido no intervalo

0.2 ? ?nh ? 0.6. (6.1)

Para estas simulações, o período de amostragem é parametrizado por

h ?
0.4

?n
. (6.2)

Percebe-se nesta parametrização que o período de amostragem aumenta com o inverso da

freqüência natural do sistema, o que reflete a relação entre o período de amostragem e o

tempo de resposta do sistema citada anteriormente.

Serão analisados 4 casos de operação:

1. sistema somente com as tasks de controle;

2. sistema com as tasks de controle e com um nó extra na rede para que 80% da banda

da rede seja utilizada de forma aleatória, representando uma situação de maior

tráfego na rede;



6.1 Análise com o TrueTime 75

3. sistema com as tasks de controle e com uma task periódica extra no controle central

com WCET uniformemente variável no intervalo [0, 500]ms, com período 1000ms e

prioridade 1, representando outras possíveis tasks sendo executadas no sistema;

4. sistema com as tasks de controle, o nó extra na rede e a task extra especificados

anteriormente.

O primeiro caso servirá como referência para as comparações com outros casos, visto

que este é o caso mais próximo do funcionamento ideal. O objetivo do caso 2 é analisar a

influência dos atrasos devido à concorrência pelo recurso da rede de comunicação. Analo-

gamente, o caso 3 tem por objetivo analisar a influência dos atrasos devido à concorrência

das tasks no controle central. E por fim, o caso 4 refere-se à análise da influência de todos

os atrasos citados anteriormente.

Cada caso pode ser subdividido em três conjuntos de simulações, onde para cada

uma varia-se o parâmetro ?ni = {1, 2, 3}rad/s. Para estes parâmetros, escolhe-se h =
{400, 200, 130}ms, respectivamente. Para todos os casos as tasks de controle possuem o
mesmo WCET (10ms) e a mesma prioridade (2). Os nós do controlador, do sensor e do

atuador também são interligados por uma rede CAN. As mensagens possuem a mesma

prioridade e o mesmo número de bits (80 bits), por simplificação.

As grandezas avaliadas são as mesmas descritas no Capítulo 4:

• LkS - latência do sensor;

• LkC - latência do controlador;

• hk - intervalo de amostragem.

6.1.1 Caso 1

Este pode ser considerado o caso ideal, onde os atrasos são constantes. O pior caso da

latência do sensor é

LkS =
80bits

80 bits
ms

+ 5 × 10 = 51ms,

referente ao tempo de transporte da mensagem pela rede somado ao tempo em que a

task demora para iniciar o cálculo do sinal de controle (ou seja, o tempo em que a task

espera para que as outras cinco tasks sejam executadas). Desta análise prévia, conclui-se



6.1 Análise com o TrueTime 76

0 0.05 0.1 0.15 0.2
0

20

40

60

80

100

L
s
 Task1 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.05 0.1 0.15 0.2
0

20

40

60

80

100

L
s
 Task2 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.05 0.1 0.15 0.2
0

20

40

60

80

100

L
s
 Task3 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.05 0.1 0.15 0.2
0

20

40

60

80

100

L
s
 Task4 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.05 0.1 0.15 0.2
0

20

40

60

80

100

L
s
 Task5 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.05 0.1 0.15 0.2
0

20

40

60

80

100

L
s
 Task6 [s]

O
co

rr
ê

n
ci

a
 [

%
]

Figura 6.1: Histogramas das latências do sensor das tasks de controle para o caso com
h = 400ms.

que o atraso devido à rede, neste caso, é pequeno (2%) em relação ao atraso gerado pela

preempção das tasks. Os histogramas das latências do sensor para cada task de controle

obtidas através das simulações com h = 400ms são apresentados na Figura 6.1. Percebe-se

que os histogramas refletem o resultado analítico do pior caso de latência do sensor.

A latência do controlador é idêntica para todos os casos, sendo dada por

LkC = 10 +
80bits

80 bits
ms

= 11ms,

referente ao tempo de execução da task somado ao tempo de transporte da mensagem

pela rede. Novamente, o atraso referente à rede, neste caso, é pequeno (10%) em relação

ao atraso devido ao tempo de execução da task. Os histogramas das latências do con-

trolador para cada task de controle obtidas através das simulações com h = 400ms são

apresentados na Figura 6.2. Percebe-se que os histogramas refletem o resultado analítico

do pior caso de latência do controlador.

Para o pior caso (a task que precisa esperar as outras cinco serem executadas), o

tempo de execução do ciclo completo (51 + 11 = 62ms) não ultrapassa nenhum dos

valores dos períodos de amostragem nominal adotados. Assim, espera-se que os intervalos

de amostragem sejam constantes e igual ao período de amostragem nominal (h = hk).



6.1 Análise com o TrueTime 77

0 0.02 0.04 0.06 0.08 0.1 0.12
0

20

40

60

80

100

L
c
 Task1 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.02 0.04 0.06 0.08 0.1 0.12
0

20

40

60

80

100

L
c
 Task2 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.02 0.04 0.06 0.08 0.1 0.12
0

20

40

60

80

100

L
c
 Task3 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.02 0.04 0.06 0.08 0.1 0.12
0

20

40

60

80

100

L
c
 Task4 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.02 0.04 0.06 0.08 0.1 0.12
0

20

40

60

80

100

L
c
 Task5 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.02 0.04 0.06 0.08 0.1 0.12
0

20

40

60

80

100

L
c
 Task6 [s]

O
co

rr
ê

n
ci

a
 [

%
]

Figura 6.2: Histogramas das latências do controlador das tasks de controle para
h = 400ms, para o Caso 1.

Este resultado analítico corrobora com os histogramas dos intervalos de amostragem para

cada task de controle obtidos através das simulações com h = 400ms, apresentados na

Figura 6.3.

As distribuições das latências para as simulações com h = {200, 130}ms são idênticas
às encontradas para o caso em que h = 400ms. A diferença está na carga1 na CPU, como

pode ser observado nos gráficos da Figura 6.4. Nota-se que quanto menor o período de

amostragem, menos tempo o processador ficará ocioso.

1Porcentagem referente ao tempo médio no qual o processador está sendo utilizado.



6.1 Análise com o TrueTime 78

0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8
0

20

40

60

80

100

h
k
 Task1 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8
0

20

40

60

80

100

h
k
 Task2 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8
0

20

40

60

80

100

h
k
 Task3 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8
0

20

40

60

80

100

h
k
 Task4 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8
0

20

40

60

80

100

h
k
 Task5 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8
0

20

40

60

80

100

h
k
 Task6 [s]

O
co

rr
ê

n
ci

a
 [

%
]

Figura 6.3: Histogramas dos intervalos de amostragem das tasks de controle para
h = 400ms, para o Caso 1.



6.1 Análise com o TrueTime 79

0 5 10 15 20 25 30 35 40 45 50
0

10

20

30

40

50

60

70

80

90

100

Tempo [s]

C
a

rg
a

 [
%

]

(a) h = 400ms

0 5 10 15 20 25 30 35 40 45 50
0

10

20

30

40

50

60

70

80

90

100

Tempo [s]

C
a

rg
a

 [
%

]

(b) h = 200ms

0 5 10 15 20 25 30 35 40 45 50
0

10

20

30

40

50

60

70

80

90

100

Tempo [s]

C
a

rg
a

 [
%

]

(c) h = 130ms

Figura 6.4: Carga na CPU em função do tempo para h = {400, 200, 130}ms, para o
Caso 1.



6.1 Análise com o TrueTime 80

6.1.2 Caso 2

O intuito agora é verificar a influência do aumento de carga2 na rede. Para isso acrescenta-

se um nó extra na rede de forma que 80% de sua banda seja utilizada aleatoriamente.

Como as latências agora possuem um termo de caráter aleatório (atraso no envio e recebi-

mento de mensagens pela rede), descrições formais não são feitas. E por isso não é possível

predizer o comportamento dos intervalos de amostragem sem recorrer aos resultados das

simulações.

Para este caso, as latências apresentadas correspondem à simulação que adota h =

130ms. Este será considerado o pior caso visto que, pressupõe-se que os atrasos serão

maiores quanto mais escassos forem os recursos computacionais. Entretanto, são tomadas

também as estatísticas das latências para h = {400, 200}ms na análise com o Jitterbug
na próxima seção.

O resultado da simulação para a latência do sensor é mostrado na Figura 6.5. É

possível observar que neste caso, ainda existem os atrasos constantes devido ao escalona-

mento das tasks de controle. Percebe-se que a rede de comunicação deu à estas latências

um caráter aleatório, cujas ocorrências se concentram próximo aos valores obtidos para

o Caso 1. E ainda, quanto maior o atraso referente ao escalonamento, mais distribuídas

são as latências do sensor.

Resultados semelhantes podem ser observados na Figura 6.6, onde as distribuições

das latências LkC também apresentam um caráter aleatório e concentram-se próximo aos

valores obtidos para o Caso 1. E ainda, quanto maior o atraso referente ao escalonamento,

mais distribuídas são as latências do controlador.

Estas variações das latências resultam na variação dos intervalos de amostragem,

visto na Figura 6.7. Percebe-se que estes intervalos de amostragem são normalmente

distribuídos em torno do período de amostragem nominal h = 130ms, e quanto maior

o atraso referente ao escalonamento, mais disperso é a distribuição, como verificado na

Tabela 6.1.

Novamente, para cada h existe uma diferente carga na CPU, como pode ser obser-

vado nos gráficos da Figura 6.8. A variação das latências causa uma clara variação na

carga somente para o pior caso, com h = 130ms, cujos recursos computacionais são mais

escassos.

2Porcentagem referente ao tempo médio no qual a rede está sendo utilizada



6.1 Análise com o TrueTime 81

0 0.01 0.02 0.03 0.04 0.05 0.06
0

10

20

30

40

50

L
s
 Task1 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.01 0.02 0.03 0.04 0.05 0.06
0

10

20

30

40

50

L
s
 Task2 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.01 0.02 0.03 0.04 0.05 0.06
0

10

20

30

40

50

L
s
 Task3 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.01 0.02 0.03 0.04 0.05 0.06
0

10

20

30

40

50

L
s
 Task4 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.01 0.02 0.03 0.04 0.05 0.06
0

10

20

30

40

50

L
s
 Task5 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.01 0.02 0.03 0.04 0.05 0.06
0

10

20

30

40

50

L
s
 Task6 [s]

O
co

rr
ê

n
ci

a
 [

%
]

Figura 6.5: Histogramas das latências do sensor das tasks de controle para h = 130ms,
para o Caso 2.

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04
0

10

20

30

40

50

L
c
 Task1 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04
0

10

20

30

40

50

L
c
 Task2 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04
0

10

20

30

40

50

L
c
 Task3 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04
0

10

20

30

40

50

L
c
 Task4 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04
0

10

20

30

40

50

L
c
 Task5 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04
0

10

20

30

40

50

L
c
 Task6 [s]

O
co

rr
ê

n
ci

a
 [

%
]

Figura 6.6: Histogramas das latências do controlador das tasks de controle para
h = 130ms, para o Caso 2.



6.1 Análise com o TrueTime 82

0 0.05 0.1 0.15 0.2 0.25
0

2

4

6

8

10

h
k
 Task1 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.05 0.1 0.15 0.2 0.25
0

2

4

6

8

10

h
k
 Task2 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.05 0.1 0.15 0.2 0.25
0

2

4

6

8

10

h
k
 Task3 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.05 0.1 0.15 0.2 0.25
0

2

4

6

8

10

h
k
 Task4 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.05 0.1 0.15 0.2 0.25
0

2

4

6

8

10

h
k
 Task5 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.05 0.1 0.15 0.2 0.25
0

2

4

6

8

10

h
k
 Task6 [s]

O
co

rr
ê

n
ci

a
 [

%
]

Figura 6.7: Histogramas dos intervalos de amostragem das tasks de controle para
h = 130ms, para o Caso 2.

Task 1 2 3 4 5 6
Média[ms] 130 130 130 130 130 130

Desvio padrão[ms] 9.4 10.7 14.4 16.1 17.7 20.0

Tabela 6.1: Médias e desvios padrão dos intervalos de amostragem das tasks de
controle para h = 130ms, para o Caso 2.



6.1 Análise com o TrueTime 83

0 5 10 15 20 25 30 35 40 45 50
0

10

20

30

40

50

60

70

80

90

100

Tempo [s]

C
a

rg
a

 [
%

]

(a) h = 400ms

0 5 10 15 20 25 30 35 40 45 50
0

10

20

30

40

50

60

70

80

90

100

Tempo [s]

C
a

rg
a

 [
%

]

(b) h = 200ms

0 5 10 15 20 25 30 35 40 45 50
0

10

20

30

40

50

60

70

80

90

100

Tempo [s]

C
a

rg
a

 [
%

]

(c) h = 130ms

Figura 6.8: Carga na CPU em função do tempo para h = {400, 200, 130}ms, para o
Caso 2.



6.1 Análise com o TrueTime 84

6.1.3 Caso 3

O intuito agora é verificar a influência do aumento de carga na CPU. Para isso acrescenta-

se uma task periódica extra no controle central com WCET uniformemente variável no

intervalo [0, 500]ms, com período 1000ms e prioridade 1. Nota-se que as latências possuem

um termo de caráter aleatório (atraso no escalonamento das tasks). E novamente, as

latências apresentadas correspondem à simulação que adota h = 130ms pela mesma

hipótese anterior. Entretanto, são tomadas também as estatísticas das latências para

h = {400, 200}ms na análise com o Jitterbug na próxima seção.

O escalonamento das tasks no controle central está representado no diagrama de

escalonamento da Figura 6.9. Nota-se que a task extra nunca fica no estado de preempção,

devido à sua maior prioridade.

O resultado da simulação para a latência do sensor é mostrado na Figura 6.10.

Percebe-se que aproximadamente metade das ocorrências se concentram perto dos va-

lores obtidos no Caso1, porém, outros 50% estão mais dispersos que no Caso 2.

O resultado da simulação para a latência do controlador é mostrado na Figura 6.11.

Diferentemente do Caso 2, as distribuições, neste caso, não experimentam muita variação,

se concentrando próximo aos valores obtidos no Caso 1.

Pela Figura 6.12 nota-se que os intervalos de amostragem ficam concentrados princi-

palmente em dois valores, sendo um deles equivalente ao período de amostragem nominal.

A carga na CPU para cada caso é dada na Figura 6.13. Percebe-se que a carga

computacional é variável. As médias e os desvios padrão são dados na Tabela 6.2. Nota-

se que a diminuição dos períodos de amostragem causam um aumento na média da carga,

mas não altera o desvio padrão.

h h = 400ms h = 200ms h = 130ms
Médias [%] 43.1 55.6 71.7

Desvios padrão [%] 14.9 14.6 14.9

Tabela 6.2: Médias e desvios padrão da carga na CPU, para h = {400, 200, 130}ms,
para o Caso 3.



6.1 Análise com o TrueTime 85

0 5 10 15 20 25 30 35 40 45 50
0

1

2

3

4

5

6

7

8

Tempo [s]

E
st

a
d

o
 d

a
s 

ta
sk

s

 

 Task 1
Task 2
Task 3
Task 4
T	ask 5
Task 6
Task
Extra

Figura 6.9: Diagrama de escalonamento das tasks do controle central para h = 130ms,
para o Caso 3.

0 0.01 0.02 0.03 0.04 0.05 0.06
0

20

40

60

80

100

L
s
 Task1 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.01 0.02 0.03 0.04 0.05 0.06
0

20

40

60

80

100

L
s
 Task2 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.01 0.02 0.03 0.04 0.05 0.06
0

20

40

60

80

100

L
s
 Task3 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.01 0.02 0.03 0.04 0.05 0.06
0

20

40

60

80

100

L
s
 Task4 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.01 0.02 0.03 0.04 0.05 0.06
0

20

40

60

80

100

L
s
 Task5 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.01 0.02 0.03 0.04 0.05 0.06
0

20

40

60

80

100

L
s
 Task6 [s]

O
co

rr
ê

n
ci

a
 [

%
]

Figura 6.10: Histogramas das latências do sensor das tasks de controle para
h = 130ms, para o Caso 3.



6.1 Análise com o TrueTime 86

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04
0

20

40

60

80

100

L
c
 Task1 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04
0

20

40

60

80

100

L
c
 Task2 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04
0

20

40

60

80

100

L
c
 Task3 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04
0

20

40

60

80

100

L
c
 Task4 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04
0

20

40

60

80

100

L
c
 Task5 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04
0

20

40

60

80

100

L
c
 Task6 [s]

O
co

rr
ê

n
ci

a
 [

%
]

Figura 6.11: Histogramas das latências do controlador das tasks de controle para
h = 130ms, para o Caso 3.

0 0.05 0.1 0.15 0.2 0.25
0

20

40

60

80

100

h
k
 Task1 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.05 0.1 0.15 0.2 0.25
0

20

40

60

80

100

h
k
 Task2 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.05 0.1 0.15 0.2 0.25
0

20

40

60

80

100

h
k
 Task3 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.05 0.1 0.15 0.2 0.25
0

20

40

60

80

100

h
k
 Task4 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.05 0.1 0.15 0.2 0.25
0

20

40

60

80

100

h
k
 Task5 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.05 0.1 0.15 0.2 0.25
0

20

40

60

80

100

h
k
 Task6 [s]

O
co

rr
ê

n
ci

a
 [

%
]

Figura 6.12: Histogramas dos intervalos de amostragem das tasks de controle para
h = 130ms, para o Caso 3.



6.1 Análise com o TrueTime 87

0 5 10 15 20 25 30 35 40 45 50
0

10

20

30

40

50

60

70

80

90

100

Tempo [s]

C
a

rg
a

 [
%

]

(a) h = 400ms

0 5 10 15 20 25 30 35 40 45 50
0

10

20

30

40

50

60

70

80

90

100

Tempo [s]

C
a

rg
a

 [
%

]

(b) h = 200ms

0 5 10 15 20 25 30 35 40 45 50
0

10

20

30

40

50

60

70

80

90

100

Tempo [s]

C
a

rg
a

 [
%

]

(c) h = 130ms

Figura 6.13: Carga na CPU em função do tempo para h = {400, 200, 130}ms, para o
Caso 3.

6.1.4 Caso 4

Nos Casos 2 e 3, o problema dos atrasos devido ao tráfego na rede de comunicação e ao es-

calonamento de tasks foi tratado separadamente. Neste Caso 4, estas duas fontes de atraso



6.1 Análise com o TrueTime 88

0 5 10 15 20 25 30 35 40 45 50
0

1

2

3

4

5

6

7

8

Tempo [s]

E
st

a
d

o
 d

a
s 

ta
sk

s

 

 
Task 1
Task 2
Task 3
Task 4
Task 5
Task 6
Task
Extra

Figura 6.14: Diagrama de escalonamento das tasks do controle central para
h = 130ms, para o Caso 4.

agem em conjunto. Novamente, as latências apresentadas correspondem à simulação que

adota h = 130ms.

Percebe-se através das Figuras 6.14, 6.15, 6.16 e 6.17 que tanto os efeitos do Caso 2

como os efeitos do Caso 3 estão contidos neste Caso 4. Estes efeitos agindo em conjunto,

como visto na Figura 6.18, aumenta a dispersão da distribuição intervalo de amostra-

gem de forma que esta se aproxima mais de uma distribuição uniforme (com intervalo de

aproximadamente [50, 150]ms) do que uma distribuição normal. O impacto maior desta

distribuição uniforme, do ponto de vista de controle, é no termo integral do controlador

discreto, que, como visto no Capítulo 5, considera o intervalo de integração (h) cons-

tante. Na análise com o Jitterbug será possível analisar esse impacto no que se refere à

estabilidade (no sentido quadrático médio) e ao desempenho do sistema de controle.



6.1 Análise com o TrueTime 89

0 0.01 0.02 0.03 0.04 0.05 0.06
0

10

20

30

40

50

L
s
 Task1 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.01 0.02 0.03 0.04 0.05 0.06
0

10

20

30

40

50

L
s
 Task2 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.01 0.02 0.03 0.04 0.05 0.06
0

10

20

30

40

50

L
s
 Task3 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.01 0.02 0.03 0.04 0.05 0.06
0

10

20

30

40

50

L
s
 Task4 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.01 0.02 0.03 0.04 0.05 0.06
0

10

20

30

40

50

L
s
 Task5 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.01 0.02 0.03 0.04 0.05 0.06
0

10

20

30

40

50

L
s
 Task6 [s]

O
co

rr
ê

n
ci

a
 [

%
]

Figura 6.15: Histogramas das latências do sensor das tasks de controle para
h = 130ms, para o Caso 4.

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04
0

10

20

30

40

50

L
c
 Task1 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04
0

10

20

30

40

50

L
c
 Task2 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04
0

10

20

30

40

50

L
c
 Task3 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04
0

10

20

30

40

50

L
c
 Task4 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04
0

10

20

30

40

50

L
c
 Task5 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04
0

10

20

30

40

50

L
c
 Task6 [s]

O
co

rr
ê

n
ci

a
 [

%
]

Figura 6.16: Histogramas das latências do controlador das tasks de controle para
h = 130ms, para o Caso 4.



6.1 Análise com o TrueTime 90

0 5 10 15 20 25 30 35 40 45 50
0

10

20

30

40

50

60

70

80

90

100

Tempo [s]

C
a

rg
a

 [
%

]

(a) h = 400ms

0 5 10 15 20 25 30 35 40 45 50
0

10

20

30

40

50

60

70

80

90

100

Tempo [s]

C
a

rg
a

 [
%

]

(b) h = 200ms

0 5 10 15 20 25 30 35 40 45 50
0

10

20

30

40

50

60

70

80

90

100

Tempo [s]

C
a

rg
a

 [
%

]

(c) h = 130ms

Figura 6.17: Carga na CPU em função do tempo para h = {400, 200, 130}ms, para o
Caso 4.



6.1 Análise com o TrueTime 91

0 0.05 0.1 0.15 0.2 0.25
0

10

20

30

40

50

h
k
 Task1 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.05 0.1 0.15 0.2 0.25
0

10

20

30

40

50

h
k
 Task2 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.05 0.1 0.15 0.2 0.25
0

10

20

30

40

50

h
k
 Task3 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.05 0.1 0.15 0.2 0.25
0

10

20

30

40

50

h
k
 Task4 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.05 0.1 0.15 0.2 0.25
0

10

20

30

40

50

h
k
 Task5 [s]

O
co

rr
ê

n
ci

a
 [

%
]

0 0.05 0.1 0.15 0.2 0.25
0

10

20

30

40

50

h
k
 Task6 [s]

O
co

rr
ê

n
ci

a
 [

%
]

Figura 6.18: Histogramas dos intervalos de amostragem das tasks de controle para
h = 130ms, para o Caso 4.



6.2 Análise com o Jitterbug 92

6.2 Análise com o Jitterbug

O modelo Jitterbug é o mesmo adotado no Capítulo 4, onde H1(z) = 1, H2(z) = PI(z) e

H3(z) = 1 representam o nó do sensor, do controlador e do atuador, respectivamente; e

G(s) é o modelo de um GL i (surge,sway,heave e yaw ) representado por uma função de

transferência de primeira ordem, do tipo

G(s) =
b

s + a
,

onde

a(x?i ) = ?
dLi
mi

? 2
dQi
mi

|x?i |,

b =
1

mi
.

Portanto, para cada ponto de operação existe uma função de transferência. No caso de

roll e pitch há o controle passivo (ou seja, a resultante do empuxo) que mantém estes dois

GLs estáveis (SOUZA, 2003), por isso não foram considerados nesta análise.

O cálculo da função de custo é feito fixando-se wni (o que é equivalente à fixar h pela

parametrização adotada); adotando os pontos de operação x?1 = 0.5m/s, x
?
2 = 0.5m/s,

x?3 = 0.5m/s e x
?
6 = 1.4rad/s; e variando-se o coeficiente de amortecimento ?i. Desta

forma, é possível obter o conjunto de parâmetros de projeto ótimos, que proporciona o

menor custo J. Faz-se isso para cada caso visto na seção anterior, através das distribuições

das latências obtidas.

Sabendo que para um dado coeficiente de amortecimento, o sistema responde mais

rapidamente para uma freqüência natural maior, espera-se que quanto mais rápida a

resposta, maior será o impacto das latências sobre desempenho e estabilidade (no sentido

quadrático médio) do sistema. Isto pode ser verificado nas Figuras 6.19, 6.20 e 6.21, onde

as curvas dos custos referentes aos Casos 2, 3 e 4 estão relativamente mais distantes da

curva do custo referente ao Caso 1 conforme aumenta-se ?ni .

Pelos gráficos também é possível notar que existem valores mínimos para as funções

de custo, que, segundo o critério de avaliação utilizado, correspondem aos pares (?i,?ni )

ótimos para cada caso e situação de atraso.

Nota-se também que mesmo para os piores casos de atraso, existem intervalos relativa-

mente grandes para a escolha dos parâmetros (?i,?ni ) que resultam num custo limitado (J



6.2 Análise com o Jitterbug 93

finito), ou seja, o sistema é considerado estável no sentido quadrático médio. Isto porque

os sistemas adotados (G(s)) são sistemas de primeira ordem com pólos no SPE (semiplano

esquerdo) do plano-s, ou seja, sistemas tipicamente estáveis. Se fossem adotados sistemas

tipicamente instáveis (como visto no trabalho de (CERVIN et al., 2006)), provavelmente os

intervalos para escolha de (?i,?ni ) seriam relativamente menores.

0 0.5 1 1.5 2 2.5
1.64

1.645

1.65

1.655

1.66

1.665

?
1

C
u

st
o

 J

 

 

Caso 1
Caso 2
Caso 3
Caso 4

(a) Surge

0 0.5 1 1.5 2 2.5
1.24

1.25

1.255

1.245

?
2

C
u

st
o

 J

 

 

Caso 1
Caso 2
Caso 3
Caso 4

(b) Sway

0 0.5 1 1.5 2 2.5
0.794

0.796

0.798

0.8

0.802

0.804

0.806

0.808

?
3

C
u

st
o

 J

 

 

Caso 1
Caso 2
Caso 3
Caso 4

(c) Heave

0 0.5 1 1.5 2 2.5

2.28

2.3

2.32

2.34

2.36

?
6

C
u

st
o

 J

 

 

Caso 1
Caso 2
Caso 3
Caso 4

(d) Heave

Figura 6.19: Custo J em função de ?i, para os Casos {1, 2, 3, 4}, considerando
?ni = 1rad/s, o que corresponde a h = 400ms.

0 0.5 1 1.5 2 2.5
6.53

6.54

6.55

6.56

6.57

6.58

?
1

C
u

st
o

 J

 

 

Caso 1
Caso 2
Caso 3
Caso 4

(a) Surge

0 0.5 1 1.5 2 2.5

4.945

4.95

4.955

4.96

4.965

4.97

4.975

4.98

4.985

?
2

C
u

st
o

 J

 

 

Caso 1
Caso 2
Caso 3
Caso 4

(b) Sway

0 0.5 1 1.5 2 2.5
3.15

3.155

3.16

3.165

3.17

3.175

3.18

?
3

C
u

st
o

 J

 

 

Caso 1
Caso 2
Caso 3
Caso 4

(c) Heave

0 0.5 1 1.5 2 2.5
8.8

8.9

9

9.1

9.2

9.3

?
6

C
u

st
o

 J

 

 

Caso 1
Caso 2
Caso 3
Caso 4

(d) Yaw

Figura 6.20: Custo J em função de ?i, para os Casos {1, 2, 3, 4}, considerando
?ni = 2rad/s, o que corresponde a h = 200ms.

No entanto, é importante salientar que a função de custo J reflete a relação de energia



6.3 Simulações com o Modelo do ROV 94

0 0.5 1 1.5 2 2.5
14.65

14.7

14.75

14.8

14.85

?
1

C
u

st
o

 J

 

 

Caso 1
Caso 2
Caso 3
Caso 4

(a) Surge

0 0.5 1 1.5 2 2.5
11.1

11.12

11.14

11.16

11.18

11.2

?
2

C
u

st
o

 J

 

 

Caso 1
Caso 2
Caso 3
Caso 4

(b) Sway

0 0.5 1 1.5 2 2.5
7.08

7.09

7.1

7.11

7.12

7.13

7.14

?
3

C
u

st
o

 J

 

 

Caso 1
Caso 2
Caso 3
Caso 4

(c) Heave

0 0.5 1 1.5 2 2.5
19.8

20

20.2

20.4

20.6

20.8

?
6

C
u

st
o

 J

 

 

Caso 1
Caso 2
Caso 3
Caso 4

(d) Yaw

Figura 6.21: Custo J em função de ?i, para os Casos {1, 2, 3, 4}, considerando
?ni = 3rad/s, o que corresponde a h = 130ms.

do sistema (Equações (2.19) e (2.21)). Portanto, o desempenho ótimo se refere à melhor

relação de energia para determinados parâmetros (?ni,?i) e casos de atrasos.

6.3 Simulações com o Modelo do ROV

Através das simulações que envolvem o modelo dinâmico do ROV descrito no Capítulo 5

em conjunto com o TrueTime, verifica-se o comportamento do sistema no tempo, compa-

rando com os resultados da seção anterior. Foram acrescentados nestas simulações ruído

branco gaussiano nos sinais adquiridos pelos sensores e sinais de distúrbio na entrada das

plantas a fim de aproximar a simulação de situações encontradas na prática.

A Figura 6.22 mostra a resposta do sistema no tempo nos GLs surge, sway, heave e

yaw considerando wn1 = wn2 = wn3 = wn6 = 3[rad/s] para o Caso 4. Foram considera-

dos dois sistemas: um com parâmetros (?i,?ni ) ótimos referentes aos menores valores da

função de custo J, de acordo com a Figura 6.21; e outro diferente deste. Visualmente é

possível notar que, embora ambos os sistemas sejam estáveis, aquele com os coeficientes

de amortecimento ditos ótimos para este caso apresenta menores amplitudes de oscilação.

A Figura 6.23 mostra a resposta no tempo do sistema no GL surge para (?n1,?1) =

{(1, 0.7), (2, 1.2), (3, 1.7)} (referentes aos menores valores de J) para o Caso 4. Nota-se
que, conforme ?n1 aumenta, o sistema responde mais rapidamente, porém, as amplitudes



6.3 Simulações com o Modelo do ROV 95

0 5 10 15 20 25 30 35 40 45 50
?1

?0.5

0

0.5

1

1.5

2

Tempo [s]

u
 [
m

/s
]

 

 

Referência
?

1
 = 1.7

?
1
 = 0.5

(a) Surge

0 5 10 15 20 25 30 35 40 45 50
?0.2

0

0.2

0.4

0.6

0.8

1

1.2

Tempo [s]

v 
[m

/s
]

 

 

Referência
?

2
 = 1.3

?
2
 = 0.5

(b) Sway

0 5 10 15 20 25 30 35 40 45 50
?1

?0.5

0

0.5

1

1.5

2

Tempo [s]

w
 [
m

/s
]

 

 

Referência
?

3
 = 0.7

?
3
 = 1.5

(c) Heave

0 5 10 15 20 25 30 35 40 45 50
?2

?1

0

1

2

3

4

Tempo [s]

r 
[r

a
d

/s
]

 

 

Referência
?

6
 = 0.7

?
6
 = 1.5

(d) Yaw

Figura 6.22: Resposta do sistema no tempo nos GLs surge, sway, heave e yaw
considerando wn1 = wn2 = wn3 = wn6 = 3[rad/s] para o Caso 4.

de oscilação são maiores.

Para visualizar a influência do comportamento temporal de cada GL na realização de

tarefas, como por exemplo o deslocamento do veículo sobre uma trajetória pré-definida,

criou-se um modelo do VSOR em realidade virtual (Figura 6.24) através do SIMULINK.

Com este modelo simulou-se três situações envolvendo o deslocamento do móvel no plano

XY (correspondente aos GLs surge, sway e yaw ), cujos resultados são observados nas

Figuras 6.25, 6.26 e 6.27.

Nestes gráficos são comparados os Casos 1 e 4, para os parâmetros ótimos obtidos

na seção anterior. Nota-se que o efeito dos atrasos não comprometeram o desempenho

do sistema de controle na realização desta tarefa específica, para os parâmetros aqui

avaliados.

O sistema com menor tempo de resposta (maior ?ni e, conseqüentemente menor h)

conseguiu se manter mais próximo da trajetória de referência do que os outros sistemas.

Do ponto de vista de controle, era esperado este comportamento. Porém, como visto

no Capítulo 4, existe uma relação de compromisso entre o desempenho do sistema de

controle e o desempenho do sistema computacional. Portanto, é provável que para valores

de ?ni maiores que 3rad/s (ou seja, h &gt; 130ms) os efeitos dos atrasos inseridos pelo

sistema computacional sejam mais relevantes no desempenho do sistema de controle para

realização desta tarefa.



6.3 Simulações com o Modelo do ROV 96

0 10 20 30 40 50
0

0.1

0.2

0.3

0.4

0.5

0.6

0.7

0.8

Tempo [s]

u
 [
m

/s
]

 

 

Referência
?

n
1

 = 1.0 rad/s

?
1
 = 0.7

?
n

1

 = 2 rad/s

?
1
 = 1.2

?
n

1

 = 3 rad/s

?
1
 = 1.7

Figura 6.23: Resposta do sistema no GL surge para
(?n1,?1) = {(1, 0.7), (2, 1.2), (3, 1.7)} para o Caso 4.

Figura 6.24: Modelo do VSOR em realidade virtual.



6.3 Simulações com o Modelo do ROV 97

?1 0 1 2 3 4 5 6
?1

0

1

2

3

4

5

6

x [m]

y 
[m

]

 

 

Referência
Caso 1
Caso 4

Figura 6.25: Deslocamento no plano XY do veículo para (?n1,?1) = (1, 0.7),
(?n2,?2) = (1, 0.8), (?n3,?3) = (1, 0.8) e (?n6,?6) = (1, 0.9), para o Caso 1 e para o Caso

4.

?1 0 1 2 3 4 5 6
?1

0

1

2

3

4

5

6

x [m]

y 
[m

]

 

 

Referência
Caso 1
Caso 4

Figura 6.26: Deslocamento no plano XY do veículo para (?n1,?1) = (2, 1.2),
(?n2,?2) = (2, 1.0), (?n3,?3) = (2, 0.8) e (?n6,?6) = (2, 0.8), para o Caso 1 e para o Caso

4.



6.4 Conclusões 98

?1 0 1 2 3 4 5 6
?1

0

1

2

3

4

5

6

x [m]

y 
[m

]

 

 

Referência
Caso 1
Caso 4

Figura 6.27: Deslocamento no plano XY do veículo para (?n1,?1) = (3, 1.7),
(?n2,?2) = (3, 1.3), (?n3,?3) = (2, 1.0) e (?n6,?6) = (2, 0.8), para o Caso 1 e para o Caso

4.

6.4 Conclusões

Os resultados obtidos foram parametrizados em função dos parâmetros de projeto do

controlador, de forma que estes podem ser escolhidos dentre um conjunto (?ni,?i) tal

que o sistema seja estável (no sentido quadrático médio) e apresente um comportamento

desejado (desempenho), mesmo em presença de atrasos devido ao sistema computacional.

Os resultados obtidos com o TrueTime permitem avaliar como as latências se compor-

tam em função da carga na rede, da carga na CPU e da freqüência natural (?ni ) desejada

para o sistema, ou mais precisamente do período de amostragem nominal h do ciclo de

controle. O comportamento das latências são descritas por suas respectivas FDPs.

Estas FDPs foram utilizadas na formulação de Modelos Lineares de Saltos Marko-

vianos para os GLs surge, sway, heave e yaw. E estes modelos foram utilizados para o

cálculo da função de custo J através do Jitterbug para cada caso de atraso e para cada

par (?ni,?i), com ?ni = {1, 2, 3}rad/s e ?i variando no intervalo [0.1,2.1]. Os valores mí-
nimos de J indicam os parâmetros (?ni,?i) ótimos (pontos de melhor relação de energia

do sistema) para cada caso.

Com os parâmetros ótimos obtidos com o Jitterbug, implementou-se os controladores



6.4 Conclusões 99

no modelo do VSOR em realidade virtual para visualização do comportamento temporal

do sistema em presença de atrasos. Foi possível constatar que, para os valores de ?ni e para

a tarefa adotados, os atrasos devido ao sistema computacional não são os determinantes

para o bom desempenho do sistema no tempo, ou seja, a sensibilidade do sistema aos

atrasos é baixa. O melhor desempenho no tempo para a realização da tarefa foi obtido

para o sistema com menor tempo de resposta. Uma possível explicação é que o modelo do

VSOR envolve plantas tipicamente estáveis (funções de transferência de primeira ordem

com pólos no SPE), diferentemente das adotadas no trabalho de Cervin et al. (2006) onde

a sensibilidade do sistema aos atrasos é alta.

O modelo do sistema com atraso em tempo discreto mostrado no Capítulo 2, embora

não utilizado neste presente capítulo, poderia ser útil na análise me freqüência da sen-

sibilidade do sistema frente aos atrasos (utilizando o pior caso de atraso obtido através

do TrueTime). Com isso seria possível criar barreiras de desempenho e estabilidade em

freqüência para uso em técnicas de projeto de controladores robustos.



100

7 Conclusões

Este trabalho teve como foco o estudo de uma nova classe de sistemas de controle (sis-

temas de controle distribuídos em redes de comunicação – NCS), tendo como objetivo o

desenvolvimento de uma solução de controle para um ROV (VSOR), utilizando a referida

arquitetura. Neste trabalho, foi abordado o problema da presença de atrasos inseridos

pelo sistema computacional, mais especificamente atrasos devido ao escalonamento de

processos e ao tráfego de mensagens na rede. Discutiu-se também possíveis candidatas

para rede de controle para NCSs.

Para análise do impacto destes atrasos em sistemas de controle, foram apresentados

dois métodos:

• utilizando um modelo de sistema com atraso e em tempo discreto, que permite fazer
a análise em freqüência do sistema para o pior caso (atraso constante);

• utilizando as ferramentas TrueTime e Jitterbug, que, em conjunto, analisam o im-
pacto de atrasos aleatórios sobre o sistema de controle através da teoria de Sistemas

Lineares com Saltos Markovianos (MJLS).

E aplicando estes métodos em um caso de estudo, foi possível constatar que existe uma

relação de compromisso entre o desempenho do sistema de controle e o desempenho do sis-

tema computacional: um período de amostragem longo para o ciclo de controle prejudica

o sistema de controle e ao mesmo tempo beneficia o sistema computacional, e vice-versa.

Foi apresentado também o modelo do ROV em questão, onde o sistema é descrito

por 6 equações diferenciais desacompladas não-lineares referentes aos GLs do veículo, sob

a hipótese de operações de baixas velocidades. O modelo inclui ainda uma matriz de

alocação de empuxo dada em função da geometria do veículo e controladores do tipo PI

com estrutura feedback-feedfoward, parametrizados em função de duas variáveis de projeto:

?ni e ?i.



7.1 Sugestões para Trabalhos Futuros 101

O desempenho e estabilidade do sistema para alguns valores de (?ni,?i) foram anali-

sados através do TreuTime e Jitterbug, sob alguns casos de atrasos. Para cada um destes

casos foram obtidos pontos ótimos (considerados pontos de melhor relação de energia na

entrada e na saída do sistema), que foram testados no modelo do ROV em realidade

virtual. Os resultados mostram que para os intervalos de (?ni,?i) analisados, os atra-

sos devido ao sistema computacional não influem muito no desempenho e estabilidade

do sistema de controle na realização de uma determinada tarefa. Atribui-se isto ao fato

do modelo do veículo envolver plantas tipicamente estáveis (funções de transferência de

primeira ordem com pólos no SPE).

Mostrou-se que, do ponto de vista de desempenho e estabilidade de sistemas com

atrasos, é viável a implantação do NCS proposto sob as condições de operação citadas

para o controle do VSOR, proporcionando ao sistema a redução de custo e do peso; a

facilidade de diagnóstico e manutenção do sistema; e maior agilidade e flexibilidade.

7.1 Sugestões para Trabalhos Futuros

Sugere-se para trabalhos futuros o uso de dados experimentais para simulações com o Tru-

eTime de forma que a simulação se aproxime mais das situações encontradas na prática.

Como por exemplo a medição do WCET através de ferramentas específicas. A análise

neste trabalho considerou que todas as tasks de controle possuem o mesmo período de

amostragem. Sugere-se que combinações de diferentes períodos de amostragem sejam es-

tudados, com especial atenção no problema da alocação de empuxo. Outros parâmetros

podem ser alterados, como o algoritmo de escalonamento de processos e o tipo de rede.

Neste trabalho tratou-se apenas do problema dos atrasos inseridos pelo sistema com-

putacional. Porém outro problema que pode ser encontrado, especialmente em se tratando

de redes de comunicação, é a perda de dados. Sugere-se que sejam estudados os efeitos

da perda de dados durante o ciclo de controle.

Pode-se também aplicar outras técnicas de projeto de controladores, como por exemplo

técnicas de controle robusto. E também estudar a aplicação de técnicas para diminuir o

impacto de atrasos e perdas de dados, como visto em Montestruque e Antsaklis (2005a),

através da técnica de model-based.



102

Anexo A -- Robustez de Sistemas SISO

+

-

+
+

+

+

r(s) e(s)

K(s)

u(s)

GR(s)

d(s)

y(s)

n(s)

Figura A.1: Diagrama do sistema em malha fechada e em tempo contínuo.

O modelo real de um sistema de controle típico é representado pelo diagrama de blocos

na Figura A.1. Nele são apresentados em freqüência:

• o sinal de referência r(s),

• o sinal de erro e(s),

• o controlador K(s),

• o sinal de controle u(s),

• o modelo real da planta GR(s),

• o sinal de distúrbio d(s),

• o sinal de ruído n(s),

• o sinal de saída y(s).

Para este sistema, o sinal de saída é representado por

y(s) = S(s)L(s)r(s) + S(s)d(s) ? S(s)L(s)n(s), (A.1)



Anexo A -- Robustez de Sistemas SISO 103

e o sinal de erro é representado por

e(s) = S(s)r(s) ? S(s)d(s) ? S(s)n(s), (A.2)

onde S(s) é a chamada função de sensibilidade do sistema definida por

S(s) =
1

1 + L(s)
, (A.3)

e L(s) é a chamada função de malha aberta do sistema definida por

L(s) = GR(s)K(s). (A.4)

Sobre este modelo real aplica-se a técnica de controle robusto1 (CRUZ, 1996). O

objetivo neste caso é garantir a estabilidade e o desempenho do sistema de controle mesmo

sob o efeito das variações provocadas pela dinâmica do sistema computacional. Para

garantir a estabilidade robusta deste sistema, utiliza-se o Critério de Nyquist que permite

afirmar que a malha fechada é dada por

CR(s) =
GR(s)K(s)

1 + GR(s)K(s)
(A.5)

é estável se e somente se o número de envolvimentos no sentido anti-horário do Diagrama

de Nyquist de L(j?) em torno do ponto ?1 + j0 é igual ao número de pólos instáveis de
L(s). Esta condição pode ser expressa por

[1 + ??M (j?)]GN (j?)K(j?) 6= ?1 + j0, para ? ? [0, 1]. (A.6)

Ou seja, a área demarcada pelos círculos tracejados na Figura 2.5 não deve conter o ponto

?1 + j0. Por sua vez, esta condição pode ser expressa por
?

?

?

?

GN (j?)K(j?)

1 + GN (j?)K(j?)

?

?

?

?

&lt;
1

eM (?)
, (A.7)

chamada por Cruz (1996) de Condição de Robustez de Estabilidade. Adotando novamente

a hipótese de que os efeitos deste erro de modelagem sejam mais perceptíveis em altas

freqüências (ou seja, eM (?) ? 1), a condição pode ser aproximada para

|GN (j?)K(j?)|&amp;lt;
1

eM (?)
, para {? | eM (?) ? 1}. (A.8)

1Robustez é a característica que permite ao sistema de controle obter um desempenho satisfatório,
mesmo em condições de operação não explicitadas no projeto do controlador.



Anexo A -- Robustez de Sistemas SISO 104

Desta forma o ganho da função de malha aberta nominal deve ser "pequeno"(ou seja,

|GN (j?)K(j?)| ? 1) em altas freqüências para garantir a estabilidade do sistema.



105

Referências

ANDERSSON, M.; HENRIKSSON, D.; CERVIN, A. TRUETIME 1.5 - Reference
Manual. [S.l.], June 2007.

AVILA, J. P. J. Modelagem e identificação de parâmetros hidrodinâmicos de um veículo
robótico submarino. Tese (Doutorado) — Escola Politécnica da Universidade de São
Paulo, 2008.

AVILA, J. P. J.; MARUYAMA, N.; ADAMOWSKI, J. C. Hydrodynamic parameter
estimation of an open frame unmanned underwater vehicle. In: Proceedings of the 17th
World Congress. The International Federation of Automatic Control, Seoul, Korea. [S.l.:
s.n.], 2008.

BROCKETT, R. W. Stabilization of motor networks. In: Proc. 34th IEEE Conf. on
Dec. and Control. [S.l.: s.n.], 1995. p. 1484–1488.

CACCIA, M.; INDIVERI, G.; VERUGGIO, G. Modeling and identification of
open-frame variable configuration unmanned underwater vehicles. Oceanic Engineering,
IEEE Journal of, v. 25, n. 2, p. 227–240, 2000. ISSN 0364-9059.

CACCIA, M.; VERUGGIO, G. Guidance and control of a reconfigurable unmanned
underwater vehicle. Control Engineering Practice, v. 8, n. 1, p. 21–37, jan. 2000.
Disponível em:&amp;lt;http://www.sciencedirect.com/science/article/B6V2H-3Y51H01-
4/2/fd60b2e613260d7e5c02eddca88abe8f&gt;.

CATSOULIS, J. Designing Embedded Hardware. [S.l.]: O’Reilly, 2005.

CERVIN, A. Integrated Control and Real-Time Scheduling. Tese (Doutorado) —
Department of Automatic Control, Lund University, Sweden, abr. 2003.

CERVIN, A.; ARZEN, K.-E.; HENRIKSSON, D.; LLUESMA, M.; BALBASTRE, P.;
RIPOLL, I.; CRESPO, A. Control loop timing analysis using truetime and jitterbug. In:
Computer-Aided Control Systems Design, 2006 IEEE International Symposium on. [S.l.:
s.n.], 2006. p. 1194–1199.

CERVIN, A.; HENRIKSSON, D.; LINCOLN, B.; EKER, J.; ARZEN, K.-E. How does
control timing affect performance? analysis and simulation of timing using jitterbug and
truetime. Control Systems Magazine, IEEE, v. 23, n. 3, p. 16–30, 2003. ISSN 0272-1708.

CERVIN, A.; LINCOLN, B. Jitterbug 1.21 Reference Manual. Box 118, SE 221 00 Lund,
Sweden, February 2006.



Referências 106

CHOW, M.-Y.; TIPSUWAN, Y. Gain adaptation of networked dc motor controllers
based on qos variations. Industrial Electronics, IEEE Transactions on, v. 50, n. 5, p.
936–943, 2003. ISSN 0278-0046.

CLARKE, D. W.; MOHTADI, C.; TUFFS, P. S. Generalized predictive control - part
i. the basic algorithm. Automatica, Pergamon Press, Inc., Tarrytown, NY, USA, v. 23,
n. 2, p. 137–148, 1987. ISSN 0005-1098.

CRUZ, J. J. Controle Robusto Multivariável. [S.l.]: Edusp, 1996.

DAVIDSON, C. Random sampling and random delays in optimal control systems. Tese
(Doutorado) — Royal Institute of Technology, 1973.

DEITEL, H. M.; DEITEL, P. J.; CHOFFNES, D. R. Sistemas Operacionais. [S.l.]:
Prentice Hall, 2005.

FARINES, J.-M.; PRAGA, J. da S.; OLIVEIRA, R. da Silva de. Sistemas de Tempo
Real. [S.l.]: IME-USP, 2000.

FOSSEN, T. I. Guidance and control of ocean vehicles. [S.l.]: John Wiley &amp;amp; Sons, 1994.

GAMBIER, A. Real-time control systems: a tutorial. In: Control Conference, 2004. 5th
Asian. [S.l.: s.n.], 2004. v. 2, p. 1024–1031 Vol.2.

HENRIKSSON, D. Resource-Constrained Embedded Control and Computing Systems.
Tese (Doutorado) — Department of Automatic Control, Lund Institute of Technology,
Sweden, jan. 2006.

HENRIKSSON, D.; CERVIN, A.; ANDERSSON, M.; ÅRZèN, K.-E. Truetime:
Simulation of networked computer control systems. In: Proceedings of the 2nd IFAC
Conference on Analysis and Design of Hybrid Systems. Alghero, Italy: [s.n.], 2006.
Invited talk.

KAPLAN, G. Ethernet’s winning ways. Spectrum, IEEE, v. 38, n. 1, p. 113–115, 2001.
ISSN 0018-9235.

KOUBIAS, S. A.; PAPADOPOULOS, G. D. Modern fieldbus commu-
nication architectures for real-time industrial applications. Computers in
Industry, v. 26, n. 3, p. 243–252, ago. 1995. ISSN 0166-3615. Disponí-
vel em:&amp;lt;http://www.sciencedirect.com/science/article/B6V2D-3YF4GSB-
5/2/e84f92c5abb6b6ef05dce1fb90aa4738&gt;.

LIAN, F.-L. Analysis, Design, Modeling, and Control of Networked Control Systems.
Tese (Doutorado) — University of Michigan, 2001.

LIAN, F.-L.; MOYNE, J.; TILBURY, D. Network design consideration for distributed
control systems. Control Systems Technology, IEEE Transactions on, v. 10, n. 2, p.
297–307, 2002. ISSN 1558-0865.

LINCOLN, B. Dynamic programming and time-varying delay systems. Tese (Doutorado)
— Lund Institute of Technology, 2003.



Referências 107

MONTESTRUQUE, L.; ANTSAKLIS, P. Networked control systems: a model-based
approach. In: IAESTED International Conference on Networks and Communication
Systems, Thailand. [S.l.: s.n.], 2005.

MONTESTRUQUE, L.; ANTSAKLIS, P. Quantization in model based networked
control systems. In: Proceedings of the 16th IFAC World Congress, Prague. [S.l.: s.n.],
2005.

MONTESTRUQUE, L.; ANTSAKLIS, P. Performance Evaluation for Model-Based
Networked Control Systems. 2006. 231–249 p.

NILSSON, J. Real-time control systems with delays. Tese (Doutorado) — Lund Institute
of Technology, 1998.

OOI, J.; VERBOUT, S.; LUDWIG, J.; WORNELL, G. A separation theorem for
periodic sharing information patterns in decentralized control. IEEE Trans. Autom.
Control, Vol 42, p. pp. 1546–1550., 1997.

OTANEZ, P. G.; PARROTT, J. T.; MOYNE, J. R.; TILBURY, D. M. The implications
of ethernet as a control network. In: Global Powertrain Conference. [S.l.: s.n.], 2002.

POSTLETHWAITE, S. Multivariable Feedback Control. [S.l.]: Wiley, 1996.

ÅRZèN, K.-E.; CERVIN, A. Control and embedded computing: Survey of research
directions. In: Proc. 16th IFAC World Congress. Prague, Czech Republic: [s.n.], 2005.

SAAB, T. Site acessado em Jan 2009. Http://www.seaeye.com/.

SANDELL, D. Evaluating Static Worst-Case Execution-Time Analysis for a Commercial
Real-Time Operating System. Dissertação (Mestrado) — Dept. of Computer Science -
Mälardalen University, 2004.

SILJAK, D. Decentralized control of complex systems. [S.l.]: Academic Press, 1991.

SOUZA, E. C. Modelagem e controle de veículos submarinos não tripulados. Dissertação
(Mestrado) — Escola Politécnica da Universidade de São Paulo, 2003.

ÅSTRöM, K. J.; HäGGLUND, T. PID Controllers: Theory, Design, and Tuning. [S.l.]:
International Society for Measurement and Con, 1995.

ÅSTRöM, K. J.; WITTENMARK, B. Computer-controlled systems: theory and design.
[S.l.]: Prentice Hall, 1997.

TANENBAUM, A. S. Sistemas Operacionais Modernos. [S.l.]: Prentice Hall, 2003.

TISCHLER, M. B. Advances In Aircraft Flight Control. [S.l.]: Taylor&amp;amp;Francis, 1996.

WALSH, G.; WALSH, G.; YE, H.; BUSHNELL, L. Stability analysis of networked
control systems. Control Systems Technology, IEEE Transactions on, v. 10, n. 3, p.
438–446, 2002. ISSN 1063-6536.



Referências 108

WITTENMARK, B.; NILSSON, J.; TORNGREN, M. Timing problems in real-time
control systems. In: American Control Conference, 1995. Proceedings of the. [S.l.: s.n.],
1995. v. 3, p. 2000–2004 vol.3.

WOLOVICH, W. A. Automatic control systems. Basic analysis and design. [S.l.]:
Harcourt Brace College Publishers, 1994.

WONG, W.; BROCKETT, R. Systems with finite comunnication bandwidth constraints
ii: Stabilization with limited information feedback. IEEE Trans. Autom. Control, Vol 44,
p. pp. 1049–1053, 1999.

YAMAMOTO, Y.; KHARGONEKAR, P. Frequency response of sampled-data systems.
Automatic Control, IEEE Transactions on, v. 41, n. 2, p. 166–176, 1996. ISSN 0018-9286.



109

Apêndice A -- Parâmetros do VSOR

Os valores das variáveis citadas no Capítulo 5 do VSOR são apresentados na Tabela A.1.

GL i mi dLi dQi bi
Surge (1) 841.93Kg 82.3Kg/s 309.07Kg/m ?0.05N
Sway (2) 841.93Kg 8.5Kg/s 505.45Kg/m ?0.14N
Heave (3) 839.37Kg 50.4Kg/s 759.73Kg/m ?0.85N
Roll (4) 70.51Kg.m2/rad 0Kg.m2/(rad.s) 174.82Kg.m2 0.16N.m
Pitch (5) 70.51Kg.m2/rad 0Kg.m2/(rad.s) 174.82Kg.m2 0.16N.m
Yaw (6) 206.74Kg.m2/rad 18.21Kg.m2/(rad.s) 94.72Kg.m2 ?2.53N.m

Tabela A.1: Dados do VSOR referentes aos GLs (AVILA, 2008).

Para o cálculo das forças restaurativas , adotou-se:

•gravidade g = 10m/s2,

•densidade do meio (água) ? = 1000Kg/m3,

•volume deslocado ? = 0.19265m3 (AVILA, 2008),

•altura do centro de flutuação zB = 0.09m (AVILA, 2008),

•massa do veículo m = 188.6Kg (AVILA, 2008).

Portanto, a força de flutuação é dada por

B = mg ? ?g? = 40.5N.

Para a alocação de empuxo, adotou-se:

•a = 0.40m,



Apêndice A -- Parâmetros do VSOR 110

•b = 0.50m,

•c = 0.15m,

•d = 0.65m,

•e = 0.45m,

•? = ?/4.


</field>
	</doc>
</add>