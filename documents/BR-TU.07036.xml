<?xml version="1.0" encoding="utf-8"?>
<add>
	<doc>
		<field name="docid">BR-TU.07036</field>
		<field name="filename">11669_206538.pdf</field>
		<field name="filetype">PDF</field>
		<field name="text">DANILO DE PAULA E SILVA
Modelagem, Análise e Controle Supervisório de Sistemas Híbridos em uma Planta Piloto
Florianópolis
2004
Universidade Federal de Santa Catarina
Programa de Pós-GradüaçAü em Engenharia Elétrica
Modelagem, Análise e Controle Supervisório de Sistemas Híbridos em uma Planta Piloto
Tese submetida à
Universidade Federal de Santa Catarina como requisito para a
obtenção do grau de Mestre em Engenharia Elétrica
Danilo de Paula e Silva
Florianépolis, maio de 2004.
Modelagem, Análise e Controle Supervisório de Sistemas Híbridos em uma Planta Piloto Danilo de Paula e Silva
Esta Tese foi julgada adequada para obtenção do Título de Mestre em Engenharia Elétrica, Area de Concentraçao em Controle, Automação e Informática Industrial, e aprovada em sua forma final pelo Programa de Pés-Graduaçao em Engenharia Elétrica da Universidade Federal de Santa Catarina.
Prof. José Eduardo Ribeiro Cury, Dr. orientador
Jefferson Luiz Brum Marques, Dr
Coordenador do curso de Pós-Graduaçao em Engenharia Elétrica da Universidade Federal de Santa Catarina.
Banca Examinadora
Prof. Josée Eduardo Ribeiro Cury, Dr. orientador
Prof. Daniel Juan Pagano, Dr.
Prof. Rafael Santos Mendes. Dr.
Dedico este trabalho aos meus pais, a minha irmã que com seus suporte e confiança muito contribuiram proporcionando-me concluir o maior feito de minha vida até o presente momento. E ao José Vítor, meu filho, que me impulsionou a empenhar de forma decisiva a realizaçao do mesmo.
Agradecimentos
Agradeço a meus orientadores José E. Ribeiro Cury e Daniel Juan Pagano, pela oportunidade de trabalho, além de seus ensinamentos e incentivos ao longo do mestrado.
Ao amigo Carlos Damião, que teve participação decisiva na minha formação.
Aos colegas Antônio Eduardo Cunha, Marcos Vallin, Agustinho Plucênio, André Leal, Gustavo Bouzon, Ricardo Santos que contribuéram de forma direta.
A todas as amizades que fiz na sala do Programa de Recursos Humanos no 34 - Agência Nacional de Petréleo e durante o mestrado.
A todos que contribuéram indiretamente para o desenvolvimento desta dissertação.
Resumo da dissertação apresentada à UFSC como parte dos requisitos necessários para obtenção do grau de Mestre em Engenharia Elétrica.
Modelagem, Verificação e Controle Supervisório de Sistemas Híbridos em uma Planta Piloto
Danilo de Paula e Silva
Março/2004
Orientador : José Eduardo Ribeiro Cury
Area de Concentração : Automaçao e Sistemas
Palavras-chave : Sistemas Híbridos, Sistemas Condicão Evento, Controle Supervisério, Planta Piloto
Numero de Paginas : 113
Recentemente o DAS teve aprovado o projeto CTPETRO ’’Sistemas de Controle Baseados em Redes Industriais Tipo Fieldbus para o Setor de Petréleo e Gás”, que visa o desenvolvimento de soluções para problemas que afetam o setor de Petréleo e Gés. No contexto deste projeto, foi adquirida uma planta piloto cujo processo consiste de vaérias malhas de controle de fluxo, nével e temperatura, implementadas mediante sensores e atuado-res digitais industriais, que se comunicam entre si e com uma estaçcãao de supervisao e controle via rede fieldbus. O presente documento trata da re-soluçcãao de um problema proposto na planta piloto atravées da abordagem de sistemas hébridos e controle superviséorio de sistemas hébridos. A primeira parte deste documento relata uma revisãao bibliogréafica de conceitos sobre sistemas hébridos, verificacçãao de sistemas hébridos e controle superviséorio de sistemas hébridos. A segunda parte do documento propoãe a resolucçãao de um problema proposto na planta piloto. Para a resoluçcaão deste problema, ée feito um modelo que representa todos os comportamentos posséveis da planta piloto através de um autômato hébrido. Para este modelo é aplicado a teoria de controle superviséorio com o intuito de resolver o problema proposto. Resolvido o problema teoricamente, ée feito na planta piloto a im-plementaçcãao de um supervisor atravées de um algoritmo constituido de um jogador de autôomatos e de uma interface homem-méaquina para supervisãao em tempo real. Os resultados computacionais sãao derivados das ferramentas Chekcmate e Grail e os resultados práticos derivados do software Matlab.
Sumário
1	Introdução	1
1.1	Objetivos do Trabalho................................................. 3
1.2	Organização do Documento ............................................. 4
2	Sistemas	Híbridos	5
2.1	Breve histórico ...................................................... 6
2.2	Abordagens para Sistemas	Híbridos..................................... 7
2.2.1	Perspectiva da Teoria de Controle.............................. 7
2.2.2	Perspectiva de Ciência da Computaçao.......................... 10
2.3	Aplicações de Sistemas Híbridos...................................... 10
2.4	Discussão ........................................................... 11
3	Sistemas	Híbridos: Modelagens e Verificação	12
3.1	Autêomato Híbrido ................................................... 12
3.1.1	Automato Híbrido Invariante-Poliedral......................... 14
3.2	Sistema Híbrido de eventos de limiar	............................ 14
3.3	Bissimulaçao e Sistema de Transicão	Quociente ....................... 16
3.4	Verificaçao de Sistemas Híbridos..................................... 18
3.4.1	Arvore de computação logica................................... 19
3.4.2	Verificação utilizando bissimulacão .......................... 19
3.4.3	Verificação utilizando sistemas de transição quociente........ 20
3.5	CheckMate ........................................................... 21
3.5.1	Principais Blocos do CheckMate ............................... 22
3.5.1.1	Switched Continuous System	(SCS)..................... 22
3.5.1.2	Polyhedral Threshold (PTHB).......................... 23
3.5.1.3	Bloco Maquina de Estados Finito (FSM)................ 24
3.5.2	Aproximações Flow Pipe........................................ 24
3.5.3	Verificação ACTL.............................................. 26
3.5.4	Refinamento da Partiçao....................................... 26
3.6	Discussão ........................................................... 27
4	Controle Supervisório de Sistemas Híbridos	29
4.1	Sistema Condição Evento........................................... 29
4.2	Formulaçao do Problema............................................ 29
4.2.1	Supervisão da planta Híbrida................................ 33
4.2.2	Comportamento Lógico........................................ 35
4.3	Abordagem por Controle de Sistemas	a Eventos Discretos............ 37
4.4	Exemplo........................................................... 42
4.5	Discussãao ....................................................... 44
5	Planta Piloto: Aspectos descritivos e modelagem matemótica	45
5.1	Descriçcãao da Planta Piloto ..................................... 45
5.1.1	Componentes da planta ...................................... 45
5.1.2	Diagrama de Processo ....................................... 47
5.1.3	Softwares Utilizados ....................................... 49
5.1.4	Características híbridas da planta piloto................... 51
5.2	Problema proposto ................................................ 51
5.3	Modelagem matemótica tanque de aquecimento........................ 53
5.3.1	Validação e calculo dos parâmetros.......................... 57
5.3.2	Linearizacão das equacães................................... 58
5.3.3	Calculo das Funçães de Transferencia........................ 60
5.3.4	Modelagem das equaçães no espaço de estados contínuo........ 62
5.4	Discussaão	.......................................... 63
6	Resolucao do problema proposto atravós da síntese de um supervisor
discreto	65
6.1	Modelagem do	autâomato híbrido ................................... 65
6.2	Cíalculo do	autâomato aproximaçcaão .............................. 70
6.2.1	Simulaçao do Modelo Planta híbrida em malha aberta ......... 72
6.2.2	Verificaçao de propriedades do modelo autâmato híbrido ....	72
6.2.3	Obtenção do Modelo Discreto................................. 74
6.3	Projeto do supervisor discreto.................................... 75
6.4	Discussão ........................................................ 78
7	Implementacão de um supervisor C/E na planta piloto	79
7.1	Arquitetura de rede da planta piloto ............................. 79
7.2	OPC - Open Process Control ....................................... 81
7.3	Implementaçao do algoritmo de supervisão discreta por um servidor
OPC conectado ao MATLAB .......................................... 82
7.4	Resultados da implementação do algoritmo.......................... 86
7.5	Discussão ........................................................ 88
8	Conclusão e Perspectivas	89
8.1	Conclusões e Contribuições......................................... 89
8.2	Perspectivas....................................................... 89
A Projeto de Controladores utilizando a Teoria de Controle Clássica 91
A.1	Introducao......................................................... 91
A.2	Projeto do controlador............................................. 91
A.2.1 Especificações de Controle................................... 92
A.2.2 Calculo dos pólos do Sistema com controlador em malha fechada 92
A.2.3 Grófico do lugar das raízes.................................. 94
A.3	Discussao ......................................................... 98
B Algoritmo de implementacao no MATLAB	99
Lista de Figuras
2.1	Estrutura de controle para sistemas chaveamos......................... 8
2.2	Estrutura genérica para o controle supervisório....................... 9
2.3	Estrutura genérica para o controle supervisório....................... 9
3.1	termostato........................................................... 14
3.2	Diagrama de blocos ilustrando um Sistema híbrido de eventos de limiar 15
3.3	Abordagens de verificação............................................ 21
3.4	Procedimento de verificação do CheckMate ............................ 22
3.5	Bloco SCS............................................................ 23
3.6	Bloco PTHB........................................................... 23
3.7	Bloco FSM ........................................................... 24
3.8	Método aproximaçães flow pipe para a dinamica	clock ................. 25
3.9	Método aproximaçães flow pipe para as dinâmicas	linear e não linear .	25
4.1	Planta híbrida H..................................................... 29
4.2	Representação dos sinais condição evento............................. 30
4.3	Subsistema contínuo Hc .............................................. 30
4.4	Esquema de controle supervisório para a planta híbrida............... 33
4.5	Autâmato para a ilustraçao de r ..................................... 38
4.6	Autâmato que reconhece a linguagem Lm =	........ 42
4.7	Especificacao E C PV (Lm)............................................ 43
4.8	Especificaçao K C Lm ................................................ 43
4.9	Móxima linguagem vu-controlóvel SupCV u(K)	.................... 43
5.1	Foto ilustrando a planta piloto...................................... 47
5.2	Diagrama de processo da planta piloto................................ 48
5.3	Ilustração do software Syscon........................................ 49
5.4	Ilustração do software Conf700 ...................................... 50
5.5	Ilustração do software Process View.................................. 51
5.6	Tanque de aquecimento de agua........................................ 53
5.7	Comportamento da temperatura em funçao do tempo...................... 56
5.8	Diagrama de blocos de um sistemas processo-compensador no espaço de
estados contónuo. .................................................. 63
6.1	Modelo Autômato híbrido para o sistema híbrido tanque de aquecimento. 69
6.2	Modelo Checkmate do Sistema híbrido em malha aberta.................. 71
6.3	Máquina de estados finita representando a dinamica discreta do
autôomato híbrido ................................................... 72
6.4	Gráficos que representam um comportamento possível do autômato híbrido 73
6.5	Modelo discreto correspondente ao autômato híbrido................... 74
6.6	Especificaçao Esp C PV(Lm)........................................... 76
6.7	Especificacão K C Lm ................................................ 76
6.8	Maxima linguagem vu-controlavel SupCV u(K)	..................... 76
6.9	Míquina de estados finita representando a planta híbrida sob ação de
um supervisor ....................................................... 77
6.10	Gráficos que representam o comportamento do automato híbrido sob
açcaão do supervisor ................................................ 77
7.1	Topologia de rede da planta piloto................................... 80
7.2	OPC na planta piloto................................................. 81
7.3	Exemplo de uma lista de instruçães de	um	autômato C/E............... 83
7.4	Fluxograma do algoritmo jogador de autômatos conectado à planta . .	85
7.5	Gráficos representando o comportamento do nível e temperatura da ígua
no tanque ........................................................... 86
7.6	Gráficos com os eventos e condicães do supervisor discreto........... 87
A.1 Diagrama de Blocos do sistema nível-controlador ...................... 92
A.2	Grafico do lugar das raízes.......................................... 96
A.3	Resposta	do	sistema com controlador................................ 97
A.4	Resposta	do	sistema com k'c = 3,0.................................. 97
A.5	Resposta	do	nível na planta piloto ................................ 98
Lista de Tabelas
3.1	Operadores básicos da CTL......................................... 19
3.2	Tipos de dinamicas contánuas...................................... 23
5.1	Legenda do diagrama da fig.5.2.................................... 48
5.2	Problema proposto................................................. 52
5.3	Tabela para o calculo de Aoko..................................... 58
6.1	Valores de k e t para cada ponto	de operaçao...................... 67
6.2	Valores de k' e t' para cada ponto	de operacão.................... 67
Capítulo 1
Introdução
No ano de 2002 o DAS-Depto de Automação e Sistemas da Universidade Federal de Santa Catarina teve aprovado o projeto CTPETRO (Sistemas de Controle baseados em Redes Industriais Tipo Fieldbus para o Setor de Petróleo e Gás), o qual visa o desenvolvimento de soluções para problemas que afetam o setor de Petróleo e Gás. No contexto deste projeto, foi adquirida uma planta piloto composta por várias malhas de controle de fluxo, nível e temperatura, implementadas mediante sensores e atuadores digitais industriais, que se comunicam entre si e com uma estaçõo de supervisõo e controle via rede fieldbus.
O processo em questõao tem aplicacçõao direta no setor de petráoleo e gáas, incluindo-se, com especial ênfase, a automaçõo das refinarias de petróleo, plataformas de extraçõo off-shore, supervisõo e controle de oleodutos, etc. Dentro deste projeto pretende-se contemplar o estudo de sistemas contánuos controlados por sistemas de supervisõao discreta, o que caracteriza um sistema de dinamica híbrida. Para isto pretende-se considerar a planta piloto em questaõo, que possui dinêamicas contánuas representadas pelas variaveis fluxo, vazao e nível e dinêmicas discretas (sinais discretos gerados por um alarme indicando temperatura alta, por exemplo) atuando em certas condiçcõoes que as variáaveis contánuas porventura podem alcançcar, caracterizando a planta piloto como uma planta hábrida.
Tendo em vista a natureza hábrida da planta, pretende-se modelar o mesmo atraváes do formalismo de autêmatos híbridos (Alur 1993) e utilizar a ferramenta computacional CheckMate (Silva e Chutinan 2000) para implementar o modelo e analisar propriedades do mesmo atravás de especificações ACTL. Tal formalismo á um dos varios modelos que representam sistemas híbridos.
Apoás a modelagem da planta, deseja-se projetar um supervisor discreto que resolva um problema proposto. Este supervisor seráa projetado segundo a abordagem de con
trole supervisório de sistemas híbridos (Cury e Niinomi 1998). Por fim, pretende-se implementar este supervisor discreto na planta piloto atravós de uma algoritmo feito no Matlab conectado a um servidor OPC da planta piloto. OPC ó uma tecnologia capaz de unificar fonte de dados com aplicações cliente, ou seja, ó uma interface de comunicacão homem-maquina x.
Sistemas híbridos (Antsaklis 2000a), (Antsaklis 2000b) em geral, são sistemas que possuem tanto dinâmicas contínuas quanto dinamicas discretas. Tais sistemas tem sido utilizados em diversas aplicaçães: na aviacão, atravós de controle de trófego aóreo e dos sistemas de controle de aeronaves, tais como o sistema de prevencçãao de colisãoes de aeronaves; em aplicaçães automotivas, como por exemplo os sistemas de controle de tráfego em rodovias e os sistemas de controle em sistemas de manufatura; na robótica; na eletrâonica de potâencia; no controle de processos quómicos e nucleares em geral; entre muitas outras.
Varios modelos de sistemas hóbridos tem sido propostos. Neste documento iremos considerar trâs modelos, denominados de autômato hébrido (Alur 1993), sistema hébrido de eventos de limiar e sistemas condicão evento. O primeiro ó uma generalização do autâmato discreto finito (Hopcroft e Ullman 1979) que inclui dinâmicas continuas em cada estado discreto denominado de locaçcãao, do autâomato. Transiçcãoes entre as locaçcãoes saão determinadas por condiçcãoes chamada de guardas, nos estados contónuos. O autâomato hóbrido seróa utilizado para a modelagem de um modelo hóbrido para a planta piloto.
O sistema hóbrido de eventos de limiar (Chutinan 1999) consiste em trâs subsistemas: sistema contónuo chaveado, com entradas discretas constantes que selecionam as dinâamicas contónuas com saódas contónuas; gerador de eventos de limiar que recebe as saódas contónuas do sistema contónuo chaveado e gera eventos quando estas atravessam certos limiares e móaquina de estados finito que óe o sistema de transicçãao puramente discreto com um nuómero finito de estados. Os sistemas hóbridos de eventos de limiar são atrativos para o documento em questão. Isso se deve ao fato de que a ferramenta CheckMate utiliza esta modelagem para o procedimento de verificação (Silva e Chutinan 2000).
Sistemas condição evento (C/E) (Gonzóles e Krogh 2001) fornecem uma forma de se definir sistemas em tempo contónuo atravóes da interconexaão de subsistemas com sinais de entrada e saóda discretos. Sendo assim, os sistemas serãao apresentados atravóes de diagramas de blocos e fluxo de sinais discretos. Vale ressaltar que embora esteja sendo usado aqui para modelagem de sistemas hóbridos, o formalismo de sistemas C/E
1	P uma tecnologia de linguagem de alto nível capaz de monitorar com facilidade equipamentos conectados a uma rede de dados. Exemplo: softwares supervisorios (Process View, In Touch, etc), Painel View, entre outros
pode ser utilizado tambóm para a modelagem de Sistemas a Eventos Discretos (SED) (Leal 2002). Atravós do sistema C/E iremos obter a solucõo de um problema proposto na planta piloto atravóes do formalismo de controle supervisoório de sistemas hóbridos (Gonzóles 2000).
1.1	Objetivos do Trabalho
A principal motivacõo para a anólise e modelagem da planta híbrida ó solucionar problemas próaticos sob o aspecto de controle supervisóorio de sistemas hóbridos (Gonzóles 2000). Em particular o tema em questõo ainda estó pouco difundido entre os pesquisadores brasileiros. Com isso, os principais resultados obtidos estõo sob enfoque teórico, estendendo metodologias e abordagens de pesquisadores pioneiros na area de controle supervisóorio de sistemas hóbridos.
Os principais objetivos deste trabalho sõo:
•	Fazer uma revisao bibliográfica de sistemas hóbridos e de controle supervisório de sistemas hóbridos
•	Estudar o processo correspondente a uma planta piloto em escala de laboratório, com muóltiplas malhas de controle de temperatura, nóvel e vazõao e propor uma modelagem matemótica da planta utilizando o formalismo de autômatos hóbridos. Isso permite a visualizaçcõao de quais sõao os possóveis comportamentos que a planta piloto pode realizar;
•	Implementar o modelo da planta piloto na ferramenta CheckMate. O CheckMate pode gerar um autôomato de estados finitos que represente o comportamento lóogico aproximado do sistema hóbrido (Silva e Krogh 2000). Esta construçõo ó um ponto crítico do trabalho, pelo fato de que pode ser extremamente difícil ou até mesmo impossóvel obter o autôomato de estados finitos devido a problemas de verificacçõao. Tais problemas serõo tratados no capótulo 3.
•	Construir especificacçõoes para o comportamento desejado do sistema sob super-visaõo e projetar um supervisor sob o enfoque de controle Supervisóorio de Sistemas Hóbridos.
•	Implementar o supervisor na planta piloto atravóes de um algoritmo que se comporta como um jogador de autômatos conectado às variaveis da planta atravós de uma conexao servidor-cliente OPC. Analisar os resultados e verificar a validacõo dos formalismos sistemas hóbridos e controle supervisoório de sistemas hóbridos no experimento próatico.
1.2	Organização do Documento
Este documento está organizado como segue:
O capátulo 2 apresenta uma introdução aos sistemas hábridos. Faz um breve histárico e apresenta algumas abordagens existentes nas perspectivas das comunidades de controle e de ciência da computacao.
O capátulo 3 faz uma discussão sobre dois modelos de sistemas hábridos: o automato hábrido e o sistema hábrido de eventos de limiar. Faz-se uma breve introducçaão sobre verificação e por fim apresentamos alguns aspectos importantes da ferramenta CheckMate.
O capátulo 4 trata do controle supervisário de sistemas hábridos. Nele á feito a for-mulacçãao de um problema de controle supervisáorio de sistemas hábridos apresentando uma classe de sistemas hábridos (sistemas C/E) que sera utilizada ao longo deste documento.
O capátulo 5 trata da descricão e utilização da planta piloto. Descreve suas principais características, os softwares utilizados e sua conexao com a interface Matlab. Propãe um problema para ser resolvido na planta piloto. Trata a modelagem ma-temáatica da planta piloto, descrevendo as equaçcãoes utilizadas, validaçcãao dos parêametros destas equacçãoes, linearizacçãao em certos pontos de operaçcãao, caálculo das funçcãoes de transferêencia e a representacçãao destas equacçãoes no espaçco de estados.
O capátulo 6 trata da sántese de um supervisor discreto para resolver um problema proposto. Para tanto, utiliza-se a abordagem de autômatos hábridos e constrói o modelo da planta no CheckMate, o qual á o programa utilizado para obter um automato discreto que á uma aproximaçao externa do comportamento lágico do sistema hábrido. Apás a obtençao do modelo discreto do sistema hábrido, apresenta-se algumas especificacães discretas de controle, segundo o problema proposto e calcula-se o supervisor utilizando o formalismo de controle supervisário de sistemas hábridos descrito no capátulo 4.
O capátulo 7 trata da implementaçao do supervisor calculado no capátulo 6 na planta piloto. Será implementado um algoritmo capaz de interpretar o autêmato discreto da planta livre sob açcaão de um supervisor na planta piloto e os softwares utilizados para a implementação. Por fim os resultados desta implementacão
O capátulo 8 é a conclusão do documento e discussao de possáveis trabalhos futuros.
Capítulo 2
Sistemas Híbridos
Este capítulo trata de sistemas híbridos sob um aspecto geral. E de suma importância o entendimento desta abordagem, pois o trabalho que sera relatado neste documento se baseia neste formalismo. Primeiramente define-se dois tipos de sistemas: os sistemas contínuos e os sistemas a eventos discretos.
Um sistema é dito ser contínuo se seus estados variam continuamente com o decorrer do tempo, ou seja, as variaveis do sistema dependem do tempo. De um modo geral, os sistemas contínuos pode ser representados por equacões diferenciais quando o tempo é contínuo. Quando o tempo é amostrado em períodos, tais sistemas podem ser representados por equações a diferenças. Em ambos os casos, a variável tempo (t no caso contínuo e k no caso amostrado) e naturalmente uma variível independente que aparece como argumento das funcões entrada, estado e saída. Exemplo de um sistema contínuo pode ser um veículo em movimento, onde se tem a variacõo da velocidade e distância percorrida por unidade de tempo.
Outros sistemas, de natureza bastante distinta dos sistemas contínuos, sõo os chamados Sistemas a Eventos Discretos (SED). A princípio iremos apresentar o conceito de evento. Um evento pode ser identificado com uma açcaõo (aperto de uma tecla), uma ocorrâencia espontâanea como um relâampago ou o resultado de víarias condiçcõoes satisfeitas em um dado instante (um equipamento finaliza uma operaçõo). Um sistema a eventos discretos (SED) íe um sistema a estado discreto dirigido por eventos, ou seja, sua evolucçõao de estado depende integralmente da ocorrâencia de eventos discretos assíncronos no tempo. Um exemplo de um SED íe o jogo de damas. A movimentaçcõao de uma pecça pode ser descrita como um evento, onde os jogadores efetuam seu lance quando querem, ou seja, de forma assíncrona com o tempo e sem intermediaçcõoes, onde hía uma configuraçcaõo das peçcas antes de um movimento e outra depois de mover a peçca.
Ha sistemas que possuem característica puramente contínua e outros com carac-
terísticas puramente discretas. Contudo, há sistemas que possuem tanto aspectos contínuos, quanto discretos. Tais sistemas eram tratados de acordo com a característica que mais se destacava. Em certos casos, nao é razoável fazer tal consideracão. O sistema entao deve ser tratado utilizando os conceitos de sistemas contínuos e de sistemas a eventos discretos.
Tais sistemas são chamados de sistemas híbridos. Genericamente, o termo híbrido se refere à mistura ou junçao de dois tipos de objetos ou metodologias fundamentalmente diferentes, como um carro bicombustível. Este carro pode ser abastecido tanto por aílcool como por gasolina, tendo portanto, uma propriedade híbrida em relaçcãao aos carros convencionais. Os sistemas híbridos aos quais nos referimos neste trabalho sãao sistemas que possuem dinamicas contínuas e dinamicas de eventos discretos, sendo que, alím de coexistirem, tambím interagem entre si. Nao apenas o sistema pode ter uma característica híbrida, mas a especificacão sobre o comportamento desejado para o mesmo tambím pode ser híbrida. Um exemplo de um sistema híbrido pode ser uma panela de pressão. Se a panela for utilizada de forma correta, a pressão irí ficar em uma faixa ideal para cozinhar os alimentos. Contudo, se esta pressãao for aumentado no decorrer do tempo (falha na vílvula de escape por exemplo) vai chegar a um ponto que a panela iría explodir. Tal explosãao nãao depende do tempo e sim do valor míaximo de pressao que a panela pode suportar. A explosão da panela pode ser considerado um evento que ocorreu quando a pressãao atingiu um certo valor.
Na próxima seçao í feito um breve histírico sobre sistemas híbridos. Na seçao 2.2 sãao apresentadas as principais abordagens existentes para o tratamento de problemas relacionados aos sistemas híbridos sob as perspectivas das comunidades de controle e ciências da computacão. Na seção 2.3 sao citados alguns exemplos de aplicação de sistemas híbridos e por fim íe apresentada a discussãao do capítulo. Este capítulo foi baseado em (Leal 2002), (Antsaklis e Koutsoukos 2002) e (Krogh 2002).
2.1	Breve histórico
Muito embora o estudo de sistemas híbridos tenha se tornado popular apenas recentemente, víarios tipos de sistemas que recaem nesta categoria jía foram estudados anteriormente. Sistemas dinêamicos descontínuos foram objeto de estudo sistemíatico na antiga Uniãao Soviíetica e em outros países do leste Europeu por um longo período, iniciando no final dos anos 40.
O recente interesse e atividades sobre sistemas híbridos tem sido motivado em parte por resultados de pesquisa de desenvolvimento no controle de sistemas a eventos discretos (SED) que ocorreu nos anos 80, no desenvolvimento do controle adaptativo nos
anos 70 e 80 e no interesse renovado na formulaçcãao do controle íotimo em sistemas de dados amostrados e controle digital.
Em paralelo houve um crescente interesse pelos sistemas híbridos entre os cientistas da computaçcãao e estudiosos de líogica. O advento de míaquinas digitais fez com o que os sistemas híbridos se tornassem muito comuns, pois sempre que um equipamento digital interage com mundo contínuo, o comportamento envolve fenâmenos híbridos que precisam ser analisados e compreendidos.
Os primeiros encontros sobre sistemas híbridos ocorreram no início dos anos 90. Organizado por Robert L. Grossas e Anil Erode, o primeiro workshop sobre sistemas híbridos foi realizado junto ao Instituto de Ciâencias Matemíaticas da Universidade de Cornell, nos EUA, em 1991. Em 1992 foi realizado o segundo workshop sobre sistemas híbrido na Universidade Tícnica de Lingy, na Dinamarca. A partir daí o tema despertou grande interesse junto a comunidade científica.
Atualmente hí importantes workshops sobre sistemas híbridos no qual destacamos o Hybrid Systems: Computation and Control (HSCC) onde podemos adquirir informaçcãoes a respeito de publicaçcãoes dos principais trabalhos e perspectivas sobre sistemas híbridos.
2.2	Abordagens para Sistemas Híbridos
Tendo em vista a ampla aírea de abrangâencia dos sistemas híbridos, muitas foram as abordagens e os enfoques dados ao seu estudo nos temas modelagem, aníalise, síntese e simulaçcaão. A seguir, divide-se as diferentes abordagens nas perspectivas das comunidades de controle e ciâencia da computacçaão.
2.2.1	Perspectiva da Teoria de Controle
Na comunidade de controle, abordagens de modelagem, anílise e projeto de controladores para sistemas híbridos estenderam a teoria de sistemas dinâamicos para incluir modos discretos. Em realidade, pode-se estender o controle com estrutura variaível, controle por modos deslizantes, controle por relâes, controle por chaveamento de ganhos e atíe mesmo controle nebuloso como exemplos de sistemas de controle híbrido. A característica comum a todos estes esquemas de controle í sua natureza de chaveamento; com base na evoluçao da planta (sistema de tempo contínuo a ser controlado) e/ou no progresso do tempo, o supervisor chaveia de um regime de controle para o outro (van der Shaft e Schumacher 2000).
A estrutura mais encontrada dentre a classe de sistemas chaveados é mostrada na figura 2.1. O supervisor decide qual dos controladores deve ser usado baseado nos sinais de entrada e saéda da planta.
Figura 2.1: Estrutura de controle para sistemas chaveamos
Pelo fato que este tipo de estrutura tem sido utilizado com sucesso na prítica hí muitas dícadas, vírios pesquisadores voltaram a atenção para a sua modelagem e analise. Desde entao, a comunidade de controle intensificou estudos sobre a extensão de definiçcãoes e condiçcoães para a estabilidade de sistemas contínuos para o contexto de sistemas híbridos (Liberzon e Morse 1999).
Outro importante tema de pesquisa junto a comunidade controle tem sido o controle supervisorio de sistemas híbridos. Inspirados na estrutura utilizada para o controle digital, alguns autores propuseram uma estrutura aníloga para o controle supervisírio de sistemas híbridos, na qual uma planta com características híbridas se comunica com um supervisor discreto atravíes de uma interface formada por conversores A/D e D/A generalizados, conforme ilustrado na figura 2.2.
Nesta estrutura, a planta evolui ao longo do tempo atí que uma variível de seu espaco de estados contínuo cruza determinado patamar, então a interface sinaliza a ocorrôencia de um evento para o supervisor. Este, por sua vez, atualiza seu estado discreto e, de acordo com o estado atual, envia um sinal discreto para a interface, a qual transforma este em um sinal contínuo a ser aplicado na planta, fazendo com o que a planta funcione em funçcãao do evento que o supervisor envia de volta para a planta.
Na metodologia de controle digital, pode-se realizar todo o projeto do controlador no domínio do tempo e entao aproximar ou emular o controlador por um equivalente discreto da planta tomada em conjunto com a interface, para entãao realizar o projeto do controlador no domínio discreto. A analogia feita no contexto de controle supervisorio de sistemas híbridos consiste em, ao invís de obter um modelo discreto, obter um modelo de eventos discretos da planta em conjunto com a interface como mostra a figura
Figura 2.2: Estrutura generica para o controle supervisorio
2.3, utilizando autômatos ou redes de Petri. Assim, na perspectiva do supervisor, o conjunto planta-interface é um sistema a eventos discretos, pois recebe e envia apenas sinais discretos e então o controlador é projetado usando metodológicas de controle supervisorio de SED.
Símbolo
Símbolo
Figura 2.3: Estrutura generica para o controle supervisorio
A estrutura apresentada na figura 2.2 foi proposta no trabalho (Antsaklis e Lemmon 1993) e depois foi considerada em varios trabalhos posteriores por estes autores (Stiver e Lemmon 1995a) ,(Stiver e Lemmon 1995b). Abordagens similares baseadas em aproximações da planta por um SED foram utilizados por (Nerode 1993). Abordagens similares baseadas em aproximacões da planta por um SED foram utilizadas em (Moor e Raish 2001), (Raish 1998) e (Cury e Niinomi 1998).
2.2.2	Perspectiva de Ciência da Computação
No final dos anos 80 (Wonham e Ramadge 1987), com a expansão de técnicas de controle supervisório de SED, cientistas da computação buscaram estender modelos puramente discretos de forma a incluir dinámicas conténuas. Como resultado inicial desta extensão foram propostos os autêmatos diferenciais (Tavernini 1987) e os diagramas de estados híbridos (Maler e Pnueli 1992). A seguir foram propostos os autômatos temporizados (Allur e Dill 1994), em cujos estados discretos foram inseridas dinamicas do tipo relégio (na forma x = 1). Assim, o comportamento conténuo resultante ée crescente com uma taxa constante e o mesmo pode ser reinicializado nos instantes de ocorráncia de eventos discretos. Em um passo posterior, foram introduzidos os automatos híbridos (Alur 1993), os quais não possuem restricão de monotonicidade e permitem equaçães diferenciais do tipo linear e não linear.
A maior parte da pesquisa desenvolvida junto a comunidade de ciáncias da com-putacçãao tem sido direcionada para o contexto de verificacçãao formal utilizando a téecnica chamada de model checking (Alur e Dill 1990), a qual testa exaustivamente todas as trajetoérias do sistema com o intuito de testar algumas propriedades dos sistemas hébridos, quanto a técnica dedutiva de prova de teoremas (Manna e Sipma 1998), que prova a especificaçcãao atravées da induçcãao sobre todas as trajetéorias. Entre os avançcos mais significativos estãao os resultados extensivos sobre divisibilidade em problemas de verificacão para vérias classes de sistemas híbridos (Puri e Varaiya 1994).
Neste trabalho seré utilizada uma abordagem similar ao da fig.2.2. Contudo, o sistema hébrido seraé modelado sob a perspectiva da ciáencia da computaçcãao utilizando o modelo autámato hébrido (Alur 1993) e a supervisao deste sistemas seré feita utilizando a abordagem de (Cury e Niinomi 1998). Tal metodologia consiste no formalismo de sistemas condição evento (Sreenivas e Krogh 1991) que se baseia na definição formal de blocos individuais de tempo conténuo, os quais possuem entradas e saédas que sãao interconectadas de forma a criar modelos de sistemas hébridos atravées de diagrama de blocos.
2.3	Aplicacães de Sistemas Híbridos
Os sistemas hébridos proporcionam um rico contexto para a definição de varios tipos de problema de controle. Enumera-se a seguir, algumas das aplicaçcãoes nas quais sãao utilizadas abordagens de sistemas hébridos.
• aplicaçães automotivas, tais como em sistemas de rodovias e automéveis inteligentes (Silva e Engell 2001)
•	Controle de processos químicos (Lennartson e Pettersson 1996)
•	redes de distribuiçõo de energia (Ferrari-Trecate 2002)
•	sistemas de segurança crítica , tais como processos nucleares, sistemas de controle de tráfego aéreo e sistemas de controle de aeronaves (Livadas 2000)
•	sistemas de manufatura (Pepyne e Cassandras 2000)
•	eletrônica de potência (Miranda e Lima 2001)
•	robética (Egerstedt 2000)
2.4	Discussao
Viu-se que os sistemas hébridos sõo adequados para representar uma grande diversidade de aplicações, envolvendo problemas de anélise e séntese e que portanto, muitos sõao os enfoques e as abordagens propostas para tratar cada um destes problemas. Atualmente, o tema vem despertando grande interesse junto às comunidades de controle e ciôencia da computaçcõao, o que tem levado a um grande fluxo de publicaçcõoes sobre o mesmo. Ressalta-se que o conceito de sistemas hébridos tratado neste capétulo é utilizado ao longo do presente documento pelo fato de que a planta piloto citada no cap. 1 possui propriedades hébridas. As características da planta piloto bem como suas propriedades hébridas serõo detalhadas no cap. 5.
Capítulo 3
Sistemas Híbridos: Modelagens e Verificação
Neste capítulo iremos fazer um breve estudo sobre dois modelos de sistemas híbridos que serão utilizados ao longo deste documento: o autômato híbrido e os sistemas híbridos de eventos de limiar. Na sequencia iremos definir conceitos importantes utilizando a nocão de sistemas de transicão para o procedimento de verificação. Por fim, introduz-se a ferramenta CheckMate e uma breve discussão do capítulo.
3.1	Automato Híbrido
Um autômato híbrido í uma generalização do autômato discreto finito (Hopcroft e Ullman 1979) que possui dinômicas contínuas bem como transicães discretas. Cada estado discreto í denominado locacao. Associado com cada locaçao sao as dinamicas contínuas descritas por equacoes diferenciais e um conjunto invariante contínuo. O autôomato híbrido pode residir em uma determinada locaçcãao tanto tempo quanto o estado contínuo permanecer dentro do seu invariante. As transiçcãoes discretas entre locaçcãoes ocorrem de acordo com as condiçcoães guarda e reset no espacço de estados contínuo. Transiçães discretas podem ocorrer quando a condição guarda í satisfeita e a condição reset deve estar satisfeita pelo estado contínuo depois que a transição discreta ocorreu. As condiçcoães guarda e reset podem ser representadas como um conjunto onde o estado contínuo deve pertencer a este conjunto para satisfazer cada condição. Introduziremos a notaçao seguinte que í usada para definir as dinamicas contínuas para cada locacão do autômato híbrido.
SejaFa,b o conjunto das funcoes que mapeiam cada membro de A nos subconjuntos de B, isto í:
Fa,b ={F : A	2b}
A definicão do autêmato híbrido segue o formalismo de (Chutinan 1999).
Definiçao 3.1 Um autômato híbrido é uma tupla H = (X,X0,F,E,I,G,R) onde:
•	X = XC x XD onde XC C Rn é o estado de espaco contínuo e XD é um conjunto finito de locaçcãoes discretas.
•	Xo C X í o conjunto de estados iniciais.
•	F :	XD	Fxc ,Rn	associa u E XD	a uma funcão	Fu	:	XC	2R	que descreve a
inclusão diferencial1 x E Fu(x).
•	I : XD	2Xc associa u a um conjunto invariante na forma I(u) C XC.
•	E C XD x XD e um conjunto de transições discretas.
•	G : E 2xc associa e = (u, u') E E a um conjunto guarda na forma S C I(u)
•	R : E x XC 2XC designa para cada par (u, u') E E e x E G((u, u')) um conjunto de estados resets S E I(u'), R((u,u'),x) C I(u').
Um exemplo de um autêmato híbrido, adaptado de (Chutinan 1999) e mostrado na fig.3.1 O autêmato híbrido modela um termostato. As locaçães on e off correspondem aos estados on e off respectivamente. O estado contínuo x í a temperatura. O sistema inicia com a temperatura entre 29o C e 30o C. A transição de off para on pode ocorrer em qualquer ponto que satisfacça o guarda. O nãao determinismo ira permanecer enquanto a trajetoria contínua de x estiver satisfazendo o invariante da locação off . No instante que chega no limite do invariante de off, a transiçcãao e1 ocorre obrigatoriamente e o termostato liga (estado on). Quando a temperatura passar de 40o, a transiçao e2 pode ocorrer em qualquer ponto pertencente a este guarda , isso atíe atingir 42o, que íe a fronteira do invariante da locaçcãao on, entaão o termostato volta necessariamente a ficar desligado (estado off) e o processo se repete. O não determinismo existe porque há uma infinidade de pontos em que a condiçcãao guarda íe satisfeita. Por exemplo, e1 pode ocorrer quando x = 29o, mas em outro momento nada impede que e1 ocorra em x=29.5o, pois este ponto tambím pertence ao guarda de e1. No entanto, se a trajetoria x atingir a fronteira do invariante, obrigatoriamente e1 deverí ocorrer (se este não ocorreu antes), pois a temperatura x nao poderí permanecer fora do invariante.
1Sao equações diferenciais definidas por intervalos. Ex: i E [1, 8]. O diferencial de x pode assumir qualquer valor compreendido entre os valores 1 e 8
Figura 3.1: termostato
3.1.1	Autômato Híbrido Invariante-Poliedral
Definição 3.2 Um Autômato Híbrido Invariante-Poliedral (PIHA)2 e um autômato híbrido H = (X, X0, F, E, I, G, R) com as seguintes restrições
•	Para cada u E XD, F associa a para u um vetor de campo determinístico fu :
Xc	Xc .
•	Para cada u E XD, I(u) é um poliedro convexo.
•	Para cada e = (u,u!) E E, o conjunto guarda G(e) é a união das faces de I(u).
•	Para cada e = (u,u') E E e x E G(e), R(e,x) = {x}, o mapa do reset é sempre um mapa identidade.
•	O conjunto de estados iniciais deve ser da forma X0 = Ui(Pi,ui) onde cada Pi Q I(u) e um politopo e ui E U. Aqui, a notacão (P, u) significa o conjunto {(x,u) E X|x E P}
•	I, G, e E deve satisfazer a seguinte condicao.
Ve = (u, u') E E, G(e) Q I(uz).
O PIHA e equivalente a chaveamento de dinâmicas contínuas no qual não ha “jumps” na trajetória de estados contínuos.
3.2	Sistema Híbrido de eventos de limiar
Sistema Híbrido de eventos de limiar (TEDHS)3 consiste de trâs tipos de subsistemas, o sistema contínuo chaveado (SCS), o gerador de eventos de limiar (TEG) e
2	A abreviatura utilizada é do nome em ingles Polyedral-Invariant Hybrid Automata
3As abreviaturas utilizadas sao dos nomes em inglês: threshold event-driven hybrid systems, switched contínuos system threshold event generator e finite state machine respectivamente.
a maquina de estados finito (FSM). Sem perda de generalidade assumimos que há somente um subsistema como mostra a fig.3.2. Subsistemas mUltiplos do mesmo tipo podem ser reduzido a um subsistema simples por representação dos sinais de entrada e saída em vetores. O sinal de entrada u(.) para o SCS é um sinal constante por partes, contínuo à direita e com limites à esquerda , assumindo valores sobre um conjunto finito de condiçães U. Este sinal é gerado pelo estado do FSM, de onde as transiçães entre os estados sao forcadas por sinal evento v(.), um sinal que assume valores nao nulos apenas em instantes isolados do tempo no conjunto {0,1}nv gerado pelo TEG4. A funcao de transicão de estados w da FSM é não determinístico (por causa das incertezas do sistema). O conjunto de eventos que representa as transicoes na FSM possui valores não nulos para v(.), isto é, valores pertencentes ao conjunto de eventos de limiar V = to nfo \nv
Figura 3.2: Diagrama de blocos ilustrando um Sistema híbrido de eventos de limiar
As dinâmicas contínuas do SCS sao definidas por uma trajetória de estados x(.), que evolui em X = e que satisfaz uma equacão de estados da forma X(t) = fu(t)x(t), onde o sinal discreto u(.) seleciona a equação de estados para a dinamica contínua em cada instante. Similar à função de transição w não determinística para a FSM, a equaçcãao de estados íe usada para modelar as dinâamicas contínuas. Os estados iniciais do SCS e da FSM são dados por x(0) G X0 C e u(0-) G U0 C U, respectivamente.
Os eventos de limiar que constituem os valores não nulos de v(.), são gerados a seguir. Cada funcao de saída g¿ define um evento de superfície M¿ = (x|gi(x) = 0} onde i í o numero dos diversos eventos de superfície. A funcão g(.) í aplicado no sinal x(.) produzindo o sinal de saída y(.). O sinal resultante y(.) = g(x(.)) é a entrada para o detector de zeros que gera o sinal v(.) de acordo com:
4Significa que o conjunto {0,1} possui nv dimensões, onde nv é o número de eventos ocorridos.
1
0
Vi(t) =
se yi(t) = 0 A (3A &gt; 0)(Vô G (0, A)) : yi(t — ô) &amp;lt;0 de outra forma
Note que o detector de zeros e direcional: um evento e gerado somente quando uma componente de y(t) se aproxima de zero por um dos lados. Note tambem que um evento distinto e gerado quando mais de um limiar e atingido em um instante particular. Isto reflete o fato que quando limiares multiplos são alcançados simultaneamente pelas componentes de y(t), a informacao sobre a localização do estado contínuo do sistema é conhecida com maior precisão quando qualquer um dos patamares é alcançado individualmente. Sendo assim, não existe a ocorrência simultânea de eventos de limiar.
O cenario de interesse e quando o sinal discreto u(.) muda de valor em resposta aos eventos de limiar observados em v(.). Então, um par de sinais (u(.),v(.)) e admissível somente se descontinuidades em u(.) ocorrem somente quando v(.) é não nulo. Isto poderia representar uma situaçao, por exemplo, onde o SCS esta operando sob um controle de malha fechada com a FSM sendo o controlador e as transiçães de estados no FSM sao guiados pelos eventos de limiar.
Assegura-se que u(.) e um sinal constante pode ter numero finito de chaveamento em um intervalo de tempo finito qualquer, assumimos que v(.) é não-explosivo (o termo usado em processos literarios de Markov), ou nao nula.
3.3	Bissimulação e Sistema de Transição Quociente
Esta secao introduz algumas definições formais de sistemas de transição, sistemas de transição quociente e bissimulaçao, que sõo a base para o procedimento de verificaçõo que iremos considerar. Mais detalhes estõo em (Chutinan 1999).
Definição 3.3 (Sistema de transição) Um sistema de transição T é uma tripla T = (Q Qo) onde Q e o conjunto de estados, Q x Q e o conjunto de transições e Qo C Q e o conjunto de estados iniciais.
Dado q e qt E Q, a notacõo q qf indica que (q, q') E^. Um caminho do sistema de transicao e uma sequencia de estados de tamanho finito ou tamanho infinito com cada par de estados consecutivos satisfazendo a relaçcaõo de transiçcõao.
Definicao 3.4 (Caminho) Dado um sistema de transição T = (Q, ^,Q0), uma
seqUencia de estados n = q0q1... 6 Q* U 'T é denominado um caminho de T se qi	qi+1 para todo i &gt; 0. O caminho n e denominado um “run” de T se q0 6 Qo.
Dado um conjunto de estados P C Q, os conjuntos de estados que podem alcançar P ou pode ser alcançado por P em um passo são denominados pre-condiqão e pos condição de P respectivamente. Estes conjuntos serâo definidos formalmente a seguir. Definição 3.5 (Conjuntos Pre/pos-condicao) Dado um sistemas de transição T = (Q, ^,Q0) e um conjunto P C Q, a pre-condição de P, denotado por Pre(P), e definido como
Pre(P) ={q 6 Q| 3p 6 P,q p}.
e a pos-condição de P, denotado por Post(P), definido como
Post(P) = {q 6 Q| 3p 6 P,p	q}.
Para a proposta de verificacçãao, introduziremos uma funçcãao etiqueta que designa uma etiqueta para cada estado no sistema de transiçcãao. O sistema de transiçcãao com a funçcaão etiqueta íe denominada de sistema de transicçãao etiquetado.
Definição 3.6 (sistema de transição etiquetado) Um sistema de transição etiquetado e uma tupla T = (Q, Qo, £,L) onde (Q, Qo) e um sistema de transição, £ e um conjunto contãvel de etiquetas e L : Q £ e ã função etiqueta.
Dado dois sistemas de transiçao etiquetados T1 e T2 com o mesmo conjunto de etiquetas, T2 í dito simular T1 se para todo caminho de T1, existir um caminho correspondente em T2. Este conceito de simulaçao sera formalizado a seguir.
Definição 3.7 (Simulacão) Seja T1	=	(Qb ^,Q01,	£,L1)	e	T2	=	(Q2,	-.Q02,	£,L2)
sistemas de transiçcãao etiquetados. Uma relacçãao de simulaçcãao de T1 para T2 e uma relação binaria fi C Q1 x Q2 tal que:
1.	Para todo q1 6 Q1, deve existir q2 6 Q2 tal que (q1, q2) 6 fi;
2.	Se	(q1,q2)	6 fi, e q1 ^1 q1, então existe q'2 tal	que q2	-2 q'2	e (qx, q'2)	6 fi;
3.	Se	(q1,q2)	6 fi, entao q1 6 Q01 q2 6 Q02; e
4.	(Simulacao com etiqueta) Se (q1,q2) Vs entao L1(q1) = L2(q2).
Dizemos que T2 simula Tx por	utiliza-se a notacao Tx — T2, se e uma relaçao
de simulação de Tx por T2. T2 e tambem chamado de uma ^-simulação de Tx.
Definição 3.8 (Bissimulaçao) Seja T1
Qoi, £,L1) e T2	=	(Q2; ^2
, Q02, £,L2) sistemas de transiçao etiquetados. Uma relaçao de bissimulaçao entre
Tx por T2 e 1 Ç Q2 x Qx e uma relaçao de simulaçao de T2 por Tx.
Dizemos que os sistemas de transicão Tx e T2 bissimulam mutuamente por	utiliza-
se a notacao Tx = T2, se é uma relação de bissimulacão entre Tx e T2.
Uma abordagem para encontrar uma bissimulacçãao do sistema de transiçcãao etiquetado e o sistema de transição quociente (QTS). Um sistema de transição quociente e construído atraves de uma partição do espaco de estados sob o sistema de transicão. A partiçcaão deve ser consistente com a funcçãao etiquetada em que nãao ha dois estados no mesmo conjunto na partiçcaão que saão permitidos ter diferentes etiquetas.
Relacçãoes de bissimulaçcaão sãao importantes para a verificaçcãao porque qualquer dois sistemas de transiçcaão que possuem uma relaçcãao de bissimulaçcãao saão equivalentes em termos de alcançcabilidade de estados. A verificaçcãao pode ser executada em qualquer um dos dois sistemas de transiçcãao e o resultado sera idôentico. Isto tem uma implicaçcaão significante para a verificaçcãao de um sistema de transiçcãao de estados infinitos em que se pudermos encontrar uma bissimulaçcãao de estados finita, podemos executar a verificaçcãao na bissimulaçcaão de estados finitos e o procedimento de verificaçcaão esta garantido que termina.
3.4	Verificaçao de Sistemas Híbridos
Sistemas de transicçãao nos proporcionam a base para a formulaçcãao para o problema de verificaçcãao. Nesta seçcãao, faremos uma breve introduçcãao sobre a arvore de com-putacao logica (CTL)5 (Chutinan 1999). Este formalismo é utilizado para expressar as especificaçcãoes de sistemas de transiçcãao, em especial, para o QTS. Tambem nesta seçcãao sera tratada a verificação de sistemas híbridos utilizando bissimulacão e QTS.
5	A abreviatura utilizada é do nome em inglês computation tree logic
z
3.4.1	.Arvore de computação lágica
Aó rvore de computacçõao lóogica óe uma linguagem que óe usada para especificar a evoluçcaõo do sistema em termos de valores verdadeiros atravóes de proposiçcõoes atôomicas ao longo dos caminho da CTL. Uma fórmula CTL consiste de operadores temporais e de quantificadores de caminhos . Operadores temporais especificam a evolucçõao do sistema ao longo de um uónico caminho da óarvore computacional. Hóa quatro operadores temporais bósicos: X, F, G, e U. O operador temporal X (“próximo passo”) assegura que a propriedade ó garantida no próximo estado do caminho. F (“no futuro”) assegura que a propriedade e garantida em algum estado no futuro (incluindo o estado atual). G (“Globalmente”) assegura que a propriedade e garantida globalmente, isto e, em todos os estados ao longo caminho. O operador U envolve duas propriedades. A insercõo f Ug requer que g e garantido em algum estado no futuro (incluindo o estado atual) e que f é garantido em todo estado ao longo do caminho antes da ocorrôncia de g. Quantificadores de caminho A e E se e para todos os caminhos ou para alguns caminhos respectivamente. A tabela 3.1 resume os operadores CTL.
Quantificadores de caminho		Operadores temporais	
A	Para todos os caminhos	F	No futuro
E	Para algum caminho	G	Globalmente
		X	Próximo passo
		U	Ató que
Tabela 3.1: Operadores basicos da CTL
Formalmente, a sintaxe da formula CTL f e dado pela semantica:
Semântica CTL:f — ap, ~ ap, f&amp;amp;f, f |f, AXf, AFf, AGf, AfUf, EXf,
EFf, EGf, EfU	(3.1)
onde ap denota uma proposição atômica e &amp;amp; e | são os operadores lógicos not, and e or respectivamente. Ha uma subclasse de CTL que é a ACTL, a qual e utilizada pela ferramenta CheckMate. Na secão 2.5 discutiremos sobre a ACTL.
3.4.2	Verificação utilizando bissimulacão
O conceito para especificação de transiçães de estados finitos pode ser estendido para transiçães de estados infinito, tal que o traço discreto do sistema de transição seja Th , onde H e um TEDHS ou um automato híbrido. Proposições atomicas podem ser
designadas para cada estado de TH para formar um sistema de transicão etiquetado e uma arvore computacional para TH (com incontavel numero de nís) pode ser obtida por desdobramento de seu grafo de transicoes. Uma especificação CTL pode ser interpretada como antes no caso de sistemas de transiçcãao de estados finitos. O problema aqui í que a computacão feita pela fírmula CTL não terminarí porque o espaco de estado de TH í infinito.
Para retificar este problema, muitos autores consideram o problema encontrando uma bissimulaçao finita de TH. Verificando propriedades da bissimulacao í equivalente verificar as mesmas propriedades do sistema original. Então, se uma bissimulação finita for encontrada, a verificacçãao pode ser executada na bissimulaçcãao, garantindo seu tírmino. A figura 3.3a mostra a abordagem de verificação utilizando bissimulaçao. No entanto, uma bissimulaçcaão de estados finitos existe somente para algumas classes de sistemas híbridos (Chutinan 1999). Sabendo que uma bissimulação de estados finitos pode nao existir para a maioria dos sistemas híbridos, o procedimento de calcular a bissimulacçãao pode naão terminar e o passo de verificaçcãao pode nãao ser executado. Mesmo que uma bissimulação de estados finitos exista, pode levar um longo tempo para o procedimento de calcular a bissimulacçaão convergir para a soluçcãao. Na príoxima secçãao, discutiremos uma alternativa para contornar este problema em certos casos.
3.4.3	Verificacão utilizando sistemas de transicão quociente
Nesta seçcãao, observamos que os sistemas de transiçcaão quociente sãao, em geral, si-mulacçãoes sob o sistema de transicçãao. Poderíamos entaão executar a verificacçãao no sistema de transiçcãao quociente em qualquer interacçãao do procedimento de bissimulaçcãao mais ríapido que esperar pelo procedimento de bissimulaçcãao terminar. Se a propriedade íe verificada, naão precisaríamos refinar o sistema de transiçcãao quociente. Senãao, outra interaçcaão de refinamento pode ser executado e a verificaçcaão pode ser atendida no novo QTS. Continuando este processo, em algumas vezes se í possível concluir ou não que o sistema híbrido satisfaz determinada propriedade antes que a bissimulacçãao fosse encontrada. A figura 3.3b mostra a alternativa de abordagem de verificação usando QTS. A restriçcãao aqui íe que como o QTS sãao aproximaçcoães conservativas sob o sistema de transicçãao, somente propriedades universais podem ser verificadas. No contexto de CTL, uma propriedade universal íe uma propriedade que pode ser especificada como uma foírmula ACTL.
Resumindo, se pudermos verificar que todas a trajetórias no QTS satisfazem alguma propriedade, podemos concluir que todas as trajetórias do sistema híbrido tambím satisfazem as mesmas propriedades, ou seja, encontramos uma bissimulacçãao para o QTS.
Figura 3.3: Abordagens de verificação
Para encontrar uma condição de bissimulação que termina a verificação, talvez seja necessário calcular um refinamento da partição. Na próxima seçao, sera feito uma introdução da ferramenta CheckMate e introduziremos o refinamento da particão que o CheckMate usa.
3.5	CheckMate
O CheckMate é uma ferramenta de verificacão de sistemas híbridos. O CheckMate implementa uma técnica de verificação que é aproximar conservativamente o sistema híbrido original para um modelo discreto puro (Alur 1993). O processo de verificação no CheckMate é mostrado na figura 3.4.
A classe de sistemas híbridos que pode ser modelada no CheckMate é o TEHDS visto na seção 2.2. O procedimento de verificaçao inicia com a conversão do modelo TEHDS feito no ambiente Simulink em um modelo equivalente, que é o PIHA, tratado na seção 2.1. O PIHA resultante é discretizado na forma de um QTS, por uma partição inicial de acordo com as especificaçcoães do usuéario. As transicçãoes feitas entre os estado no QTS sãao calculadas utilizando a téecnica de anéalise de alcancçabilidade conténua Aproximações Flow Pipe (Chutinan e Krogh 1999b). O QTS é entao verificado pelas especificacães ACTL utilizando a técnica padrão Model Checking (Alur e Dill 1990) para um sistema de transicçãao de estados finitos. A verificaçcãao pode falhar devido ao fato do sistema híbrido aproximado pelo QTS ser modelado de uma maneira mais grosseira. A particçaão para o QTS pode ser refinado gerando uma aproximaçcãao mais exigente. Após o refinamento da partição, as aproximacães flow pipe são utilizadas
Figura 3.4: Procedimento de verificação do CheckMate
para redefinir as transiçcãoes no QTS. O processo se repete atíe que o QTS satisfaçca a especificaçcãao ou o usuíario escolha encerrar a verificaçcãao.
Mais detalhes do CheckMate serão discutidos nas subsecoes subsequentes.
3.5.1	Principais Blocos do CheckMate
Modelos do CheckMate sao construídos sob a interface Matlab/Simulink utilizando duas mascara de blocos do simulink, alím dos vírios blocos padrâo do Simulink. A seguir a descriçcãao de cada bloco do Checkmate:
3.5.1.1	Switched Continuous System (SCS)
-	Parôametro: Funcçãao de Mudançcas f
-	Entrada: Sinal Discreto u
-	Saída: Vetor de estados Contínuos x
-	Descricao:Dinamicas contínuas selecionadas pelo sinal de entrada discreto
Figura 3.5: Bloco SCS
As dinômicas conténuas do bloco SCS sõo da forma:
± = fu(x)
(3.2)
O SCS aceita trôs tipos de dinamicas contónuas, que podem ser especificadas por cada valor da entrada discreta u. A tabela 3.2 ilustra os tipos de dinômicas contónuas:
‘clock’	Dinômicas contónuas da forma x = c onde c ó um vetor constante
‘linear’	Dinômicas contónuas da forma x = Ax + b onde A e b sao vetores constantes n x n e n x 1 respectivamente
‘nolinear’	Dinômicas contónuas da forma Xc = f (x)
Tabela 3.2: Tipos de dinômicas conténuas
3.5.1.2	Polyhedral Threshold (PTHB)
Figura 3.6: Bloco PTHB
-	Parômetro: C,d
-	Entrada: Vetor de estados Conténuos x
-	Saída: Sinal Booleano
-	1 se Cx &amp;lt;d , 0 se nao
-	Descrição: As saídas indicam quando x está dentro da região (poliedro Cx &amp;lt;d) ou não.
3.5.1.3	Bloco Máquina de Estados Finito (FSM)
Figura 3.7: Bloco FSM
Dinâmicas discretas são modeladas usando um FSM. O FSM possui as seguintes propriedades:
-	Entradas: podem ser eventos (vetores) ou dados escalares
-	Dados de entrada devem ser funcoes booleanas do PTHB e FSMB produz saídas somente
-	Eventos de entrada devem ser funçães booleanas de saídas do PTHB somente
-	Saídas: Sinal discreto (Inteiro) indicando estado ativo do FSM
Outros blocos do Simulink suportados pelo CheckMate inclui multiplexadores e blocos logicos ( AND, OR, NOT, etc.) para criar combinacães lágicas de PTHB e saídas FSM.
3.5.2	Aproximações Flow Pipe
Para calcular um QTS para um PIHA, á necessario calcular o conjunto de estados alcançaveis sob as dinamicas contínuas para uma locação dada do PIHA, denominado de aproximaçães flow pipe.
Para a dinâmica clock, as equações de todas as locações são da forma x G F onde F e um poliedro constante. Neste caso os conjuntos alcançaveis de qualquer poliedro inicial sõo obtidos pela projeçõo do poliedro inicial em todas as possíveis direções que as trajetórias do poliedro inicial podem alcancar. A fig. 3.8 mostra como funciona as aproximações flow pipe para a dinamica clock.
Figura 3.8: Método aproximações flow pipe para a dinâmica clock
No caso de dinâmicas nõo-lineares e lineares da forma x = Ax + b a tecnica de aproximações flow pipe aproxima os conjuntos alcançaveis por uma sequencia de poliedros convexos. O metodo inicia dividindo os conjuntos alcançaveis em time segments e aproxima cada conjunto alcançcavel de cada segmento por um encapsulamento de um poliedro convexo, denominado de politopo, ilustrado na fig. 3.9.
Figura 3.9: Metodo aproximações flow pipe para as dinâmicas linear e nõo linear
Mais detalhes sobre esta tecnica podem ser encontrados em (Chutinan e Krogh 1999b).
3.5.3	Verificação ACTL
ACTL í uma subclasse do CTL. A sintaxe da fírmula ACTL f í dado pela semaântica:
Semântica CTL:f	ap, ~ ap, f&amp;amp;f, f\f, AXf, AFf, AGf, AfUf	(T3)
Note que somente o quantificador universal A estí presente na fírmula ACTL. Isto í devido ao fato que o CheckMate utiliza aproximações conservativas (QTS) para verificar propriedades do sistema híbrido. Concluímos que o sistema híbrido original satisfaz a especificaçcõao das aproximaçcoões conservativas somente quando uma especificaçcõao universal (uma especificaçao no qual requer que uma certa propriedade í garantida para todos os comportamentos do sistema) íe usada. A seguir alguns exemplos de expressõoes ACTL.
•	AG seguro: o sistema í seguro em todos os caminhos
•	AG (AF reset): o sistema í resetado infinitamente ao longo de todo caminho computacional
Dado uma especificaçcõao CTL e um sistema de transiçcaõo de estados finitos , o problema de verificaçõo, tambem chamado de problema model checking í formalizado como:
Problema Model Checking: encontrar o conjunto de valores onde a fírmula CTL dada íe verdadeira.
3.5.4	Refinamento da Partição
Neste tíopico sería discutido o refinamento da particçõao que íe usado pelo CheckMate (Chutinan e Krogh 2001).
Se a verificaçcõao do QTS falhar devido uma discretizaçcõao grosseira, o usuíario tem a opçcõao de refinar a partiçcaõo, construir o príoximo QTS, e uma nova tentativa de verificacçaõo. Para evitar que haja uma explosõao de estados no refinamento, o CheckMate somente refina os estados que satisfazem os seguintes critíerios:
Estados com mais de um estado sucessor
•	Estados iniciais que não satisfazem a especificação ACTL e todos os seus descendentes
Os critérios foram adotados pelas razoes seguintes. Para o primeiro critério, não é preciso refinar um estado se este somente tem um Unico comportamento, sempre direcionado a um unico caminho, de tal forma que nao há ganho de nova informação. Para o segundo critério, recai no conceito que a especificaçao ACTL é universal. Então, todos os comportamentos dos estados iniciais que satisfazem a especificaçcãao estãao no QTS sao garantidos para satisfazer a especificacao no sistema híbrido. Então, a ve-rificacçaão resultante naão pode ser melhorada por refinamento desses estados iniciais e seus descendentes.
O esquema seguinte de refinamento utilizado pelo CheckMate para cada estado que foi refinado.
•	Calcular os estados fonte, ou seja, o conjunto de estados que possuem transição para o estado corrente.
•	Super aproximar o conjunto alcancével para cada estado fonte que esta contido no mesmo invariante como os politopos do estado corrente atravées de um hiper-retângulo (Isto é feito para reduzir o numero de politopos que podemos processar enquanto mantém conservativamente a aproximacão).
•	Subtrai e interseciona cada hiperretâangulo com o politopo associado a cada estado corrente. Isto separa o politopo para o estado corrente na parte que pode ser alcançcada e a parte que ée definitivamente inalcançcéavel por cada estado fonte.
O esquema de refinamento ée designado para dividir o politopo de cada estado em partes que podem ser alcançcadas por diferentes combinaçcãoes dos estados fontes.
3.6	Discussão
Neste capítulo apresentou-se uma introdução de conceitos importantes sobre o formalismo de sistemas hébridos. Estes conceitos estãao implécitos no procedimento de verificacçãao do CheckMate , outros sãao importantes para uma modelagem proposta na planta piloto através de autâmatos hébridos. Tal modelagem seré discutida no cap. 5. O importante para o leitor ée fixar este formalismo para entãao facilitar o entendimento de como modelar uma planta hébrida e utilizaçcaão do CheckMate .
Discutiu-se, ainda neste capétulo, a ferramenta CheckMate sob um contexto teérico. A utilizacçãao do CheckMate para o presente trabalho ée gerar um autâomato discreto
que represente todos os comportamentos posséveis da planta de acordo com o modelo autoômato hébrido. Tal autôomato hébrido foi modelado conforme sistema hébrido que será proposto no cap. 5.
Vale ressaltar que alguns conceitos como refinamento da partição do QTS foram citados de forma especéfica. Este procedimento é importante para o uso do CheckMate , nãao sendo o foco deste documento detalhar o amplo formalismo dos procedimentos de verificaçcãao de sistemas hébridos.
Capítulo 4
Controle Supervisório de Sistemas
Híbridos
4.1	Sistema Condição Evento
Neste capátulo sera feita a modelagem da planta hábrida sob o formalismo de sistema C/E. O experimento que será feito nos capátulos subsequentes sera baseado nesta abordagem. Sistema C/E pode ser aplicado tanto para modelagem de sistemas hábridos como para modelagem de SED (Leal 2002).
4.2	Formulação do Problema
-&gt;
Considera-se a classe de sistemas hábridos de tempo contánuo, H, composta pela interconexão de um subsistema de dinâmica discreta, Hd e outro de dinamica contánua, Hc, conforme ilustrado na fig.4.1. Os aspectos discretos da planta hábrida sao caracterizados por sinais condiçao e sinais evento (Sreenivas e Krogh 1991).
Figura 4.1: Planta hébrida H
O sinal de entrada para o subsistema conténuo, Hc, é um sinal condicao, u(.), um sinal constante por partes, conténuo a direita e com limites a esquerda (figura 4.2(a)), assumindo valores sobre um conjunto finito de condiçoes U. O espaco de todos os sinais condicao u(.) em [0, x ) é denotado por U. O sinal de saéda do subsistema conténuo é um sinal evento, v(.), um sinal que assume valores nao nulos apenas em instantes isolados do tempo (ver figura 4.2 (b)). O espaço de todos os sinais evento v(.) em [0, x) é denotado por V.
Figura 4.2: Representação dos sinais condição evento
O subsistema conténuo pode ser divido ainda em dois blocos funcionais: um sistema conténuo chaveado e um gerador de eventos de limiar conforme mostrado na figura 4.3.
Figura 4.3: Subsistema contínuo Hc
As dinamicas conténuas da planta hébrida H são definidas por uma trajetéria de estados x(.), que evolui em X = e que satisfaz uma equaçao de estados da forma x(t) = fu(t)x(t), onde fu :	para todo u E U. Assim, a seleçao da dinômica
conténua(representada pela equaçcãao de estados) ée feita a cada instante pelo sinal condição u(t). O valor inicial da trajetória de estados, x(0), pertence ao conjunto de estados iniciais X0 Ç Rn. O conjunto de todas as posséveis trajetórias de estado para um dado sinal de entrada u(.) E U, iniciando em qualquer estado do conjunto X' C X0, é denotado por Xu(.) (X').
A funcão g : X	gera o sinal conténuo de saéda, y E , da trajetória de
estados, ou seja, y(.) = g(x(.)). Cada componente do sinal conténuo de salda, y^ e comparado a um patamar, Ti, definido pelos componentes de um vetor de patamares, T E e o sinal de saéda evento é gerado por um detector de zeros, definido para t &gt; 0 e i = 1,2,m como:
se yi(t) - Ti = 0 A (3A &gt; 0)
(Võ 6 (0, 5)) : yi(t - õ) - Ti &amp;lt;0 de outra forma
Um evento de limiar ocorre nos instantes em que vi = 0. Note que os sinais evento v(.) assumem valores não nulos, isto í, valores pertencentes ao conjunto de eventos de limiar V = {0,1}nv -{0 }nv.
Observe que na equaçao de vi(t) a condicão dada por yi(t- õ) -Ti &amp;lt;0 faz com o que um evento de limiar seja gerado somente quando a superfície limite for alcancada por um dos lados, ou seja, a sinalizacçãao do evento íe unidirecional. Note que a inequaçcaão yi(t - õ) - Ti &amp;lt;0 deve ser satisfeita para um õ &gt; 0, ou seja, para que um evento v seja gerado no instante t íe necessíario que yi - Ti &amp;lt;0 durante algum tempo A antes da superfície yi-Ti ser atingida. Essa restriçao impede que eventos sejam “continuamente” gerados quando yi desliza sobre a superfície por um certo instante de tempo.
O subsistema discreto í um sistema de dinômica puramente discreta que mapeia, de forma nao determinística, sinais evento v(.) 6 V em sinais condiçao u(.) 6 U. Assume-se que pode mudar o sinal condição de entrada para Hc se e somente se um evento de limiar íe observado. O subsistema discreto tem uma característica de possibilitar a adicçaão de informaçcãoes sobre as possibilidades de chaveamento, ou seja, permite modelar restriçães sobre as possíveis entradas a serem aplicadas a Hc. A dinôamica discreta íe expressa por autôomatos de Moore, sendo que as transiçcãoes de estados representam os eventos e as saídas dos estados são as condicães u (Cury e Niinomi 1998).
A seguir da-se continuidade a modelagem da planta híbrida, utilizando-se para tal o formalismo de sistemas sistema C/E introduzido por (Sreenivas e Krogh 1991). Antes, porém, define-se o produto cartesiano síncrono de V e U, denotado por V ® U, como o conjunto de todos os pares (v(.), u(.)) 6 VxU, tal que descontinuidades em u(.) ocorrem apenas em instantes em que v(.) í não nulo. Define-se ainda o conjunto Vm C V com a classe de sinais evento v(t) que tôem a propriedade de possuir um nuímero finito de descontinuidades em t 6 [0, x).
O subsistema contínuo Hc í definido como um subconjunto de V U, sendo que o par (v(.),u(.)) 6 H se e somente se existe uma trajetória de estados x(.) 6 Xu(.)(X0) tal que o sinal evento de saída resultante íe v(.).
Descreve-se o comportamento discreto do sistema C/E Hc pelo seu modelo estado discreto. Para tanto, introduz-se a representarlo de traco discreto para Hc como uma 4 - tupla (W, fi,p, W0), descrita com segue. Considere o sinal condicao w(.), constante
por partes e contínuo à direita , que registra o valor correspondente da trajetória de estados x(.) apenas nos instantes de descontinuidades em (v(.),u(.)) G Hc. O conjunto W í o conjunto de todos os valores que o sinal w(.) pode assumir e W0 í o conjunto dos possíveis valores iniciais para w(.) . A diferenca entre w(.) e x(.) í que somente o segundo registra a trajetória entre as descontinuidades na entrada e saída do sistemas . Assim, W í o mesmo conjunto original de estados X, ou seja, W = e W0 = X0. A funcão de transicao P : w x u W para w(.) possui a forma w(t) = P(w(t-),u(t-)) e íe tal que:
( íu(t-)(t,W(t")) w(t) =
[ u(t-)
se para algum i =1, 2,	gi(^u(t-)(t, u(t ))) — Ti = 0
A(3A &gt; 0)(W G (0, A)) : gi($u(t-)(t —	-	— ! &amp;lt;0
de outra forma
onde $u(t,x(t0)) í a solução da equacão diferencial X = fu(x) para u G U, t &gt; t0 e valor inicial x(t0). Utiliza-se a notação t- para simbolizar o limite pela esquerda ao instante t. Observe que as transiçães de estado (mudanças no valor de w) ocorrem apenas nos instantes em que um hiperplano í alcançada. A funcao de saída evento p : W x W V gera o evento de limiar correspondente no instante de transicão do estado w(.) e í nula em qualquer outro instante. Ela í definida como:
v(t) = p(w(t ),w(t))
(4.1)
De forma semelhante, o subsistema discreto é definido como Ç . O modelo de estado discreto para é dado pela 4 - tupla (Q, ê, p, q0) onde q e conjunto discreto de estados, enumeravel e possivelmente infinito, q0 = q(0-) e o estado inicial e as funçães de transiçao 5 : Q x V 2Q e de saída condicao : Q U são definidas para t G [0, x ) por:
?(í) G â(í(í ),»&gt;(())
u(í) = 0(q(í»
(4.2)
(4.3)
Note que a ocorrência de um evento v(.) a transição do estado q(.) é feita de forma nao determinística e que o sinal de saída do subsistema discreto 'Hd depende apenas deste estado. Portanto, a escolha do sinal condição a ser aplicado ao subsistema contínuo, em resposta ao evento observado, í feita de forma não determinística por 'híd. Desta forma, ao observar um evento v(t), Hd transita para o estado q(t) e um sinal condição u(t) í aplicado de forma instantênea.
4.2.1	Supervisão da planta Híbrida
Considere agora o esquema de controle supervisorio da fig.4.4 para a classe de sistemas híbridos apresentada anteriormente nesta capítulo. Observe que neste modelo foi acrescida uma entrada m ao subsistema discreto e consequentemente, a planta híbrida H. Assim, denotaremos por e H o subsistema discreto em malha fechada e a planta híbrida em malha fechada respectivamente, de forma a diferenciá-los dos seu correspondentes sem acao de controle. O supervisor F observa os sinais condição u(.) e evento v(.) da planta híbrida H, em resposta, aplica uma entrada de controle m(.) ao subsistema discreto de forma a restringir a gama de possíveis condicães u(.) aplicadas ao subsistema contínuo A entrada de controle í um sinal evento m(.) E M tomando valores nao-nulos no conjunto M = 2U e í interpretada como o conjunto das condicães que pode aplicar à Hc. O cenario de interesse e quando m(.) muda de valor somente quando ocorre uma descontinuidade no sinal evento v(.). O supervisor pode gerar um sinal evento m(t) se e somente se ele observar um evento de limiar v(t), o que faz com o que as descontinuidades em m(.) e em v(.) e consequentemente em u(.) sejam síncronas. No momento de ocorrência de um evento v(t) E V uma entrada de controle m(t) C U e aplicada no supervisor e, estando no estado q(t-), o conjunto das possíveis condições de entrada a serem aplicadas a Hc fica restrito a m(t) 0 ^(q(t)) E U : q(t) E õ(q(t~)), v(t)).
Figura 4.4: Esquema de controle supervisírio para a planta híbrida.
O subsistema discreto com entrada de controle í definido como C V O M O U, sendo que a unica diferenca entre o modelo de estado discreto de em relaçao ao modelo para a versãao em malha aberta reside na funçcaão de transicçãao, definida agora na forma: 5 : Q x V x M 2Q para t E [0, x ) como:
5(q(t ),v(t),m(t)) = q(t) E ê(q(t ),v(t)): ^(q(t)) E m(t)	(4.4)
Modelando a restriçao imposta pela entrada de controle m(t) às possíveis condiçães
que o subsistema discreto pode escolher no instante t de ocorrência do evento v(t). A funcão de saída condiçao é a mesma que a do modelo sem entrada de controle, ou seja, u(t) = ^(Ç(t))-
O sistema híbrido sob acao de um supervisor é dado por H Q V 0 M 0U, sendo que o mesmo apresenta uma característica não determinística oriunda do subsistema Hd.
O supervisor F é definido como um subconjunto de V 0 M 0 U sendo que para (v(.), u(.), m(.)), (v'(.), m'(.), u'(.)) E F, tem-se que:
(v(.),u(.)) = (v'(.),u'(.))(Vt E [to,ti) A (v(ti) = v'(ti))) m(ti) = m'(tx (4.5)
Descreve-se o comportamento discreto do supervisor C/E F Q V 0 M 0 U pelo seu modelo discreto dado pela 4-tupla Z,£,rf,z0, onde Z é o conjunto de estados, z0 = z (0-) é o estado inicial, £ : Z x U x V Zéa funcao de transicao de estado e
: Z x Z M e a funçao saéda evento, definidas para t E [0, x ) como:
z (t) =&amp;lt;(z(t-),u(t),v(t))	(4-6)
m(t) = ^(z(t-),z(t-))	(4-7)
Observe que a transição de estado do supervisor ocorre de forma determinística e que í forcada pelo sinal evento v(t). Observe ainda que a função de saída depende do estado alcançcado nesta transiçcãao. Assim, no instante em que o supervisor observa o evento v(t) proveniente da planta híbrida, ele muda seu estado discreto e aplica o sinal m(t) ao sistema híbrido.
Finalmente, o fechamento da malha resulta em um sistema C/E autânomo F/H Q V U e seu modelo de estado discreto í obtido pela conexao cascata e realimentação (Sreenivas e Krogh 1991) dos modelos do supervisor F e do sistema híbrido H.
A seguir, expressaremos o comportamento líogico dos sistemas em termos de linguagens.
4.2.2	Comportamento Lógico
Uma vez que o sistema C/E possui sinais de entrada e saída que assumem valores discretos no tempo, íe possível associar a este um comportamento líogico, o qual íe representado aqui por linguagens de palavras de comprimento finito para sistema C/E (Sreenivas e Krogh 1991).
Seja um sistema C/E G Ç , por exemplo. A linguagem gerada de G, denotada por L(G), é a linguagem definida sobre palavras de comprimento finito obtidas pelo prefixo-fechamento de todas as cadeias formadas pelas sequencias dos valores que os pares de sinais (v(.),u(.)) G	assumem em seus pontos de descontinuidade (sem
registrar os instantes de ocorrôncia de tais descontinuidades). Vale lembrar que os sinais v(.) u(.) assume valores sobre os conjuntos discretos V e U, respectivamente. Portanto, para o sistema G tem-se que L(G) Ç (V x U)*. Na eq. 4.8 apresenta-se uma definicão formal da linguagem L(G).
L(G) = {w = w1 o u2 o ... o un G (V x U)* : 3(v(.),u(.)) gV®U^
t &gt; 0 /\ ti&amp;lt;t2 &amp;lt;...tn &amp;lt;t, (v(ti),u(ti)) = Z /\	(4.8)
(v(tr),u(tr)) = (0,u(t'))Vt/ = ti,t2, ...tn,t' &amp;lt;t}
Conforme visto anteriormente, sinais condiçcaão sãao utilizados somente nos instantes de ocorrôencia de eventos. Desta forma, para possibilitar a representaçcaão da aplicaçcãao de um sinal condiçcãao inicial (antes que tenha ocorrido qualquer evento) associa-se a este um evento fictício denominado evento de inicialização, denotado por rç. Portanto, n é um evento fictício que é associado a escolha não determinística do estado inicial x(0) e que nao está associado a transicães de estado na planta, ou seja, n G V .O conjunto V+ = {n} U V denota a inclusão do evento de inicialização em V. Considerando-se ainda o sistema G, tem-se entao que L(G) Ç (V+ x U)*, ou mais especificamente L(G) Ç ({n} x U)(V x U)*, uma vez que eventos n sao considerados apenas de inicialização da planta. O evento de inicializaçcaão n naão sío tem a funçcaão de inicializaçcãao, mas tambíem íe importante para sistema C/E que possuem víarios estados iniciais. A inserçcãao do evento n faz com o que estes sistemas tenham apenas um estado inicial.
Ao longo deste trabalho saão tratadas duas classes de linguagens, a saber: linguagens em V* e (V+ x U)* . A seguir comenta-se sobre a utilizacao de cada uma destas linguagens.
• As especificaçães sobre os comportamentos desejados para o sistema híbrido sob
supervisão (em malha fechada), são expressas por linguagens E C V*, ou seja, em termos de sequencias de patamares atingidos no espaço de estados contínuo da planta híbrida. Assim, os controles u e U sob os quais os eventos v E V são gerados naão fazem parte da especificacçãao.
• Para descrever os comportamentos líogicos dos sistemas sem entrada de controle (L(Hd)), (L(Hc)) e (L(H)) e tambím para descrever o comportamento lígico do sistema híbrido sob supervisao (L((F/H)) sao utilizadas linguagens em (V x M x U)*. A semantica de um evento a = vu E L(H), por exemplo, í a seguinte: quando uma variavel do espaço de estados contínuo do sistema híbrido H atinge um certo patamar, o subsistema contínuo gera um evento de limiar v E V, em resposta, o subsistema discreto aplica uma condicçaão u E U.
O comportamento lígico do sistema híbrido sob ação do supervisor í dado pela linguagem (L((F/H)) C (V x U)*. No entanto, as especificaçães sobre o comportamentos lígicos desejados para o sistema híbrido em malha fechada sao feitas em termos de eventos, ou seja, por linguagens E C V*. Sendo assim, í necessírio definir a projeção l\ : (V+ x U)* V*, a fim de que se possa relacionar o comportamento real com o desejado para o sistema sob supervisãao.
E
V
para a = nu E ({n} x U) para a = vu E (V x U);
A projecõo definida anteriormente tambím pode ser aplicada para linguagens (V+ x
U)*. Assim, a projecõo de uma linguagem em K C (V+ x U)* í definida como:
Py(K) = {t E V* : (3s E K)Py(s) = t}	(4.9)
Desta forma, a projeçao PV : (V+ x U)* V* apaga os símbolos n e u E U de palavras em (V+ x U)*.
Considere novamente um sistema G C (V+ x U)*. Define-se agora a linguagem marcada de G, denotada por Lm(G), como o conjuntos das cadeias u E (V+ x U)* formadas pelas sequencias dos valores que os pares de sinais (v(.),u(.)) E Vm U assumem em seus pontos de descontinuidades e tais que PV (u) representa uma sequencia de eventos de limiar que corresponde ao completamente de uma tarefa por parte do sistema híbrido .
Por fim apresentar-se o problema de síntese de supervisores para sistema híbrido .
Problema 4.1 (Síntese de Supervisores para Sistemas Híbridos - SSSH) Seja H o
modelo de C/E da planta híbrida com entrada de controle e dada as especificações A,E Q V* para o comportamento da planta em malha fechada, encontrar um supervisor C/E F consistente para H tal que:
A Q Pv[Lm(F/H)] Q E	(4.10)
Onde A e a especificação do comportamento mínimo da planta em malha fechada. Na secão seguinte utiliza-se da teoria de controle supervisério de SED de modo a propor uma solucão formal para o problema supra apresentado.
4.3	Abordagem por Controle de Sistemas a Eventos Discretos
Nesta secão, o problema de síntese de supervisores para sistema híbrido (SSSH) é traduzido para uma abordagem de controle puramente discreta. Mostra-se então como este problema pode ser solucionado atraves de um problema equivalente no domínio de SED. Esta secçãao descreve de forma sucinta algumas definicçãoes e teoremas de controle de SED. Maiores detalhes sobre esta abordagem estão em (Leal 2002), (Cury e Niinomi 1998), (Gonzíles 2000).
Antes de apresentar um modelo de SED para o sistema híbrido í necessario definir dois novos conjuntos. Seja uma linguagem K Q (V+ x U)*.
•	O conjunto ativo de eventos em K apís w E K í dado por VK (w) = {v E V+ : (3u E U)w o vu E K}
•	O conjunto ativo de condicães em K apos w E K para um dado v E VK(w) e definido como UK(w, v) = {u E U : w o vu E K}.
O modelo de sistemas a eventos discretos com estrutura de controle para o sistema híbrido com entrada de controle H e a tripla (L, Lm, r), onde:
L = L(H)
Lm = Lm(H)	(4.11)
isto e, L e Lm sao, respectivamente, as linguagens gerada e marcada pelo sistema
híbrido sem entrada de controle H e a estrutura de controle 7 G 2v+ xUé um mapa tal que para todo u G L tem-se que:
f(u) = {7 G 2v+ xU :: (Vv G VL(u))(3u G UL(u,v)) : vu G 7}	(4-12)
Note que a estrutura de controle depende da palavra gerada pelo sistema. Conforme definida, a estrutura de controle traduz a idéia de que um dado evento v, ativo após uma cadeia u G L, deve sempre haver pelo o menos uma condição u habilitada. Repare que a inibiçao de todas as condicães possíveis para um dado evento significaria que o supervisor não previu uma resposta para a ocorrência de uma dada cadeia, nao havendo contrapartida física para essa situacão.
Seja o automato mostrado na fig.4.5, o qual reconhece a linguagem L C (V x U). Antes de mais nada vamos interpretar a linguagem do autêmato . Para este exemplo, o conjunto V é representado por V = {v1, v2, v3, v4} e o conjunto U = {u1,u2}. Começamos a anólise pelo estado inicial, de onde sai a transiçao v1u1. Este comportamento nos diz que o estado inicial sío possui um uínico evento ativo (vi) e que este evento estó associado a apenas uma condição, no caso a u1. Isto significa que a planta possui restriçães próprias, que fazem com o que apenas um unico evento (v1) associado a uma uónica condiçcaão u1 para o estado inicial. No estado 2 hóa apenas um evento ativo, que é o v2. Porém, ha duas condições associadas a este evento. Ja no estado 3, a regra é a seguinte: hó apenas 2 eventos ativos: v3,v4. O evento v3 esta associado as duas condiçoes pertencentes ao conjunto U. Mas para o evento v4, este esta associado apenas a condiçcãao u1.
Voltando agora para estrutura de controle, para u = v1 u1 G L tem-se r(u) = {{v2u1}, {v2u2 O v3u1, v2u2 O v3^, v2^ O v^}, {v2u2 ◦ v3u1,v2u2 O v^}, {v2u2 O v3u2,v2u2 O v4u1}} = {71,72,73,74}
Figura 4.5: Automato para a ilustraçao de r
Note que 7 = {v3u1, v3u2} G r(u) uma vez que nao contempla o evento v4 G Vl(u).
A proposicçãao apresentada a seguir estabelece a equivalêencia léogica entre o modelo
C/E H e o modelo de eventos discretos H = (L,Lm, r) para a planta hábrida com entrada de controle. Eá uma proposiçcãao adaptada por (Leal 2002) de forma a tratar de linguagens marcadas.
Proposição 4.1 O modelo de eventos discretos H =	(L,Lm, r) e o modelo
condição/evento H Q V ® M U para a planta híbrida com entrada de controle são logicamente equivalentes no sentido que:
1.	(Vw E (V+ x M x U)*), w E L(H) o Pyxu(w) e L;
2.	(Vw E L(H)(Vvmu E V+ x M x U),w o vmu E L(H) o (3y E r(PyxU(w))) : u E m = {u' E U : vu E 7} e
3.	(VV E (V+ x M x U)*), V E L(H) o Pyxu(V) E Lm
O supervisor de eventos discretos F para a planta H = (L,Lm, r) á definido pelo mapa F : L 2y+ xU e á representado por uma máquina de estados F = (P,V+ x U, 0,p0) onde P é o conjunto de estados, p0 o estado inicial e a funcão de transição 0 : V+ x M x U P á tal que para p E P e a E (V+ x U), 0(p, a) á definida se e somente se para u E L tem-se que a E F(u) e u E (V+ x U)* tal que 0(p0,u) = p onde 0 consiste na extensão da funcão de transiçao para palavras em (V+ x U)*.
A linguagem L(F/H) Q L representa o comportamento gerado da planta H = (L, Lm, r) sob acao de um supervisor F, e á definida recursivamente como:
1.	e E L(F/H) e
2.	u o vu E L(F/H) o u E L(F/H) A u o vu E L A vu E F(u)
O comportamento marcado de F/H á dado por Lm(F/H) = L(F/H) n Lm e representa a parte da linguagem marcada da planta que sobrevive sob açcãao de controle.
Segundo (Leal 2002), um supervisor F e consistente para uma planta se para qualquer cadeia u E L(F/H) e para todo evento ativo apos u, ha ao menos uma condicão de entrada habilitada pelo supervisor pertencente a conjunto de condicães admissáveis na planta.
A proposicão seguinte sugere que o problema de sántese de supervisores para sistema hábrido (SSSH) pode ser solucionado atraves da resolução de um problema de controle supervisorio equivalente no dománio de SED.
Problema 4.2 (Problema do Controle Supervisorio Equivalente - PCSE) Seja H = (L, Lm, r) o modelo de SED com entrada de controle para a planta híbrida e dada as especificações A C E C V* para o comportamento da planta em malha fechada, encontrar um supervisor F consistente para H tal que:
A C Pv[Lm(F/H)] C E.	(4.13)
No intuito de apresentar uma solução formal para este problema, apresenta-se a seguir uma série de resultados da teoria de controle supervisorio de SED adaptando-so para o contexto deste trabalho (Leal 2002).
A seguir, apresentaremos algumas definiçães de controlabilidade de linguagens é uma adaptação ao nosso contexto da definiçao introduzida em (Gonzéles 2000)
Definicao 4.1 Sejam as linguagens K C L C (V+ x U)*. K e dita ser vu-controlavel em relacão a L se:
(Vw G K)Vl(w) = VK(w)	(4.14)
Assim, K é vu-controlavel em relacao a L se apos qualquer cadeia w G K, todo evento possível de ocorrer em K também é possível de ocorrer em L.
Seja Ek(w) = {vu G V+ x U : wovu G K} o conjunto ativo de condicoes/eventos em K apos w G K. Seja ainda um modelo SED com estrutura de controle H = (L, Lm, r). A condição apresentada na eq. 4.14 equivale à seguinte condiçao:
(Vw G K)(37 G r(w)) : y n Sl(w) = Ek(w).	(4.15)
Ou seja, uma linguagem K é em relacao a L se para toda cadeia w G K existe pelo o menos um padrâo de controle 37 G r(w) que habilite na planta o mesmo conjunto ativo de condiçcãoes/eventos habilitados em K apéos w.
Da mesma forma que no doménio das linguagens em (V+ x U)*, podemos introduzir o conceito de controlabilidade para linguagens em V*, mais detalhes sobre as definicçãoes nas linguagens em V* estãao em (Leal 2002). Entretanto, uma vez que o controle ée feito atravées dos sinais condicçãao, a controlabilidade de uma linguagem em V* estéa diretamente associada a definiçao de vu — controlabilidade apresentada anteriormente. Logo, a analise sobre a controlabilidade se dá no domínio (V+ x U)*.
Segundo (Leal 2002) ée possével provar que qualquer supervisor consistente ée nãao
bloqueante para H. Segundo a mesma referência é possível provar que as propriedades de vu-controlabilidade e v-controlabilidade sao fechadas para a uniao de conjuntos.
Logo, pode-se enunciar o seguinte lema:
Lema 4.1 O conjunto Cv u(K) e não vazio, fechado para a união de conjuntos e contém um elemento supremo Unico, chamado “maxima linguagem vu-controiavel”, denotado por SupCv u (K) .
Proposição 4.2 Sejam H = (L,Lm, r) e K C (V+ x U)*, K = 0. Se K = K n Lm então existe um supervisor não bloqueante F para H tal que Lm(F/H) =SupCv u(K).
A seguir iremos introduzir alguns lemas e proposições sobre o conjunto E C V*
Seja o conjunto de todas as sublinguagens de E que sõo v-controlaveis em relaçõo L definido como:
Cv(E) = {E' C E : E é v-controlélvel em r a L}	(4.16)
Pode-se enunciar o seguinte lema:
Lema 4.2 O conjunto Cv (E) e nao vazio, fechado para a união de conjuntos e contém um elemento supremo unico, chamado “maxima linguagem v-controlavel”, denotado por SupCv (E) .
Segundo (Leal 2002), e possével provar que os conjuntos SupCV u (K) e SupCV (E) sao Lm-fechada e Pv(Lm)-fechada respectivamente.
Proposição 4.3 Sejam H = (L, Lm, r) e E C V*, E = $.Se E = E n Pv(Lm) então existe um supervisor não bloqueante F para H tal que Pv[Lm(F/H)]=SupCV(E).
Proposição 4.4 Sejam as linguagens Lm C L(V+ x U)* e E C V*. Seja ainda K = P-1(E) n Lm. Se E C Pv(Lm) então tem-se que SupCV(E) = Pv[SupCV u(K)]
Desta forma, a méaxima linguagem contida em E que ée v-controléavel em relacçãao a L, é igual à projeçao em V* da méxima linguagem contida em K que é vu-controlével em relaçcaão a L. Note que se E consiste na especificaçcaão sobre o comportamento léogico do sistema sob supervisão feita em termos sequencias de eventos, então K consiste na projeção de E em (V+ x U)* e é obtida habilitando-se todas as condiçães posséveis de ocorrer na planta para cada cadeia de eventos em E.
Retomando o problema de controle supervisírio equivalente (PCSE) para sistema híbrido , a teoria introduzida anteriormente indica que a solucão de PCSE requer a execução dos seguintes passos:
1.	Dada a especificaçao E C V*, obter a especificacão equivalente K C Lm C (V+ x U)*
2.	Verificar se K í vu-controlível em relaçao a L. Se for, pular para o passo seguinte. Caso contrario, deve-se obter a maxima linguagem vu-controlavel contida em K, denotada por SupCvu(K)
3.	O supervisor F e implementado atraves de um autômato tal que Lm(F/H) =SupCvu(K).
A seguir, ilustra-se esta metodologia atraves de um exemplo:
4.4	Exemplo
Seja um sistema hébrido H cujo comportamento logico Lm = Lm(H) e reconhecida pelo autômato ilustrado na fig.4.6.
Figura 4.6: Autômato que reconhece a linguagem Lm = L^íT0!
Dada a especificacão E Ç PV(Lm) para o comportamento desejado da planta sob supervisao como mostra a fig.4.7. Esta especificação significa que vi e v2 podem ocorrer livremente, mas se ocorrer v3, obrigatoriamente tem que ocorrer v2.
O primeiro passo consiste em obter uma especificaçcãao equivalente que esteja contida na linguagem da planta, ou seja, K Ç Lm Ç (V+ x U)*. Tal especificaçao e
Figura 4.7: Especificação E C PV(Lm)
obtida fazendo-se K = Pv x(E)CiLm e o automato que a reconhece é mostrado na fig.4.8.
Figura 4.8: Especificacao K C Lm
Verifica-se, entretanto, que a linguagem K não é vu-controlavel em relação a L. Note, por exemplo, apos a cadeia u' = n«i ◦ v1u5 o v2u6 o v3u5 G K, a especificacao não prevê a ocorrência da transição v2u6, sendo que as sequencias apés u o v2u6: v3u2 o v4u1 ou v3u2 o v4u3 nao seja vu-controlavel em relacao a K. Obtém-se então a méxima linguagem vu-controlével contida em K, a qual é reconhecida pelo autêmato mostrado na fig.4.9.
Figura 4.9: Maxima linguagem vu-controlável SupCV u(K)
Vale lembrar que Lm(F/H) = SupCV U(K). Assim, o supervisor F pode ser implementado pelo autêomato da fig.4.9.
Pode-se enunciar agora o seguinte teorema (Cury e Niinomi 1998):
Teorema 4.1 O Problema de controle Supervisorio Equivalente para sistema híbrido (PCSE) possui solucão se e somente se SupCV(E) D A.
Sendo assim, um supervisor F para H tal que PV[Lm(F/H)] = SupCV(E) é uma solução otima para o PCSE no sentido de ser o menos restritivo possível.
Corolário 4.1 O problema de Síntese de Supervisores para Sistemas Híbridos (SSSH) possui soluccaão se e somente se o PCSE possui soluccãao.
4.5	Discussao
Neste capítulo, tratou-se do controle supervisíorio de uma classe de sistema híbrido que possui dinôamicas contínuas e discretas interagindo entre si. Neste capítulo foram introduzidos exemplos bastante acadôemicos, de forma a facilitar a introduçcaão dos conceitos.
No príoximo capítulo sería iniciado ao objetivo deste trabalho, que íe a implementaçcãao de um supervisor discreto numa planta piloto com características híbridas. Sería feita uma breve descricçãao da planta piloto e de um problema proposto nesta planta que sería resolvido baseado na teria descrita neste capítulo e nos capítulos anteriores.
Capítulo 5
Planta Piloto: Aspectos descritivos e modelagem matemática
Este capítulo trata da planta piloto citada no cap. 1 e de suas principais características. Ainda, este capítulo trata da formulaçõo de um problema proposto na planta piloto. Os resultados de resoluçõo deste problema se encontram no capítulo 6. Por fim, inicia a resoluçcõao do problema proposto com a modelagem matemíatica da planta piloto.
5.1	Descrição da Planta Piloto
A aquisicõo da planta piloto atravís do projeto CTPETRO tem por objetivo demonstrar de maneira didíatica a operaçcaõo das diversas malhas de controle utilizando os mesmos equipamentos e ferramentas de configuraçcõao desenvolvidos para aplicaçcõao em controle industrial. Esta planta tem como principal característica uma rede fieldbus. Esta rede possui processamento descentralizado, onde cada dispositivo de campo possui seu proíprio processamento. As principais variíaveis da planta possuem dispositivos inteligentes ligados por um barramento Fieldbus.
5.1.1	Componentes da planta
A seguir uma breve descricçõao dos equipamentos da planta piloto.
• Moto-bombas centrífugas. Sõo acionadas por um motor de induçõo e alimentadas por uma fase de 220 V e frequância de 60 Hz. Sõo as responsíveis pela movi-mentaçao do fluido no equipamento. A planta possui duas moto-bombas, uma para cada tanque do processo.
•	LC700 - Controlador Lógico Programável. Este CLP integra a rede fieldbus da planta com a logica discreta do CLP.
•	Chave de Nóvel: ó responsóvel por detectar nóvel baixo no tanque de ógua quente. O lóquido, atingindo o eletrodo terra e o eletrodo de atuaçao, fecha o circuito pela sua própria condutividade, acionando um circuito elétrico que por sua vez comuta o rele de saóda. Este sinal ó enviado para o painel de controle fazendo habilitar a corrente que estóa indo para o conversor estóatico e por conseguinte que as resistências sejam ligadas.
•	Termostato: esta localizado no tanque de agua quente e tem a função de enviar um contato para inibir o conversor estóatico quando a temperatura atingir um limite alto.
•	Tanque reservatóorio: este tanque tem a funçcãao apenas de reservatóorio de óagua. As moto-bombas centrófugas alimentam os demais tanques atravóes da aógua do tanque reservatoório.
•	Tanque de aquecimento de óagua: neste tanque óe que se localizam os resistores, sendo possóvel esquentar a óagua. Este tanque óe conectado no tanque de mistura por um cano localizado no nóvel móaximo de óagua no tanque.
•	Tanque de mistura: este tanque óe onde obtemos os resultados finais de um processo. Este tanque óe alimentado por óagua fria vindo de uma segunda moto-bomba e alimentado por óagua quente atravóes do tanque de aquecimento.
A planta piloto possui seis dispositivos fieldbus distintos, com quantidade variada.
•	LD302 - Eó um medidor de pressãao diferencial, onde óe possóvel converter o sinal de pressão em sinal de vazão e sinal de nóvel. São trôs LD302: um que representa o medidor de nóvel no tanque de aquecimento e os outro dois representam medidores de vazaão de entrada dos tanques de aquecimento e mistura.
•	FY302 - Posicionador de valvula. E alimentado por uma fonte externa de ar comprimido por razoães de segurançca intrónseca. Possui um dispositivo de retro-alimentacçãao de posiçcaão que se utiliza do efeito Hall. Existem dois dispositivos desse tipo na planta.
•	FI302 - Controlador da intensidade de corrente eletrica: Este dispositivo ó res-ponsóavel pelo controle de corrente que o conversor estóatico envia para os resistores.
•	TT302 - Transmissor Indicador de Temperatura: A medição de temperatura se dá através de sensores localizados nos tanques de processo. A planta possui dois dispositivos desse tipo, um localizado no tanque de aquecimento e outro no tanque de mistura.
•	DFI302 - bridge. Faz a comunicação da planta com os níveis superiores da rede fieldbus. No cap.7 este dispositivo é descrito com mais detalhes.
•	FB700: Permite a integração entre o controle da planta (contínuo) e a logica ladder do CLP (discreta).
A figura 5.1 ilustra uma representação esquematica da planta piloto com todos os seus dispositivos e equipamentos.
Figura 5.1: Foto ilustrando a planta piloto
5.1.2	Diagrama de Processo
O líquido que constitui o processo da planta e a agua. O diagrama da planta é ilustrado na fig.5.2 com sua respectiva legenda na tabela 5.1. As linhas com setas indicativas representam o fluxo de agua no processo. As linhas contínuas representam o fluxo principal e as linhas tracejadas são fluxos alternativos.
Figura 5.2: Diagrama de processo da planta piloto
ITEM	TAG	descricAo
1	TQ-01	Reservatório de água
2	TQ-02	Tanque de aquecimento de agua
3	TQ-03	Tanque de mistura de agua
4	TM-01	Termostato
5	-	Suspiro
6	CH-01	Chave de Nível
7	-	Vaivulas manuais tipo esfera
8	BD-01	Bomba d’água
9	BD-02	Bomba dYgua
10	FY-01	Posicionador de válvula
11	FY-02	Posicionador de válvula
12	LD-01	Transmissor de vazão
13	LD-02	Transmissor de vazão
14	LD-03	Transmissor de nível
15	TT-01	Transmissor de temperatura
16	TT-02	Transmissor de temperatura
17	FI-01	Transmissor de corrente
18	-	Resistencias eletricas
19	FL-01	Filtro de água
20	FL-02	Filtro de água
Tabela 5.1: Legenda do diagrama da fig.5.2.
Seguindo o fluxo principal, a água que alimenta o tanque TQ-02 sai do TQ-01 através das bombas BD-01, passa nos filtros, passa no posicionador de válvula FY-01 e chega no TQ-01. Esta água pode ser esquentada pelas resistências elátricas, que por sua vez podem ser controladas pelo transmissor FI-01, quando o nivel for alto. E possível encher o TQ-03 com agua quente vindo do tanque TQ-02. E possivel também misturar agua quente com agua fria no TQ-03 ligando a BD-02 com o TQ-01 cheio e com água quente. O TQ-02 possui um suspiro caso ambos os tanques estejam cheios. A água que sai dos tanques TQ-02 e TQ-03 podem voltar para o TQ-01 ou ir para a rua. No fluxo principal a água vai para rua evitando misturar agua quente do TQ-02 com a água fria do TQ-01. No TQ-03 ha mais três saídas de água para rua que podem ser habilitadas manualmente.
5.1.3	Softwares Utilizados
Tanto para a configuração dos equipamentos fieldbus quanto para o acompanhamento das dinamicas das variáveis da rede fieldbus na planta, é necessária a utilização de softwares de configuraçao e monitoramento. Nesta seçao, serão mostrados os principais programas utilizados na planta.
Syscon
O Syscon é responsavel pela configuração dos dispositivos fieldbus da planta piloto. Podemos escolher os dispositivos que serão utilizados, criar estratégias de controle, configurar os parâmetros de cada dispositivo e depois descarregar os dados do PC para cada dispositivo na planta piloto. A fig.5.3 ilustra uma janela de trabalho do syscon.
Figura 5.3: Ilustração do software Syscon
Conf700
Este software é o responsóvel pela configuracão do CLP LC700. Através dele pode-se controlar toda a parte discreta da planta. Como exemplo de sinal discreto temos o ligamento/desligamento da bomba, o sinal da chave de nével e o sinal do termostato.
Figura 5.4: Ilustracão do software Conf700
Process View
Este ée o software superviséorio do sistema, construédo para ser a interface homem-méaquina. Sua programaçcãao consiste de se fazer uma boa representaçcãao visual do sistema para o seu monitoramento e, em alguns casos, controle. O software utiliza a tecnologia OPC1 para ter acesso às varióveis. Através dele, podemos ter acesso aos mesmos parêmetros configurados no software Syscon e no CONF700, através de servidores OPC que cada software possui.
Soft OPC Client
E um cliente OPC que tem comunicação com o MATLAB. Com isso, podemos monitorar e desenvolver algoritmos de controle com as variáveis da planta através do arquivos de extensao m do MATLAB. Mais detalhes sobre este tápico será tratado no capátulo 7.
1Open Process Control
Figura 5.5: Ilustração do software Process View
5.1.4	Características híbridas da planta piloto
A planta piloto em questão é utilizada neste trabalho devido às suas características híbridas. As principais características híbridas da planta são:
•	Chave de nível: é responsével por um chaveamento da dinamica de temperatura quando o nível atinge 90% do seu valor. E tambím uma limitacão que a planta possui.
•	Tanque cheio e vazio: este dois casos provocam uma mudança na dinâmica do nível de ígua no tanque. Quando o tanque enche, o nível de agua torna-se constante no seu valor maximo. O mesmo acontece com o tanque vazio: nível constante e igual a zero.
•	Modelagem híbrida: forçam-se certos chaveamentos para que determinadas condicoes sejam satisfeitas. Exemplo: subdividir um sistema não-linear em equacçãoes lineares com víarios pontos de operaçcãao.
5.2	Problema proposto
O problema serí focado somente no tanque de aquecimento da planta. Uma justificativa í que se fosse os dois tanques, o no de variíveis de estado iria dobrar. Com isso o problema torna-se intratavel pelo fato de que a ferramenta CheckMate estí limitada ao uso de no míximo cinco variaveis de estado contínuas. Portanto, o tanque de aquecimento de agua serí o sistema híbrido estudado ao longo deste documento.
Fazer com que a agua que escoa para o tanque de mistura atraves da vazão Fs tenha uma temperatura constante e maior que a temperatura ambiente.
Tabela 5.2: Problema proposto
Deseja-se resolver o seguinte problema no tanque de aquecimento:
Onde Fs í a vazao de agua do cano que liga o tanque de aquecimento ao tanque de mistura (o sentido da vazão e do tanque de aquecimento para o tanque de mistura). Uma maneira de resolver o problema proposto anteriormente e executar os seguintes passos:
•	Ligar a bomba 1 e deixar que o nível do tanque de aquecimento atinja a chave do nível, situada a 90% do nível.
•	Quando o nível atingir 90%, as resistências serâo ligadas. Inicia-se entao um controle PI do nível em um valor entre 90% e 100% do maximo. Tambím é feito um controle PI de temperatura para o valor desejado. A justificativa para este controle íe que a constante de tempo da temperatura íe muito grande comparada com a constante de tempo do nível e tambíem porque a íagua sío começca a esquentar quando a chave de nível atua habilitando o conversor estíatico a fornecer potêencia para as resistêencias.
•	No instante em que a temperatura atingir o valor desejado, faz-se um controle de nível de tal forma que o tanque encha e permaneçca o controle de temperatura.
•	Quando o tanque estiver cheio, verificamos se o fluxo de agua que escoa atravís do cano que interliga os dois tanques estaría com agua na temperatura desejada ou nãao.
Quando for utilizado o termo sistema híbrido, ou planta híbrida, tais termos se referem ao tanque de aquecimento da planta.
Todo o trabalho escrito a partir deste ponto estía baseado nesta seçcãao. O tíopico seguinte dá início a modelagem matemática do tanque de aquecimento com o intuito de resolver este problema.
5.3	Modelagem matemática tanque de aqueci-
mento
A seguir será tratada a modelagem matemática do tanque de aquecimento. Consideraremos as equações de forma genárica. No práximo capítulo, quando será feita a modelagem do autômato hábrido, serõo calculados os valores numéricos para cada locacõo. Para o calculo das equacoes, considera-se que agua á um láquido incompressável2 e que as perdas de calor no tanque sõo desprezáveis.
A figura 5.6 ilustra o desenho do tanque de aquecimento separado da planta.
Figura 5.6: Tanque de aquecimento de água
Este tanque possui variáveis que estao conectadas aos dispositivos inteligentes. As variáveis são:
• F1	vazão de entrada vinda da bomba 1 em L/s.
• h nivel de água no tanque em cm.
• T1	temperatura da agua do tanque de aquecimento em oC.
• Q Potências dos resistores em Watts.
2	massa específica da água nao varia com o tempo
Ha também variaveis que não são monitoradas pelos dispositivos diretamente. São elas:
•	Fo	vazao de saéda inferior do tanque de aquecimento. Denominada vazao
”ladrao“ do tanque. Esta vazão escoa agua direto para a rua.
•	Fs	vazao superior que so existe quando o nével do tanque for maximo. Ela
escoa aégua do tanque de aquecimento para o tanque de mistura.
Por fim temos os parômetros :
•	A area da secao transversal to tanque em cm2.
•	Ao	érea da secao transversal do cano da vazao ladrâo em cm2.
Na figura 5.6, iremos aplicar o princépio de conservação de duas grandezas fundamentais: massa e energia.
Balanço de massa: Em um sistema qualquer, o balanço de massa é dado por:
massatotoi = massain — :mi.ssaout
Em termos de equaçcãoes para o tanque de aquecimento temos:
(5.1)
Assumindo a água como líquido incompressível a eq. 5.1 torna-se:
(5.2)
Pela equação de Bernoulli (Halliday e Walker 1997) obtemos a vazão ladrão Fo:
Fo = 2Aok
(5.3)
onde ko é uma constante adimensional que varia entre 0,6 e 1.
Substituindo a eq. 5.3 na eq. 5.2 obtemos:
, dh	.	/——
A— = Fi - 2Aoko\fgh dt
(5.4)
Quando o tanque está cheio, a eq. 5.4 muda para:
dh	.____
A~dt	F1	2Aoko\/ ghmax	Fs
(5.5)
onde hmàx ó o valor do nóvel móximo.
Balanço de energia
O balanço de energia é dado por:
energiaínterna	energia™	ener giaout + energia fonte
Em termos de equações para o tanque de aquecimento temos (Stephanopoulos 1984):
d[p AhCd1 ~ T0)] = ~pAF1c(T1 - To) + pAFoc(T1 - T0) + Q	(5.6)
dt
onde Q é a quantidade de calor fornecida pelas resistências por unidade de tempo, ceo calor específico da agua e To e a temperatura inicial do tanque. Reagrupando os termos da eq. 5.6 obtemos:
Ad(hTi) FT FT , Q	(57)
A—-— = FiTo - FoTi +--------	(5.7)
dt	pc
A equacao 5.7 assumiré a forma de diferença de temperatura. Chamaremos de T a diferença entre a temperatura T1 — To onde T1 &gt; To. Desenvolvendo a derivada do produto e substituindo a eq. 5.2 na eq. 5.7 obtemos:
Ah^f = -F1T + Q dt	pc
(5.8)
A eq. 5.8 tera um nível constante e igual a li,:l!!x caso o tanque de aquecimento esteja cheio.
Resumindo os passos da modelagem, temos que:
. dh
A	= Fi - 2Aok^/gh
dt
AhdT = -FiT + Q dt	pc
(5.9)
(5.10)
As variaveis nas equacoes 5.9 e 5.10 são classificadas como:
Variáveis de estado: h, T
Saídas: h, T
Entradas: entradas classificadas como:
Pertubaçoes: T0, F03
Variaveis manipuladas: Q,F1
Apesar das equaçcãoes e 5.9 e 5.10 serem nãao-lineares, tais equaçcãoes possuem comportamento similar a uma funçcãao de transferêencia de primeira ordem. A fig.5.7 ilustra o comportamento da temperatura em funçcaão do tempo da eq. 5.10.
Figura 5.7: Comportamento da temperatura em funçcãao do tempo
Pode ser verificado que a temperatura possui uma faixa de variação entre T1 e To.
Antes de se iniciar o proximo topico é necessario acrescentar uma observação importante a respeito do problema proposto da secão 5.2. Para que o problema seja resolvido de forma otimizada, foram feitas as seguintes consideracçãoes:
3To e a temperatura ambiente e como tal, pode ser distinta em instantes distintos. Já F0 tem haver mais com certas ocorrências indesejaveis, como o cano entupir ou quebrar, alguma pessoa mexer na vaivula do cano de F0 em um dado instante, fazendo com o que esta variavel seja uma pertubacão.
1.	Coloca a valvula do cano da vazão Fo semi-aberta. Isto se justifica na eq. 5.7 pois quanto maior for a vazão Fo, maior serâ a perda de energia interna pelo tanque, fazendo com o que a faixa de variação de temperatura seja menor.
2.	O controle de nível com tanque cheio descrito na secão 5.2 se justifica para constatar que a vazão F1 nao precisa ser a vazao nominal da bomba para encher o tanque e contribui para que a temperatura tenha uma maior faixa de variaçcaão (vide eq.5.7) .
5.3.1	Validação e cálculo dos parâmetros
Na verdade, há dois parâmetros a serem levantados na planta.
Área do tanque
Mediu-se o diâmetro interno do tanque com uma fita métrica:
d = 20, 7cm
Com isso:
A = nr2 = 335, 885cm2
Área do cano da vazao Fo: calcularemos na verdade o produto Aoko.
Para isso, foi feito um teste na planta. Colocou-se a véalvula do cano em questãao semi-aberta em quatro pontos diferentes e mediu-se a vazaão e o nével em regime permanente.
Para cada valor, aplicou-se a eq. 5.9, isolando os termos Aoko quando a derivada do nével for nula, obtemos:
Aok
Fi
2Vgh
(5.11)
o
Com os valores de cada ponto calculou-se uma méedia aritméetica deste valores.
Aoko = 0, 7322e-4
(5.12)
As grandes variações obtidas na tab.5.3 se devem principalmente nos dois primeiros
Abertura da Válvula (%)	Vazão (L/s)	Nível (%)	Aoko (10-4)
39	0,1933	36,1	0,8808
42	0,2083	86,15	0,7911
46	0,2267	98,0	0,6132
50	0,245	100,0	0,6477
Tabela 5.3: Tabela para o cílculo de A0k0
valores, onde as medidas são menos precisas em funcão do nível oscilar mesmo em regime. Estas oscilaçcãoes ocorrem porque quando o tanque estía com pouca íagua, a massa de íagua que escoa para dentro do tanque íe significativa comparada com a massa de íagua dentro tanque, logo o deslocamento de íagua que ocorre no tanque faz com o que o nível oscile, dificultando a precisãao das medidas. Em contrapartida, quando o nível estaí alto, a massa de íagua que entra íe insignificante comparada com a massa de ígua dentro do tanque. Logo, as oscilacães no nível sao desprezíveis, acarretando em uma melhor precisãao das medidas.
Os demais paraâmetros sãao:
p = 1000Kg/m3 c = 4186J/KgoC hmax = 68,0cm
Pmax = 4400W F1max 0, 5L/s
g = 9, 81m/s2
As equacoes 5.9 e 5.10 são não lineares e serí preciso lineariza-las em certos pontos de operacão. A linearizacão tem por objetivo facilitar o projeto de controladores PI e proporcionais e a representacão das equações em variíveis de estado. Na príxima seçcãao iremos tratar desta linearizacçãao.
5.3.2	Linearização das equações
Balanço de massa
Para efeito de recapitulaçcãao, a equaçcaão de balancço de massa íe dada por:
, dh	.	/——
A— = Fi - 2Aok^/gh dt
(5.13)
Temos então que linearizar o termo nao linear definida por f (h) = 2Aok^/gh. Para isso, criaremos uma varióvel incremento h dada por:
h = h — h
(5.14)
onde h é o ponto de operação. Aplicando série de Taylor na função f (h) obtemos (Stephanopoulos 1984):
f (h) = Aoko&amp;lt;/y-h
hã
(5.15)
Entãao a eq. 5.13 torna-se:
A— = Fi - 2Aoko dt
(5.16)
onde = F1 — . Em alguns casos, quando a vazao F1 for nula, a série de Taylor teró apenas um elemento, a constante. Aplicando h = h na funçao f (h) e substituindo na eq. 5.13 obtemos:
. dh . ,
A— = -2Aok^/ gh dt
Balanço de energia
Para a o balançco de energia, modelou-se a seguinte equaçcãao:
AhdT = -FiT + Q dt	pc
(5.17)
(5.18)
Considerou-se a eq. 5.18 para variaçoes de T e F1 somente. Com a limitaçao da chave de nével, o conversor estótico so injeta corrente nos resistores com o nével acima de 90%. Com isso, admitiu-se a variação do nével no intervalo entre 90% e 100% é desprezével. Temos entaão que a eq. 5.18 possui um termo nãao linear:
f (T, F,) = F,T
(5.19)
Usando a sírie de Taylor para duas ou mais variaveis para a eq 5.19 obtemos:
f (T, F,) = TF, + F1T
onde:
(5.20)
(5.21)
e Fi e T sao os pontos de operaçao para as variaveis Fi e T respectivamente.
Substituindo a eq. 5.20 na eq. 5.18 e agrupando os termos obtemos:
hA^ = -TFi - FXT + Q	(5.22)
dt	pc
Portanto, temos que a equacao 5.16 possui uma entrada (Fi) e uma variavel apenas (h). Ja a equaçao 5.22 possui duas entradas (Q e F\). Na proxima secao calcularemos as funçcãoes de transferâencia para cada caso.
5.3.3	Cálculo das Funções de Transferência
Neste tíopico iremos aplicar a transformada de Laplace nas equaçcãoes de balançco de massa e balancço de energia linearizadas para efetuar o cíalculo das funçcãoes de trans-ferâencia do processo. Considera-se que as condiçcãoes iniciais saão nulas.
Balanço de Massa
Para facilitar o cíalculo da funcçãao de transferâencia do balancço de massa, define-se uma constante co como:
co	Aok
o
(5.23)
Para calcular a funçcãao de transferâencia de balancço de massa, aplica-se a transformada de Laplace na eq.5.16 ja com a eq. 5.23 incluéda:
AsH(s) = -coH(s) + Fi(s)
(5.24)
Apos algumas manipulações algébricas, obtemos:
H(s) =	co 1
Fi(s)	As + 1
(5.25)
Balanço de Energia
Seja a equacçãao do balancço de energia linearizada:
hA—^ = -TFi - F\T + Q	(5.26)
dt	pc
Aplicando a transformada de Laplace na eq. 5.26 teremos duas funções de transferência, uma para a entrada Q e outra para a entrada F1.
1.	Entrada F1
Neste caso, a funçao de transferência é dada por:
T(s) Fi(s)
2.	Para entrada Q
A funçao de transferência é dada por:
T(s)
Q(s)
T(Fi)-1	(5.27)
f s + 1	
(PcF^i)-1	(5.28)
f s + 1	
Apesar da temperatura possuir duas funções de transferência, utilizaremos somente a eq. 5.28. Verifica-se que todas as funcoes de transferência sao de 1a ordem e que este e um processo multivariável, onde a entrada F1 acopla as variaveis nível e temperatura. No capítulo seguinte trataremos da sintonia dos controladores PI para cada funçao de transferência. Porém, iremos considerar os controladores para a modelagem das equaçcoões no espacço de estados contánuo tratado no táopico seguinte.
5.3.4	Modelagem das equações no espaço de estados contínuo
Iremos deduzir de forma generica a transformação das funçoes de transferôncia e controladores para o espaçco de estados.
Seja a funcao de transferôncia de 1a ordem dada por:
Y (s)	k
U (s)	TS + 1
(5.29)
onde U(s) é a entrada do sistema, Y(s) é a saída, k é ganho do sistema e t é a constante de tempo.
Para transformar esta funçcãao de transferôencia em uma equacçaão de variaveis de estados, aplica-se a transformada inversa de Laplace à equaçao 5.29 e fazendo y = x:
1k
x = — x(t) +— u(t)
TT
O compensador ou controlador PI e dado por:
U (s)	kc s + kikc
E(s) =	s
(5.30)
(5.31)
onde kc e o ganho proporcional e o ki é o ganho integral.
De acordo com (Ogata 1998), colocou-se o controlador PI na forma canónica ob-servavel . Com isso, as equaçães de estado para eq. 5.31 sao da forma:
Xc =
kikce(t)
(5.32)
u(t) = xc(t) + kce(t)
(5.33)
onde a funcão e(t) e o erro dado por:
e(t) = r(t) - y(t)	(5.34)
sendo que r(t) é a referôncia. Substituindo e(t) da eq. 5.34 na eq. 5.32 e y(t) por x(t) obtemos:
xc = — kikcx(t) + kikcr(t)
(5.35)
Esta é a equação de estados para o compensador PI. Para a planta, substituindo a eq. 5.33 na eq. 5.30 a agrupando os termos obtemos:
(1 + kkc)
T
k	kkc
x(t) + - Xc(t) +----r(t)
T	T
(5.36)
A figura seguinte ilustra um diagrama de blocos com o sistema processo-compensador no intuito de facilitar o entendimento ao leitor.
COMPENSADOR
PROCESSO
r(t)
+
		x = kikce(t')	u(t) f	X = --Í-X0+ — u(t) T	T
-		u(t} = xc (t}+kce(t}		r(0= x(f)
y(t)
X = —
Figura 5.8: Diagrama de blocos de um sistemas processo-compensador no espaço de estados conténuo.
Colocando as equações na forma matricial:
X
Xc
(i+fefee)	k
T	T
— kikc	0
x(t)
Xc(t)
kkc
T
kikc
r(t)
(5.37)
+
Este modelo matricial é útil pelo fato de ser a estrutura utilizada pelo CheckMate de declarar as possíveis dinâmicas contínuas sob a forma de equacães de estados. O capítulo seguinte trata esta questao com mais detalhes.
5.4	Discussão
Este capítulo tratou de uma breve descriçõo da planta piloto, onde serâo feitos experimentos práticos aplicando-se a teoria de controle supervisório de sistemas híbridos. Iniciou-se a resoluçõo do problema proposto tratando os aspectos matemáticos do tanque de aquecimento. Tal modelagem ó importante nao sá para o modelo autômato híbrido, mas tambám para diversos estudos de outras áreas e abordagens. O próximo capítulo continua a resoluçao do problema da secõo 5.2 com a modelagem do autômato hábrido de comportamento livre e o cáalculo de seu respectivo autôomato discreto atraváes da ferramenta CheckMate , tratada no cap 3.
Capítulo 6
Resolução do problema proposto através da síntese de um supervisor discreto
O presente capítulo dá continuidade na resolução do problema proposto tratado no capítulo 5 com a modelagem de um automato híbrido que represente o comportamento da planta livre. Em seguida trata o cálculo do autômato discreto aproximado que representa o autômato híbrido. Por fim, dada uma especificacão em relação ao problema proposto, faz o projeto de um supervisor discreto de acordo com a teoria de controle supervisoírio de sistemas híbridos.
6.1	Modelagem do autômato híbrido
Inicia-se a modelagem destacando as variáveis nível (h) e temperatura (T). A modelagem híbrida, como cruzamento de hiperplanos e os guardas do modelo autôomato híbrido do tanque de aquecimento íe baseada nestas duas variíaveis. As variíaveis de estado utilizadas para a modelagem sao 4:
•	x1 esta variavel representa o nível de agua no tanque h.
•	x2 esta variível nao tem sentido físico explícito, mas surgiu com a inserçao de um compensador PI para o nível.
•	x3	esta variavel representa a temperatura de agua no tanque T.
•	x4	esta variível nao tem sentido físico explícito, mas surgiu com a inserçao de
um compensador PI para a temperatura.
A seguir a definiçõo de cada hiperplano de h:
•	h &amp;lt;0: A modelagem híbrida proposta í que se a igualdade referida anteriormente for satisfeita, podem ocorrer duas possibilidades. A primeira é o tanque ficar permanentemente vazio e a segunda é o nível de agua no tanque voltar a subir.
•	h &gt; 0.5m Este hiperplano tem a funçao de inserir no sistema a técnica de chave-amento de controladores. Este chaveamento se justifica no intuito de atenuar o overshoot do nível de água, evitando assim que haja cruzamentos indesejáveis de hiperplanos .
•	h &gt; 0.64m: A modelagem híbrida neste caso dar-se-á pelo fato da uma restriçõo de funcionamento da planta piloto dada pela chave de nível. Sá é possível fornecer potência aos resistores quando a condicõo h &gt;= 0.64m for satisfeita. Por questõo de segurançca, os resistores sío podem estar ligados se estiverem submersos na ígua. Caso contrario, a falta de ígua acarretaria na queima dos resistores. Nesta desigualdade hí vírias dinêmicas possíveis de serem implementadas, que serâo tratadas ainda nesta seçcõao.
•	h &amp;lt;0.64m: Este hiperplano possui comportamento oposto do hiperplano anterior. Com o nível baixo, o conversor estítico deixa de fornecer potência aos resistores.
•	h &gt; 0.68m: A modelagem híbrida proposta í que se a igualdade referida anteriormente for satisfeita, o tanque fica cheio e aparecerí a vazõo Fs. Ha tambím víarias dinêamicas possíveis e estas seraõo tratadas posteriormente
Neste momento definem-se os hiperplanos para a temperatura.
•	T &gt; 2 este valor de temperatura e o valor desejado para resolver o problema proposto.
•	T &gt; Tmax: este hiperplano foi criado no intuito de evitar que o tanque fique muito quente.
Valores numíricos das equações:
Primeiro, reescreve-se funcao de transferência de 1a ordem:
Y (s)	k
U (s)	TS + 1
(6.1)
Comparando a eq. 5.25 com a eq. 5.29 temos:
e
k = c-1
(6.2)
A
T = —
Co
(6.3)
A equação do balanço de massa será dividida em três pontos de operação, uma para cada regiao entre os hiperplanos do nável. A tabela 6.1 mostra os valores calculados para as funçães de transferência do nável para cada ponto de operação.
Intervalos (cm)	h (cm)	Co	k	T
]0, 50]	30,0	0,2961	3,378	113,44
]50,60[	50,0	0,2293	4,36	146,48
[60, 68[	62,0	0,206	4,85	163,05
Tabela 6.1: Valores de k e t para cada ponto de operação
Para o balanço de energia, comparando a eq. 5.28 com a eq. 5.29 obtém-se
k' = (pc.F1)-1
(6.4)
e
Ah
K
(6.5)
Neste caso, utiliza-se dois pontos de operaçao para o nável e um ponto de operação para a vazão F\. Os valores dos pontos de operacao localizam-se entre a chave de nável e o nável maximo do tanque. A tabela 6.2 mostra os valores das funçães de transferêencia da temperatura para os dois casos.
Intervalos (cm)	h (cm)	. (l/s)	k’	T'
[62, 68[	62,0	0,333	1	62,54
68	68,0	0,333	1	68,60
Tabela 6.2: Valores de k' e t' para cada ponto de operação
Nestas tabelas não se inclui os controladores. O apêndice A deste documento trata de um projeto de controlador PI feito passo a passo e os valores dos demais controladores.
Modelo Autômato Híbrido
O modelo autômato híbrido que está ilustrado na fig.6.11 está de acordo com a definição 3.1 e com os valores numéricos ja incluídos. As equações estao no espaço de estados contínuo de acordo com a eq. 5.37.
Onde:
•	r é a referência do nível igual a 64cm.
•	rmáx é a referência do nível para tanque cheio
•	rT í a referência da temperatura igual a 2oC
•	Tmáx í a diferença maxima de temperatura que o tanque pode atingir. Este valor í obtido aplicando-se o teorema do valor final na eq.5.28 com um degrau Q = 4400W . Logo, Tmáx = 3,1oC.
A seguir uma breve descriçao de cada locacao:
Locacão 1: E a locação inicial do autômato híbrido. Significa que o tanque está inicialmente vazio e enchendo sob acão de um controlador proporcional. Neste momento nãao tem aquecimento de íagua.
Locaçcãao 3: sua importêancia se da pela modelagem de um chaveamento de controladores. O controlador proporcional dí lugar a um controlador PI. Este chaveamento tem o intuito de se evitar um sobressinal muito alto no nível de ígua no tanque.
Locaçães de 4 a 8: São locacoes que estao com valores de nível acima do hiperplano da chave de nível. Foi proposto aqui uma combinaçao de possíveis dinamicas que podem ser configuradas na planta. As locacães 4 e 5 o nível de ígua continua enchendo, mas na locaçcãao 4 a temperatura estía em malha aberta e na locaçcãao 5 a temperatura estía em malha fechada com referência igual a 2oC. O mesmo acontece com as locaçães 6 e 7. Ambas estão com o nível com controlador PI com referência em 64cm, mas na locaçcãao 6 a temperatura estía em malha aberta e na locaçcaão 7 a temperatura estía em malha fechada com referência igual a 2. Ja a locacao 8 representa uma situação em que o nível esta diminuindo. Neste caso, o nível atingirí a chave de nível fazendo cortar o aquecimento do tanque.
Locaçoes 9 e 10: Sao locaçoes que indicam que o nível de agua no tanque estí no míaximo. A temperatura estía em malha aberta na locaçcãao 9 e com um controlador PI
1A transição em tracejado e similar às demais transições, servindo apenas para não atrapalhar a leitura textual da figura.
-0.0 lõx, +1.146 10"’
r_0F9i67 +	0-
Figura 6.1: Modelo Autômato híbrido para o sistema híbrido tanque de aquecimento.
com referência igual a 2 na locaçao 10. Esta ultima í o objetivo deste trabalho. Se for possível atingir esta locaçcaão e permanecer nela, resolve-se o problema proposto.
Locacçãao 2: Esta locaçcãao indica que a chave de nível desabilitou a temperatura e que o nível estía decaindo com o tempo.
Locacçãao 11: Significa que o tanque estía vazio.
Verifica-se o autêmato híbrido modelado na fig.6.1 possui transições de mesmo nome e guardas. Isto caracteriza o comportamento não determinístico deste autêmato. A transição C, por exemplo, pode levar para qualquer locação de 4 a 8.
Logo, a modelagem do comportamento livre da planta íe importante para que se possa formular um problema sob um aspecto geral, onde se considera no modelo todas as possibilidades de chaveamentos de dinêamicas relevantes. O modelo planta livre nãao íe uínico. Eí possível, em um mesmo sistema híbrido, modelar uma planta livre com um modelo automato híbrido diferente da fig.6.1. Isto depende do problema a ser resolvido, quais sãao as variíaveis relevantes, a modelagem dos hiperplanos, escolha dos controladores, possibilidades de chaveamento, etc.
Para resolver este problema de controle, obtím-se um autêmato de estados finitos que represente o comportamento líogico aproximado do sistema híbrido. Na seçcãao seguinte íe detalhada a obtencçãao deste modelo discreto.
6.2	Calculo do automato aproximação
Para o tratamento do autêmato híbrido da fig.6.1, utilizaremos a ferramenta CheckMate . A fig. 6.2 ilustra este modelo.
Dinâmica Contínua
O bloco SCS da fig.6.2 corresponde a um bloco de sistema contínuo chaveado modelando Hc. Para este modelo em particular, o sinal de entrada u í um vetor (sinal multiplexado) de 4 sinais cada um assumindo o valor das variíveis x1, x2, x3 e x4 da fig.6.1.
A funçcãao de chaveamento que retorna a derivada de cada valor de u íe especificada em um arquivo de extensão “.m” que associa cada valor de u uma dinamica do autêmato híbrido, onde o no da locacão í igual a u.
Sete blocos à direita do bloco SCS correspondem a blocos de limite poliídrico (PTHB). Tais blocos equivalem aos guardas do automato híbrido. Nota-se que o autoêmato híbrido da fig.6.1 possui mais que sete transiçcãoes. No entanto haí muitas
transiçcoães iguais devido ao comportamento nãao-determinístico do autâomato híbrido e portanto basta um PTHB para representar todas as transiçães iguais. Neste modelo, cada poliedro convexo limita-se apenas a definir um limite do tipo reta associado a cada transicçãao do modelo autâomato híbrido. Assim por exemplo, considerando x = [x1 x2 x3 x4]T, o poliedro definido pelo par (C, d), onde C = [—1 0 0 0] e d = [—0.5 0 0 0]T, define o limite —x1 &amp;lt;—0.5 ou x1 &gt; 0.5. Para este poliedro, o sinal de saída so í verdadeiro para valores x1 &gt; 0.5.
Dinâmica Discreta
O bloco mais a direita da fig. 6.2 representa o bloco de maquina de estados finito que modela Hd. Os eventos de entrada deste bloco sao sinais multiplexados, ou vetores de sinais. O critíerio de detençcãao da mudançca do sinal adotado para todos os eventos íe do tipo borda de descida. Para funcionar como borda de descida, muda a desigualdade dos guardas. Assim, para borda de descida, o limite x1 &gt; 0.5 mudarí para x1 &amp;lt;0.5.
O modelo da míquina de estado finito da fig.6.3 representa as características discretas do autâomato híbrido.
Figura 6.3: Máquina de estados finita representando a dinâmica discreta do autômato híbrido
Destacam-se as locações de no 11 (Avoid) e de no 10 (sucesso). A primeira significa uma locaçõo indesejável, que é quando o tanque esvazia e permanece vazio. A segunda é a locaçõo que resolve o problema proposto, conseguir agua quente a uma temperatura constante escoando para o tanque de mistura.
6.2.1	Simulação do Modelo Planta híbrida em malha aberta
Uma dos aspectos relevantes do CheckMate nõo sé é a verificaçõo , mas também a simulacõo de um sistema híbrido. A simulaçõo engloba apenas um subconjunto de condiçcõoes iniciais do sistema enquanto que a verificacçaõo considera todas as possibilidades pertencentes a um conjunto de condicçõoes iniciais. Assim, a simulaçcaõo pode ser uétil para conhecer a resposta do sistema sob certas condiçcoões sem a necessidade de se efetuar uma verificaçõo, que é bem mais demorado. A simulaçao é feita sob o ambiente Simulink do MATLAB. A fig.6.4 ilustra um dos posséveis comportamentos que o modelo da planta hébrida em malha aberta pode realizar.
6.2.2	Verificação de propriedades do modelo autômato híbrido
A principal utilização da ferramenta CheckMate á a verificação de sistemas híbridos. Este tápico inicia a verificaçao do modelo autômato híbrido da fig.6.1. A verificação utiliza a mesma configuração de blocos da fig. 6.2.
Para a verificação, dois parâmetros são importantes no CheckMate : O conjunto
(a)	Nível	(b) temperatura
Figura 6.4: Gráficos que representam um comportamento possível do autômato híbrido
de condições iniciais e as especificações ACTL tratadas no cap. 3 para verificação de propriedades.
Para as condições iniciais temos que:
0 &amp;lt;x1 &amp;lt;0.3m
X2 = 0
0 &amp;lt;x3 &amp;lt;0.01oC	(6.6)
0 &amp;lt;X4 &amp;lt;0.01
O CheckMate obriga o usuário a definir um intervalo de condições iniciais para n-1 variáveis, mesmo que um intervalo de condicões iniciais seja importante para apenas uma variável. Neste caso em particular, apenas o conjunto de condiçoes iniciais de x1 á importante analisar devido ao fato de que x2 e x4 nao possuem sentido físico e x3 que representa a temperatura está inativa na locação inicial e portanto sua condição inicial á sempre nula.
As especificacões ACTL foram geradas em relaçao aos estados avoid e sucesso:
•	Especificaçõo 1 AG(AF fsm == sucesso): Significa que todos os caminhos no futuro levam ao estado sucesso e vaõo permanecer nele.
•	Especificacõo 2 (AG-fsm == avoid): Significa que para todos os caminhos globalmente o estado avoid nunca sera atingido.
Vale ressaltar que se a especificacõo 1 for satisfeita, necessariamente a especificaçõo 2 também á satisfeita, já que no estado sucesso nao haverá mais cruzamentos de hi-perplanos. Efetuou-se a verificaçõo no CheckMate atravás do comando verify. Ambas
as especificações falharam, o que significa que existe alguma condição inicial e também o comportamento não determinístico do autômato híbrido que leva ao estado avoid e que consequentemente nao atinja o estado sucesso.
6.2.3	Obtenção do Modelo Discreto
O modelo discreto da verificação descrita anteriormente é guardado em uma variável do MATLAB/Workspace chamada de GLOBAL AUTOMATON. O modelo discreto é uma aproximacão do modelo autômato híbrido.
Este modelo é tratado na ferramenta Grail, que é uma biblioteca de funçães em C++ que permite a computacão simbólica sobre expressões regulares, linguagens finitas e autômatos finitos (Gonzáles 2000). Contudo, a variável GLOBAL AUTOMATON não pode ser interpretada diretamente pelo Grail. Para isso, foi utilizado um algoritmo que é capaz de converter o modelo discreto calculado no CheckMate em uma lista de instruções que pode ser interpretada pelo Grail (Leal e Cury 2004). O resultado é um autômato C/E que descreve o comportamento da planta hébrida
A fig.6.5 mostra o resultado da verificacão:
Figura 6.5: Modelo discreto correspondente ao autômato hébrido
O modelo da fig.6.5 é um autômato C/E onde v são os eventos e u são as condiçães. Na abordagem de sistemas híbridos, os eventos de um sistema C/E estão associados ao cruzamento de hiperplanos de um sistema híbrido. Hiperplanos diferentes e sentido de cruzamento diferentes implicam em eventos distintos. As condiçoes são associadas as
dinamicas de um sistema híbrido. Dinâmicas distintas sao determinadas por condicães distintas.
Para o modelo discreto da fig.6.5, a numeração do índices de u é a mesma que cada locacão do autâmato híbrido possui. As transicães A, B, C, D, E, F, e G, são representados pelos eventos v1, v2, v3, v4, v5, v6 e v7 respectivamente.
Analisando o modelo discreto da fig.6.5, verificamos que o evento de inicializaçcãao ocorre com a condiçao u1. Repare que o estado atingido pela transicao nu1 possui restricoes de comportamento, pois ha somente um evento ativo apís nu1, que í o v1. Para o evento v1 hí somente a condicao u3. Com a ocorrância da transicao v1u3, o estado atingido possui tambem apenas um evento ativo apís a cadeia nu1 o v1u3 (v3), contudo tal evento estí associado a cinco condicães: u4, u5, u6, u7 e u8. A cadeia nu1 o v1u3 corresponde a inicializacao do autâmato híbrido na locaçao 1 e a ocorrência da transição A: x1 &gt; 0, 5 levando o modelo para a locacao 2. Na locaçao 2, hí um nao determinismo que faz com o que uma transiçcãao possa atingir cinco locaçcãoes distintas.
Fazendo a anílise completa do modelo discreto, í fícil notar que tal modelo í idântico ao autâmato híbrido (sob aspecto discreto). O que normalmente ocorre í a obtençcãao de uma aproximaçcãao externa e que com o refinamento desta aproximaçcãao talvez consiga atingir o modelo exato (Chutinan 1999). Neste caso em particular o modelo discreto exato do autâmato híbrido foi calculado sem a necessidade de um refinamento.
O problema agora íe que tal modelo nãao satisfaz a especificaçcaão de atingir e permanecer no estado sucesso. Para isso, serí utilizado a teoria de controle supervisírio de sistemas híbridos para resolver o problema proposto.
6.3	Projeto do supervisor discreto
Para o projeto de um supervisor, foi utilizada a ferramenta Grail. Recentes pequisas acrescentaram ao Grail novas bibliotecas de funçães. Tais bibliotecas dizem respeito a teoria de controle supervisorio de SED, autâmato C/E e controle supervisorio de sistemas C/E e outras. Foram utilizadas neste trabalho as bibliotecas de funçães sobre o autâomato C/E e controle supervisíorio de sistemas C/E. O projeto do supervisor discreto segue os mesmos passos do exemplo feito no cap.4. A planta livre íe o modelo da fig.6.5
Dada a especificacao E C PV(Lm) para o comportamento desejado da planta sob supervisao como mostra a fig.6.6. Esta especificação í do tipo sequância de eventos que leva ao estado correspondente à locacão 10 do autâmato híbrido.
Figura 6.6: Especificação Esp C PV(Lm)
O proximo passo á encontrar uma linguagem K C (V+ x U)*. Aplica-se a projeção inversa em Esp e faz a intersecçao com a linguagem marcada da planta. Com isso obtemos o autêmato ilustrado na fig. 6.7.
Figura 6.7: Especificaçao K C Lm
Verifica-se, entretanto, que a linguagem K não á vu-controlavel em relaçao a L. Note, por exemplo, que apás a sequencia u = puy o vyu2 ◦ v3u5 E K pode levar a sequencias que nao são vu-controlaveis em relaçao a K. Obtám-se então a máxima linguagem vu-controlável contida em K, a qual á reconhecida pelo automato mostrado na fig.6.8.
Figura 6.8: Maxima linguagem vu-controlavel SupCV u(K)
Com isso o supervisor para o autêmato híbrido que representa o comportamento da planta híbrida foi concluído. Ressalta-se que pela fig.6.8 hé quatro caminhos distintos que levam ao estado desejado. So o aspecto físico, tais caminhos combinam as variéveis nível e temperatura tendo controladores ou em malha aberta. O préximo passo é utilizar novamente o CheckMate para verificar as especificacães da subseçao 6.2.2 que falharam para o modelo discreto da planta híbrida em malha fechada.
Verificação de propriedades do modelo autômato híbrido sob ação do supervisor
Para este caso em particular, basta substituir a parte discreta da planta original pelo supervisor, pois o modelo discreto da planta é exato e não aproximado. Se o modelo discreto fosse uma aproximação externa teria que se fazer o produto síncrono do supervisor e parte discreta da planta acoplada com a parte contínua da planta (Gonzáles 2000).
ff	"dd
99		ee
entry: q=7;	U	K	entry: q=5,
Figura 6.9: Máquina de estados finita representando a planta híbrida sob ação de um supervisor
Efetua-se agora a verificacao para a 1a especificaçao descrita na subseção 6.2.2. Observar-se que na fig. 6.9 o estado avoid nao se encontra. Então não faz sentido testar a segunda especificaçao da subsecão 6.2.2, pois o supervisor impede que tal especificaçao falhe.
Efetuou-se uma simulacao que comprova que a especificacao foi satisfeita. Pela fig.
6.10	observa-se pelo gráfico do nível que o tanque enche em torno de 150 segundos e a temperatura estabiliza em torno de 200 segundos.
(a)	Nível	(b) temperatura
Figura 6.10: Gráficos que representam o comportamento do automato híbrido sob açao do supervisor
A especificação, como previsto, á satisfeita. Isso mostra que sistema híbrido modelado pelo autômato híbrido da fig.6.1 sob acão do supervisor da fig. 6.8 atende a especificação ACTL. Vale ressaltar que esta é apenas uma possibilidade das quatro
possíveis que a planta híbrida em malha fechada consegue satisfazer a especificação ACTL. Fisicamente, a possibilidade í encher o tanque ígua e nível com controle proporcional, chaveamento do controlador proporcional do nível para um PI com referência em 64cm. Com o nível estabilizado em 64cm, a temperatura comeca a subir e esta sem controle atí atingir o valor de 2 graus. Com isso, o nível volta a subir e a temperatura permanece aumentando e sem controle atíe que o tanque enche e a temperatura passa a ser controlada com referêencia em 2 graus.
6.4	Discussão
Este capítulo apresentou a resoluçcãao de um problema proposto na planta piloto, que possui comportamento de um sistema híbrido guiado por eventos. Este problema aborda a síntese de supervisores discretos acoplados em uma planta híbrida.
A utilizacão da ferramenta CheckMate e uma extensao de funçoes sobre autômatos Grail permitiram resolver computacionalmente o problema de controle proposto. Contudo, o problema da complexidade algorítmica envolvida na verificação impoem uma severa limitaçcãao computacional para problemas mais complexos.
Os resultados obtidos atíe agora sãao teíoricos, mas constituem um passo importante para uma implementação prítica. O príximo capítulo trata da implementacao pratica do supervisor discreto na planta piloto.
Capítulo 7
Implementação de um supervisor C/E na planta piloto
Este capítulo mostra um procedimento para implementaçcãao de supervisores discretos como o projetado no cap.6. Sería descrito aqui um pouco mais sobre a rede Fieldbus, em especial a rede Fieldbus da planta, denominada de Foundation Fieldbus. A arquitetura de rede, protocolos de comunicaçcãao terãao uma breve descriçcãao. Sería tratado tambíem o conceito de OPC, alguns servidores OPC disponíveis na planta e sua interface com o MATLAB. Por fim, íe descrito o algoritmo de controle que introduz o supervisor discreto por um jogador de autêomatos feito no MATLAB e interagindo com as variíaveis contínuas da planta.
7.1	Arquitetura de rede da planta piloto
A rede Foundation Fieldbus íe uma arquitetura aberta para a integraçcãao da in-formaçcãao. O sistema de comunicaçcaão Foundation íe um sistema digital, serial e bidirecional. Esta rede se destaca das outras por ter a capacidade de distribuir o controle no campo. Isto í possível devido à inserção de processadores nos dispositivos de campo. Ela íe regulamentada pela Fieldbus Foundation, uma organizaçcãao internacional, sem fins lucrativos, formada pela uniaão de mais de 185 companhias-membros que representam aproximadamente 90% do mercado mundial do mercado de instrumentacão e controle de processos.
Topologia da Rede
A arquitetura de rede da planta piloto é distribuída e possui uma ponte denominada de DFI302 (Fieldbus Universal Bridge) que interliga os níveis de chão de fabrica com os níveis de usuario ou estação de trabalho. A fig.7.1 ilustra a topologia da rede
Foundation Fieldbus na planta piloto. O DFI302 í um elemento chave na arquitetura distribuída da planta. Este combina características de comunicação com acesso direto de entrada e saída (I/O) e controle para aplicacoes contínuas e discretas. Tambím provê servicos de comunicacao para controle, utilizando o OPC, configuracão e manutencao usando OLE.
Figura 7.1: Topologia de rede da planta piloto
Os principais protocolos de comunicaçcãao do DFI sãao:
•	Ethernet: í o protocolo que interliga os níveis mais altos, como controladores de alta velocidade, dos serviçcos de dados e de estaçcãoes de trabalho, como mostra a fig.7.1. Este protocolo possui uma taxa de transmissão de 100Mbits/s e í baseado no protocolo TCP/IP.
•	Foundation Fieldbus: que íe um dos mais avancçados protocolos destinados para sistemas de automação. O nível H1 conforme mostra a fig.7.1 possui uma velocidade de 31.25Kbit/s por razães de segurança intrínseca. E o nível responsavel pela interconexãao dos equipamentos de chãao de fíabrica tais como sensores, atua-dores e dispositivos de I/O.
•	Utilizando portas adicionais, o Protocolo Modbus conecta com os dados da rede Fieldbus virtualmente e com qualquer dispositivo da rede que esteja disponível.
7.2	OPC - Open Process Control
OPC í uma maneira unificada para conectar fontes de dados tais como dispositivos, base de dados, com aplicacoes cliente (interfaces homem-míquina). Esta tecnologia melhora a interface entre as aplicaçoes cliente e servidor fazendo com que exista um mecanismo padrâo para comunicacao de uma fonte de dados para qualquer aplicacao cliente. Em outras palavras, OPC í um mecanismo que habilita no campo a automaçao e as interfaces homem-maquina.
As principais características da tecnologia OPC sao:
•	E flexível - suporta diversas aplicaçães.
•	Eficiência e escalavel - suporta aplicacoes grandes e complexas.
•	Facilidade de compreensaão e de uso.
•	Possui uma grande aceitaçcaão no mercado.
Para o caso da planta, os clientes OPC sãao conectados no servidor OPC atravíes de um software backplane, ou seja, í um software que pode ser conectado diretamente por qualquer cliente OPC. Por fim, os servidores OPC se comunicam com as variaveis dos dispositivos inteligentes da planta. A fig. 7.2 ilustra a configuracao OPC para a planta piloto.
Figura 7.2: OPC na planta piloto
O servidor OPC que os softwares da planta, como o syscon, utilizam é o servidor com o nome SMAR.DFIOLESRVER.0. Com este servidor, é possível acessar os parâmetros de configuração que cada dispositivo inteligente da planta possui.
Recentemente um novo cliente OPC foi instalado na planta. Tal cliente possui um controle denominado de ActiveX, que possibilita a integraçao de dados com diferentes sistemas tais como fontes de banco de dados, linguagens de programacçõao, etc. O controle ActiveX possibilita o software MATLAB acessar os servidores OPC da planta, em especial o servidor SMAR.DFIOLESRVER.0. Atraves de alguns comandos feitos no MATLAB, e possível acessar os parômetros de configuraçao de cada dispositivo da planta e ate mesmo modifica-los. O MATLAB utiliza o novo cliente OPC para se conectar aos servidores OPC da planta piloto.
7.3	Implementação do algoritmo de supervisão discreta por um servidor OPC conectado ao MATLAB
O algoritmo de implementaçõo é um jogador de autômatos C/E conectado em um servidor OPC da planta1. Os eventos e condições do jogador estõo associados com as variaveis T e h vindas da planta. Os controladores PIDs2 estao embutidos na configuraçõo da planta. Cria-se entõo uma configuraçõo no Syscon que possui os blocos de nível, temperatura, controladores e atuadores. Para o nível, o atuador é o posicionador de valvula FY302 e para a temperatura í o conversor estatico que estí interligado com o dispositivo FI302, um medidor de corrente. Apís isso, o operador descarrega esta configuraçcaõo na planta, para que o experimento possa ser realizado. O mais importante íe que o cliente OPC acessa as variíaveis que estõao no servidor OPC da ultima configuracõo descarregada do Syscon para os dispositivos da planta. Logo, tal configuraçcõao deve ser conferida para o correto funcionamento da implementaçcaõo do supervisor discreto. Com relaçao às variaveis, o algoritmo tem capacidade de ler e setar paraômetros como ganho e integrador do PID, setpoints, etc. Para leituras e escritas das variaíveis, o servidor OPC necessita de um atraso no algoritmo com o intuito de atualizar as variíveis, que varia de acordo com o no de dispositivos configurados na rede e se í leitura ou escrita de dados. Quanto mais dispositivos estiverem na rede, maior sera o atraso. Assim ocorre com escritas, que necessitam de um atraso maior que a leitura de dados. Para este algoritmo em particular, a atualizaçcõao das variaveis possui um atraso de 2 segundos. Com isso, se quisermos plotar um grafico com 30 amostras do nível e temperatura, o tempo do experimento sera de 1 minuto.
1A implementação do algoritmo também pode ser feita em outras linguagens de programação, como C, C++, java, etc. Para isso, é preciso obter uma biblioteca de comandos Activex para a linguagem escolhida com o intuito de se obter acesso às variaveis da planta.
2	Os blocos de funçao dos dispositivos da planta sao chamados de PID. Contudo, os controladores modelados são PIs, que são um caso particular dos PIDs. Logo, foi utilizado o bloco PID e configurou-se um controlador PI de acordo com a modelagem feita no capítulo 5.
O algoritmo de implementaçcaõo do supervisor discreto sob abordagem do controle supervisoário de sistemas hábridos possui sete passos distintos:
1. Conversõao do arquivo em formato grail para uma matriz de transiçcõao. A fig.7.3 ilustra uma lista de instruções do grail representando um autômato C/E qualquer.
(START) I- 0
0 [OJ ] 1
1	[1.5] 2
3	[3.5] 2
2	[2.6] 3
2-I (FINAL)
Figura 7.3: Exemplo de uma lista de instruções de um autômato C/E
O termo START indica qual áe o estado inicial e o termo FINAL sõao para os estados que possuem marcaçcõao. Os termos entre colchetes sõao os eventos e condiçcõoes respectivamente. Os termos da 1a coluna sõo os estados de partida das transições e os termos da 4a coluna sao os estados atingidos pelas transicões. Uma funçõo denominada de grailce2mat lô os numeros do arquivo do grail e os guarda em uma matriz, arquivada em formato .mat. Esta matriz possui n linhas por 4 colunas, onde a 1a coluna significa o estado de onde sai a transiçao, a 2a coluna significa os eventos pertencentes aos estados da 1a coluna, a 3a coluna sao as condicões referentes as colunas anteriores e a 4a coluna sõo os estados atingidos pela transiçcõao vu. O nuámero de linhas significa o tamanho do autôomato em termos de transições. A seguir a matriz de transiçao equivalente a lista de instruções da fig.7.3.
0 0 11
115 2
2223
(7.1)
3352
O algoritmo de conversao ordena todos as linhas pela ordem crescente dos estados de saída das transições e em seguida pela ordem crescente dos eventos servindo para facilitar o cálculo do algoritmo. No entanto, a marcaçõo nao é considerada na matriz. Isto se justifica que a marcaçõo é um atributo teórico que serve para marcar estados que possuem tarefa completa. A marcaçao foi de grande importancia na síntese do supervisor. Mas no caso desta implementaçõo, o jogador iréa percorrer todas as transiçcõoes pertencentes a matriz de transiçcõao do autôomato independente da marcaçcaõo dos estados.
2.	Conexão com o servidor OPC. O algoritmo configura o cliente OPC, conecta com o servidor OPC, adiciona as variáveis que se deseja utilizar, leituras e escritas das variãveis.
3.	Nesta parte declaram-se alguns parâmetros importantes, como o tamanho da matriz de transicão, estado inicial, variáveis auxiliares, etc.
4.	Inácio do jogador de autômatos. Nesta parte se inicia um loop que termina de acordo com no de amostras das variáveis contínuas conectadas no servidor OPC, que se deseja analisar. Este loop contám o jogador de autômatos e a atualização das variáaveis conectadas com o servidor OPC.
5.	Eventos. Nesta parte localizam-se os eventos pertencentes ao estado inicial e atravás de uma funcão de configuraçao dos eventos, verifica-se qual o evento ocorreu. A funçao dos eventos descreve quais sao os cruzamentos de patamares que podem ocorrer no estado inicial. Se não ocorreu nenhum evento, o algoritmo volta para o início do loop e repete-se as partes 3, 4 e 5. Se ocorreu algum evento, entaão ocorre o passo seguinte, que áe localizar as condiçcãoes associadas ao evento ocorrido.
6.	Condicães. Apás a ocorrôncia de um evento, verifica-se quais são as condicães associadas ao evento ocorrido e atraváes de uma funcçãao naão determinástica, escolhe-se o valor da condicçaão de maneira aleatáoria. Com o valor da condiçcãao, associa-se este valor uma dinôamica. Isto áe feito atraváes de uma funçcãao onde se declaram todas as dinômicas possáveis de ocorrer na planta hábrida para cada valor da condiçcãao. Por fim, ocorrido o evento e determinado a condiçcaão, atualiza o estado do autôomato e a dinôamica a ele associado e repete os passos de 3 atáe 6 para o estado atual.
7.	Os passos de 3 a 6 ocorrem até que acabe o no de amostras, que então se encerra o loop, desconecta com o servidor OPC e fim do algoritmo
A fig.7.4 ilustra o fluxograma do algoritmo implementando o supervisor discreto na planta piloto. Cada retaôngulo pontilhado representa as partes do algoritmo que foram descritas anteriormente.
Figura 7.4: Fluxograma do algoritmo jogador de autêmatos conectado à planta
E importante ressaltar que o algoritmo descrito pelo fluxograma da fig. 7.4 é capaz de implementar supervisores para diferentes especificacões. O que mudaria é o arquivo gerado pelo do grail devido a inserçõo de diferentes especificações e consequentemente a matriz de transicao.
Também é possível a implementaçõo de supervisores para outros sistemas híbridos (SH). Para isso, é necessário alterar as funções de configuracao de eventos e condicoes do algoritmo. Isto porque a funcao eventos esta associado com os guardas do modelo autômato hébrido de um supervisor para um SH qualquer. Basta alterar os guardas e o numero de eventos de acordo com a modelagem escolhida. A funçõo de confi-guracçõao de condiçcõoes estéa associado com as posséveis dinôamicas do sistema. Para um supervisor de um SH qualquer, basta alterar as equações, as variéveis e o numero de dinamicas posséveis de acordo com a modelagem escolhida. Deve ser checado se o supervisor em questõao possui interface homem-méaquina, isto ée, se ée possével obter acesso as suas variéveis em tempo real. Logo, cada supervisor tem seus préprios arquivos de configuracçõao de eventos e condiçcõoes.
O Apôndice B deste documento ilustra o codigo de instruções em MATLAB do algoritmo.
7.4	Resultados da implementação do algoritmo
A seguir é apresentado os resultados da implementação do algoritmo para o supervisor da fig.6.8.
(a) nível	(b) Temperatura
Figura 7.5: Gráficos representando o comportamento do nével e temperatura da égua no tanque
Note que o nével inicia subindo, depois tem-se um queda e volta a subir. O controlador PI faz o nével atingir a referência e depois o nével sobe até encher o tanque.
A descida do nível conforme ilustra a fig.7.5(a) foi um fato inesperado e que ocorreu no instante em que o controlador, que antes era proporcional, passou a ser um PI. O controlador PID do nível, por questões de segurança, fez a válvula fechar totalmente por um certo tempo. A princípio o problema dever estar na atualização brusca do valor do O controlador PID não foi projetado para alteracoes bruscas nos seus parâmetros de configuração. Uma lágica de controle que varie gradativamente o valor de Ti poderia resolver este problema. Para o jogador de autômatos, o problema no PID nãao afetou o algoritmo porque nãao havia nenhum cruzamento de patamar que gerasse a ocorrância de um evento na descida do nível de água no tanque.
Pela curva da temperatura ilustrada na fig.7.5(b), nota-se que esta não foi afetada pelo chaveamento, pois ainda não havia aquecimento no tanque. Verifica-se no início do experimento uma queda de temperatura. Isto ocorreu porque foram feitas outros experimentos e provavelmente o tanque ficou com um resíduo de calor. Quando o tanque começcou a encher com íagua fria, isto fez com o que a temperatura diminuísse e sí voltou a aquecer quando a chave de nível atuou, habilitando o conversor estítico a fornecer potâencia aos resistores.
Pela fig.7.6(a), nota-se que o supervisor segue a sequencia de eventos dado pela especificacão da fig.6.6. Pode-se observar que os eventos 1, 3, 4 e 5 ocorrem aproximadamente nos tempo de 60s, 120s 200s e 240s respectivamente. E no mesmo instante, acrescido de 2s de atraso, que o comportamento das variaveis continuas se alteram pela introducao da nova condicao. Na fig.7.6(b) ilustra o comportamento das condiçoes, que são constantes por partes e mudam de valor somente nos instantes em que ocorreu os eventos.
(a) Eventos	(b) Condições
Figura 7.6: Gráficos com os eventos e condições do supervisor discreto
Foram realizadas outras duas implementares na planta, mas por coincidência, as condicões associadas aos eventos foram os mesmos da fig.7.5. Coincidência pelo fato da funcao nao determinística ser capaz de escolher outro valor de condiçao que pertenca
ao supervisor da planta.
7.5	Discussão
Este capítulo apresentou os resultados da implementacõo do supervisor discreto da fig.6.8 na planta piloto atravís de um algoritmo que í um jogador de autêmatos C/E conectado ao servidor OPC das variíveis contínuas da planta. Os resultados mostraram ser satisfatírios com relaçao a teoria de controle supervisírio de sistemas híbridos, apesar do problema no chaveamento de controladores referente a locaçõo 3 do autêmato híbrido da fig.6.1. Logo, foi possível efetuar o controle de uma planta com características híbridas por um supervisor discreto, uma abordagem utilizada por (Cury e Niinomi 1998).
Vale ressaltar alguns pontos sobre o atraso na planta. Uma sugestõo seria modelar o atraso que ocorre na atualizaçõo das variíveis do modelo como um clock entre uma dinamica e outra, ficando assim, um modelo mais complexo e interessante. Isto í, o modelo autêmato híbrido da planta teria uma variível de estado a mais e quase o dobro de locaçcoões em relacçaõo ao modelo original. No entanto, problemas de verificaçcõao com a ferramenta CheckMate devido ao aumento do numero de locacões do automato híbrido e principalmente o aumento de variaíveis de estado, tornariam a verificaçcõao intrataível. Sabe-se que pesquisas recentes estao surgindo com o objetivo de resolver o problema de aspecto computacional e algorítmico que dificulta e muito a verificacõo de sistemas híbridos. Em um futuro nõao muito distante espera-se que este problema seja resolvido ou pelo o menos minimizado.
Capítulo 8
Conclusõo e Perspectivas
Este capítulo reúne algumas conclusães e contribuiçães da pesquisa apresentada neste documento. Por fim algumas perspectivas de trabalho futuro sao apresentadas.
8.1	Conclusoes e Contribuicões
Nesta dissertaçcãao foram estudados e implementados numa planta piloto a abordagem de controle superviséorio de sistemas hébridos. Os aspectos de controle supervisoério de sistemas híbridos foram abordados no cap. 4. A principal contribuicão deste trabalho foi da abordagem utilizada por (Gonzales 2000) e (Cury e Niinomi 1998) com aplicaçcaão préatica. Foi feita uma modelagem sobre as caracterésticas hébridas da planta piloto, modelo autámato híbrido e séntese de um supervisor discreto utilizando softwares acadêmicos, como o CheckMate e o Grail. Através destes resultados foi possével implementar um algoritmo que interpretasse o supervisor que controle a planta em tempo real, conforme o problema proposto do cap. 5. A implementacão foi feita em um sistema hébrido relativamente simples, que possui poucas locaçcãoes, mas pode mostrar, com resultados satisfatéorios, a validacçaão da teoria na praética, feita no cap. 7.
8.2	Perspectivas
Algumas sugestoães de pesquisa sobre a implementacçaão de supervisores discretos em sistemas hébridos reais sãao listados a seguir:
• Aperfeiçoamento de técnicas computacionais para a verificação e extraçao de aproximaçcoães do comportamento loégico de sistemas hébridos.
•	Implementacao do formalismo sistemas híbridos em plantas mais complexas. E sempre importante o início da implementaçao de um formalismo em sistemas reais mais simples. Contudo, isto nos leva pensar que sistemas reais mais complexos tambíem podem ser estudados e analisados.
•	A introducçãao da abordagem modular para o controle supervisíorio de sistemas híbridos (Leal 2002). A implementaçao do formalismo de controle supervisírio de sistemas híbridos para plantas reais complexas se tornaraí mais atrativa com a utilizaçcãao de abordagens mais apuradas, como a abordagem modular.
•	Aperfeicçoamento e criaçcãao de ferramentas para verificacçãao de sistemas híbridos. Considerando a ferramenta CheckMate e a dificuldade envolvida no calculo do modelo aproximadoi do comportamento líogico da planta híbrida íe razoíavel considerar melhorias nesta ferramenta, como por exemplo uma melhor documentaçcãao, melhor interface homem maquina, diminuiçao de limitacoes, como a de no de variíaveis de estado.
1Como descrito no cap.6 para este trabalho em particular foi obtido o modelo exato do comportamento lógico da planta híbrida.
Apêndice A
Projeto de Controladores utilizando ã Teoria de Controle Clássica
A.1 Introdução
Este apêndice trata de um projeto de um controlador utilizando a teoria de controle cléssico. Dadas especificaçães de controle, ir-se-é projetar um controlador que satisfaça as especificaçcãoes. O projeto do controlador utiliza o méetodo lugar das raézes, que ée um méetodo onde as raézes da equacçaão caracteréstica saão colocadas em um gréafico para todos os valores do ganho de malha aberta.
A.2 Projeto do controlador
Nível de água no tanque:
Esta seçcãao dar-se inécio no projeto de um controlador. O processo escolhido a ser controlado ée:
Hís! =	4-85	(A 1)
F(s)	163.05s + 1	v ’ 7
que utiliza os valores de ganho e constante de tempo ilustrados na tabela 6.1. Foi escolhido tais valores devido ao valor de referôencia se situar dentro do intervalo 60cm &amp;lt;h &amp;lt;68cm, que é o mesmo intervalo para os valores de ganho e constante de tempo do nével descritos na eq. A.1.
A.2.1 Especificações de Controle
O projeto do controlador deverí satisfazer as seguintes especificações:
•	Sobre-sinal maximo1 SSM &amp;lt;4%. Para evitar que o tanque encha.
•	Tempo de acomodação2 ts = 8s. Usada para obter uma resposta rápida do sistema.
O primeiro passo á definir um controlador. O controlador será do tipo atraso de fase. Mais especificamente um PI, que possui um polo na origem.
O controlador á o mesmo da eq. A.2, mas reescrito da forma:
C (s) = k'c
Ti s + 1
(A.2)
s
onde ki = T e k'c =	.
COMPENSADOR	PROCESSO
Figura A.1: Diagrama de Blocos do sistema nível-controlador
A.2.2 Cálculo dos pólos do Sistema com controlador em malha fechada
A equaçao característica do sistema da fig. A.1 á de segunda ordem do tipo
s2 + 2^un + w2 — 0
(A.3)
que possui duas raázes do tipo:
ráSM é o maior desvio da saída para a entrada.
2ts e o tempo que o sistema leva para entrar na regiao de regime permanente. Neste caso, o critério utilizado e de 2 %.
S12 =	± jun\/1 — £2
(A.4)
Calcula-se os polos de malha fechada (MF) da equagao característica do sistema. Para isso,utiliza-se a definicao do SSM que í:
SSM = exp(

(A.5)
Para SSM = 0, 04 tem-se que £ = 0, 71564. Utiliza-se agora a definicão de ts com o critírio de 2%:
substituindo o valor de ts = 8 obtém-se un = 0, 69867. Para calcular os pólos de MF, basta substituir os valores numéricos de £ e zn na eq.A.4:
si2 = —0, 5 ± j0, 34085
(A.7)
Define-se então o ponto po do plano s da locacão de pólos de MF. Tal ponto pode ser qualquer um dos pólos da eq. A.7, cujo módulo é:
|po| = 0, 60513
(A.8)
O compensador devera introduzir uma fase quase nula em po e que o ganho em baixas frequências permita aumentar o valor do ganho do sistema em 5 vezes. Para isso o controlador teraí um par píolos-zeros com a seguinte relacçãao.
|p| &amp;lt;|z|&amp;lt;&amp;lt;|po|
(A.9)
Para o controlador PI, |p| = 0. Isto significa que basta z ser diferente de zero para atender a primeira desigualdade da eq. A.9. Na segunda desigualdade da eq. A.9, a regra pratica para o cílculo í escolher |z| no mínimo dez vezes menor que [po^ Entao o valor de |z| = 0,060513. Com isso, o valor de Ti = z-1 = 16,53. Para facilitar os cílculos escolheu-se Ti = 17.
O proíximo passo íe traçcar o lugar das raízes para o ganho do sistema com controlador em malha aberta (MA).
A.2.3 Gráfico do lugar das raízes
Para se analisar o ganho do sistema com controlador em MA í de grande utilidade esboçar o grafico do lugar das raízes (LR). Com este metodo temos todos os valores de ganho de zero atíe infinito e podemos analisar a posiçcaõo dos píolos do sistema para cada valor deste ganho.
Dar-se início ao LR calculando a funçõo de transferência em MA.
G(s)=C (s) Hs)
4, 85kC
17s + 1 163,05s2 + s
(A.10)
Para o LR, calcula-se a FT de MA com um fator multiplicativo do tipo:
1	+ KG'(s) = 0
(A.11)
substitui-se a eq. A.10 na eq. A.11 e obtíem-se
1 + K
17s + 1 163,05s2 + s
=0
(A.12)
onde K = 4, 85k'c.
Pólos de G(s): sõo os pontos onde K = 0.
Portanto, p1 = 0 e p2 = -6,133 • 10-3
Zeros de G(s): sao os pontos onde K = x.
Portanto, z1 = x e z2 = -5, 882 • 10-2
Determinação do no de ramos:
O numero de ramos í o grau da equaçõo característica. Portanto sõo dois ramos.
Ponto de teste sobre o eixo real s = — 1:
A direita deste ponto haí dois poílos e um zero, onde a soma total íe trâes3. Portanto s G LR
Intersecção das Assintotas:
3	O no ímpar da soma de pólos e zeros finitos significa que o ponto está na LR e no par significa LR Complementar.
Esta sobre o eixo real e é único para LR.
Ja
Epolos finitos — Ezeros finitos
nm
(A.13)
Onde n e m sao os no de pélos e zeros finitos respectivamente e aa é o ponto de interseccão das asséntotas. Logo, aa = 0, 0564.
Angulos da assintotas:
E o angulo entre 2(n — m) asséntotas. O cálculo do êngulo é feito pela seguinte equacão:
&amp;amp; = ±180(21 + " (l = 0,1,2, ...|n — m|)
nm
(A.14)
Logo, Jo =	= 180. As duas asséntotas possuem um ôngulo de 180 graus entre si
no ponto aa.
Angulo de partida dos pólos e de chegada dos zeros:
Todos os poélos e zeros finitos sõao reais. Portanto o aôngulo de partida para os poélos e de chegada para os zeros é de ±180.
Interseccão com o eixo imaginario:
No pélo s = ju = 0 é a intersecçõo com o eixo imaginério. Logo K = 0 e u = 0.
Pontos de ramificacão ou pontos sela:
Correspondem às raézes de ordem múltipla. Se n ramos se aproximam, n ramos deixam com o ponto de ramificaçao com espacamento 'j". Logo , sao dois ramos que deixam o(s) ponto(s) de ramificacao com espacamento de 90o.
Condiçcõoes para o céalculo do ponto de ramificaçcaõo.
•	condiçõo necessaria mas nao suficiente: d' ±' = 0
•	as solucões desta equacõo devem também satisfazer a eq. A.11 quando a soluçõo for raézes complexas. Para raézes reais sempre existe um K que satisfaz a eq.A.11, bastando apenas verificar se os pontos pertencem ao LR ou ao lugar das raézes complementar (LRC).
Entãao faz-se
d	17s +1	=0
ds 163,05s2 + s
(A.15)
apos algumas manipulaçcõoes algebricas, obtem-se a seguinte equaçcõao:
2771,85s2 + 326,1s + 1 = 0	(A.16)
A solucão da eq. A.16 e s1 = -3,1509 • 10-3 e s2 = -0,1145. Sao raízes reais, portanto são pontos de ramificacão. Ambos do LR, pois s1 esta a direita dos dois polos e do zero, sendo portanto trâs pontos e o s2 esta à direita somente do polo na origem, caracterizando assim, um ponto.
Na figura A.2 mostra o esboco grafico do lugar das raízes com a regiao £ &gt; 0, 715 onde os pílos de MF do sistema devem se situar na regiao conica formada pelas duas retas.
Figura A.2: Grífico do lugar das raízes
Cálculo do modulo de K para o ponto s2 = —0,1145:
|K| = Wí	&lt;A-17)
Substituindo s2 na eq. A.17 obtemos K = 2,14.
Cílculo do mídulo de K para o ponto s^n = — &amp;amp;n = —0, 5, que í o valor da parte real de po. Substituindo s^n na eq. A.17 obtemos K = 5, 368. Com isso, k'c = 1,107.
O grafico da fig. A.3 ilustra o comportamento do sistema com o controlador PI.
Pode-se observar que as especificacçoões do sistema nõao foram atingidas. Isto se deve ao fato de que o zero do controlador e muito pequeno, proximo dos polos dominantes
Figura A.3: Resposta do sistema com controlador
e também porque o cálculo dos pólos em MF feito na eq. A.4 é para uma função de 2a ordem pura, não levando em conta o zero. Observa-se pela fig.A.2 que aumentando o valor de K, o SSM cai. Com isso, colocando o valor de em torno de 14,55 , teremos k'c = 3, 0. O grafico da fig.A.4 ilustra a nova resposta do sistema:
Figura A.4: Resposta do sistema com k'c = 3, 0.
Nota-se que o pico maximo foi de aproximadamente 0, 66 metros que corresponde a um SSM de 3,1%, satisfazendo a especificaçao. No caso do tempo de acomodação, tal especificacao pode ser relaxada, pelo fato de que a especificaçao importante para este sistema seja o SSM, para que se evite que o tanque encha. Um fator importante nao considerado aqui, mas considerado no problema tratado neste documento é a saturacao da valvula. A vazao maxima é em torno de 0, 5 litros por segundo. Com isso, a resposta do sistema com saturaçcaão seraé bem mais lenta que a resposta sem saturaçcaão, que ée o que ocorre na praética.
Aqui é ilustra-se um grafico da planta piloto com o controlador de nível.4
4O atraso inicial do resposta e em virtude da demora do operador em ligar o processo com relação a plotagem do grafico.
Figura A.5: Resposta do nével na planta piloto
Temperatura:
Para a temperatura, foi projetado um controlador PI para a função de transferência daeq. 5.28 com os valores da Ultima linha da tab. 6.2. Utilizou-se a mesma metodologia feita para o nível de agua e os resultados foram:
kc = 29,3
Ti = 18	(A.18)
A.3 Discussão
Este apêndice tratou de um projeto de um controlador PI feito passo a passo utilizando a teoria de controle ciassica. Este projeto tem como intuito mostrar uma metodologia de projeto e não uma técnica de controle. Parâmetros de controle como as pertubacoes, filtros de referência e atraso de transporte não foram tratados, apesar de serem bastante relevantes para a teoria de controle, devido ao fato de que esta não é a proposta de trabalho deste documento e sim o controle de um sistema hébrido por um supervisor discreto sob a abordagem de Sistemas Híbridos e Sistemas a Eventos Discretos. Os controladores do ponto de vista de um sistema híbrido, sao apenas um subconjunto do conjunto de todas as dinaêmicas conténuas deste sistema. Por fim, ressalta-se que as especificaçães foram um meio utilizado para ser uma referência de projeto, mas o ajuste final se baseou em atender apenas uma especificaçao (o SSM para o nível e o ts para a temperatura) e nao foi levado em conta a saturaçao. Contudo, resultados préaticos mostraram que a resposta do sistema nével com controlador foram satisfatérias, mesmo com a saturaçao real existente.
Apêndice B
Algoritmo de implementação no MATLAB
Este apôendice ilustra o coádigo de instrucçõoes do algoritmo jogador de autoômatos C/E conectado ao servidor OPC da planta piloto descrito no cap.7.
clear all
k=input('Informe o n. de amostras ')
To=input('Informe a temperatura ambiente ')
s=input('Informe o nome completo do supervisor ')
% Parte 1:
% Funcao que converte o arquivo do grail em uma matriz contendo
% a funcao de transicao do supervisor C/E
[X, V, U, n, Mark, name] = grailce2mat(s);
sortrows(X ,[1 2]);	% Ordena a matriz X de forma crescente em
% relacao as colunas 1 e 2
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parte 2: Criacao dos ervidor OPC
OPC = actxserver('Softing.SOAXC.OPCDataControl.1 ' )	;
% Selecao do servidor OPC
set(OPC, 'ServerName ' , 'Smar.DfiOleServer.0'); set (OPC , 'UpdateRate ' , 1000)	;
% Selecao das variaveis I = get (OPC , 'Items')
invoke(I, 'AddItem',
Ni v e l
de agua no
tanque
invoke(I, 'AddItem',
do processo
'LD_AI.PV.VALUE')	;
'FY_AO.OUT.VALUE')	;
'LD_PID.SP.VALUE ')	;
'LD_PID.GAIN')	;
' LD_PID.RESET ' ) ;
do posicionador de valvula
% Saida
invoke (I ,	AddItem' ,
% Setpoint	do nivel
invoke (I ,	AddItem' ,
% Ganho kp	
invoke (I ,	AddItem' ,
% Ganho Ti	
invoke (I ,	' AddItem' ,
' TT_AI . PV . VALUE ' )
% Valor da invoke (I ,
% Sa i d a do invoke (I ,
temperatura
AddItem', 'FI_AO.OUT.VALUE
conversor de potencia
AddItem' ,	' TT_PID. SP. VALUE
)
)
% Setpoint da temperatura invoked, 'AddItem', 'TT_PID.GAIN')	;
% Ganho kpt invoked, 'AddItem', ' TT_PID . RESET ' ) ;
% Ganho Tit
% Obter acesso individual a cada uma das variaveis
ItemH	= get	(I,	' Item'	,0)
ItemFY_	AO = get	(I,	' Item'	,1)
ItemPID	_SP = get	(I,	' Item'	,2)
ItemPID	_kp = get	(I,	' Item'	,3)
ItemPID	_Ti = get	(I,	' Item'	,4)
ItemT		= get	(I,	' Item	' ,5) ;
ItemFI_AO		= get	(I,	' Item	' ,6) ;
ItemTTPID_	SP	= get	(I,	' Item	' ,7) ;
ItemTTPID_	kp	= get	(I,	' Item	' ,8) ;
ItemTTPID_	Ti	= get	(I,	' Item	' ,9);
% Conexao	ao	servidor		OPC e	atualizacao
invoke (OPC	,	Connect ' )			
invoke (OPC	,	Update	');		
das variaveis
get (ItemH, 'Value'); get (ItemT, 'Value');
pause(2)
invoke (OPC , get (ItemT ,
'Update '); 'Value ')
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
% Parte 3: Declaracao de parametros utilizados ao longo
% do algoritmo
[m,n]= size(X);
UU=[] ;
P=[] ;
state = X(1 ,1);
q=100;
tic
c o nt = 1 ;
Time = [] ;
fq = 0;
ff = 1;
flag=0;
fv = 0;
To=26;
%	Informa as m linhas e n colunas	de	X
%	Vetor Sinal condicao		
%	Vetor Sinal Evento		
%	Informa o estado inicial		
%	Sempre sera o primeiro elemento	da	matriz por
%	causa do comando " sortrows "		
% Temperatura ambiente
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Parte j:
% Testa o automato atraves de um jogador de automatos C/E
while cont&lt;=k
if fq = = 0
% Numero
de amostras que se deseja analisar
Teste para evitar que na ocorrencia de um
% evento
o comando pause seja executado 2 vezes
invoke (OPC ,
pause (2)
end
'Update ');
% Pausa a
% Atualizacao das variaveis execucao do algoritmo em 2 seg
% Principais h(cont) = T(cont) = Q(cont) = v(cont) =
variaveis da planta piloto get (ItemH, 'Value'); get (ItemT, 'Value'); get (ItemFI_AO, 'Value'); get (ItemFY_AO, 'Value');
% Nivel
% Temperatura
% Potencia
% Valvula
fq = 0;
% Parte:5 Associacao dos eventos com os cruzamentos de
% patamares.
if ff == 1	% Teste para que a rotina seguinte ocorra uma
% unica vez apos encontrar o estado.
for i=1:m % Localiza o estado atual na matriz X
if state == X(i ,1)
ff=0;
break;
end
end
end
j = i;
while state= = X(j ,1) % Testa todos os eventos possiveis de % ocorrer pertencentes a um estado
P = X(j ,2);
[fv]= eventos(cont, p ,h, T, To); % Funcao eventos
if fv==1
disp (p)
break;
end
j=j+1;
if j &gt;m
break;
e nd
end
P( cont)=fv*p; % Valor do sinal evento
% Parte 5: Verifica-se a condicao associada e estado
% atingido apos uma ocorrência de um evento
if fv==1 % Indica que ocorreu um evento no estado atual
[u, state] = nao_determinismo_temp(j , m, p, X)
% Funcao que fornece o valor de u nao
% deterministico associado ao evento corrente
flag=1;
fq = 1;
ff = 1; fv=0;
% Habilita a funcao condicoes
% Desabilita atualizacao inicial
% de variaveis
% Habilita localizacao de estado
% Indica que nao ocorreu nenhum evento
% no estado atual
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
UU(cont)= u; % Sinal condicao
% Parte 6:
if flag==1
% teste para que a condicao seja aplicada
% somente na ocorrencia de um evento
% condicao aplicada
q = condicoes_temperatura(OPC, To , ItemPID_SP , ItemPID_kp , ItemPID_Ti, ItemTTPID_SP, u)
fq=i;
e nd
Time (cont)=toc;
[h(cont) T(cont) P(cont)
UU( cont )
Time(cont) ] ;
cont=cont+1; % Atualiza contador de amostras
flag=0; % Zera o flag para que se aplique as condicoes
% somente quando a condicao fv=1 (ocorreu um evento) % fo r s at i s fe i t a
end
save data h T P UU Time % Salva as amostras das variaveis em
% um arquivo de extensao . mat
|| invoke (OPC ,
’Disconnect’) % Fim do algoritmo
Algoritmo B.1: Corpo principal do Jogador de Autâmatos.
//
function [X, V, U, n, Mark, name] = grailce2mat(file)
% Converte o arquivo .do para .mat
if ~ exist (file ) ,
error([ 'File ’ char(file) ’ not f ound! ’ ]);
end
[path,name,ext] = fileparts (file);
ini	= 0;			
Mark	= []	i		
X =	[];			
V=[]	; %	vetor	de	eventos
U=[]	; %	vetor	de	condicoes
fid = fopen(file);
s=fgetl(fid);
while ischar (s)
if ~isempty(strfind (s ,’| -	’))
ini = sscanf(s,’(START)	|- %u ’);
elseif ~isempty ( strfind (s, ’ -| ’))
Mark = [Mark sscanf (s, ’%u -|	(FINAL)')];
else
Trans = sscanf (s,’%i	[%i,%i] %i’);
if length(Trans)==4
X = [X; Trans ’] ;
if ~any(V = =Trans (2))
V = [V Trans (2)] ;
end
if ~any(U = =Trans (3))
U = [U Trans (3)] ;
end
end
e nd
s = fgetl(fid) ;
end
V=sort(V) ;
U=sort(U);
X=sortrows(X , [ 1 2]);
n = max([X(: ,1) ;X(: ,4) ] ) + 1;
fclose (fid) ;
disp(X)
i)
Algoritmo B.2: Conversão do arquivo no formato Grail para uma Matriz.
function [fv]= eventos(cont , p ,h, T)
%
%
%
Funcao que verifica a ocorrência ou nao de eventos pertencentes ao estado atual
Funcao especifica para o automato hibrido da fig . 6.1
switch p
case 0
if h(cont)&gt;=-1
f v = 1;
else
f v=0 ;
end
% Variavel evento
% Patamar cInicializaao da planta
% Ocorreu o evento 0
% Nao ocorreu eventos
case 1
if h(cont)&gt;=52
f v = 1;
else
f v=0 ;
e nd
% Patamar chaveamento de controladores
% Ocorreu o evento 1
% Nao ocorreu eventos
case 3
if h(cont)&gt;=60
% Patamar Indica resistencias ligadas
fv=1;
else
fv=0;
e nd
case 4
if T(cont)&gt;=2+To
fv = 1;
else
fv = 0;
e nd
case 5
if h( cont)&gt; = 67 fv = 1;
else
fv=0;
e nd
% Patamar Encher o tanque
% Patamar Tanque esta cheio
case 7
if T(cont)&gt;=3+To fv = 1;
else
fv=0;
e nd
case 6
if h( cont)&amp;lt;= 60 fv = 1;
else
fv=0;
e nd
case 2
if h( cont)&amp;lt;= 1
% Patamar Temperatura muito alta
% Patamar Desliga resistencias
% Patamar Tanque vazio
fv = 1;
else
fv = 0;
end
end
return
Algoritmo B.3: Funcõo de Configuraçao de Eventos.
function q = condicoes_temperatura(OPC, To, ItemPID_SP , ItemPID_kp , ItemPID_Ti , ItemTTPID_SP , u)
% Associando as dinámicas possiveis a cada estado atraves da % condicao u
switch u, %Variavel condicao
case 1 % Estado inicial
tanque enchendo
set (ItemPID_Ti , 'Value pause(2)
invoke(OPC, 'Update'); set (ItemPID_kp , 'Value pause (2)
invoke(OPC, 'Update'); set (ItemPID_SP , 'Value invoke(OPC ,	' Update ' ) ;
pause (2)
,100000);% Ti
,50)
,60)
Nivel com Controle
Proporcional
Setpoint do nivel em 60cm
q=
get (ItemPID_SP, 'Value % funcao
Artificio para
case 3
set
% Chaveia
(ItemPID_kp (ItemPID_Ti
set
invoke (OPC , pause (2)
seja aceita.
i
Variavel sem funcao
contro le de
'Value ' ,3);
'Value',18);
&gt;
'Update ');
nivel proporcional Controle PI Kp Ganho Ti
%
%
%
%
Atualizacao das
que a presente no algor itmo.
PI
variaveis
Pause para atualizacao
o
&gt;


i
%
%

i
%

)
%
q= get (ItemPID_SP, 'Value')
i
case 2 % Tanque esvaziando com temp. desligada set (ItemPID_SP, 'Value', 0);
invoke(OPC, 'Update');
pause(2) q= get (ItemPID_SP, 'Value');
case 4	% Liga o conversor, temp em malha aberta e tanque
% enchendo
set (ItemPID_SP , 'Value’,67); % % set (ItemTTPID_SP ,	'Value',10);
invoke(OPC, 'Update');	%
pause (2)	%
q= get (ItemPID_SP, 'Value');
Setpoint do nivel para tanque cheio
Atualizacao das variaveis
Pause para atualizacao
case 5
% Liga o conversor, temp com controle PI e tanque
% enchendo
set (ItemPID_SP ,	'Value',67);	% Setpoint do nivel para
% tanque cheio
set (ItemTTPID_SP , 'Value',To+2);	% Referencia da temperatura
% igual a 2
invoke( OPC ,	' Update ' ) ;	% Atualizacao das variaveis
pause (2)	% Pause para atualizacao
q= get (ItemPID_SP, 'Value');
case 6 % Liga o conversor, temp em malha aberta com PI em 64cm % no nivel
set (ItemTTPID_SP ,	'Value',10);	% malha aberta
set(ItemPID_SP, ’Value’ ,64); % Setpoint do nivel em 64cm invoke(OPC, 'Update');	% Atualizacao das variaveis
pause (2)	% Pause para atualizacao
q= get (ItemPID_SP, 'Value');
case 7	% Liga o conversor, temp com controle PI e com
% controle PI em 64cm no nivel
set (ItemTTPID_SP , 'Value',To+2);
set ( ItemPID_SP ,	' Value ' , 64) ;	% Setpoint do nivel em 64cm
invoke( OPC ,	' Update ' ) ;
pause (2)
q= get ( ItemPID_SP ,	' Value ' ) ;
case 8	% O tanque comeca a esvaziar
set (ItemPID_SP , 'Value' , 0); %Valvula em 0% invoke(OPC, 'Update');
pause(2)
q = get (ItemPID_SP, 'Value');
case 10 % Controle de temperatura com tanque cheio: SUCESSO
set (ItemTTPID_SP , 'Value',To+2); invoke(OPC, 'Update');
pause (2)
q= get (ItemPID_SP, 'Value');
case 9 % Temperatura em malha aberta e tanque cheio
set (ItemTTPID_SP , 'Value',10); invoke(OPC, 'Update');
pause (2)
q= get (ItemPID_SP, 'Value');
case 11 % Estado indesejado, tanque vazio
invoke(OPC, 'Update');
pause(2)
q= get (ItemPID_SP, 'Value');
end
return
Algoritmo B.4: Funçao de Configuração de Condicães.
	 function [u , state] =			nao_determinismo_temp(j, m, p, X)	—
% Funcao para gerar		uma condicao u nao-deterministica		
B=[] ;				
b=j;		%	Guarda alinha da matriz x	
c = 1;		%	Declara o indice de B	
while X(b , 2)= = p		%	Testa quantas çcondioes estao	
		%	associadas ao evento p	
B(c)=X(b,3);		%	Guarda o valor do sinal u no vetor linha	B
c=c+1;		%	Atualiza contadores	
b=b+1;				
if b&gt;m		%	Evita erro de dimensao de X	
break;				
end				
end				
z=length(B);		%	Calcula o tamanho do vetor B e guarda em	z
d=randperm(z);		%	Gera o vetor d de tamanho igual ao B	
		%	mas com os indices de B como elemetos	
		%	permutados aleatoriamente no vetor d	
u=X(d(1)+b-c ,3);	%	u	recebe o valor de X com o indice contendo	
	%	o primeiro elemento de d, que eh		
	%	um	indice de B aleatorio, mais a defazagem	
	%	dos	contadores de X e B	
state=X(d(1)+b-c	,4)	;%	state recebe o valor do estado a ser	
		%	atingido associado a condicao u	
		%	anterior.	
return				
					—y
Algoritmo B.5: Funçao de escolha da condição de forma não-determinística.
Referencias Bibliográficas
Allur, R. e Dill, D. L. (1994). A theory of timed automata,, Theorycal Computer Science 126(2): 183-235.
Alur, R. Courcoubetis, C. e Dill, D. (1990). Model checking for a real-time systems, 5th IEEE Symposium on Logic in Computer Science, pp. 414-425.
Alur, R. Courcoubetis, C. H. T. A. e. H. P. H. (1993). Hybrid automata: an algoritmic approach to the specification and verification of hybrid systems, in Grossman et al. p. 209-229.
Antsaklis, P. J. e Koutsoukos, X. D. (2002). Hybrid systems: Review and recent progress., Chapter in Software-Enabled Control: Information Technologies for Dynamic systems. 88(7): 879-557.
Antsaklis, P. J. Stiver, J. A. e Lemmon, M. D. (1993). Hybrid systems modeling and autonomous control systems, in Grossman et al p. 366-392.
Antsaklis, P. J. (2000a). A brief introducion to the teory and aplications of hybrid systems, Proceedings of the IEEE, Special Issue on Hybrid Systems, Theory and applications .
Antsaklis, P. J. (2000b). Special issue on hybrid systems, theory and applications, Proceedings of the IEEE .
Chutinan, A. e Krogh, B. H. (1999a). Computing approximating automata for a class of linear hybrid systems., In Hybrid Systems V, LNCS 1567, Springer-Verlag p. 1637.
Chutinan, A. e Krogh, B. H. (1999b). Verification of polyhedral-invariant hybrid automata using polygonal flow pipe approximations, In Hybrid systems: Computation and Control, Second International Workshop, Springer-Verlag p. 76-90.
Chutinan, A. e Krogh, B. H. (2001). Verification of infinite-state dynamic systems using approximate quotient transition systems, IEEE Trans. on Automatic Control 46(9): 1401-1410.
Chutinan, A. (1999). Hybrid system verification using discrete model approximations, Ph.d. in electrical engeneering, Carnegie Mellon University, Pittsburgh, USA.
Cury, J. E. R. Krogh, B. H. e Niinomi, T. (1998). Synthesis of supervisory controllers for hybrid systems based on approximating automata, IEE Transations on Automatic Control, Special issue on Hybrid Control Systems 43(4): 564-568.
Egerstedt, M. (2000). Behavior besed robotics using hybrid automata, Third International Workshop, HSCC 2000 .
Ferrari-Trecate, e. a. (2002). Modeling and control of co-generation power plants:, 5th International Workshop, HSCC 2002 p. 209-224.
Garcia, T. R. (2002). Controle supervisorio de sistemas a eventos discretos: Uma abordagem por modelo condição/evento, Dissertacão de mestrado, Universidade Federal de Santa Catarina, Florianópolis, Brasil.
Gonzales, J. M. E. da Cunha, A. E. C. C. J. E. R. e Krogh, B. H. (2001). Surpevision of event-driven hybrid systems: Modeling and syntesis, 4th International Workshop, HSCC, Rome, Italy.
Gonzales, J. M. E. (2000). Aspectos de .síntese de surpevisores para sistemas a eventos discretos e sistemas híbridos, Tese (doutorado), Universidade Federal de Santa Catarina, Florianoópolis , Brasil.
Halliday, D. Resnick, R. e Walker, J. (1997). Fundamentos de Física 2, 4a ed., Livros Tócnicos e Científicos Editora S.A.
Hopcroft, J. E. e Ullman, J. D. (1979). Introducion to automata theory, languages and computation, Addison-Wesley .
Khalil, H. K. (1996). Nonlinear systems, Prentice Hall.
Krogh, B. H. (2002). Recent advances in discrete analysis and control of hybrid systems, 6o International Workshop on Discrete Event Systems, Zaragoza, Spain.
Leal, A. B. E. e Cury, J. E. R. (2004). Modular supervision of hybrid systems: A des approach, 7th Workshop on Discrete Event Systems.
Leal, A. B. (2002). Controle supervisorio modular de sistemas híbridos, Exame de qua-lificacao (doutor), Universidade Federal de Santa Catarina, Florianópolis, Brasil.
Lennartson, B. Tittus, M. E. B. e Pettersson, S. (1996). Hybrid systems in process control, IEEE, Control Engeneering Lab. Chalmers University of Thecnology, Gothenburg, Sweden.
Liberzon, D. e Morse, A. S. (1999). Basic problems in stability and design of switched systems,, IEEE Control Systems Magazine 19(5): 59-70.
Livadas, e. a. (2000). High-level modeling and analysis of the traffic alert and collision avoidance system, IEEE, Special Issue of Hybrid Systems: Theory and Aplications 88(7): 926-948.
Maler, O. Manna, Z. e Pnueli, A. (1992). From timed to hybrid systems, in the Bakker et al. p. 474-484.
Manna, Z. e Sipma, H. (1998). Deductive verification of hybrid systems usin step, First International Workshop, HSCC 98, Berkeley, California, USA 11(6): 665-683.
Miranda, M. V. C. e Lima, A. M. N. (2001). Using hyibrid automata to model power eletronic circuits,, VI Congresso brasileiro de Eletrônica de Potência - COPEB 2001 .
Moor, T. Davoren, J. M. e Raish, J. (2001). Modular supervisory control of a class of hybrid systems in behavior framework, Proc. euproean Control Conference ECC2001, Porto Portugal p. 870-875.
Nerode, A. e. K. (1993). Models of hybrid systems: Automata, topologies, controllability, observability,, in Grossman et al p. 317-356.
Ogata, K. (1998). Engenharia de Controle Moderno 3a ed.
Pepyne, D. L. e Cassandras, C. G. (2000). Optimal control of hybrid systems in manfacturing, IEEE, Special Issue of Hybrid Systems: Theory and Aplications 88(7): 1108-1123.
Puri, A. e Varaiya, P. (1994). Decidability of hybrid systems with rectangular differential inclusions, 818: 95-104.
Raish, J. e O’Young, S. D. (1998). Discrete approximation and supervisory control of continuous systems, IEEE Transacitons on Automatic Control, Special issue on Hybrid Control Systems 43(4): 569-573.
Rico, J. E. N. (2000). Apostila de Controle Clássico.
Silva, B. I. e Krogh, B. H. (2000). Formal verification of hybrid system using checkmate: A case study, American Control Conference.
Silva, B. I. Richeson, K. K. B. H. e Chutinan, A. (2000). Modeling and verification of hybrid dynamical system using checkmate, ADPM 2000.
Silva, B. I. Stursberg, O. K. B. H. e Engell, S. (2001). An assessment of the current status of algorithmic, approaches to the verification of hybrid systems, Conference on Decision and Control, Carnegie Mellon University, Pittsburgh, USA.
Sreenivas, R. S. e Krogh, B. H. (1991). On condition/event systems with discrete state realizations., Discrete Event Dynamic Systems: Theory and Applications p. 1:209-236.
Stephanopoulos, G. (1984). Chemical Process Control An introducion to theory and practice, Prentice Hall.
Stiver, J. A. Antsaklis, P. J. e Lemmon, M. D. (1995a). Hybrid control system design for hybrid control systems, 34th IEEE Conference on Decision and control, .
Stiver, J. A. Antsaklis, P. J. e Lemmon, M. D. (1995b). Interface and controler designs for hybrid control systems, Hybrid Systems II, Spribger-Velag .
Tavernini, L. (1987). Differencial automata and their discrete simulators, Nonlinear Analysis, Theory, Methods and Aplications 11(6): 665-683.
van der Shaft, A. e Schumacher (2000). An Introducion to Hybrid Dynamics Systems, Vol. 251 of Lecture Notes in Control and Informtion Sciences.
Wonham, W. M. e Ramadge, P. J. (1987). On the supremal controllable sublanguage of given language, SIAM, Journal of Control and Optimization 25(3): 637-659.</field>
	</doc>
</add>