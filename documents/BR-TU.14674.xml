<?xml version="1.0" encoding="utf-8"?>
<add>
	<doc>
		<field name="docid">BR-TU.14674</field>
		<field name="filename">21035_258232.pdf</field>
		<field name="filetype">PDF</field>
		<field name="text">
UNIVERSIDADE FEDERAL DE SANTA CATARINA
PROGRAMA DE PO?S-GRADUAC?A?O EM CIE?NCIA DA

COMPUTAC?A?O

Tu?lio C??cero Salvaro de Souza

Aspectos Te?cnicos e Teo?ricos da Gesta?o do Ciclo de
Vida de Chaves Criptogra?ficas no OpenHSM

Dissertac?a?o submetida a? Universidade Federal de Santa Catarina como parte dos

requisitos para a obtenc?a?o do grau de Mestre em Cie?ncia da Computac?a?o.

Prof. Ricardo Felipe Custo?dio, Dr.
Orientador

Floriano?polis, Outubro de 2008



Aspectos Te?cnicos e Teo?ricos da Gesta?o do Ciclo de Vida de
Chaves Criptogra?ficas no OpenHSM

Tu?lio C??cero Salvaro de Souza

Esta Dissertac?a?o foi julgada adequada para a obtenc?a?o do t??tulo de Mestre em Cie?ncia

da Computac?a?o, a?rea de concentrac?a?o Sistemas de Computac?a?o e aprovada em sua forma

final pelo Programa de Po?s-Graduac?a?o em Cie?ncia da Computac?a?o.

Prof. Frank Augusto Siqueira, Dr.

Coordenador do Curso

Banca Examinadora

Prof. Ricardo Felipe Custo?dio, Dr.

Orientador

Prof. Jeroen Antonius Maria van de Graaf, PhD.

Prof. Joni da Silva Fraga, Dr.

Prof. Michael Anthony Stanton, Dr.

Prof. Olinto Jose? Varella Furtado, Dr.

Prof. Renato da Silveira Martini, PhD.



iii

”Me abafa Dalila ... que eu estou abanado!”

Marco Aure?lio Salvaro de Souza 2005.



iv

Ao meu grande avo? Silvino.



Agradecimentos

Primeiramente, gostaria de agradecer a toda minha fam??lia, principal-

mente aos meus pais, Mariano e Ilda, e a Giani, que se tornou minha esposa durante

a execuc?a?o deste trabalho. E? o apoio de voce?s que garante o sucesso de todas minhas

escolhas de vida.

Tambe?m sou grato ao meu orientador, professor Custo?dio, que esta?

pronto para ajudar a qualquer momento, mantendo sempre a situac?a?o sobre controle. Sua

experie?ncia serve de guia para os membros do LabSEC. Membros estes que, mesmo a um

oceano de dista?ncia, continuam apoiando e ajudando na minha caminhada de descobertas.

Com certeza todos ganham muito convivendo neste ambiente de aprendizado.

Na?o poderia deixar de citar minha gratida?o ao professor, tio, padrinho e

amigo Olinto. Ele ve?m me guiando desde a escolha do curso de graduac?a?o ideal. Nunca

vou esquecer o dia que estava em sua sala, desabafando sobre o meu descontentamento

com o tema do meu trabalho de conclusa?o de curso. Ele virou pra mim e disse: “por que?

voce? na?o vai ali conversar com o Professor Custo?dio, eu acho que voce? tem o perfil para

trabalhar na a?rea de seguranc?a”. Obrigado pelas dicas certas nas horas certas.

E finalmente, agradec?o a Rede Nacional de Ensino e Pesquisa, entidade

que ve?m promovendo o uso de tecnologias avanc?adas nas instituic?o?es parceiras, proporci-

onando aos professores e pesquisadores ferramentas e meios de grande valia na pesquisa

e ensino no Brasil.



Suma?rio

Lista de Figuras x

Lista de Tabelas xi

Lista de Siglas xii

Lista de S??mbolos xv

Resumo xvi

Abstract xvii

1 Introduc?a?o 1

1.1 Infra-estrutura de Chaves Pu?blicas para Pesquisa e Ensino . . . . . . . . 3

1.2 Contextualizac?a?o das Contribuic?o?es . . . . . . . . . . . . . . . . . . . . 5

1.3 Objetivos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8

1.3.1 Objetivo Geral . . . . . . . . . . . . . . . . . . . . . . . . . . . 8

1.3.2 Objetivos Espec??ficos . . . . . . . . . . . . . . . . . . . . . . . . 8

1.4 Justificativa e Motivac?a?o . . . . . . . . . . . . . . . . . . . . . . . . . . 9

1.5 Trabalhos Correlatos . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

1.6 Organizac?a?o deste Trabalho . . . . . . . . . . . . . . . . . . . . . . . . . 11

2 Hardware Criptogra?fico 12

2.1 Introduc?a?o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12

2.2 Smartcards . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13



vii

2.2.1 Smartcards para HSMs . . . . . . . . . . . . . . . . . . . . . . . 14

2.3 Mo?dulo de Seguranc?a Criptogra?fica (HSM) . . . . . . . . . . . . . . . . 15

2.3.1 Ciclo de vida de chaves criptogra?ficas . . . . . . . . . . . . . . . 15

2.3.2 Mo?dulos de Seguranc?a Criptogra?fica de Mercado . . . . . . . . . 16

2.4 Conclusa?o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17

3 Normas 20

3.1 Introduc?a?o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

3.2 FIPS PUB 140 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21

3.2.1 Especificac?a?o do Mo?dulo Criptogra?fico . . . . . . . . . . . . . . 22

3.2.2 Portas F??sicas e Interfaces Lo?gicas . . . . . . . . . . . . . . . . . 22

3.2.3 Pape?is, Servic?os e Mecanismos de Autenticac?a?o . . . . . . . . . 23

3.2.4 Modelo de estados finitos . . . . . . . . . . . . . . . . . . . . . 25

3.2.5 Seguranc?a F??sica . . . . . . . . . . . . . . . . . . . . . . . . . . 25

3.2.6 Ambiente Operacional . . . . . . . . . . . . . . . . . . . . . . . 26

3.2.7 Gerenciamento de Chaves Criptogra?ficas . . . . . . . . . . . . . 27

3.2.8 Interfere?ncia e Compatibilidade Eletromagne?tica . . . . . . . . . 28

3.2.9 Auto-testes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

3.2.10 Garantia de Projeto . . . . . . . . . . . . . . . . . . . . . . . . . 29

3.2.11 Mitigac?a?o de Outros Ataques . . . . . . . . . . . . . . . . . . . . 29

3.3 Manual de Condutas Te?cnicas 7 (LEA/ITI) . . . . . . . . . . . . . . . . 30

3.3.1 Requisitos de Especificac?a?o . . . . . . . . . . . . . . . . . . . . 31

3.3.2 Portas F??sicas e Interfaces Lo?gicas . . . . . . . . . . . . . . . . . 31

3.3.3 Pape?is, Servic?os e Mecanismos de Autenticac?a?o . . . . . . . . . 32

3.3.4 Modelo de Estado Finito . . . . . . . . . . . . . . . . . . . . . . 32

3.3.5 Seguranc?a F??sica . . . . . . . . . . . . . . . . . . . . . . . . . . 32

3.3.6 Ambiente Operacional . . . . . . . . . . . . . . . . . . . . . . . 33

3.3.7 Gerenciamento de Chaves Criptogra?ficas . . . . . . . . . . . . . 33

3.3.8 Interfere?ncia e Compatibilidade Eletromagne?tica . . . . . . . . . 34

3.3.9 Auto-testes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34



viii

3.3.10 Garantia de Projeto . . . . . . . . . . . . . . . . . . . . . . . . . 34

3.3.11 Mitigac?a?o de Outros Ataques . . . . . . . . . . . . . . . . . . . . 34

3.3.12 Requisitos de Gerenciamento . . . . . . . . . . . . . . . . . . . 34

3.3.13 Requisitos de Interoperabilidade . . . . . . . . . . . . . . . . . . 35

3.3.14 Requisitos para restric?a?o de substa?ncias nocivas . . . . . . . . . . 35

3.4 Conclusa?o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 36

4 OpenSSL 37

4.1 Introduc?a?o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37

4.2 Aplicac?a?o de Linha de Comando . . . . . . . . . . . . . . . . . . . . . . 38

4.3 Infra-estrutura de Suporte . . . . . . . . . . . . . . . . . . . . . . . . . . 39

4.3.1 Arquivos de Configurac?a?o . . . . . . . . . . . . . . . . . . . . . 39

4.3.2 Func?o?es de Callback . . . . . . . . . . . . . . . . . . . . . . . . 40

4.3.3 Suporte Multi-thread . . . . . . . . . . . . . . . . . . . . . . . . 41

4.3.4 Matema?tica de Precisa?o Arbitra?ria . . . . . . . . . . . . . . . . . 42

4.3.5 Tratamento de Erros . . . . . . . . . . . . . . . . . . . . . . . . 43

4.3.6 Abstrac?a?o de Entrada e Sa??da . . . . . . . . . . . . . . . . . . . 44

4.4 Documentac?a?o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45

4.5 Engine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46

4.6 OpenSSL FIPS 140-2 n??vel 1 . . . . . . . . . . . . . . . . . . . . . . . . 49

4.7 Conclusa?o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51

5 ASI-HSM 53

5.1 Introduc?a?o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53

5.2 Arquitetura . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54

5.3 Aplicativos de Administrac?a?o Remota . . . . . . . . . . . . . . . . . . . 56

5.4 Engine OpenSSL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57

5.5 Conclusa?o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 58

6 OpenHSM - Operacionalizac?a?o 59

6.1 Aspectos Gerais . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 60



ix

6.2 Inicializac?a?o do HSM e criac?a?o do grupo de Administradores . . . . . . . 64

6.3 Criac?a?o de um grupo de Auditores . . . . . . . . . . . . . . . . . . . . . 65

6.4 Criac?a?o de um grupo de Operadores . . . . . . . . . . . . . . . . . . . . 67

6.5 Criac?a?o de Chave Gerenciada . . . . . . . . . . . . . . . . . . . . . . . . 69

6.6 Liberando uma Chave Gerenciada para Uso . . . . . . . . . . . . . . . . 70

6.7 Troca do grupo de Administratores . . . . . . . . . . . . . . . . . . . . . 71

6.8 Alterando os responsa?veis por uma chave gerenciada . . . . . . . . . . . 73

6.9 Criando o ponto de confianc?a de um grupo de Operadores em relac?a?o aos

Administradores . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74

6.10 Exportac?a?o dos Registros de Atividades . . . . . . . . . . . . . . . . . . 75

6.11 Limpeza dos Registros de Atividades . . . . . . . . . . . . . . . . . . . . 76

6.12 Conclusa?o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77

7 OpenHSM - Co?pias de Seguranc?a 79

7.1 Preparando um HSM para ser uma unidade de backup . . . . . . . . . . . 80

7.2 Importando o Certificado de Backup em HSM Operacional . . . . . . . . 81

7.3 Backup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82

7.4 Recuperac?a?o do Backup . . . . . . . . . . . . . . . . . . . . . . . . . . 84

7.5 Utilizac?a?o de Mu?ltiplos Ambientes Operacionais . . . . . . . . . . . . . 86

7.6 Conclusa?o . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88

8 Conclusa?o 89

8.1 Resumo das Contribuic?o?es . . . . . . . . . . . . . . . . . . . . . . . . . 90

8.2 Trabalhos Futuros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91

Refere?ncias Bibliogra?ficas 92

A Convenc?o?es 97



Lista de Figuras

1.1 Contextualiza a a?rea de atuac?a?o do trabalho . . . . . . . . . . . . . . . . 6

4.1 Funcionamento das func?o?es de callback, empregadas no OpenSSL. . . . . 41

5.1 Visa?o geral da arquitetura do HSM da GT ICPEDU II . . . . . . . . . . . 54

5.2 Interface texto para administrac?a?o remota do HSM do GT ICPEDU II . . 56

5.3 Interface gra?fica para administrac?a?o remota do HSM do GT ICPEDU II . 57

7.1 Processo de criac?a?o de um HSM de backup . . . . . . . . . . . . . . . . 79



Lista de Tabelas

2.1 Categorias dos estados do ciclo de vida de chaves criptogra?ficas quanto a

sua disponibilidade de uso. . . . . . . . . . . . . . . . . . . . . . . . . . 16

2.2 Caracter??sticas do HSM nShield F3 2000 da nCipher . . . . . . . . . . . 17

2.3 Caracter??sticas do HSM Luna PCI 3000 da SafeNet . . . . . . . . . . . . 18

2.4 Caracter??sticas do HSM Keyper PCI da AEP Networks . . . . . . . . . . 19

4.1 Arquivo de configurac?a?o do OpenSSL para carga da engine do ASI-HSM. 40

4.2 Algoritmos Criptogra?ficos Aprovados no OpenSSL FIPS versa?o 1.1.2 . . 50

A.1 Sistemas de armazenamento de dados utilizados no OpenHSM . . . . . . 97



Lista de Siglas

AC Autoridade Certificadora

ACT Autoridade de Carimbo de Tempo

AES Advanced Encryption Algorithm (Algor??tmo de Cifragem Avanc?ada)

ASN Abstract Syntax Notation (Notac?a?o para Sintaxe Abstrata)

ANSI American National Standards Institute (Instituto Nacional de

Padro?es Americanos)

API Application Program Interface (Interface de Programac?a?o de Aplica-

tivos)

AR Autoridade de Registro

BIO I/O Abstraction (Abstrac?a?o de Entrada e Sa??da )

CBC Cipher Block Chaining (Encadeamento de Blocos Cifrados)

CC Common Criteria (Crite?rios Comuns)

CSP Critical security parameter (Para?metro Cr??tico de Seguranc?a)

DER Distinguished Encoding Rules

DES Decryption and Encryption Standard (Padra?o de Cifragem e Decifra-

gem)

EAL Evaluation Assurance Level (N??vel de Garantia de Avaliac?a?o)

FCC Federal Communications Commission

FIPS Federal Information Processing Standard (Padra?o Federal de Proces-

samento de Informac?o?es)

GSM Global System for Mobile communications (Sistema Global para

Comunicac?o?es Mo?veis)



xiii

GT Grupo de Trabalho

HSM Hardware Security Module (Mo?dulo de Seguranc?a Criptogra?fica)

ICP Infra-estrutura de Chaves Pu?blicas

ICPEDU Infra-estrutura de Chaves Pu?blicas Educacional

ICP-Brasil Infra-estrutura de Chaves Pu?blicas Brasileira

IEEE Institute of Electrical and Electronics Engineers (Instituto de Enge-

nharia Ele?trica e Eletro?nica)

ISO Internal Organization for Standardization (Organizac?a?o Internacio-

nal para Padronizac?a?o)

ITI Instituto Nacional de Tecnologia da Informac?a?o

JCA Java Communications API (API de comunicac?a?o Java)

JCE Java Cryptography Extension (Extensa?o de criptografia JAVA)

LCR Lista de Certificados Revogados

LEA Laborato?rio de Ensaios e Auditoria

MCT Manual de Condutas Te?cnicas

NIST National Institute of Standards and Technology (Instituto Nacional

de Padro?es e Tecnologia)

NSF N??vel de Seguranc?a F??sica

NSH N??vel de Seguranc?a de Homologac?a?o

OSSI Open Source Software Institute (Instituto de Software de Co?digo

Aberto)

PEM Privacy Enhanced Mail

PIN Personal Identification Number (Nu?mero de Identificac?a?o Pessoal)

PKCS Public Key Crypto System

PUK Personal Unlocking Code (Co?digo de Desbloqueio Pessoal)

RNP Rede Nacional de Ensino e Pesquisa

RoHS Restriction to the use of Hazardous Substances

RSA Rivest, Shamir e Adelman

SGC Sistema de Gerenciamento de Certificados Digitais



xiv

SHA Secure Hash Algorithm (Algoritmo Seguro de Resumo Crip-

togra?fico)

SO Sistema Operacional

SSL Secure Sockets Layer

TLS Transport Layer Security

UFSC Universidade Federal de Santa Catarina

UFMG Universidade Federal de Minas Gerais

UG Unidade Gestora

Unicamp Universidade de Campinas

US Unidade de Seguranc?a

USB Universal Serial Bus

WEEE Waste from Electrical and Electronic Equipament



Lista de S??mbolos

? Menor ou igual que
? XOR / Ou exclusivo



Resumo

O OpenHSM e? um protocolo aberto para gesta?o do ciclo de vida de

chaves criptogra?ficas em mo?dulos de seguranc?a criptogra?fica, voltado principalmente

para implantac?a?o de Infra-estruturas de Chaves Pu?blicas. Esta dissertac?a?o formaliza

e apresenta os va?rios sub-protocolos que juntos permitem a gesta?o confia?vel das cha-

ves criptogra?ficas. Os protocolos foram implementados e embarcados em um hardware

criptogra?fico especialmente desenvolvido para evitar o acesso ao material sens??vel dos

mesmos. Deu-se especial atenc?a?o aos aspectos pra?ticos da implementac?a?o tal como sua

adere?ncia as normas nacionais e internacionais – MCT-7 e FIPS PUB 140-2 – e sua in-

terface de comunicac?a?o com a aplicac?a?o de gesta?o de certificados digitais. Tambe?m sa?o

tratados os processos de criac?a?o e recuperac?a?o de co?pias de seguranc?a do OpenHSM,

possibilitando a continuidade do ciclo de vida das chaves gerenciadas mesmo em caso de

falhas ou desastres.



Abstract

The OpenHSM is an open protocol that has been developed to manage

the life cycle of the cryptographic keys in hardware security modules, mainly addres-

sed to public key infrastructure deployment. This thesis formalises and presents all sub-

protocols that together provide reliable management of cryptographic keys. The protocols

have been implemented and embedded in a cryptographic hardware especially develo-

ped to avoid unauthorized access to its sensitive data. Special attention was given to the

practical aspects of the implementation, such as adherence to national and international

standards – MCT-7 and FIPS PUB 140-2 – and integration with certificate management

systems. The processes of creation and recovery of backup copies are also included in

this thesis, permitting the continuity of the management keys’ life-cycle even in the event

of hardware failures or disasters.



Cap??tulo 1

Introduc?a?o

Hardware ou mo?dulos criptogra?ficos1 te?m sido usados como a?ncoras

de confianc?a em sistemas de informac?a?o e comunicac?a?o. Sa?o dispositivos especialmente

projetados para o armazenamento e o processamento seguro de informac?o?es sens??veis, tal

como chaves criptogra?ficas. Entre os modelos mais conhecidos esta?o os carto?es inteligen-

tes ou smartcards e os mo?dulos de seguranc?a criptogra?fica (HSMs)2. Ambos sa?o usados

para a gerac?a?o, protec?a?o e processamento de chaves criptogra?ficas. Os smartcards sa?o

mais simples que os HSMs em termos de funcionalidades, quantidade e qualidade dos

mecanismos de protec?a?o das chaves e registro dos eventos associados ao ciclo de vida das

chaves criptogra?ficas, capacidade de processamento e formato f??sico.

Os smartcards sa?o amplamente usados como dispositivo de autenticac?a?o

de clientes em aplicac?o?es banca?rias e cidada?os em sistemas de governo eletro?nico (e-

CPF). Em alguns pa??ses europeus e estados norte-americanos, por exemplo, os smartcards

sa?o utilizados como carta?o de identificac?a?o do cidada?o ou licenc?a de motorista.

Os HSMs, por sua vez, sa?o dirigidos a sistemas mais complexos que

requerem um maior rigor no controle e auditoria do material sens??vel armazenado e pro-

cessado.

O grande mercado dos HSMs sa?o as aplicac?o?es militares e banca?rias.

Nessas aplicac?o?es, os HSM sa?o usados para processar informac?o?es de autenticac?a?o de

1Neste trabalho os termos hardware criptogra?fico e mo?dulo criptogra?fico sa?o usados indistintamente.
2HSM vem do Ingle?s e significa Hardware Security Module.



2

usua?rios, registros de eventos cr??ticos, assinatura de mensagens e execuc?a?o segura de

co?digo.

Um nicho pouco explorado mas importante para o uso de HSMs sa?o as

infra-estruturas de chaves pu?blicas (ICP) e suas aplicac?o?es, tais como autoridades certi-

ficadoras (AC), autoridades de registro (AR) e autoridades de carimbo de tempo (ACT).

Neste nicho, na?o seriam necessa?rias algumas das funcionalidades e potencialidades exis-

tentes nos HSM dispon??veis no mercado, ao mesmo tempo em que precisariam de outras

caracter??sticas na?o contempladas, tal como um tratamento mais elaborado da criac?a?o e

recuperac?a?o de co?pia de seguranc?a do material sens??vel. Esta lacuna e? exaustivamente

explorada neste trabalho.

Para a garantia da qualidade e padronizac?a?o dos servic?os e mensagens

processadas pelos hardwares criptogra?ficos, estes podem e devem ser desenvolvidos se-

gundo normas e recomendac?o?es de entidades tais como o National Institute of Standards

and Technology (NIST) e a Organizac?a?o Internacional para Padronizac?a?o (ISO). Dentre

as va?rias normas existentes, a FIPS 140-2 promovida pelo NIST trata especificamente de

hardware criptogra?fico, com a criac?a?o de um servic?o de homologac?a?o de tais dispositivos.

O fabricante de um hardware criptogra?fico pode solicitar a homologac?a?o de seu equipa-

mento segundo os requisitos e recomendac?o?es apostas na norma. Apo?s a avaliac?a?o pelo

NIST ou por uma entidade credenciada, o hardware criptogra?fico recebe um atestado de

adere?ncia. Este atestado e? exigido por inu?meras organizac?o?es como requisito para a sua

aquisic?a?o.

Entretanto, ale?m de preocupac?o?es te?cnicas, deve-se considerar a questa?o

de seguranc?a nacional, principalmente quando o HSM e? usado para proteger informac?o?es

de governo, militares e de empresas brasileiras. Em determinadas aplicac?o?es, conside-

radas de seguranc?a nacional, tais dispositivos devem ser de absoluta confianc?a. Na?o e?

suficiente ter uma declarac?a?o do NIST ou de outra entidade internacional atestando que o

hardware criptogra?fico e? seguro e respeita os requisitos, recomendac?o?es e boas pra?ticas de

um hardware a ser usado como a?ncora de confianc?a. E? necessa?rio que o HSM seja pass??vel

de auditoria - deve ser poss??vel avaliar a seguranc?a dos mecanismos criptogra?ficos e, em

particular, a gerac?a?o de chaves criptogra?ficas. Como tais dispositivos precisam ser natu-



3

ralmente lacrados para evitar que seja poss??vel o acesso a informac?a?o sens??vel, tal audito-

ria na?o pode ser realizada. E? necessa?rio confiar-se cegamente na entidade certificadora e

no fabricante.

Com esta preocupac?a?o em mente, o governo brasileiro, sabiamente,

atrave?s do Instituto Nacional de Tecnologia da Informac?a?o (ITI), estabeleceu normas e

criou laborato?rios de ensaios e ana?lises (LEA) para avaliac?a?o de sistemas e equipamen-

tos a serem usados pela Infra-estrutura de Chaves Pu?blicas Brasileira (ICP-Brasil) e suas

aplicac?o?es. Foi criado uma se?rie de normas de avaliac?a?o dos equipamentos e sistemas,

com va?rios n??veis de ana?lise. A mais rigorosa requer o depo?sito do co?digo fonte da

aplicac?a?o e do sistema operacional embarcado.

Apesar do grande mercado e de questo?es de seguranc?a nacional, o Bra-

sil ainda esta? engatinhando em relac?a?o ao dom??nio tecnolo?gico e fabril de dispositivos

de hardware criptogra?ficos. Duas louva?veis iniciativas merecem destaque quanto ao de-

senvolvimento de compete?ncia nacional na a?rea de hardware criptogra?fico: o programa

Joa?o de Barro criado pelo ITI a ordem do Comite? Gestor da ICP-Brasil e a Infra-estrutura

de Chaves Pu?blicas para Pesquisa e Ensino (ICPEDU) da Rede Nacional de Ensino e

Pesquisa (RNP)[1].

1.1 Infra-estrutura de Chaves Pu?blicas para Pesquisa e

Ensino

A RNP tem-se utilizado de grupos de trabalho, constitu??do por pesqui-

sadores de instituic?o?es pu?blicas e privadas escolhidos a partir de editais pu?blicos peri-

odicamente lanc?ados, como forma de absorver e realizar inovac?a?o tecnolo?gica, adquirir

experie?ncia e desenvolver ferramentas para melhorar e disponibilizar novos servic?os para

seus clientes, normalmente universidades e centros de pesquisa brasileiros.

Especificamente, em 2003, foi criado o Grupo de Trabalho de Infra-

estrutura de Chaves Pu?blicas (GT ICPEDU) com o objetivo de estudar e implantar um

servic?o piloto para a emissa?o de certificados digitais para fins educacionais e de pesquisa.



4

Participaram desse esforc?o as Universidades Federais de Santa Catarina (UFSC) e de Mi-

nas Gerais (UFMG) e a Universidade de Campinas (UNICAMP). O GT ICPEDU teve

tre?s edic?o?es. A primeira, GT ICPEDU I, teve como resultado o dom??nio da tecnologia de

certificac?a?o digital, com o desenvolvimento de um sistema de gerenciamento do ciclo de

vida de certificados digitais (SGCI). O GT ICPEDU II teve como objetivo o desenvolvi-

mento de um HSM, enquanto, o GT ICPEDU III, preocupou-se com a guarda da chave

privada dos usua?rios, com o desenvolvimento de smartcards virtuais.

Entre os servic?os almejados pela ICPEDU estavam a utilizac?a?o de certi-

ficados digitais para a autenticac?a?o dos usua?rios nos servic?os de rede e a realizac?a?o de as-

sinatura digital de documentos eletro?nicos em substituic?a?o ao papel, principalmente para

viabilizar a utilizac?a?o de formula?rios eletro?nicos nos processos acade?micos. E? objetivo

tambe?m, a disseminac?a?o da tecnologia de certificac?a?o digital, atrave?s de cursos, reunio?es

e participac?a?o ativa das entidades na concepc?a?o da Infra-estrutura de Chaves Pu?blicas

para Pesquisa e Ensino (ICPEDU). Ve?-se a ICPEDU como uma versa?o acade?mico e de

pesquisa da ICP-Brasil.

A ICPEDU e? hoje condic?a?o e insumo ba?sico para a integrac?a?o e o

compartilhamento de recursos das instituic?o?es de ensino e pesquisa brasileiros e en-

tre estas, incluindo as instituic?o?es afins de outros pa??ses. Va?rios projetos associados a

disponibilizac?a?o de recursos computacionais pela Internet necessitam dos servic?os pres-

tados pela ICPEDU. Destaca-se o esforc?o da RNP na implantac?a?o de um sistema de

federac?o?es de forma a compartilhar os processos de autenticac?a?o entre as instituic?o?es

usua?rias.

Um dos grandes desafios a ser superado pelos participantes na

implantac?a?o da ICPEDU era o alto custo do HSM necessa?rio a? criac?a?o de ACs e ARs

e suas aplicac?o?es. O custo era proibitivo para maioria dessas instituic?o?es. Ale?m do custo,

a tecnologia de fabricac?a?o de hardwares criptogra?ficos na?o estava dispon??vel no Brasil e

haviam restric?o?es quando a sua importac?a?o, devido ao cara?ter de “seguranc?a nacional”

que os governos dos pa??ses detentores dessa tecnologia impunham aos fabricantes. De-

vido a isso, a RNP aceitou a proposta do GT ICPEDU II para desenvolver, projetar e

construir um HSM de baixo custo e que provesse os requisitos de seguranc?a apostos na



5

FIPS 140-2.

Assim, foram estabelecidos os seguintes requisitos gerais para o HSM:

• baixo custo;

• co?digo aberto para facilitar a auditoria;

• visando atender os requisitos dos componentes de infra-estruturas de chaves
pu?blicas (rastreabilidade de chaves e um sistema de auditoria forte);

• capacidade m??nima de processamento de 10 assinaturas RSA/segundo;

• compat??vel com o Sistema de Gerenciamento de Certificados Digitais da ICPEDU
(SGCI).

O estudo e projeto do HSM tem sido alvo de va?rias dissertac?o?es de

mestrado e trabalhos de conclusa?o de curso na Universidade Federal de Santa Catarina.

Ao mesmo tempo em que estudam e se formam na a?rea de protocolos criptogra?ficos e

sistemas criptogra?ficos embarcados, os alunos e professores se dedicam a desenvolver a

tecnologia e o produto HSM da ICPEDU (ASI-HSM). O software de gerenciamento do

ciclo de vida das chaves criptogra?ficas foi desenvolvido neste seio. O hardware, dese-

nhado pelo GT ICPEDU II, foi projetado pela empresa brasileira Kryptus3 em parceria

com a RNP.

1.2 Contextualizac?a?o das Contribuic?o?es

A implantac?a?o de ACs e ARs no contexto de ICPs e? bem estabelecida,

devendo seguir pol??ticas previamente definidas de forma a nortear todas as atividades

envolvidas no seu gerenciamento. A figura 1.1 apresenta a estrutura documental normal-

mente adotada na implantac?a?o de uma infra-estrutura de chaves pu?blicas.

As pol??ticas sa?o descritas na forma de documentos, seguindo preceitos

regidos por normas, padro?es e recomendac?o?es nacionais e internacionais. Parte desses

3http://www.kryptus.com.br



6

Figura 1.1: Contextualiza a a?rea de atuac?a?o do trabalho

documentos orientam como um certificado deve ser emitido para ser aplica?vel um uma

determinada situac?a?o, respeitando os requisitos de uma pol??tica de seguranc?a, na forma

de Pol??ticas de Certificado (PC). Outra parte, o conjunto de requisitos que promovem a

protec?a?o adequada dos ativos dos sistemas de informac?a?o das entidades da ICP, constitue

a pol??tica de seguranc?a (PS).

A declarac?a?o de pra?ticas de certificac?a?o (DPC), por sua vez, descreve

como a PC e? implementada, levando em considerac?a?o as boas pra?ticas de seguranc?a esta-

belecidas na PS, englobando os requisitos da organizac?a?o que hospeda a ICP.

Como forma de facilitar a escrita destes documentos, o comite? gestor

da ICP define requisitos m??nimos das PC e DPC para todas as ACs e ARs existentes na

a?rvore da ICP. Desta forma, todas a entidades participantes da ICP podem facilmente

seguir a mesma orientac?a?o.



7

Uma vez consolidado o documento DPC, pode-se implementar o am-

biente de produc?a?o e elaborar as cerimo?niais. O ambiente de produc?a?o consiste de um

ambiente seguro com sistemas de controle de acesso, ambiente de registro, entre outros.

Esses controlam o acesso ao material criptogra?fico, gerando evide?ncias de seu uso atrave?s

de registros de evide?ncias (logs). As cerimo?nias sa?o normalmente escritas na forma de

roteiro em ordem cronolo?gica de execuc?a?o, para todas as atividades previstas no ambi-

ente de produc?a?o. O produto das cerimo?nias sa?o as atas cerimoniais. A partir das atas

e registros de atividades dos componentes envolvidos sa?o realizadas as auditorias, que

produzira?o relato?rios, demonstrando a confiabilidade de toda a estrutura para a parte con-

fiante.

Este trabalho contribui no contexto de implementac?a?o de ICPs nas a?reas

de Cerimo?nias (detalhando todos os passos realizados no gerenciamento do ciclo de vida

das chaves privadas), Ambiente de Produc?a?o (ASI-HSM com o OpenHSM) e Audito-

ria (registro de todas as etapas realizadas no interior do HSM com a possibilidade de

exportac?a?o), conforme a a?rea em destaque na figura 1.1.

Em termos de ambiente de produc?a?o, destacam-se os protocolos que sa?o

propostos para o estrito controle do ciclo de vida das chaves criptogra?ficas, mesmo consi-

derando va?rias co?pias operacionais destas chaves, atrave?s do uso de grupos de operadores

(custodiantes de material sens??vel), grupos de administradores e grupos totalmente inde-

pendentes de auditores. Todos os passos executados dentro do HSM sa?o registrados em

arquivos de registro de auditoria e exportados com a autorizac?a?o dos auditores.

Os passos de todos os sub-protocolos do HSM sa?o mapeados dentro das

cerimo?nias, detalhando principalmente as atividades diretamente relacionadas ao geren-

ciamento do ciclo de vida das chaves criptogra?ficas de uma ICP. Esta associac?a?o mostra

perfeita sintonia entre o roteiro cerimonial e o registro de sua execuc?a?o nos registros de

atividades do HSM. Garante-se com isso maior confianc?a das testemunhas presentes na

cerimo?nia quanto a corretude do uso das chaves criptogra?ficas.

Por u?ltimo, sentem-se os auditores capazes de produzir suas ana?lises e

relato?rios com a certeza de mostrar que tudo foi feito respeitando as pol??ticas preconiza-

das.



8

As contribuic?o?es deste trabalho sa?o de cara?ter te?cnico e teo?rico-

cient??fico. Quando se expo?e a contribuic?a?o te?cnica procura-se organizar o material ja?

existente na literatura te?cnica e documentac?a?o das soluc?o?es existentes de forma a eluci-

dar e dirigir tal escrito a?s necessidades dos desenvolvedores de componentes destinados a

ICP. Um forte exemplo deste tipo de contribuic?a?o e? a apresentac?a?o dida?tica para desenvol-

vimento de Engines – padra?o utilizado para a comunicac?a?o entre aplicac?o?es e provedo-

res de servic?os criptogra?ficos em ambientes de co?digo aberto suportados pela plataforma

OpenSSL.

Por outro lado, este trabalho apresenta diversas contribuic?o?es teo?rico-

cient??ficas. A principal delas esta relacionada ao protocolo que permite a gesta?o confia?vel

de va?rias insta?ncias simulta?neas do material criptogra?fico em HSM. Tal protocolo esta?

implementado no HSM do projeto ICP-EDU II, ASI-HSM.

1.3 Objetivos

1.3.1 Objetivo Geral

Este trabalho tem por objetivo geral descrever, e propor modificac?o?es

onde necessa?rio, nos sub-protocolos criptogra?ficos de gesta?o do ciclo de vida de cha-

ves criptogra?ficas que compo?em o OpenHSM, com e?nfase nos esquemas de co?pia e

recuperac?a?o de chaves e a instanciac?a?o de ambientes de produc?a?o com co?pias das chaves

gerenciadas, respeitando as principais recomendac?o?es nacionais e internacionais relacio-

nadas a? implementac?a?o de hardware criptogra?ficos.

1.3.2 Objetivos Espec??ficos

Visando alcanc?ar o objetivo geral, foram definidos alguns objetivos es-

pec??ficos, tais como:

• apresentar os principais dispositivos criptogra?ficos utilizados no contexto de uma
infra-estrutura de chaves pu?blicas;



9

• levantar as normas e recomendac?o?es nacionais e internacionais que regem o desen-
volvimento de dispositivos criptogra?ficos;

• descrever o OpenSSL e suas funcionalidades, com foco na implementac?a?o de engi-
nes para integrac?a?o de hardware criptogra?ficos;

• aprofundar o entendimento dos mecanismos de criac?a?o e recuperac?a?o de co?pias de
seguranc?a do OpenHSM, capazes de proporcionar o uso simulta?neo de va?rias co?pias

das chaves gerenciadas em ambientes paralelos;

• gerar, quando inexistente, documentac?a?o sobre os recursos tecnolo?gicos utilizados
no produtac?a?o do OpenHSM, na forma do ASI-HSM.

1.4 Justificativa e Motivac?a?o

A certificac?a?o digital tem se tornado uma ferramenta essencial a?

modernizac?a?o das instituic?o?es pu?blicas e privadas brasileiras. Ve?-se o uso desta tec-

nologia na emissa?o de notas fiscais eletro?nicas, nos sistemas banca?rios e na gesta?o de

documentos eletro?nicos, para citar alguns exemplos.

Um dos elementos chaves desse sucesso e? o investimento que o Estado

Brasileiro tem feito para o total dom??nio desta tecnologia no Brasil. O uso acade?mico

de certificac?a?o digital nas instituic?o?es de pesquisa e ensino nacionais formara?o os recur-

sos humanos necessa?rios para garantir a adoc?a?o em larga escala dos certificados digitais

nas mais diversas situac?o?es, sem ficarmos refe?ns de corporac?o?es que esta?o unicamente

subordinadas ao arcabouc?o jur??dico de outros pa??ses.

Em especial, o dom??nio no desenvolvimento de dispositivos de hard-

ware ira? permitir, na?o so? um maior uso destes nas mais diversas aplicac?o?es, como um

substancial barateamento da tecnologia. Isso sem falar que tais dispositivos sofrem de

controle rigoroso nos pa??ses que dominam sua tecnologia, e na?o sa?o poucos os casos em

que a tecnologia e? vista como de seguranc?a nacional, impondo restric?o?es a sua exportac?a?o.

Foi neste cena?rio que a RNP criou e mante?m um grupo de pesquisado-

res, de va?rias universidades e instituic?o?es de pesquisa, com o objetivo de implantar uma



10

infra-estrutura de chaves pu?blicas para pesquisa e ensino.

O HSM, resultado desse esforc?o, foi concebido para prover aos inte-

grantes da ICPEDU e parceiros de um dispositivo de baixo custo que permitisse a gesta?o

segura de chaves criptogra?ficas.

1.5 Trabalhos Correlatos

Um dos primeiros trabalhos que se tem not??cia sobre a protec?a?o de cha-

ves criptogra?ficas no contexto de uma AC e? devido a Jeff Schiller[2]. Seu trabalho propo?e

duas abordagens diferentes para a gesta?o do ciclo de vida da chave, dependendo de quem

tem acesso ao material criptogra?fico. A primeira, quando o ser humano tem acesso direto

as chaves e a segunda, quando este acesso direto na?o e? poss??vel. O trabalho, de cara?ter

mais geral, discute as diferentes preocupac?o?es quanto ao controle do ciclo de vida das

chaves nestes dois contextos.

Os primeiros estudos sobre o gerenciamento de chaves criptogra?ficas no

Laborato?rio de Seguranc?a em Computac?a?o (LabSEC) da Universidade Federal de Santa

Catarina foram feitos em 2003. Assim que o GT ICPEDU II foi aprovado pela RNP,

iniciou-se o desenvolvimento de um proto?tipo do HSM. Como resultado acade?mico do GT

teve-se dois trabalhos: um trabalho conclusa?o de curso (TCC) de Graduac?a?o em Sistemas

de Informac?a?o e uma dissertac?a?o de mestrado no Programa de Po?s-Graduac?a?o em Cie?ncia

da Computac?a?o (PPGCC) da Universidade Federal de Santa Catarina (UFSC).

No in??cio dos trabalhos foi feita uma revisa?o da literatura sobre esta a?rea

em particular e obteve-se somente refere?ncias a produtos comerciais de empresas fabri-

cantes de HSM. Muito pouco se sabe sobre os protocolos que esses produtos implemen-

tam, provavelmente devido a protec?a?o de propriedade intelectual e ao segredo industrial.

Souza[3] tratou em seu trabalho o gerenciamento de chaves crip-

togra?ficas em hardwares embarcados. Martina[4] desenvolveu sua dissertac?a?o de mes-

trado estudando e propondo modificac?o?es nos dispositivos de hardware criptogra?ficos de

forma a atender melhor as necessidades funcionais de uma autoridade certificadora.

Em 2007, Martina[5] apresentou os protocolos de gesta?o dos grupos de



11

administrac?a?o, operac?a?o e auditoria de chaves criptogra?ficas no OpenHSM. E em 2008,

Souza[6] publicou um trabalho que aprimorava os protocolos de co?pia e recuperac?a?o do

material criptogra?fico no OpenHSM.

1.6 Organizac?a?o deste Trabalho

O Cap??tulo 2 apresenta os dispositivos mais utilizados para armazena-

mento de chaves criptogra?ficas. Nesse, sa?o apresentados os smartcards, com e?nfase no

modelo utilizado no OpenHSM, tokens criptogra?ficos e HSM dispon??veis no mercado.

No cap??tulo 3, as normas nacionais e internacionais de certificac?a?o

com maior releva?ncia sa?o analisadas. E? apresentada para cada norma, seus n??veis de

certificac?a?o, a?reas de atuac?a?o e requisitos definidos para cada a?rea.

A seguir, no cap??tulo 4, e? apresentado o OpenSSL, poderosa ferramenta

criptogra?fica, na qual o ASI-HSM esta? baseado. O cap??tulo descreve a aplicac?a?o de linha

de comando, suporte a engines para integrac?a?o de mo?dulos criptogra?ficos e a versa?o sim-

plificada da biblioteca com certificac?a?o FIPS 140-2 n??vel 1. Justifica-se a inclusa?o deste

material neste texto uma vez que a documentac?a?o original e? desatualizada e dispersa.

O cap??tulo 5 apresenta a soluc?a?o como um todo do HSM, na forma do

ASI-HSM, incluindo sua arquitetura, interfaces de gerenciamento e engine para utilizac?a?o

de seus servic?os criptogra?ficos.

Na sequ?e?ncia, o cap??tulo 6 aborda o protocolo OpenHSM para gerencia-

mento do ciclo de vida das chaves criptogra?ficas, incluindo os sub-protocolos para criac?a?o

e uso de chaves criptogra?ficas gerenciadas.

O cap??tulo 7 descreve todos os sub-protocolos do OpenHSM res-

ponsa?veis pela criac?a?o e recuperac?a?o de co?pias de seguranc?a do HSM, de forma a garantir

a continuidade do ciclo de vida das chaves criptogra?ficas gerenciadas mesmo em caso de

falhas de hardware ou desastres.

Finalmente, no cap??tulo 8, conclui-se o trabalho, apresentando suas

contribuic?o?es e trabalhos futuros.



Cap??tulo 2

Hardware Criptogra?fico

2.1 Introduc?a?o

Um hardware criptogra?fico e? um dispositivo que visa atender aos requi-

sitos de seguranc?a encontrados em aplicac?o?es que usam servic?os criptogra?ficos onde na?o

e? poss??vel segregar o material sens??vel unicamente dentro da estac?a?o hospedeira, que em-

barca a aplicac?a?o, ou em situac?o?es onde e? necessa?rio um alto volume de processamento

criptogra?fico. Um HSM, por exemplo, e? tipicamente de 10 a 100 vezes mais ra?pido que

um computador pessoal para as finalidades especializadas.

Algumas aplicac?o?es, como servidores seguros de pa?ginas Web, reque-

rem grande capacidade de processamento criptogra?fico, que pode ser alcanc?ado com o

emprego de um HSM que e? usado como um co-processador para operac?o?es criptogra?ficas,

liberando unidade de processamento dos servidores para outras finalidades.

Este cap??tulo apresenta os dois principais tipos de hardware crip-

togra?ficos, sendo na sec?a?o 2.2 apresentado os smartcards, com especial atenc?a?o aos re-

quisitos referentes ao modelo de smartcards utilizados no HSM alvo do OpenHSM. A

Sec?a?o 2.3 apresenta uma visa?o geral dos HSMs, hardware que permite um controle rigo-

roso do ciclo de vida de chaves criptogra?ficas, sendo um dispositivo fundamental para a

gesta?o da chave privada de uma autoridade certificadora raiz de uma ICP. Adicionalmente,

alguns HSMs comerciais sa?o destacados.



13

2.2 Smartcards

Primeiramente empregados por empresas de telefonia da Franc?a e Ale-

manha nos anos 80, os smartcards ganharam mercado com o desenvolvimento da crip-

tografia moderna e evoluc?a?o da tecnologia de semicondutores, sendo considerados uma

gerac?a?o mais nova, inteligente e segura dos carto?es de identificac?a?o. Os celulares com

tecnologia GSM e carto?es de cre?ditos incorporam smartcards, visando principalmente sua

efetividade no combate a fraudes[7].

Smartcards conte?m um circuito integrado embarcado, capaz de receber,

transmitir, armazenar e processar dados. A comunicac?a?o pode ser feita com ou sem con-

tato f??sico, sendo no u?ltimo caso utilizadas ondas de ra?dio.

Uma das grandes caracter??sticas dos smartcards e? que os dados nele

armazenados podem ser protegidos contra acesso e manipulac?a?o na?o autorizados. Seu

sistema operacional estabelece uma lo?gica de seguranc?a que controla a entrada e sa??da de

comandos e dados atrave?s de sua interface de comunicac?a?o serial. E? poss??vel, por exem-

plo, gerar um par de chaves assime?tricas em um smartcard e configura?-lo de tal forma que

a chave privada nunca podera? ser exportada. Neste caso, as operac?o?es criptogra?ficas para

utilizar esta chave podem ser realizadas somente dentro do mesmo.

O controle de acesso ao smartcard e? realizado com a utilizac?a?o de se-

nha ou controle biome?trico. A senha e? conhecida como nu?mero de identificac?a?o pes-

soal (PIN)1, que deve ser conhecida somente pelo dono do smartcard, e consiste de uma

sequ?encia nume?rica normalmente entre 4 e 6 d??gitos. Os smartcards podem implementar

um modelo de PIN fixo ou modifica?vel. O modelo de PIN fixo na?o permite que seus

usua?rios alterem o PIN, obrigando sua memorizac?a?o, enquanto o modelo de PIN modi-

fica?vel atende as necessidades de seus usua?rios, permitindo a alterac?a?o do PIN.

Os smartcards, por questa?o de seguranc?a, possuem um controle do

nu?mero de tentativas consecutivas sem e?xito na liberac?a?o do acesso, bloqueando o PIN

quando digitado mais de tre?s vezes incorretamente. Este comportamento evita o ataque de

tentativa e erro, tambe?m chamada de ataque de forc?a bruta. Em caso de bloqueio, o smart-

1do ingle?s Personal Identification Number



14

card precisa ser submetido a um processo de desbloqueio, utilizando uma senha chamada

de chave de desbloqueio pessoal (PUK)2, normalmente entre 6 e 8 d??gitos nume?ricos. Ela

reinicia o contador de tentativas sem sucesso e permite a configurac?a?o de um novo PIN.

O PUK, ale?m de na?o ser altera?vel, tambe?m e? bloqueado se digitado incorretamente 10

vezes, inutilizando o smartcard.

O uso de smartcards se da? atrave?s de leitores especialmente desenvol-

vidos para este fim. Eles sa?o o meio pelo qual um computador pode interagir com seu

conteu?do, provendo energia para o sistema operacional.

Os conceitos de smartcard tambe?m sa?o empregados em tokens crip-

togra?ficos, no formato de dispositivos USB[8], na?o necessitando de leitora espec??fica para

sua utilizac?a?o.

2.2.1 Smartcards para HSMs

O objetivo do emprego de smartcards no projeto piloto do HSM e? a

segura identificac?a?o dos membros de seus grupos. Cada membro possui um smartcard,

no qual sera? armazenado um par de chaves criptogra?ficas RSA[9] e um certificado. A

utilizac?a?o deste smartcard com o PIN correto garante a autenticac?a?o do membro.

Apesar de existirem inu?meros modelos comerciais de smartcards atual-

mente no mercado, com diferentes caracter??sticas e capacidades, o GT ICP-EDU II definiu

o seguinte conjunto de requisitos na escolha do smartcard apropriado:

• ser utiliza?vel a partir de contato f??sico;

• suportar a gerac?a?o de chaves assime?tricas RSA[9] de do m??nimo 1024 bits;

• permitir a importac?a?o de pares de chaves RSA gerados fora do smartcard;

• suportar criptografia de dados com chaves assime?tricas RSA de ate? de 1024 bits;

• ter capacidade de gerac?a?o e verificac?a?o de assinaturas digitais utilizando chaves
RSA;

2do ingle?s Personal Unblocking key



15

• suportar armazenamento de certificados X.509v3[10];

• ser compat??vel com a norma ISO 7816 1/2/3/4[11];

• implementar uma estrutura de objetos e arquivos compat??vel com PKCS#15[12];

• possuir no m??nimo 32 kilobytes de capacidade de armazenamento.

2.3 Mo?dulo de Seguranc?a Criptogra?fica (HSM)

Mo?dulos de seguranc?a criptogra?fica sa?o empregados em soluc?o?es onde

o controle do ciclo de vida de suas chaves criptogra?ficas e? crucial para seu funcionamento.

Esses mo?dulos devem permitir que as chaves criptogra?ficas sejam criadas, armazenadas,

utilizadas e apagadas internamente, sem nunca serem vis??veis ao mundo externo.

Os HSMs possuem mais capacidade de processamento que os smart-

cards, servindo na sua maioria como aceleradores criptogra?ficos, sendo capazes de geren-

ciar o ciclo de vida de va?rias chaves ao mesmo tempo.

2.3.1 Ciclo de vida de chaves criptogra?ficas

O ciclo de vida de uma chave criptogra?fica consiste da sequ?encia de

estados por ela assumida, desde sua gerac?a?o ate? a sua destruic?a?o[13], com o mo?dulo

criptogra?fico garantindo seu correto manuseio em cada estado assumido.

A continuidade do ciclo de vida das chaves deve ser poss??vel mesmo

em caso de falha de hardware ou acontecimento de um desastre, atrave?s da utilizac?a?o de

mecanismos de criac?a?o e recuperac?a?o de co?pias de seguranc?a. Entretanto, no caso de

destruic?a?o de uma chave, deve-se ter garantia que todas suas insta?ncias foram destru??das,

inclusive as co?pias de seguranc?a.

A seguir, apresenta-se uma lista dos principais estados que uma chave

criptogra?fica pode assumir durante seu ciclo de vida em um HSM:

• gerac?a?o: o ponto inicial do ciclo de vida de uma chave criptogra?fica;



16

• armazenamento: a chave esta? armazenada de forma segura no interior do per??metro
criptogra?fico;

• uso: utilizac?a?o da chave para realizac?a?o de operac?o?es criptogra?ficas;

• backup: referente as co?pias de seguranc?a da chave, que deve estar armazenado em
lugar independente, possibilitando a recuperac?a?o em caso de falha de hardware ou

desastre;

• recuperac?a?o: refere-se a recuperac?a?o de uma co?pia de seguranc?a da chave, utilizado
quando a chave foi perdida de alguma forma, sem seu comprometimento;

• destruic?a?o: a chave na?o e? mais necessa?ria, finalizando seu ciclo de vida.

Os estados ainda podem ser categorizados quanto a disponibilidade de

uso de uma chave criptogra?fica[14], como e? descrito na tabela 2.1.

Tabela 2.1: Categorias dos estados do ciclo de vida de chaves criptogra?ficas quanto a sua dispo-
nibilidade de uso.

Categoria Descric?a?o
pre?-operacional per??odo desde a criac?a?o do par de chaves ate? sua liberac?a?o para

realizac?a?o de operac?o?es criptogra?ficas;
operacional a chave esta? dispon??vel para uso
po?s-operacional a chave na?o pode ser mais utilizada ativamente para realizac?a?o

de operac?o?es criptogra?ficas. Sua utilidade e? prover garantia das
operac?o?es realizadas no passado.

obsoleta todas as insta?ncias da chave criptogra?fica sa?o apagadas

2.3.2 Mo?dulos de Seguranc?a Criptogra?fica de Mercado

Existem diversos fabricantes de HSMs no mundo e alguns de seus pro-

dutos sa?o descritos nas tabelas 2.2, 2.3 e 2.4, salientando suas caracter??sticas e capacida-

des. Os principais fabricantes sa?o: nCipher, SafeNet e AEP Networks.

O nShield F3 2000 da nCipher, ale?m das caracter??sticas apresentadas na

tabela 2.2, suporta execuc?a?o segura de co?digo, o que permite ao seu usua?rio importar um



17

trecho de co?digo para ser executado dentro do HSM, considerado um ambiente seguro.

Ale?m disso, conta com relo?gio interno de alta precisa?o, permitindo sua utilizac?a?o em

sistemas de carimbo do tempo.

Tabela 2.2: Caracter??sticas do HSM nShield F3 2000 da nCipher

Item Caracter??sticas
Certificac?a?o FIPS 140-2 n??vel 3
Capacidade de Processamento 2000 assinaturas RSA de 1024 bits por segundo
Conectividade Interface PCI
API integrac?a?o OpenSSL, PKCS#11, Microsoft CryptoAPI
Algoritmos criptogra?ficos (As-
sime?tricos)

DSA, ECDSA, RSA

Algoritmos criptogra?ficos
(Sime?tricos)

AES, Triple-DES

Algoritmos criptogra?ficos
(Func?o?es de Resumo)

Triple-DES MAC, SHS, HMAC

Backup Proprieta?rio e para HSMs do mesmo fabricante
Uso Propo?sito geral

Da mesma forma que o HSM da nCipher, o Luna PCI 3000 da Sa-

feNet apresenta caracter??sticas adicionais ao gerenciamento do ciclo de vida de chaves

criptogra?ficas, como a utilizac?a?o de um teclado diretamente conectado ao HSM para au-

tenticar seus usua?rios, provendo uma caminho confia?vel para a digitac?a?o do PIN. Suas

caracter??sticas gerais podem ser vistas na tabela 2.3.

O HSM Keyper PCI da AEP Networks possui uma funcionalidade in-

teressante para ambientes que demandem alto poder de processamento, suportando ba-

lanceamento de carga entre va?rios HSMs. Em caso de uma falha em um dos HSMs, os

restantes automaticamente assumem o controle. As caracter??sticas gerais do KeyPer PCI

podem ser encontradas na tabela 2.4.

2.4 Conclusa?o

A utilizac?a?o de hardwares criptogra?ficos e? crucial em ambientes com al-

gum tipo de valor agregado, ja? que, idealmente, a seguranc?a dos algoritmos criptogra?ficos



18

Tabela 2.3: Caracter??sticas do HSM Luna PCI 3000 da SafeNet

Item Caracter??sticas
Certificac?a?o FIPS 140-2 n??vel 2 e 3
Capacidade de Processamento 3000 assinaturas RSA de 1024 bits por segundo
Conectividade Interface PCI
API integrac?a?o OpenSSL, PKCS#11, Microsoft CryptoAPI 2.0, Java JCA/JCE
Algoritmos criptogra?ficos (As-
sime?tricos)

RSA, DSA, Diffie Hellman

Algoritmos criptogra?ficos
(Sime?tricos)

DES/3DES, AES, RC2, RC4, RC5

Algoritmos criptogra?ficos
(Func?o?es de Resumo)

SHA-1, SHA-256, SHA-384, SHA-512, MD2, MD5

Backup Proprieta?rio e para HSMs do mesmo fabricante
Uso Propo?sito geral

esta? diretamente relacionada ao correto manuseio de suas chaves.

Os dois principais exemplares de hardware criptogra?ficos sa?o o smart-

card e o HSM. O smartcard tem o formato de uma carta?o e e? utilizado para proteger a

chave privada de pessoas ou de sistemas, onde na?o ha? a necessidade de uma taxa elevada

de processamento criptogra?fico. Ja? os HSMs, como visto neste cap??tulo, tem um controle

maior do ciclo de vida de chaves criptogra?ficas e alto poder de processamento.

Pode-se observar que os HSMs de mercado sa?o normalmente destinados

a aplicac?o?es gerais e na?o sa?o projetados para a instanciac?a?o de autoridades certificadoras.

Uma das principais deficie?ncias dos HSMs comerciais e? a falta de um

padra?o aceita?vel para realizar a co?pia e a restaurac?a?o do seu material cr??tico, tal como as

chaves criptogra?ficas. Os fabricantes alegam que possuem tal funcionalidade, mas esta

e? limitada a produtos do pro?prio fabricante. Alegam que isso e? necessa?rio para manter

a protec?a?o das chaves. Acontece que num ambiente de produc?a?o, por exemplo, uma

AC Raiz, normalmente a chave e? gerada e deve ser mantida no mo?dulo por per??odo de

tempo superior a 10 anos. E os produtos comerciais sa?o descontinuados antes de vencer

a validade da chave.

Como sera? visto nos pro?ximos cap??tulos, esta dissertac?a?o de mestrado

trata desta funcionalidade com especial atenc?a?o. Ou seja, como podem ser criadas co?pias



19

Tabela 2.4: Caracter??sticas do HSM Keyper PCI da AEP Networks

Item Caracter??sticas
Certificac?a?o FIPS 140-1 n??vel 3
Capacidade de Processamento na?o informada
Conectividade Interface PCI mas utiliza?vel atrave?s da rede
API integrac?a?o OpenSSL, PKCS#11, Microsoft CryptoAPI 2.0, Java JCA/JCE
Algoritmos criptogra?ficos (As-
sime?tricos)

RSA, DSA, Diffie Hellman

Algoritmos criptogra?ficos
(Sime?tricos)

DES/3DES

Algoritmos criptogra?ficos
(Func?o?es de Resumo)

SHA-1, MD5

Backup Proprieta?rio e para HSMs do mesmo fabricante
Uso Propo?sito geral

de seguranc?a, que permitem posterior recuperac?a?o em dispositivos adicionais, sem perder

a rastreabilidade de todas as insta?ncias das chaves criptogra?ficas em operac?a?o.



Cap??tulo 3

Normas

3.1 Introduc?a?o

A falta de interoperabilidade entre hardware criptogra?ficos torna sua

utilizac?a?o custosa, pois cada vez que e? necessa?rio mudar um hardware, deve-se adaptar

a aplicac?a?o que o utiliza. Neste sentido, governos e empresas se uniram e propuseram

padro?es de interoperabilidade que devem ser seguidos no projeto e fabricac?a?o de tais

dispositivos.

Desta forma, este cap??tulo apresenta as principais normas nacionais e

internacionais que devem ser consideradas no contexto de hardware criptogra?ficos. Dentre

eles esta?o a FIPS PUB 140-2 (sec?a?o 3.2) e o Manual de Condutas Te?cnicas 7 do LEA-ITI

(sec?a?o 3.3). Ambas estabelecem requisitos na construc?a?o de HSMs.

Os crite?rios comuns[15], que podem ser aplicados na construc?a?o de

qualquer dispositivo eletro?nico, tambe?m pode ser utilizado na construc?a?o de HSMs. En-

tretanto, por ser mais gene?rico, na?o sera? abordado aqui, permanecendo o foco nas normas

FIPS PUB 140-2 e no MCT-7.



21

3.2 FIPS PUB 140

A norma FIPS PUB 140-2[16], publicada pelo Instituto Nacional de

Padro?es e Tecnologia1 do governo norte-americano, define um conjunto de requisitos de

seguranc?a para hardware criptogra?ficos empregados na protec?a?o de informac?o?es sens??veis

em sistemas computacionais e de telecomunicac?a?o. Esta norma e? a evoluc?a?o da FIPS PUB

140-1[17].

Os requisitos de seguranc?a cobrem diversas a?reas relacionadas com o

projeto e implementac?a?o de um mo?dulo criptogra?fico, devendo o mo?dulo satisfazer todos

os requisitos do n??vel de certificac?a?o desejado. A FIPS 140-2 preve? quatro n??veis: 1, 2, 3

ou 4. Nos n??veis em que os requisitos se diferem, aplica-se o comportamento acumulativo,

ou seja, as certificac?o?es em n??veis mais altos (4) devem tambe?m satisfazer os requisitos

dos n??veis mais baixos (1).

Em um processo de avaliac?a?o de um mo?dulo criptogra?fico, atribui-se o

n??vel de cada a?rea analisada individualmente. Posteriormente, a a?rea com o n??vel mais

baixo estabelecera? o n??vel de certificac?a?o do mo?dulo criptogra?fico.

A FIPS 140-2 utiliza o termo ”para?metros cr??ticos de seguranc?a

(CSP)”para informac?o?es que, se divulgadas ou modificadas, podem comprometer a

seguranc?a do mo?dulo criptogra?fico, tais como segredos e chaves privadas criptogra?ficas e

dados de autenticac?a?o (PINs e senhas).

A norma ainda inclui outros quatro documentos, complementando o

documento principal, chamados de anexo A, B, C e D, respectivamente a fam??lia de al-

goritmos criptogra?ficos aprovados, perfis de protec?a?o, geradores de nu?meros aleato?rios

aprovados e te?cnicas de estabelecimento de chaves2 sime?tricas e assime?tricas.

As sub-sec?o?es seguintes sumarizam cada uma das a?reas cobertas pela

norma, com uma e?nfase nas principais diferenc?as entre os n??veis de seguranc?a.

1do ingle?s National Institute of Standards and Technology - NIST
2do ingle?s key establishment



22

3.2.1 Especificac?a?o do Mo?dulo Criptogra?fico

Esta a?rea conte?m as definic?o?es de mo?dulo e fronteira criptogra?ficos que

devem ser utilizadas na norma como um todo, ale?m de sumarizar uma lista com toda a

documentac?a?o de hardware, software e firmware, diretamente relacionada a? seguranc?a do

mo?dulo, que e? necessa?ria no processo de certificac?a?o. Entre os documentos requeridos

esta?o:

• especificac?a?o f??sica do mo?dulo;

• portas f??sicas e interfaces lo?gicas empregadas;

• especificac?a?o dos controles f??sicos e lo?gicos do mo?dulo;

• lista de todas as func?o?es de seguranc?a, aprovadas ou na?o, empregadas pelo mo?dulo,
especificando todos os modos de operac?a?o suportados, aprovados ou na?o;

Adicionalmente, requer-se que os mo?dulos criptogra?ficos possuam uma

pol??tica de seguranc?a3, contendo regras derivadas dos requisitos da norma FIPS 140-2 e

quaisquer outras regras derivadas dos requisitos impostos pelo fabricante do mo?dulo.

Por fim, define-se que a documentac?a?o deve conter um diagrama de blo-

cos, detalhando os principais componentes de hardware e suas interconexo?es, tais como

microprocessadores, buffers e memo?rias. Ale?m disso, e? necessa?rio prover documentac?a?o

do projeto dos componentes de hardware, software e firmware.

3.2.2 Portas F??sicas e Interfaces Lo?gicas

A FIPS 140-2 define que o fluxo de dados e acesso f??sico de um mo?dulo

criptogra?fico devem estar limitados as suas portas f??sicas e interfaces lo?gicas, identifi-

cando assim, todos os pontos de entrada e sa??da existentes.

As interfaces lo?gicas sa?o divididas em quatro tipos. Apesar de cada tipo

poder compartilhar da mesma porta f??sica, elas devem ser logicamente independentes

umas das outras. Os tipos de interfaces sa?o:

3do ingle?s security policy



23

• entrada de dados: todos os dados que sa?o direcionados ao mo?dulo criptogra?fico para
serem processados devem utilizar este tipo de interface;

• sa??da de dados: todos os dados, com excec?a?o de dados de estado, devem sair do
mo?dulo atrave?s deste tipo de interface;

• entrada de controle: os comandos, sinais e dados de controle para operacionalizac?a?o
do mo?dulo criptogra?fico devem utilizar este tipo de interface;

• sa??da de estado: todos os dados utilizados para indicar estado do mo?dulo, incluindo
leds e displays, devem utilizar este tipo de interface.

Os n??veis 1 e 2 somente requerem que exista uma interface lo?gica de

cada um dos tipos descritos anteriormente. Nos n??veis 3 e 4, ale?m do requisito ante-

rior, a norma requer que a porta de entrada e sa??da de CSP do mo?dulo criptogra?fico -

para?metros de chaves criptogra?ficas em texto claro e dados de autenticac?a?o - sejam fisica-

mente separadas de outras portas ou utilizem uma interface lo?gica de caminho confia?vel4.

Adicionalmente, a entrada dos dados deve ser de forma direta, atrave?s de um cabo dire-

tamente conectado ao mo?dulo, ou tambe?m, com a utilizac?a?o de um caminho confia?vel de

dados. O uso de caminho confia?vel visa cumprir os dois requisitos dos n??veis 3 e 4.

3.2.3 Pape?is, Servic?os e Mecanismos de Autenticac?a?o

O mo?dulo criptogra?fico deve suportar pape?is de usua?rios, onde cada

papel e? associado a um conjunto definido de servic?os, pore?m, e? opcional para o mo?dulo,

o emprego ou na?o de mecanismos para autenticac?a?o dos mesmos. Os servic?os que na?o

modifiquem, substituam ou revelam chaves criptogra?ficas e CSP do interior do mo?dulo,

podem ser executados sem que os usua?rios sejam autenticados.

Entre os pape?is de usua?rios que devem ser suportados pelo mo?dulo

esta?o:

• operador: executa servic?os gerais de seguranc?a, incluindo operac?o?es criptogra?ficas;
4do ingle?s trusted path.



24

• administrador (crypto officer): responsa?vel pela inicializac?a?o e gerenciamento do
mo?dulo criptogra?fico, incluindo a gerac?a?o de chaves criptogra?ficas e auditoria;

• manutenc?a?o: papel opcional, utilizado durante reparos f??sicos ou lo?gicos no mo?dulo
criptogra?fico. Todos os segredos e chave privadas em aberto e CSPs desprotegidos

devem ser apagados utilizando o circuito zerador5 sempre que este papel e? autenti-

cado.

E? opcional para o mo?dulo criptogra?fico a definic?a?o de pape?is ou sub-

pape?is adicionais aos citados acima.

Existem alguns servic?os que o mo?dulo deve obrigatoriamente prover,

tais como mostrar o estado do mo?dulo, executar auto-testes e suportar a execuc?a?o de

pelo menos uma operac?a?o criptogra?fica em um algoritmo aprovado. Ale?m destes, muitos

outros servic?os podem existir, ate? operac?o?es criptogra?ficas de algoritmos na?o aprovados,

operando em modo tambe?m na?o aprovado.

Os mecanismos de autenticac?a?o de um mo?dulo criptogra?fico, quando

implementado, devem ser classificados em uma das seguintes categorias:

• baseado em papel: a autenticac?a?o e? realizada no papel selecionado (impl??cita ou
explicitamente). O mo?dulo na?o autentica a identidade individual do usua?rio.

• baseado em identidade: o usua?rio e? individualmente identificado e verifica-se se ele
pode assumir o papel selecionado. O papel pode ser selecionado direta ou indireta-

mente.

E? opcional para o mo?dulo a possibilidade de executar va?rios servic?os

uma vez que um papel esta? autenticado ou solicitar uma autenticac?a?o para cada servic?o.

Entretanto, os resultados das autenticac?o?es depois de desligar e ligar o mo?dulo na?o podem

ser armazenados, necessitando re-autenticac?a?o de qualquer um dos pape?is existentes.

O n??vel 1 da norma FIPS 140-2 na?o requer nenhum mecanismo de

autenticac?a?o dos operadores. Ja? o n??vel 2, requer a autenticac?a?o baseada em papel, e

os n??veis 3 e 4 baseada em identidade.
5do ingle?s zeroized



25

3.2.4 Modelo de estados finitos

Todos os n??veis de certificac?a?o da FIPS 140-2 requerem que a operac?a?o

do mo?dulo criptogra?fico seja especificada em um modelo de estados finitos, representado

por um diagrama ou tabela de transic?a?o de estados, incluindo:

• todos os estados operacionais e de erro;

• as transic?o?es de um estado para outro;

• os eventos de entrada que causam uma transic?a?o;

• os eventos de sa??da apo?s a transic?a?o para outro estado.

Alguns exemplos de estados operacionais obrigato?rios sa?o a execuc?a?o

dos auto-testes, autenticac?a?o do papel administrador, estado de manutenc?a?o, entre outros.

3.2.5 Seguranc?a F??sica

O FIPS 140-2 define que um mo?dulo criptogra?fico deve empregar meca-

nismos de seguranc?a para restringir acesso f??sico na?o autorizado ao conteu?do do mo?dulo,

prevenindo sua utilizac?a?o e modificac?a?o.

O n??vel 1 de certificac?a?o na?o possui nenhum requisito para mo?dulos

criptogra?ficos de chip u?nico, como um smartcard, pore?m, define que o mo?dulo deve estar

embalado por um invo?lucro de metal ou pla?stico duro, podendo incluir portas ou capas

remov??veis.

O n??vel 2 requer a utilizac?a?o de travas e a evide?ncia de qualquer tentativa

de invasa?o do per??metro criptogra?fico do mo?dulo. No n??vel 3, ale?m de ficar evidente

a tentativa de invasa?o, deve existir alta probabilidade de ocorrer danos irrepara?veis ao

mo?dulo, por exemplo, envolvendo o mo?dulo em uma pasta para criac?a?o de um bloco

u?nico, r??gido e opaco a luminosidade.

O u?ltimo n??vel, requer ainda que o mo?dulo responda ativamente a ten-

tativa de invasa?o, ativando o circuito zerador que apaga segredos, chaves privadas e PCSs

em texto claro.



26

3.2.6 Ambiente Operacional

O ambiente operacional de um mo?dulo criptogra?fico se refere ao ge-

renciamento de software, firmware e hardware necessa?rios para sua operac?a?o, sendo o

sistema operacional (SO) um dos principais componentes. O ambiente operacional de um

mo?dulo deve se enquadrar em uma das seguintes categorias:

• ambiente operacional de propo?sito geral: se refere ao uso de um sistema operacional
de propo?sito geral e comercialmente dispon??vel.

• ambiente operacional limitado: ambiente operacional esta?tico na?o modifica?vel, que
na?o requer um sistema de propo?sito geral para seu suporte.

• ambiente operacional modifica?vel: se refere a ambiente operacional que pode ser
reconfigurado, adicionando, deletando ou modificando funcionalidades. Sistemas

operacionais sa?o considerados ambientes operacionais modifica?veis se componen-

tes de software/firmware, que na?o foram inclu??dos no processo de certificac?a?o, po-

dem ser importados e executados no mo?dulo por seus usua?rios.

Os requisitos desta a?rea se aplicam apenas para ambientes operacionais

modifica?veis, tendo abrange?ncias diferentes para cada n??vel de certificac?a?o.

O n??vel ba?sico requer que apenas um usua?rio possa utilizar o mo?dulo

criptogra?fico por vez, prevenindo acesso de outros processos a segredos, chaves privadas

e CSPs armazenados em aberto, sendo que o requisito anterior e? aplica?vel somente para

o n??vel 1 da certificac?a?o. O software/firmware do mo?dulo deve estar instalado de uma

tal forma que bloqueie modificac?o?es ou acesso de usua?rios na?o autorizados, utilizando

alguma te?cnica de integridade aprovada pela fam??lia de algoritmos FIPS.

Os n??veis 2, 3 e 4, requerem, respectivamente, um sistema operacional

de n??vel EAL2, EAL3 e EAL4 do Crite?rios Comuns[15], ou uma avaliac?a?o equivalente.

Um mecanismo de auditoria e? requisito do n??vel 2, incluindo uma lista de eventos que

precisam obrigatoriamente ser registrados. O n??vel 3 inclui outros eventos e requer a

utilizac?a?o de caminho confia?vel6 e modelo de pol??tica de seguranc?a7.
6do ingle?s trusted path (FTP TRP.1 dos crite?rios comuns).
7do ingle?s Security Policy Model (ADV SPM.1 do crite?rio comum).



27

3.2.7 Gerenciamento de Chaves Criptogra?ficas

Esta a?rea apresenta requisitos de seguranc?a que visam proteger o ge-

renciamento de todo o ciclo de vida de chaves criptogra?ficas, componentes de chaves

criptogra?ficas e CSPs empregados pelo mo?dulo.

Os requisitos sa?o agrupados em va?rias atividades do processo de geren-

ciamento de chaves criptogra?ficas, tais como:

• gerac?a?o de nu?meros aleato?rios: o gerador utilizado para gerac?a?o de chaves crip-
togra?ficas deve obrigatoriamente ser aprovado pela fam??lia de padro?es FIPS. En-

tretanto, se o mo?dulo criptogra?fico emprega geradores na?o aprovados, os dados

gerados devem apenas ser utilizados para gerar sementes para um gerador aprovado

ou para gerar vetores de inicializac?a?o para algoritmos sime?tricos;

• gerac?a?o de chaves criptogra?ficas: se o mo?dulo suportar essa funcionalidade, os
me?todos de gerac?a?o devem ser aprovados pela fam??lia de padro?es FIPS [16, anexo

A];

• estabelecimento de chaves: o processo de estabelecer uma chave sime?trica para
a comunicac?a?o de duas ou mais partes, podendo ser realizado atrave?s de me?todo

automa?tico, manual ou uma combinac?a?o de etapas manuais e automa?ticas;

• importac?a?o e exportac?a?o de chaves criptogra?ficas: o mo?dulo pode suportar
importac?a?o e/ou exportac?a?o de chaves, que podem ser realizados de forma manual,

atrave?s do teclado, ou automa?tica, utilizando smartcards;

• armazenamento de chaves criptogra?ficas: as chaves criptogra?ficas podem ser arma-
zenadas cifradas ou em claro. Segredo e chaves armazenados em claro na?o podem

ser acess??veis a usua?rios na?o autorizados;

• circuito zerador de chaves criptogra?ficas: o mo?dulo deve prover um me?todo para
apagar segredos, chaves privadas e CSPs armazenados em claro dentro do mo?dulo.

Ale?m disso, define-se que chaves criptogra?ficas e CSPs cifrados com

algoritmos na?o aprovados sa?o considerados em formato de texto claro.



28

3.2.8 Interfere?ncia e Compatibilidade Eletromagne?tica

O mo?dulo criptogra?fico deve estar em conformidade em relac?a?o a in-

terfere?ncia8 e compatibilidade9 eletromagne?tica definida pela comissa?o de comunicac?a?o

federal do governo americano (FCC)[18]. Os n??veis 1 e 2 da certificac?a?o devem seguir os

requisitos para uso comercial, enquanto os n??veis 3, 4 para uso dome?stico.

3.2.9 Auto-testes

O mo?dulo criptogra?fico deve realizar auto-testes que visam garantir seu

funcionamento apropriado, devendo entrar em um estado de erro se qualquer auto-teste

falhar. O mo?dulo na?o podera? realizar nenhuma operac?a?o criptogra?fica enquanto estiver

neste estado, devendo a interface de sa??da de dados ser fechada. Existem duas categorias

de auto-teste: de energizac?a?o e condicional.

Os auto-testes de energizac?a?o sa?o automaticamente realizados quando

o mo?dulo e? energizado, sem intervenc?a?o dos usua?rios. Entre os testes necessa?rios esta?o:

testes de algoritmos criptogra?ficos, testes de integridade de software e firmware, testes

de func?o?es cr??ticas para o funcionamento seguro do mo?dulo. Define-se que todos os

algoritmos criptogra?ficos devem ser submetidos a testes de resposta conhecida.

Os auto-testes condicionais sa?o realizados quando determinadas

operac?o?es ocorrerem no mo?dulo:

• gerac?a?o de par de chaves: testes de consiste?ncias do par;

• carregamento de software/firmware externo: testes de validac?a?o de soft-
ware/firmware carregados para dentro do mo?dulo;

• quando chaves ou componentes de chaves sa?o entradas manualmente no mo?dulo:
mecanismos de verificac?a?o de corretude do seu conteu?do;

• utilizac?a?o de um gerador de nu?meros aleato?rios: executar testes cont??nuos para
detectar gerac?a?o de valores constantes.

8do ingle?s electromagnetic interference - EMI
9do ingle?s electromagnetic compatibility - EMC



29

• quando o mo?dulo troca de modo de operac?a?o normal para de desvio10: testes para
confirmar o comportamento correto de func?o?es que operam com material crip-

togra?fico no momento de troca de modo de operac?a?o.

3.2.10 Garantia de Projeto

A garantia de projeto se refere ao uso de boas pra?ticas do fabricante

do mo?dulo criptogra?fico durante seu projeto, distribuic?a?o e operac?a?o. O fabricante deve

fornecer garantias que o mo?dulo e? devidamente testado, configurado, entregue, instalado e

desenvolvido, contendo guias de manuseio adequado para seus usua?rios (administradores

e operadores).

Esta a?rea requer a utilizac?a?o de gere?ncia de configurac?a?o para todo o

ciclo de desenvolvimento do mo?dulo, incluindo a definic?a?o dos requisitos de sua entrega

e operac?a?o. Ale?m disso, para auxiliar a compreensa?o do funcionamento interno, requer-se

um conjunto de documentos referentes a sua especificac?a?o e desenvolvimento.

Adicionalmente, um conjunto de requisitos ligados ao desenvolvimento

do mo?dulo criptogra?fico e? definido, variando dependendo do n??vel de certificac?a?o. Estes

requisitos visam prover garantia que a implementac?a?o do mo?dulo corresponde com sua

pol??tica de seguranc?a e especificac?a?o funcional.

3.2.11 Mitigac?a?o de Outros Ataques

Esta a?rea de requisitos visa abranger ataques que na?o eram conhecidos

durante a escrita da norma FIPS 140-2 ou que ficaram de fora do escopo da mesma. Esses

ataques que o mo?dulo na?o e? suscet??vel devem estar descritos na sua pol??tica de seguranc?a.

A maioria dos ataques a um mo?dulo criptogra?fico tentam determinar

alguma informac?a?o referente ao material criptogra?fico armazenado dentro do mo?dulo,

tais como: ana?lise da tensa?o utilizada durante a gerac?a?o de chaves e/ou operac?o?es crip-

togra?ficas, ana?lise de tempo de processamento, induc?a?o para ocorre?ncia de erros, entre

outros.
10do ingle?s bypass



30

3.3 Manual de Condutas Te?cnicas 7 (LEA/ITI)

O manual de condutas te?cnicas 7 (MCT-7)[19], de responsabilidade do

Instituto Nacional de Tecnologia da Informac?a?o (ITI)[20] em conjunto com os Labo-

rato?rios de Ensaios e Auditoria11 (LEA), descreve os requisitos te?cnicos a serem valida-

dos no processo de homologac?a?o de um mo?dulo de seguranc?a criptogra?fica no a?mbito da

Infra-estrutura de Chaves Pu?blicas Brasileira, ICP-Brasil[21].

Por HSM entende-se um servidor ou placa auxiliar criptogra?fica fisica-

mente segura, resistente a? violac?a?o que fornece funcionalidades criptogra?ficas com capa-

cidade de gerac?a?o e armazenamento de chaves sime?tricas e assime?tricas voltados essen-

cialmente para utilizac?a?o em uma Infra-estrutura de Chaves Pu?blicas (ICP).

O padra?o MCT-7 define tre?s N??veis de Seguranc?a de Homologac?a?o

(NSH) e dois N??veis de Seguranc?a F??sica (NSF). O NSH e? baseado na disponibilizac?a?o

do co?digo fonte do HSM, onde o NSH 1 na?o requer depo?sito e ana?lise do co?digo fonte

do HSM, o NSH 2 requer depo?sito e ana?lise do co?digo fonte de componentes espec??ficos

associados ao dispositivo em homologac?a?o, enquanto o NSH 3 requer o depo?sito e ana?lise

do co?digo fonte completo associado ao dispositivo em homologac?a?o.

O NSF 1 requer que o mo?dulo tenha mecanismos de seguranc?a f??sica

que evidenciam e resistem a? violac?a?o, enquanto o NSF 2, requer que os mecanismos de

seguranc?a f??sica do HSM detectem e respondam a?s tentativas de violac?a?o. O fabricante

do mo?dulo, referenciado pela norma como parte interessada (PI), deve especificar o N??vel

de Seguranc?a F??sica desejada para homologac?a?o.

O processo de homologac?a?o visa a interoperabilidade e operac?a?o segura

dos servic?os criptogra?ficos providos por um HSM para uma ICP, analisando a adere?ncia

aos requisitos. O escopo da homologac?a?o na?o visa avaliar outros servic?os presentes no

HSM que na?o sejam u?teis para uso em ICPs, desde que na?o exista risco desta coexiste?ncia.

O MCT-7 aborda as 11 a?reas de atuac?a?o relacionadas ao projeto e

implementac?a?o do mo?dulo criptogra?fico utilizadas pela FIPS 140-2 (vide sec?a?o 3.2), ale?m

11Entidades formalmente vinculadas ao ITI, aptas a realizar os ensaios exigidos nas avaliac?o?es de con-
formidade.



31

de incluir outros quatro temas: algoritmos criptogra?ficos obrigato?rios, gerenciamento, in-

teroperabilidade e restric?a?o de substa?ncias nocivas.

Apesar da utilizac?a?o das mesmas a?reas de atuac?a?o, algumas delas sofre-

ram alterac?o?es (adic?a?o, remoc?a?o ou modificac?a?o de alguns requisitos) e sera?o abordados

a seguir, com foco nestas diferenc?as.

3.3.1 Requisitos de Especificac?a?o

Esta a?rea permanece praticamente a mesma existente no padra?o FIPS

140-2, diferenciando-se apenas em um dos requisitos. Enquanto a FIPS requer que o

HSM implemente no m??nimo um algoritmo criptogra?fico aprovado, o MCT-7 apresenta

uma lista de algoritmos obrigato?rias, que inclui:

• DES[22] nos modos de operac?a?o ECB e CBC. Apenas para uso legado;

• Triple-DES nos modos de operac?a?o ECB e CBC;

• AES[23] nos modos de operac?a?o ECB e CBC com tamanho de chaves de 128 bits;

• Assinatura RSA[9, 24] com chaves de 1024 bits no m??nimo;

• Resumos criptogra?ficos: SHA-1[25] e SHA-256, sendo o primeiro apenas para uso
legado.

Ale?m dos obrigato?rios, o MCT-7 recomenda o suporte a outros algorit-

mos criptogra?ficos.

3.3.2 Portas F??sicas e Interfaces Lo?gicas

O MCT-7 define que as portas f??sicas e interfaces lo?gicas para a entrada

e sa??da de componentes de chaves criptogra?ficas, dados de autenticac?a?o e PCSs devem ser

fisica e logicamente separados de outras portas e interfaces do HSM, se enquadrando nos

requisitos de n??vel 3 e 4 do FIPS 140-2.



32

3.3.3 Pape?is, Servic?os e Mecanismos de Autenticac?a?o

Esta a?rea difere em alguns pontos com relac?a?o aos requisitos definidos

na FIPS 140-2. Primeiramente, define-se que o mecanismo de autenticac?a?o deve ser ba-

seado em papel (referente ao n??vel 2 da FIPS 140-2) no NSH 1 e baseado em identidade

nos NSH 2 e NSH 3 (referente aos n??veis 3 e 4 da FIPS 140-2).

Ale?m disso, apesar de suportar o mesmo conjunto de pape?is, somente

o papel administrador e? obrigato?rio, devendo receber a responsabilidade dos pape?is na?o

existentes. A seguir, apresenta-se o conjunto de servic?os obrigato?rios para cada um dos

pape?is:

• papel administrador: inicializac?a?o do HSM, gerac?a?o de chaves RSA, sobrescrita de
chaves criptogra?ficas com zero, finalizac?a?o do mo?dulo, execuc?a?o de auto-testes e

requisic?a?o do estado do HSM;

• papel operador: manipulac?a?o de chaves criptogra?ficas e PCS no HSM, acesso a
algoritmos de resumo e autenticac?a?o, requisic?a?o do estado do HSM e gerac?a?o de

chaves RSA;

• papel de manutenc?a?o: backup e recuperac?a?o de chaves, configurac?a?o de operado-
res e configurac?a?o e controle dos registros do sistema (o processo de auditoria e?

realizado pelo papel de manutenc?a?o).

3.3.4 Modelo de Estado Finito

O modelo de estado finito segue os requisitos especificados no padra?o

FIPS 140-2 com a exclusa?o do estado de desvio, que na?o e? aceito pelo MCT-7.

3.3.5 Seguranc?a F??sica

O MCT-7 na?o faz distinc?a?o do nu?mero de componentes eletro?nicos con-

tidos no HSM como definido na FIPS 140-2, sendo que o modelo de seguranc?a f??sica deve

se enquadrar em uma das seguintes categorias:



33

• protec?a?o que evidencia violac?a?o: referente ao n??vel 2 do padra?o FIPS 140-2 para
mo?dulos criptogra?ficos multi ? chipstandalone

• protec?a?o que resiste a violac?a?o: referente ao n??vel 3 do padra?o FIPS 140-2 para
mo?dulos criptogra?ficos multi ? chipstandalone

• protec?a?o que detecta e responde a? violac?a?o: referente ao n??vel 4 do padra?o FIPS
140-2 para mo?dulos criptogra?ficos multi ? chipstandalone

3.3.6 Ambiente Operacional

O MCT-7 classifica os ambientes operacionais nas tre?s categorias defi-

nidas pela FIPS 140-2, utilizando os requisitos referentes ao n??vel 2, sem a obrigatorie-

dade de um sistema operacional com n??vel de garantia de avaliac?a?o 2 (EAL2) do Crite?rio

Comum.

3.3.7 Gerenciamento de Chaves Criptogra?ficas

Ale?m de herdar todos os requisitos existentes no padra?o FIPS 140-2, o

MCT-7 incorpora outros para se adequar as caracter??sticas da ICP-Brasil. Primeiramente,

requer que a documentac?a?o especifique os me?todos utilizados para armazenar chaves se-

cretas, chaves privadas e PCSs que evitem divulgac?a?o, modificac?a?o e substituic?a?o na?o

autorizada. O mesmo se aplica para chaves pu?blicas, mas com o objetivo de proteger

contra modificac?a?o e substituic?a?o na?o autorizadas.

O MCT-7 tambe?m requer que as chaves criptogra?ficas geradas interna-

mente ao HSM possam ser configuradas como exporta?vel ou na?o exporta?vel. Este requi-

sito visa criar compatibilidade com os certificados digitais do tipo S3, S4, A3 e A4 da

ICP-Brasil. Uma vez configurada como na?o exporta?vel, na?o deve ser poss??vel altera?-la

para exporta?vel.



34

3.3.8 Interfere?ncia e Compatibilidade Eletromagne?tica

Esta a?rea de atuac?a?o conte?m os mesmo requisitos existentes na FIPS

140-2.

3.3.9 Auto-testes

O MCT-7 utiliza o mesmo conjunto de auto-testes definidos no padra?o

FIPS 140-2, com a restric?a?o de que se o auto-teste de inicializac?a?o falhar, o HSM esta?

comprometido e na?o pode mais ser considerado confia?vel.

3.3.10 Garantia de Projeto

Os requisitos de garantia de projeto sa?o os mesmos encontrados no

padra?o FIPS 140-2, mudando apenas a relac?a?o de alguns dos requisitos com o n??vel de

seguranc?a de homologac?a?o (NSH) desejado.

O NSH 1 requer documentos guias para administradores e operadores,

enquanto o NSH 2, adicionalmente, requer o co?digo fonte de todos os componentes de

software e firmware, com comenta?rios que esclarec?am a corresponde?ncia com os compo-

nentes do mo?dulo criptogra?fico.

3.3.11 Mitigac?a?o de Outros Ataques

Abordado da mesma forma que o padra?o FIPS 140-2.

3.3.12 Requisitos de Gerenciamento

Esta a?rea de atuac?a?o apresenta uma lista de funcionalidades que devem

estar dispon??veis aos usua?rios do HSM, para executar operac?o?es de controle do hardware,

do mo?dulo criptogra?fico e das chaves gerenciadas. Cada um dos itens anteriores se rami-

ficam em va?rios requisitos.

O gerenciamento do hardware deve conter procedimentos de gerac?a?o

de co?pias de seguranc?a e sua posterior recuperac?a?o, protec?a?o contra falta de energia e



35

falhas de comunicac?a?o, atualizac?a?o e validac?a?o de firmware e controle de ativac?a?o de

mecanismos de segredo compartilhado.

O HSM deve dispor de uma interface gra?fica com idioma em portugue?s

ou ingle?s para seu gerenciamento, incluindo a possibilidade de importar e exportar cha-

ves sime?tricas e assime?tricas, apagar dados contidos no mo?dulo (inclusive chaves crip-

togra?ficas), entre outros.

3.3.13 Requisitos de Interoperabilidade

Esta a?rea avalia o mo?dulo do ponto de vista de interoperabilidade,

visando garantir um conjunto m??nimo de funcionalidades para integrac?a?o com outras

aplicac?o?es. O MCT-7 requer que pelo menos uma das seguintes API esteja dispon??vel

para o HSM em avaliac?a?o:

• Microsoft CryptoAPI[26]

• PKCS#11 v.2.11[27]

• JCE12/JCA13

• interface pro?pria14

• engine OpenSSL (vide sec?a?o 4.5)

Para cada uma das API, define-se um conjunto m??nimo de func?o?es que

deve estar presente, devendo, quando poss??vel, ser compat??vel com os sistemas operacio-

nais Microsoft Windows 2000, Linux Kernel 2.4 ou suas verso?es mais recentes.

3.3.14 Requisitos para restric?a?o de substa?ncias nocivas

O MCT-7 recomenda que os HSM estejam em conformidade com di-

retivas estabelecidas quanto a restric?a?o da utilizac?a?o de substa?ncias nocivas, visando a?
12Extensa?o de criptografia JAVA, do ingle?s Java Cryptography Extension
13API de comunicac?a?o Java, do ingle?s Java Communications API
14conjunto de func?o?es disponibilizadas pelo fabricante do mo?dulo, sem seguir um padra?o conhecido, que

permitira? a utilizac?a?o das chaves criptogra?ficas gerenciadas.



36

preservac?a?o da sau?de humana e do meio ambiente. Como refere?ncia cita-se o RoHS15[28]

e o WEEE16[29], ambas diretivas da Unia?o Europe?ia, sendo que a u?ltima define o correto

tratamento, recuperac?a?o e reciclagem de res??duos de materiais eletroeletro?nicos.

3.4 Conclusa?o

As normas de avaliac?a?o apresentadas nesse cap??tulo diferenciam-se

principalmente pelo grau de abrange?ncia, onde a FIPS 140-2 certifica qualquer hardware

criptogra?fico, enquanto o MCT-7 restringe-se a HSM voltados para ICPs.

Ale?m disso, o MCT-7, nos n??veis 2 e 3 de seguranc?a da homologac?a?o,

requer o depo?sito de co?digo fonte, requisito muitas vezes na?o aprovado pelos fabricantes

dos HSM, por ameac?ar o segredo industrial.

O MCT-7 se encaixa perfeitamente com os objetivos do HSM do GT

ICPEDU II, ja? que este u?ltimo teve seu desenvolvimento direcionado para ICPs e possui

plataforma totalmente aberta.

A ause?ncia de elementos que viabilizem um processo de auditoria afe-

tam tanto a FIPS 140-2 quanto o MCT-7. Ale?m disso, como o foco deste u?ltimo sa?o

as aplicac?o?es de ICPs, esse comportamento torna o ambiente deficiente, ja? que um sis-

tema de auditoria forte e? requisito fundamental para a utilizac?a?o de cerimo?nias que visam

garantir a correta operacionalizac?a?o de HSM no a?mbito de ICPs.

Outro ponto a se considerar e? a falta de requisitos para o estabeleci-

mento de um controle mais restrito no uso de chaves criptogra?ficas, como tambe?m na

criac?a?o e recuperac?a?o de co?pias de seguranc?a dos HSM. A rastreabilidade das mesmas no

a?mbito de ICPs e? fundamental, ja? que suas ACs e ARs definem o ponto de confianc?a de

toda uma hierarquia.

15do ingle?s Restriction to the use of Hazardous Substances
16do ingle?s Waste from Electrical and Electronic Equipament



Cap??tulo 4

OpenSSL

4.1 Introduc?a?o

O OpenSSL[30] e? uma poderosa e robusta ferramenta para soluc?o?es

envolvendo criptografia. Desenvolvido na linguagem C sob esforc?o colaborativo de

co?digo aberto, o OpenSSL possui uma aplicac?a?o de linha de comando para execuc?a?o

de operac?o?es criptogra?ficas e uma rica biblioteca, que inclui implementac?a?o dos dois

principais protocolos de comunicac?a?o segura: SSL (Secure Socket Layer v3)[31] e TLS

(Transport Layer Security v1)[32].

Atualmente (julho de 2008) na versa?o 0.9.8h, o OpenSSL foi baseado

na biblioteca SSLeay desenvolvida por Eric A. Young e Tim J. Hudson e e? distribu??do

sob licenc?a estilo apache, que basicamente significa que qualquer um e? livre para usa?-la,

comercialmente ou na?o.

O OpenSSL e? largamente empregado em aplicac?o?es criptogra?ficas co-

merciais, como no mo?dulo de conexa?o segura (mod-ssl) do servidor Web mais utilizado

no mundo, o Apache[33]. Adicionalmente, o OpenSSL possui uma versa?o certificada

FIPS 140-2 n??vel 1 (vide sec?a?o 4.6), que mostra a abrange?ncia do projeto.

As pro?ximas sec?o?es descrevera?o as principais funcionalidades e recur-

sos implementados no OpenSSL, incluindo sua aplicac?a?o de linha de comando para exe-

cutar operac?o?es criptogra?ficas, a biblioteca de aux??lio ao desenvolvimento de aplicac?o?es



38

e o suporte a engines, que permitem a utilizac?a?o de outras implementac?o?es dos algorit-

mos suportados pelo OpenSSL, possibilitando, por exemplo, sua integrac?a?o a hardware

criptogra?ficos.

4.2 Aplicac?a?o de Linha de Comando

O pacote do OpenSSL inclui uma aplicac?a?o de linha de comando que

possibilita a utilizac?a?o de todas as func?o?es criptogra?ficas implementadas na biblioteca.

Todas essas func?o?es podem ser agrupadas em:

• operac?o?es de criptografia sime?trica;

• criac?a?o e manipulac?a?o de chaves e para?metros criptogra?ficos de algoritmos as-
sime?tricos;

• operac?o?es de criptografia assime?trica;

• ca?lculo de mensagens de resumo (hash);

• criac?a?o de certificados X.509[10], requisic?o?es de certificados (REQ)[34] e lista de
certificados revogados (LCR)[10];

• testes de servidores e clientes que implementam protocolos SSL/TLS;

• codificac?a?o de e-mails assinados e/ou cifrados;

• requisic?a?o, gerac?a?o e verificac?a?o de carimbos de tempo (implementado na futura
versa?o 0.9.9 do OpenSSL).

As func?o?es dispon??veis na aplicac?a?o de linha de comando sa?o imple-

mentadas visando a maior abrange?ncia poss??vel. Por exemplo, no caso de gerac?a?o de um

certificado, seu conteu?do pode ser gravado em formato PEM (Base 64), DER (Bina?rio)

ou NET (um formato obsoleto da Netscape).



39

O poder de customizac?a?o das operac?o?es possibilita o desenvolvimento

de aplicac?o?es sem utilizac?a?o da biblioteca e sim chamadas da linha de comando, que pos-

sui seu poder de ac?a?o aumentado com o suporte a arquivos de configurac?a?o (sec?a?o 4.3.1),

automatizando e padronizando diversas operac?o?es. Ale?m disso, existem comandos que

foram criados especialmente para integrar aplicac?o?es com o OpenSSL linha de comando,

tais como as func?o?es que informam se um determinado algoritmo e? suportado.

4.3 Infra-estrutura de Suporte

Ale?m de algoritmos criptogra?ficos, o OpenSSL implementa inu?meras

func?o?es e funcionalidades auxiliares que facilitam o desenvolvimento de aplicac?o?es reais.

Algumas das facilidades, entre elas a operac?a?o de nu?meros grandes,

tratamento de erros e abstrac?a?o de entrada e sa??da, sera?o tratadas separadamente em sub-

sec?o?es neste cap??tulo, apontando suas caracter??sticas e utilidade. As facilidades imple-

mentadas podem ser u?teis para a aplicac?a?o de linha de comando e/ou aplicac?o?es utilizando

a biblioteca OpenSSL.

4.3.1 Arquivos de Configurac?a?o

O OpenSSL inclui a capacidade de ler e interpretar arquivos de

configurac?a?o em tempo de execuc?a?o. Com estrutura interna baseada em sec?o?es, esses

arquivos podem ser utilizados atrave?s da aplicac?a?o de linha de comando ou pela bibli-

oteca OpenSSL. O item openssl conf e? utilizado pelo OpenSSL para mapear a sec?a?o

principal (como pode ser visto na tabela 4.1).

Os arquivos de configurac?a?o sa?o essenciais no gerenciamento de uma

autoridade certificadora atrave?s da aplicac?a?o de linha de comando do OpenSSL, definindo

o conteu?do dos certificados e lista de certificados revogados. Adicionalmente, todas as

extenso?es suportadas ou na?o pelo OpenSSL podem ser definidas com a utilizac?a?o de ar-

quivos de configurac?a?o. Para extenso?es na?o suportadas e? necessa?rio definir sua sequ?e?ncia

ASN.1[35] correspondente.



40

Um processo de carga e utilizac?a?o de engines (vide sec?a?o 4.5) tambe?m

pode ser automatizado utilizando arquivos de configurac?a?o, suportando ate? eventuais

para?metros que podem ser necessa?rios em alguns casos. O arquivo de configurac?a?o ne-

cessa?rio para carga da engine do HSM do GT ICPEDU II pode ser visto na tabela 4.1.

Tabela 4.1: Arquivo de configurac?a?o do OpenSSL para carga da engine do ASI-HSM.

1. openssl conf = openssl init

2. [ openssl init ]

3. engines = engine section

4. [ engine section ]

5. openhsmd = openhsmd section

6. [ openhsmd section ]

7. engine id = openhsmd

8. dynamic path = ../engines/engine openhsmd.so

9. ADDRESS CONN = 192.168.1.1

10. PORT CONN = 5001

A API dos arquivos de configurac?a?o do OpenSSL pode ser extendida

e utilizada em outras aplicac?o?es, evitando a implementac?a?o de um mo?dulo de software

com a mesma finalidade, economizando tempo e minimizando as chances de ocorre?ncia

de erros.

4.3.2 Func?o?es de Callback

O objetivo dessas func?o?es e? proporcionar flexibilidade e extensa?o das

funcionalidades de uma biblioteca, permitindo aos desenvolvedores implementar o com-

portamento de acordo com a necessidade de sua aplicac?a?o.

As func?o?es de callback na?o sa?o executadas diretamente pela aplicac?a?o,

ao inve?s disso, seu ponteiro e? passado para outras func?o?es, de onde elas sera?o chamadas.

Para isso, as func?o?es de callback devem seguir o formato previamente definido pela bibli-

oteca que as utilizam, isto e?, a quantidade e tipos dos argumentos e o tipo da varia?vel de

retorno.

A figura 4.1 demonstra o funcionamento das func?o?es de callback, sa-

lientando a indiferenc?a da biblioteca quanto a operac?a?o que esta? sendo executada. A



41

Figura 4.1: Funcionamento das func?o?es de callback, empregadas no OpenSSL.

biblioteca esta? passando os inteiro 5 e 2 como para?metro de uma func?o?es implementada

pela aplicac?o?es. A execuc?a?o das linhas 10 e 11 resulta, respectivamente, nos valores 7 e

3.

O OpenSSL emprega func?o?es de callback em va?rias de suas funciona-

lidades, tal como no processo de gerac?a?o de nu?meros primos, que, com sua utilizac?a?o,

pode-se acompanhar cada tentativa do processo de encontrar o nu?mero primo apropriado.

Adicionalmente, para algumas funcionalidades da biblioteca OpenSSL,

o emprego dessas func?o?es e? fundamental, como no suporte a execuc?a?o multi-thread, que

e? o assunto da pro?xima sub-sec?a?o.

4.3.3 Suporte Multi-thread

A biblioteca OpenSSL emprega controle de acesso concorrente as estru-

turas consideradas cr??ticas quando executado em modo multi-thread, protegendo-os com

uso de sema?foros.

Entretanto, o efetivo uso desse controle fica a cargo da aplicac?a?o que

esta? utilizando a biblioteca OpenSSL, pois esta deve implementar a func?a?o que sera? res-

ponsa?vel por checar e bloquear o acesso aos recursos. Essa func?a?o de callback deve ser

configurada no OpenSSL no in??cio da execuc?a?o da aplicac?a?o.



42

O controle de acesso a recursos na biblioteca requer obrigatoriamente a

definic?a?o da func?a?o de callback que ira? implementar as operac?o?es de bloqueio e liberac?a?o

dos sema?foros. Nas chamadas a func?a?o de callback solicitando acesso a um recurso

compartilhado, existe a distinc?a?o de operac?o?es de somente-leitura das operac?o?es leitura-

escrita. Fica a cargo da aplicac?a?o o n??vel de controle desejado. A aplicac?a?o de linha de

comando do OpenSSL implementa uma func?a?o de callback que trata indiferentemente

operac?a?o de leitura e escrita, garantindo acesso exclusivo a qualquer um dos casos.

Na sec?a?o 4.5 sera? abordado com detalhes o controle de acesso si-

multa?neo realizado pela biblioteca para gerenciar o suporte as engines.

4.3.4 Matema?tica de Precisa?o Arbitra?ria

A biblioteca OpenSSL possui incorporado um conjunto de func?o?es ca-

paz de manipular e executar operac?o?es matema?ticas sobre nu?meros grandes, isto e?, que

na?o podem ser representados nas varia?veis do tipo inteiro de 32 ou 64 bits encontrado nas

plataformas computacionais convencionais.

A manipulac?a?o de nu?meros grandes e? essencial para a implementac?a?o,

entre outra, do algoritmo de chaves pu?blicas RSA, considerando que chaves deste algo-

ritmo devem ter um tamanho m??nimo de seguranc?a de 1024 bits, como definido na FIPS

140-2.

O conjunto de func?o?es implementadas inclui todas operac?o?es normal-

mente dispon??veis sobre varia?veis do tipo inteiro em linguagens de programac?a?o em ge-

ral, incluindo operac?o?es modulares, utilizadas em cifragens e decifragens RSA, ale?m da

gerac?a?o de nu?meros primos, que incorpora os testes conhecidos de primalidade.

Esta funcionalidade e? outro recurso que pode ser usufruido por

aplicac?o?es utilizando a biblioteca OpenSSL, diminuindo a complexidade de aplicac?o?es

com necessidades semelhantes.



43

4.3.5 Tratamento de Erros

O OpenSSL possui um sistema centralizado para tratar erros durante

sua execuc?a?o, atribuindo identificadores u?nicos para cada parte/mo?dulo de sua biblioteca.

Esses identificadores sa?o utilizados para separar os identificadores de func?o?es e erros de

cada mo?dulo.

Quando um erro acontece, 5 informac?o?es referentes ao erro sa?o regis-

tradas:

• o identificador do mo?dulo;

• o identificador da func?a?o;

• identificador do erro;

• nome do arquivo (automaticamente obtido com a macro F ILE da linguagem
C);

• linha na qual o erro foi disparado (automaticamente obtido com a macro LIN E
da linguagem C);

Cada mo?dulo e? responsa?vel por carregar no sistema o texto correspon-

dente a cada identificador, tanto de func?a?o quanto de erro, permitindo a conversa?o dos

erros ocorridos durante a execuc?a?o do sistema em texto leg??vel.

O OpenSSL disponibiliza a func?a?o ERR load crypto strings para

carregar todos os identificadores e seus respectivos textos de todos seus mo?dulos nativos

de uma so? vez. Normalmente, esse e? um dos primeiros passos dentro de uma aplicac?a?o

utilizando a biblioteca OpenSSL.

Na aplicac?a?o de linha de comando, os erros sa?o impressos ao final da

execuc?a?o de qualquer operac?a?o que venha a falhar. Ja? no caso de aplicac?o?es utilizando

a biblioteca OpenSSL, as func?o?es de manipulac?a?o dos erros precisam ser explicitamente

acionadas.

O sistema de erros do OpenSSL suporta a adic?a?o de novos mo?dulos

de erros, permitindo que bibliotecas e aplicativos o utilizem para gerenciamento de seus



44

erros, deixando o sistema uniforme. O OpenSSL inclui scripts que vasculham o co?digo

fonte e geram os arquivos necessa?rio para essa integrac?a?o.

4.3.6 Abstrac?a?o de Entrada e Sa??da

A abstrac?a?o de entrada e sa??da (BIO) do OpenSSL permite a

comunicac?a?o entre dois pontos de forma transparente, isto e?, sem a manipulac?a?o de carac-

ter??sticas inerentes a fonte/destino da informac?a?o. Ale?m disso, camadas podem ser adici-

onadas nesses canais de comunicac?a?o, provendo funcionaliades extras. No OpenSSL, os

BIOs sa?o agrupados em dois tipos primitivos: comunicac?a?o e filtro.

Os BIOs de comunicac?a?o sa?o utilizados na troca de informac?a?o entre

duas entidades, podendo essas serem arquivos, sockets, memo?ria ou simplesmente um

outro BIO para comunicac?a?o dentro da pro?pria aplicac?a?o. O uso de algumas dessas enti-

dades incorporam um outro sub-tipo de BIOs, chamado de descriptor. Este sub-tipo se

aplica a entidades que utilizam descritores de arquivos, como no caso de sockets.

Um exemplo da utilizac?a?o dos BIOs de comunicac?a?o seria o processo

de escrita de dados em um arquivo no disco r??gido, atrave?s de um BIO arquivo. O mesmo

processo vale para leitura de arquivos.

Os BIOs do tipo filtro sa?o recursos adicionais aos BIOs de comunicac?a?o,

capazes de processar os dados transferidos, agindo como uma camada extra na

comunicac?a?o entre dois pontos. O processamento realizado pelo filtro depende da sua

finalidade, que pode ser:

• conversor base64 ( conversa?o e vice-versa );

• calculo de func?o?es de resumo;

• criptografia sime?trica (cifrar e decifrar);

• protocolo SSL;

No caso do exemplo anterior, se os dados a serem escritos no arquivo

precisam ser convertidos em base64, acopla-se o BIO filtro espec??fico em frente ao BIO



45

arquivo, de forma que os dados sera?o escritos no BIO base64 e terminara?o no arquivo de

destino, com os dados convertidos em base64. Na?o existe limite da quantidade de filtros

que podem ser conectados.

O emprego de filtros deixa o processo simples e uniforme, independente

da quantidade de camadas existentes, onde a sa??da de uma camada e? a entrada da pro?xima,

ate? atingir o no? final. Cada BIO do tipo filtro realiza uma operac?a?o em um sentido que

a informac?a?o e? transferida e a operac?a?o inversa no sentido oposto, ou seja, voltando no

exemplo do arquivo em base64, tudo que for escrito sera? convertido em base64, e o que

for lido retornara? ao formato original. Vale destacar que o processo inverso na?o se aplica

para a func?o?es de resumo, devido sua propriedade de irreversibilidade.

A abstrac?a?o provida pelos BIOs de comunicac?a?o ja? justificaria a

existe?ncia dos BIOs, entretanto, com a adic?a?o dos tipos filtros, sua utilidade multiplica-se

de tamanho, agregando inu?meras possibilidades. E? poss??vel por exemplo criar um socket

usando BIO e posteriormente adicionar um BIO ssl nas pontas, de forma a estabelecer um

canal seguro de comunicac?a?o.

A utilizac?a?o de BIOs esta? difundida em todo co?digo do OpenSSL, en-

globando todas as func?o?es de leitura e escrita de arquivos do sistema, tais como o manu-

seio de chaves pu?blicas e privadas.

A abstrac?a?o de Entrada e Sa??da apresentada nesta sec?a?o e? voltada para

desenvolvedores utilizando a biblioteca OpenSSL, ja? que na aplicac?a?o de linha de co-

mando, apesar de utiliza?-los intensamente, esse recurso passa despercebido.

4.4 Documentac?a?o

Documentac?a?o e? um dos pontos mais importantes para que uma ferra-

menta, que e? necessariamente voltada para usua?rios em geral, seja facilmente assimilada e

compreendida na sua forma de utilizac?a?o e operac?a?o. O OpenSSL, apesar de toda sua ge-

nialidade explicada aqui, peca neste quesito. A falta de documentac?a?o, principalmente na

biblioteca que permite integrac?a?o com outros aplicativos, dificulta muito sua utilizac?a?o.

As constantes atualizac?o?es e gerac?a?o de novas verso?es acabam aconte-



46

cendo sem os devidos cuidados com os materiais auxiliares de aprendizado, fazendo com

que a pouca documentac?a?o existente fique desatualizada e muitas vezes piorando ainda

mais sua compreensa?o.

O co?digo fonte acaba se tornando o principal meio de obter conheci-

mento detalhado dos objetivos das func?o?es e procedimentos, resultando muitas vezes em

mais tempo gasto entendendo a biblioteca do que realmente pensando na soluc?a?o do pro-

blema. A utilizac?a?o de outras fontes de documentac?a?o como livros[36], artigos e lista de

discusso?es sa?o alternativas.

4.5 Engine

O OpenSSL implementa cada um dos algoritmos criptogra?ficos por ele

suportado, possibilitando que sejam operacionalizados por outras aplicac?o?es. Entretanto,

em algumas situac?o?es, e? necessa?rio a utilizac?a?o de outras implementac?o?es, como no caso

dos aceleradores criptogra?ficos, que implementam os algoritmos em hardware e suportam

grande poder de processamento. Nestes casos, a sa??da e? a utilizac?a?o de engines OpenSSL.

Uma engine OpenSSL e? um mo?dulo de software que permite ao seu de-

senvolvedor substituir as implementac?o?es padro?es dos algoritmos existentes. As engines

podem implementar um ou mais algoritmos e sa?o classificadas de esta?ticas ou dina?micas.

As engines esta?ticas sa?o integradas e compiladas com o co?digo fonte do

OpenSSL, tornando-as parte do pacote criptogra?fico. Elas sa?o automaticamente carrega-

das sempre que o OpenSSL e? referenciado. Por outro lado, as engines dina?micas podem

ser carregadas em tempo de execuc?a?o, sem necessitar nenhuma alterac?a?o na versa?o ori-

ginal do OpenSSL. Uma engine dina?mica e? gerada da mesma forma que uma biblioteca

dina?mica, sendo normalmente identificada pela extensa?o .so no Unix1 e .dll no Microsoft

Windows2.

Internamente, o OpenSSL define uma engine como uma estrutura cha-

mada EN GIN E, que contem os seguintes campos:

1Sistema operacional de software livre.
2Sistema operacional da Microsoft Corporation.



47

• id: identifica unicamente uma engine no OpenSSL. Tanto a aplicac?a?o de linha de
comando quanto a biblioteca utilizando este campo como refere?ncia;

• name: tem somente papel descritivo;

• rsa meth, dsa meth, dh method, ecdsa meth, ecdh meth e rand meth: estru-
tura definindo os ponteiros das func?o?es responsa?veis pelo manuseio do algoritmo

em questa?o (RSA, DSA, DH, ECDSA, ECDH ou func?o?es de aleatoriedade). Por

exemplo, o campo rand meth conte?m os ponteiros para func?o?es capazes de gerar

dados rando?micos e pseudorando?micos, adicionar entropia, carregar o estado do

gerador, entre outros;

• ciphers e digests: diferentemente dos algoritmos anteriores, onde cada algoritmo
possuia uma estrutura pro?pria, os algoritmo sime?tricos e func?o?es de resumo pos-

suem o ponteiro para apenas uma func?a?o cada;

• init e f inish: func?o?es de inicializac?a?o e fim da execuc?a?o da engine. Servem para
a engine criar e preparar as estruturas internas necessa?rias para seu funcionamento.

Por exemplo o estabelecimento da conexa?o com um HSM.

• destroy: func?a?o chamada antes de remover a engine da lista de engines do
OpenSSL. Deve ser utilizada para liberar qualquer tipo de memo?ria alocada, como

por exemplo a descarga de suas mensagens de erros do sistema de erro do OpenSSL;

• ctrl: ponteiro para uma func?a?o capaz de interpretar os para?metros necessa?rios pela
engine. Por exemplo o enderec?o IP de um HSM conectado na rede;

• load privkey e load pubkey: func?a?o para carregar chaves pu?blicas e privadas ge-
renciadas atrave?s da engine. O retorno desta func?a?o e? uma estrutura EV P P KEY ,

que pode ser utilizada para encapsular todas as chaves assime?tricas suportadas pelo

OpenSSL;

• cmd def ns: define os comandos aceitos e interpretados por ctrl. Cada co-
mando conte?m um identificador (que deve iniciar com o valor da constante



48

EN GIN E CM D BASE, seguindo com EN GIN E CM D BASE + 1, ...),

nome do commando, sua descric?a?o e o tipo do valor de entrada esperado. Os

poss??veis tipos de respostas sa?o: nume?rico ou texto. Os comandos ainda podem

na?o necessitar nenhuma entrada ou ate? mesmo ser marcado para uso interno;

• struct ref e f unct ref : utilizado pelo OpenSSL para controle do nu?mero de re-
fere?ncias a? estrutura e ao conjunto de func?o?es de uma engine. Garante a utilizac?a?o

da engine em va?rias partes do aplicac?a?o, evitando, por exemplo, a inicializac?a?o de

uma engine ja? inicializada;

• outros: para?metros utilizados para controle interno, como prev e next, que mante?m
uma lista duplamente encadeada das engines dispon??veis, ex data, utilizada para

armazenamento de dados referente a engine e f lags, que define suas caracter??sticas.

Algumas peculiaridades devem ser levadas em conta no desenvolvi-

mento de uma engine OpenSSL para a utilizac?a?o de chaves gerenciadas por um HSM.

Primeiramente, o que fazer com a func?a?o loadprivkey, ja? que na?o se quer carregar a chave

privada na memo?ria da ma?quina hospedeira, na?o faria o m??nimo sentido utilizar uma HSM

para proteger o ciclo de vida de chaves criptogra?ficas e deixa?-la em aberto desta forma.

Uma abordagem comum para resolver esse problema e? retornar a chave pu?blica nas duas

func?o?es loadprivkey e loadpubkey. Em um primeiro momento pode parecer estranho,

mas isso e? poss??vel porque ale?m de o OpenSSL utilizar uma u?nica estrutura para repre-

sentar chaves pu?blicas e privadas de um mesmo algoritmo, sera? a engine que ira? executar

as operac?o?es sobre essa chave. Portanto, toda vez que uma operac?a?o com a chave privada

for realizada, a pro?pria engine sera? chamada e a chave privada correta pode ser identifi-

cada baseado na chave pu?blica, utilizando seus valores pu?blicos (nu?meros primos n e e)

ou atrave?s do identificador da chave explicitamente armazenado na varia?vel exdata, que

como na engine, existe tambe?m nas estruturas de chaves.

Adicionalmente, a estrutura de chaves criptogra?ficas da biblioteca pos-

sui um atributo chamado engine, que aponta para a engine responsa?vel por realizar as

operac?o?es criptogra?ficas da chave. Portanto, apo?s a carga da chave atra?ves das func?o?es

load privkey e load pubkey, deve-se substituir o valor deste atributo pela engine atual.



49

Conceitualmente falando, a diferenc?a entre uma cifragem assime?trica

e uma assinatura esta? na chave que e? utilizada na operac?a?o, chave pu?blica no primeiro

caso e chave privada no segundo, e tambe?m na informac?a?o sobre a qual a ac?a?o e? rea-

lizada, no u?ltimo caso o resultado de uma func?a?o de resumo. Sabendo disso, o u?ltimo

ponto relevante na implementac?a?o de uma engine esta? na estrutura de operac?o?es RSA

(RSA M ET HOD). Ela possui basicamente 6 func?o?es:

• rsa pub enc: cifragem utilizando uma chave pu?blica;

• rsa priv dec: decifragem utilizando uma chave privada;

• rsa priv enc: cifragem utilizando uma chave privada;

• rsa pub dec: decifragem utilizando uma chave pu?blica;

• rsa sign: gerac?a?o de assinaturas;

• rsa verif y: verificac?a?o de assinaturas;

Como pode ser observado, as func?o?es rsa priv enc e rsa sign pos-

suem a mesma finalidade de gerac?a?o de assinaturas, o que acontence com rsa pub dec e

rsa verif y tambe?m. Uma engine na?o deve implementar estas quatro func?o?es, e sim es-

colher o conjunto que preferir. O ponto chave aqui e? utilizar o campo f lags da estrutura

das chaves RSA para marcar qual o conjunto de func?o?es que deve ser acionado. Se a flag

RSA F LAG SIGN V ER estiver configurada, as func?o?es rsa sign e rsa verif y sera?o

utilizadas. As quatro func?o?es ainda existem por uma questa?o de compatibilidade com

verso?es anteriores do OpenSSL, sendo por padra?o utilizado rsa privenc e rsa pub dec,

apesar de rsa sign e rsa verif y serem mais novas.

4.6 OpenSSL FIPS 140-2 n??vel 1

O OSSI[37] (Open Source Software Institute3), entidade sem fins lu-

crativos, em conjunto com o nu?cleo de desenvolvimento do OpenSSL preparou e subme-
3Instituto de Software de Co?digo Aberto em traduc?a?o literal



50

teu a biblioteca do OpenSSL para avaliac?a?o nos requisitos da FIPS 140-2, alcanc?ando a

certificac?a?o da versa?o 1.0 do OpenSSL FIPS em marc?o de 2006[38].

O OpenSSL FIPS 1.0 submetido a certificac?a?o conte?m um conjunto li-

mitado de func?o?es do OpenSSL 0.9.7 e sua utilizac?a?o por um aplicac?a?o difere-se um

pouco do usual. O co?digo do OpenSSL FIPS deve ser compilado para gerar o co?digo

objeto e esse co?digo objeto deve ser estaticamente ligado4 no processo de compilac?a?o

do co?digo fonte da aplicac?a?o. A biblioteca criptogra?fica do OpenSSL tambe?m deve ser

ligada na aplicac?a?o, podendo esta ser esta?tica ou dina?mica.

Os desenvolvedores do OpenSSL FIPS implementaram va?rias te?cnicas

para verificac?a?o de integridade nas va?rias etapas que o mo?dulo pode assumir, com che-

cagens automa?ticas do co?digo fonte durante a compilac?a?o, no co?digo objeto durante a

ligac?a?o e no co?digo executa?vel quando o modo FIPS do mo?dulo e? ativado. Durante a

ativac?a?o do modo FIPS, atrave?s da func?a?o F IP S mode set, os auto-testes sa?o iniciados

e todos devem obrigatoriamente passar. Uma vez em modo FIPS, somente operac?o?es de

algoritmos aprovados podem ser executadas. A tabela 4.2 conte?m os algoritmos crip-

togra?ficos aprovados na versa?o FIPS do OpenSSL.

Tabela 4.2: Algoritmos Criptogra?ficos Aprovados no OpenSSL FIPS versa?o 1.1.2

Tipo de Algoritmo Algoritmos
Assime?trico RSA
Sime?trico 3DES (nos modos: CBC, CFB8, CFB64, ECB e OFB)

AES de 128, 192 or 256 bits (nos modos CBC, CFB8, CFB128,
ECB e OFB)

HMAC HMAC-SHA-1, HMAC-SHA-224, HMAC-SHA-256, HMAC-
SHA-384 e HMAC-SHA-512

Func?o?es de resumo SHA-1, SHA-224, SHA-256, SHA-384 e SHA-512
RNG ANSI X9.31[39]

Em junho de 2006, o certificado da versa?o 1.0 foi suspenso, porque

identificou-se que func?o?es cr??ticas na?o estavam implementadas dentro do per??metro de

seguranc?a. Apo?s as alterac?o?es necessa?rias, submeteu-se uma nova versa?o, 1.1, mas a

4processo de associac?a?o dos va?rios co?digos objetos com o objetivo de resolver pende?ncias externas,
gerando o co?digo executa?vel



51

reativac?a?o do certificado nunca ocorreu. A versa?o foi alterada de 1.1 para 1.1.1 e subme-

tida a um novo processo de certificac?a?o.

A versa?o 1.1.1[40], aprovada em 06/02/2007, foi revogada em

30/11/2007 por dois problemas no gerador de nu?meros aleato?rios: um bug no auto-teste

cont??nuo e uma vulnerabilidade no processo de inclusa?o de sementes. Uma nova versa?o

do co?digo, 1.1.2, com essas deficie?ncias sanadas, foi novamente submetida a certificac?a?o,

pore?m, no meio do processo, os requisitos dos auto-testes para operac?o?es DSA mudou de

512 bits para a utilizac?a?o de chaves de 1024 bits. Para evitar mais atrasos, o algoritmo

DSA foi retirado do processo de certificac?a?o, diminuindo o nu?meros de algoritmos apro-

vados. A alterac?a?o do auto-teste do DSA de 512 para 1024 bits era realmente simples,

mas significaria o rein??cio do processo de certificac?a?o, uma vez que o co?digo fonte iria

sofrer alterac?o?es.

A versa?o 1.1.2 recebeu a certificac?a?o em 6 de fevereiro de 2008[41].

Uma nova versa?o, 1.2, ja? esta? em processo de desenvolvimento e sera? baseada na versa?o

0.9.8 do OpenSSL.

4.7 Conclusa?o

O OpenSSL e? uma ferramenta de criptografia com suporte a um grande

nu?mero de algoritmos criptogra?ficos. Seus va?rios anos de desenvolvimento e testes rea-

lizados por muitos usua?rios ao redor do mundo passam credibilidade quanto a qualidade

dos resultados obtidos. Ale?m disso, alguns de seus algoritmos criptogra?ficos fazem parte

do OpenSSL FIPS, que possui certificac?a?o FIPS 140-2 n??vel 1.

Por outro lado, sua documentac?a?o e? um tanto deficiente, deixando de-

senvolvedores sem muitas alternativas de aux??lio. As principais fontes de informac?o?es

acabam sendo seu co?digo fonte e suas listas de discussa?o, que esta?o dispon??veis na pa?gina

do projeto.

As engines OpenSSL permitem a integrac?a?o de aplicativos com

mo?dulos criptogra?ficos, tornando poss??vel a utilizac?a?o de chaves criptogra?ficas geren-

ciadas em um HSM. E? nessa plataforma que o desenvolvimento do ASI-HSM se baseou,



52

suprindo o requisito de ser compat??vel com o sistema de gerenciamento de certificado

digitais da ICPEDU.



Cap??tulo 5

ASI-HSM

5.1 Introduc?a?o

O projeto ICPEDU II surgiu da necessidade de se criar um mo?dulo de

seguranc?a criptogra?fica com tecnologia brasileira, de co?digo aberto e de baixo custo, vol-

tado principalmente para a implantac?a?o da Infra-estrutura de Chaves Pu?blicas para Ensino

e Pesquisa (ICPEDU). O HSM fruto deste projeto e? o ASI-HSM.

O ASI-HSM sera? descrito neste cap??tulo, com apresentac?a?o de sua ar-

quitetura e os componentes necessa?rios para sua operacionalizac?a?o. O protocolo imple-

mentado internamente para a gesta?o do ciclo de vida de chaves criptogra?ficas e? conhe-

cida como OpenHSM e e? abordado nos cap??tulos 6 e 7. Os protocolos e algoritmos

do OpenHSM foram concebidos para serem embarcados em hardware criptogra?fico que

provesse os mecanismos de protec?a?o conforme estabelece os requisitos apresentados no

Cap??tulo 3. A arquitetura do ASI-HSM e? descrita na Sec?a?o 5.2.

O HSM pode ser visto como um sistema provedor de servic?os crip-

togra?ficos. Para poder utiliza?-lo a partir de uma aplicac?a?o numa ma?quina hospedeira, e?

necessa?rio uma interface de comunicac?a?o. A interface escolhida para o ASI-HSM foi

a ”engine”do OpenSSL, descrito no Cap??tulo 4. A interface do proto?tipo e? descrita na

Sec?a?o 5.4.

Ale?m deste canal de comunicac?a?o para acesso aos servic?os, foi proje-



54

tado um sistema de gesta?o remota do HSM, que e? executado na ma?quina hospedeira, para

realizar a configurac?a?o, administrac?a?o, operac?a?o e auditoria do material criptogra?fico pro-

tegido pelo HSM e gerenciado pelo OpenHSM. Este sistema e? apresentado na Sec?a?o 5.3.

5.2 Arquitetura

O ASI-HSM e? composto por uma se?rie de componentes de hardware

e software, que cooperam entre si com o intuito de proteger, gerenciar e monitorar os

recursos e servic?os dispon??veis no mesmo. A figura 5.1 apresenta uma visa?o geral da

arquitetura do mo?dulo1.

Figura 5.1: Visa?o geral da arquitetura do HSM da GT ICPEDU II

Na parte interna ao per??metro criptogra?fico, o mo?dulo conta com dois

componentes principais: a Unidade de Seguranc?a e a Unidade Gestora.

1cre?ditos pela figura para Juliano Romani



55

A Unidade de Seguranc?a (US), dispositivo desenvolvido especifica-

mente para monitorar o funcionamento do mo?dulo, conta com uma se?rie de sensores

que visam a detecc?a?o de qualquer tentativa de violac?a?o ou risco de comprometimento da

seguranc?a por influe?ncia de fatores externos, sendo qualquer comportamento inesperado

registrado no sistema de registros interno a? US. O mo?dulo emprega sensores de tensa?o,

temperatura, luminosidade e detecc?a?o de intrusa?o f??sica, sendo o u?ltimo provido atrave?s de

uma malha de circuitos que envolve o per??metro criptogra?fico. Ale?m disso, e? dentro dessa

unidade que ficam o gerador de nu?meros aleato?rios (PNG) e o relo?gio de alta-estabilidade,

usado no processo de gerac?a?o dos pares de chaves gerenciados pelo mo?dulo e controle de

tempo interno, respectivamente.

A Unidade Gestora (UG) consiste de um conjunto de software/hardware

responsa?vel por hospedar as aplicac?o?es e dados referentes a? execuc?a?o do mo?dulo, como

por exemplo, as ferramentas e bibliotecas que compo?em o OpenSSL, bem como as chaves

gerenciadas pelo mo?dulo.

Operando sobre a UG esta?o as aplicac?o?es envolvidas na gere?ncia do ci-

clo de vida das chaves privadas do HSM (OpenHSMd), bem como a memo?ria persistente

do mo?dulo, uma Compact Flash (CF), responsa?vel por armazenar os dados relacionados

a? configurac?a?o do HSM, as chaves sime?tricas e assime?tricas, certificados, entre outras

informac?o?es u?teis ao funcionamento do HSM. Ainda na memo?ria flash, encontra-se a

versa?o customizada do sistema operacional FreeBSD embarcada para gerenciamento da

soluc?a?o como um todo.

A comunicac?a?o com o mundo externo esta? restrito a duas portas f??sicas,

uma porta de rede e uma porta USB. A porta de rede e? utilizada para gerenciamento do

HSM, atrave?s dos aplicativos de administrac?a?o remota (sec?a?o 5.3), e para uso das chaves

gerenciadas, atrave?s de uma engine OpenSSL (sec?a?o 5.4). Na porta USB conecta-se o

leitor de smartcards utilizado nos processos de criac?a?o e autenticac?a?o dos usua?rios do

mo?dulo.



56

5.3 Aplicativos de Administrac?a?o Remota

O gerenciamento do HSM e? realizado atrave?s de dois aplicativos de

administrac?a?o remota: interface texto (linha de comando) e interface gra?fica. Ambas tem

o mesmo conjunto de func?o?es e comandos e se conectam ao HSM atrave?s de um canal

seguro de comunicac?a?o, tu?nel SSL.

A interface texto, uma vez conectada ao HSM, prove? um ambiente no

mesmo estilo linha de comando do OpenSSL, aonde comandos podem ser executados

com seus respectivos para?metros e opc?o?es, sendo que todas as func?o?es possuem sua

documentac?a?o de fa?cil acesso na pro?pria interface. E? uma forma eficiente e eficaz de

obter a informac?a?o requerida. A figura 5.2 apresenta um exemplo da interface texto co-

nectada ao HSM.

Figura 5.2: Interface texto para administrac?a?o remota do HSM do GT ICPEDU II

Por outro lado, a interface gra?fica, desenvolvida em Java2, e? rica em

detalhes com componentes ativos que se atualizam baseados na configurac?a?o atual do

HSM. Outro ponto forte dessa interface e? sua portabilidade. A figura 5.3 apresenta um

exemplo da interface gra?fica conectada no HSM.

As duas aplicac?o?es de administrac?a?o remota do mo?dulo sa?o internacio-

nalizadas, suportando atualmente os idiomas ingle?s e portugue?s.

2linguagem de programac?a?o, dispon??vel em http://java.sun.com/



57

Figura 5.3: Interface gra?fica para administrac?a?o remota do HSM do GT ICPEDU II

5.4 Engine OpenSSL

Um mo?dulo criptogra?fico deve prover uma API de integrac?a?o que per-

mita a uma aplicac?a?o utilizar suas chaves criptogra?ficas gerenciadas. Essa API pode

seguir um padra?o ja? estabelecido, como por exemplo PKCS#11, CryptoAPI, Engine

OpenSSL, ou ser uma interface pro?pria do fabricante do HSM.

A escolha da API de integrac?a?o adequada levou em considerac?a?o dois

principais fatores: grau de complexidade de implementac?a?o e o nu?mero de aplicativos

afetados. Desta forma, os servic?os criptogra?ficos do HSM sa?o providos atrave?s de uma

engine OpenSSL, que pode ser carregada de forma esta?tica ou dina?mica. O mo?dulo prove?

as seguintes funcionalidades atrave?s desta engine:

• operac?o?es sobre chaves privadas RSA: permite o uso das chaves criptogra?ficas ge-
renciadas pelos HSM;



58

• gerador de nu?meros aleato?rios: este servic?o utiliza o gerador de nu?meros aleato?rios
dispon??vel na unidade de seguranc?a.

5.5 Conclusa?o

Este cap??tulo apresentou a arquitetura e os principais componentes do

HSM desenvolvido no projeto ICPEDU II, o ASI-HSM. Este desenvolvimento, que pare-

cia distante devido a falta de documentac?a?o e publicac?o?es existente no mundo acade?mico,

por serem normalmente guardadas a sete chaves por empresas comerciais, se mostrou to-

talmente via?vel e os objetivos do projeto foram alcanc?ados, sendo concebido utilizando

apenas software livre.

Os pro?ximos dois cap??tulos ira?o descrever em detalhes o protocolo

de gerenciamento do ciclo de vida de chaves criptogra?ficas utilizados no ASI-HSM, o

OpenHSM.



Cap??tulo 6

OpenHSM - Operacionalizac?a?o

O OpenHSM e? um protocolo para gerenciamento completo do ciclo

de vida de chaves criptogra?ficas de HSMs. O foco principal deste protocolo e? suprir

as necessidades encontradas na implantac?a?o de infra-estruturas de chaves pu?blicas, tais

como rastreabilidades de chaves e com operac?o?es totalmente audita?veis.

O gerenciamento do ciclo de vida de chaves criptogra?ficas de forma

segura e? o objetivo de qualquer HSM, sendo que este objetivo pode levar um longo

tempo de maturac?a?o ate? ser plenamente alcanc?ado. Sabendo disso, este cap??tulo apre-

senta o protocolo do OpenHSM, que foi primeiramente apresentado em uma dissertac?a?o

de mestrado[4] defendida em 2005 e vem sendo aprimorado em va?rias ocasio?es, tais como

trabalhos de conclusa?o de curso[3], outras dissertac?o?es e artigos[5][6]. Apesar disso, o

conjunto destas publicac?o?es na?o apresenta de forma coerente todos os sub-protocolos do

OpenHSM.

As mudanc?as nos sub-protocolos do OpenHSM, ale?m de estruturais,

tambe?m ocorreram na forma de sua representac?a?o, com o objetivo descreve?-los formal-

mente. A descric?a?o formal e? o primeiro passo para poder-se realizar a verificac?a?o formal

da corretude dos protocolos. As alterac?o?es e aprimoramentos estruturais sa?o relativos aos

protocolos de criac?a?o e recuperac?a?o de co?pias de seguranc?a do material criptogra?fico, que

sa?o descritos no Cap??tulo 7.



60

6.1 Aspectos Gerais

Esta sec?a?o apresenta as definic?o?es e caracter??sticas inerentes aos proto-

colos do OpenHSM, de forma a ajudar na compreensa?o dos mesmos. Ale?m disso, dois

sub-protocolos, que tambe?m dara?o suporte para as pro?ximas sec?o?es, sera?o abordados: a

criac?a?o e a autenticac?a?o de grupos de usua?rios.

O conjunto de definic?o?es e caracter??sticas utilizadas no protocolo

OpenHSM sa?o:

• Uma vez inicializado, o HSM gera um par de chaves assime?tricas krh e kuh, pos-
sibilitando a emissa?o de um certificado auto-assinado ch. Esta autoridade certifica-

dora interna define o elemento central de confianc?a do HSM, a partir do qual todos

os certificados de seus membros sera?o gerados;

• O protocolo define 3 diferentes grupos de usua?rios: administradores, auditores e
operadores;

• Cada tipo de grupo suportado pelo HSM possui um sistema de armazenamento
(DS) diferente. Sendo o dos administradores ADS, operadores ODS e auditores

AudDS. Os dados enviados para esses sistemas sa?o armazenados sem nenhum tipo

adicional de criptografia;

• Cada grupo no HSM possui um identificador, sendo este u?nico em grupos do mesmo
tipo. Entretanto, existe apenas um grupo de administradores va?lido para um dado

momento, com o identificador ADM sempre apontando para o grupo corrente.

• Todos os grupos sa?o submetidos ao esquema de segredo compartilhado[42], onde
a chave sime?trica do grupo ks, e? dividida em n partes das quais k sa?o necessa?rias

para recuperar ks. Os limiares seguem a seguinte regra: 1 ? k ? n. Um conjunto
de partes de um segredo e? representado por Ks;

• Durante a criac?a?o de um grupo no HSM, cada membro recebe um par de chaves
assime?tricas, kri e kui, ale?m de um certificado emitido pela AC interna do HSM,



61

ci. Esse material e? enta?o armazenado no smartcard do membro e sera? utilizado

novamente durante sua autenticac?a?o;

• Cada parte do segredo compartilhado do grupo, ksi, passa a representar um de seus
membros, sendo sua chave pu?blica utilizada para cifrar sua parte do segredo antes

que este seja armazenado no HSM. Este e? o material que sera? decifrado durante o

processo de autenticac?a?o do grupo;

• O sistema de armazenamento de dados na?o-exporta?veis, N XD, e? um sistema de
armazenamento como qualquer outro, diferenciando-se somente porque na criac?a?o

de uma co?pia de seguranc?a do HSM, os dados nele contidos na?o sa?o copiados;

• A interac?a?o dos membros dos grupos com o HSM e? feito atrave?s de um computador
diretamente conectado, referenciado por hm.

Os protocolos do OpenHSM, dada sua complexidade e quantidade de

passos, sera?o descritos aqui na forma de algoritmos. Esta mudanc?a na sua forma de

representac?a?o e? justificada pelos comenta?rios recebidos nas publicac?o?es citadas anterior-

mente, garantindo legibilidade e melhor entendimento.

O processo de criac?a?o de grupos do HSM permanece igual independente

do seu tipo, sendo abordado aqui e referenciado posteriormente quando for necessa?rio. A

execuc?a?o do algoritmo createGroup requer alguns para?metros, entre eles os dados sobre

o novo grupo, como: identificador (id) e limiares (k e n), o sistema de armazenamento

referente ao tipo de grupo a ser criado, DS, e por fim a chave privada e o certificado do

HSM (krh e ch).

A execuc?a?o inicia com a gerac?a?o da chave sime?trica do grupo ks no

passo 1. A chave e? enta?o submetida ao esquema de compartilhando de segredo, utilizando

n como o nu?mero total de partes e k o nu?mero m??nimo de partes para reconstruir ks,

resultando no conjuntos de partes da chave Ks.

No passo 3, inicia-se o processo de criac?a?o dos membros, que deve ser

executado n vezes, ate? que todos os membros do grupo estejam criados. No passo 4, o par

1Um suma?rio das descric?o?es das varia?veis e func?o?es esta? dispon??vel no ape?ndice A



62

Algoritmo createGroup(DS, id, k, n, ch, krh) 1

Cria um grupo utilizando o esquema de compartilhamento de segredo, gerando um
par de chaves (kri e kui) e um certificado (ci) para cada membro do grupo (si). Os
certificados dos membros sa?o assinados pela chave privada do HSM krh. O certifi-
cado de cada membro inclui seu nome e informac?o?es requisitadas durante o processo
de criac?a?o dos membros. O token criptogra?fico de cada membro ctsi e? utilizado para
armazenar seus objetos criados no processo, ci e kri. A chave sime?trica do grupo ks,
que foi compartilhada em n partes, e? retornada como resultado do algoritmo.
1: ks ? genSessionKey()
2: Ks ? splitSecret( ks, k, n )
3: for ksi in Ks do
4: (kri, kui) ? genKeyPair()
5: idi ? load( hm, si )
6: ci ? genCert( idi, kui, ch, krh )
7: store( ctsi , kri, ci, ch )
8: eksi ? encrypt( ksi, ci )
9: store( DS, id, ci, eksi )
10: end for
11: store( DS, id, k, n )
12: return ks

de chaves do membro e? gerado, kri e kui. Na sequ?e?ncia, o nome do membro e? solicitado

a? ma?quina hospedeira, informac?a?o que sera? utilizada para emitir o seu certificado ci no

passo 6. Uma vez que o certificado esta? gerado, kri, ci e ch pode ser armazenado no token

criptogra?fico do membro.

Continuando, uma das partes do segredo do grupo ksi e? cifrada com

o certificado do membro ci (seu certificado possui sua chave pu?blica). E finalmente, no

passo 9, com todos os procedimentos para o membro finalizados, seus dados sa?o arma-

zenados em DS. Salientando que a chave privada do membro kri na?o e? armazenada,

preservando sua caracter??stica principal de privacidade.

No passo 11 os dados referentes ao grupo sa?o armazenados. E final-

mente, no passo 12, a chave sime?trica do grupo e? retornada.

Outro algoritmo que permanece igual independente do tipo (grupo) e? a

autenticac?a?o de um grupo authenticGroup. O processo requer o sistema de armazena-

mento e o identificador referentes ao grupo a ser autenticado.

O algoritmo authenticGroup inicia carregando k do grupo identificado



63

Algoritmo authenticGroup( DS, id )
Autentica um grupo do HSM identificado por id no sistema de armazenamento DS.
Os certificados dos membros ci a serem autenticados sa?o lidos de seus tokens crip-
togra?ficos ctsi , identificando-o e possibilitando a decifragem da parte do segredo do
grupo referente ao membro. E? necessa?rio que k membros sejam autenticados para
recuperar o segredo do grupo ks.
1: k ? load( DS, id )
2: for i = 1 to k do
3: ci ? load( ctsi )
4: eksi ? load( DS, id, ci )
5: u ? genSessionKey()
6: euksi ? encrypt( u || eksi, ci )
7: eksu ? ctDecrypt(ctsi , euksi )
8: ksi ? decrypt( eksu, u )
9: end for
10: ks ? joinSecret( Ks )
11: return ks

por id do sistema de armazenamento DS. No passo 2, inicia-se a iterac?a?o para autenticar

os k membros do grupo, k foi definido no processo de sua criac?a?o e define o nu?mero

m??nimo de membros que precisam ser autenticados para permitir a reconstruc?a?o do se-

gredo do grupo.

As operac?o?es entre os passos 2 e 9 sera?o realizadas k vezes, ate? ser

poss??vel recuperar o segredo do grupo. No passo 3 carrega-se do token criptogra?fico do

membro seu certificado ci, objeto necessa?rio para, no passo 4, identificar no DS a parte

do segredo cifrado do membro eksi.

Os pro?ximos dois passos, 4 e 5, sa?o necessa?rios para evitar o ataque de

replay do Dolev-Yao[43], gerando u e recifrando seu valor concatenado a eksi, resultando

em euksi. Este u?ltimo enta?o e? enviado ao token criptogra?fico do membro para decifragem,

liberado u e ksi. Antes de retorna?-los ao HSM, o token cifra ksi com u. Como u e?

conhecido pelo HSM, o valor de ksi e? recuperado no passo 8.

Finalmente no passo 10, recupera-se a chave sime?trica do grupo ks a

partir do conjunto de partes decifradas nos passos anteriores. O algoritmo termina retor-

nando o valor de ks.



64

6.2 Inicializac?a?o do HSM e criac?a?o do grupo de Admi-

nistradores

Este e? o primeiro passo na preparac?a?o de um ambiente para gerencia-

mento do ciclo de vida de chaves privadas. Este algoritmo ira? realizar a criac?a?o da auto-

ridade certificadora raiz interna e do grupo de administradores do HSM, estabelecendo,

respectivamente, seu ponto de confianc?a e o grupo responsa?vel por suas operarac?o?es ad-

ministrativas.

O HSM, como apresentado nos aspectos gerais, possui apenas um grupo

de administradores va?lido para um determinado momento no tempo, sendo que esse grupo

pode ser alterado a qualquer momento utilizando o algoritmo changeAdmGroup descrito

na sec?a?o 6.7.

O algoritmo e? disparado com a especificac?a?o dos valores de k e n, res-

pectivamente o nu?mero m??nimo de membros para autenticar o grupo e seu nu?mero total

de membros.

Algoritmo createAdm( k, n ) 1

Inicializa o HSM, criando a AC interna que servira? de ponto de confianc?a para suas
operac?o?es. O grupo de administradores tambe?m e? criado.
1: krh, kuh ? genKeyPair()
2: ch ? genSelfSignedCert( krh, kuh, id )
3: ksad ? createGroup( ADS, ADM , k, n, ch, krh )
4: ekrh ? encrypt( krh, ksad )
5: store( ADS, ch, ekrh )
6: store( CT L, ch )
7: return ch

No primeiro passo, o par de chaves assime?tricas do HSM, krh e kuh,

e? gerado e a partir dele o certificado auto-assinado do HSM e? emitido. Estes sa?o os

componentes necessa?rios para criar o grupo de administradores no passo 3. Como ja?

explicado anteriormente, a criac?a?o de um grupo do HSM e? gene?rica e permanece a mesma

para todos os tipos de grupos. A chave sime?trica do grupo de administradores ksad e?

retornada como resultado. Essa chave e? utilizada para cifrar a chave privada do HSM no

passo 4, gerando ekrh.



65

Ate? o passo 4, todos as operac?o?es necessa?rias para a inicializac?a?o e

criac?a?o dos administradores foram finalizadas, restando apenas armazenar todos os com-

ponentes rece?m criados, o que permitira? a execuc?a?o da pro?xima etapa do processo de

tornar o HSM operacional, a criac?a?o de um grupo de auditores.

Enta?o, no passo 5 o certificado do HSM e sua chave privada cifrada

sa?o armazenados no sistema de armazenamento de administradores e o passo 6 adiciona

o certificado auto-assinado ch na lista de certificados confia?veis CT L, estabelecendo o

ponto de confianc?a do HSM.

Finalmente, ch e? retornado para a ma?quina hospedeira que iniciou a

execuc?a?o do algoritmo, o que identifica unicamente o HSM.

6.3 Criac?a?o de um grupo de Auditores

Apesar de na?o existir restric?a?o criptogra?fica que impec?a a criac?a?o de um

grupo de operadores diretamente apo?s a inicializac?a?o do HSM, o protocolo do OpenHSM

define que a criac?a?o de um grupo de auditores seja obrigatoriamente o segundo passo

para criar um HSM operacional, de forma a garantir que o processo de auditoria possa ser

realizado antes mesmo de uma chave ser criada ou ate? utilizada.

Tratando-se de uma operac?a?o administrativa, o grupo de administrado-

res do HSM e? autenticado nos primeiros passos do algoritmo, permitindo a reconstruc?a?o

de sua chave s??metrica, possibilitando a decifragem da chave privada do HSM.

Cada grupo de auditores recebe um par de chaves assime?trica que sera?

utilizado para assinar os registros do HSM que sera?o exportados pelo grupo. Outros pares

de chaves na?o podem ser associados a um grupo de auditores, como acontece aos grupos

de operadores, mas este e? assunto das pro?ximas sec?o?es.

O algoritmo requer os valores de k e n para o novo grupo de auditores,

como acontece na criac?a?o do grupo de administradores, e um identificador para o grupo

id, sendo que este deve identificar unicamente o grupo dentro do conjunto de grupos de

auditores.

O algoritmo comec?a autenticando o grupo de administradores do sis-



66

Algoritmo createAudGroup(id, k, n)
Apo?s a autenticac?a?o dos administradores do HSM, e? criado um novo grupo de audi-
tores identificado por id. A chave sime?trica desse grupo e? submetida ao mecanismo
de compartilhamento de segredo, utilizando os limiares k e n. Adicionalmente, um
par de chaves assime?tricas e? associado ao grupo rece?m criado.
1: ksad ? authenticateGroup( ADS, ADM )
2: ch, ekrh ? load( ADS )
3: krh ? decrypt( ekrh, ksad )
4: ksau ? createGroup( AudDS, id, k, n, ch, krh )
5: krau, kuau ? genKeyPair()
6: cau ? genCert( id, kuau, ch, krh )
7: ekrau ? encrypt( krau, ksau )
8: store( AudDS, id, cau, ekrau )
9: return cau

tema, especificando o sistema de armazenamento dos administradores ADS e o iden-

tificador do grupo ADM . Como definido nas premissas, o HSM possui apenas um

grupo va?lido de administradores para um determinando periodo de tempo e o identifi-

cador ADM sempre aponta para o grupo atual.

O segundo e terceiro passo visam acessar a chave privada do HSM,

carregando-a cifrada de ADS, decifrando em seguida com a chave sime?trica do admi-

nistradores. Portanto, os tre?s primeiros passos dos algoritmos considerados operac?o?es

administrativas sera?o os mesmos, autenticando o grupo de administradores e permitindo

acesso a chave privada do HSM.

No passo 4, o grupo de auditores e? criado utilizando o algoritmo

createGroup previamente definido, resultando na chave sime?trica do novo grupo ksau.

Logo apo?s, um par de chaves criptogra?ficas e? gerado, sendo que um

certificado utilizando-o sera? emitido pela AC interna do HSM no passo 6. Este certifi-

cado sera? u?til para verificac?a?o da integridade dos registros exportados do HSM, atrave?s

do algoritmo abordado na sec?a?o 6.10. Posteriormente, no passo 7, a chave privada dos

auditores e? cifrada com ksau, garantindo confidencialidade da mesma.

Finalmente, o certificado e a chave privada cifrada do novo grupo po-

dem ser armazenados no sistema de armazenamento de auditores, identificados por id, no

passo 8. O certificado do grupo de auditores e? retornado como resultado da execuc?a?o do



67

algoritmo.

6.4 Criac?a?o de um grupo de Operadores

Os grupos de operadores no protocolo do OpenHSM dete?m a responsa-

bilidade de liberac?a?o para uso das chaves gerenciadas de um HSM, podendo cada grupo

ter nenhuma ou va?rias chaves associadas. Definido como uma tarefa administrativa, o

processo de criac?a?o de um grupo de operadores requer a autenticac?a?o do grupo de admi-

nistradores.

A peculiaridade neste tipo de grupo e? a existe?ncia de um link com o

grupo de administradores, habilitando este u?ltimo a realizar operac?o?es sobre um grupo de

operadores. Este link, por exemplo, permite aos administradores do HSM associar novas

chaves ao grupo de operadores como tambe?m desassocia?-las.

Os para?metros necessa?rios para criar um grupo de operadores sa?o os

mesmos requeridos no criac?a?o de um grupo de auditores, com o identificador do novo

grupo id e os limiares para o esquema de segredo compartilhado k e n.

Algoritmo createOperGroup(id, k, n)
Cria um grupo de operadores, autenticando primeiramente o grupo de administrado-
res. O ponto de confianc?a do novo grupo em relac?a?o aos administradores e? estabele-
cido.
1: ksad ? authenticateGroup( ADS, ADM )
2: ch, ekrh ? load( ADS )
3: krh ? decrypt( ekrh, ksad )
4: kso createGroup( ODS, id, k, n, ch, krh )
5: kso? ? genSessionKey()
6: ksao ? xor( kso, kso? )
7: eksao ? encrypt( ksao, ch )
8: store( ADS, id, eksao )
9: store( N XD, id, kso? )

Os tre?s primeiros passos deste algoritmo sa?o exatamente iguais ao pro-

cesso de criac?a?o de auditores. Tem o objetivo de autenticar o grupo de administradores e

permitir acesso a? chave privada krh e ao certificado ch do HSM.

No passo 4, o novo grupo de operadores e? criado, com sua chave



68

sime?trica, kso, sendo retornada como resultado da execuc?a?o. Essa chave sera? utilizada

para cifrar as chaves que forem associadas com esse grupo de operadores.

Os passos seguintes, de 5 a 9, servem para criar o ponto de confianc?a

dos operadores nos administradores, permitindo a realizac?a?o de operac?o?es administrativas

sobre os mesmo. Inicia-se com a gerac?a?o de uma segunda chave sime?trica para o grupo

de operadores kso?. No passo 6, realiza-se a operac?a?o ou-exclusivo (XOR) entre as duas

chaves sime?tricas do grupo de operadores, resultado em ksao. Uma das propriedades da

func?a?o de XOR e? sua reversibilidade, isto e?, A?B = C e C?B = A. Portando, se reali-
zar a operac?a?o kso??ksad, o resultado sera? kso. Desta forma, o grupo de administradores
pode reconstruir kso tendo acesso apenas a kso? e ksad.

No passo 7, o resultado da operac?a?o XOR ksad e? cifrado com a chave

pu?blica do HSM, garantindo que so? quem possui acesso a chave privada do HSM, no caso

o grupo de administradores, podera? ter acesso a mesma. E por fim, os dados sens??veis

para futuras execuc?o?es sa?o armazenadas nos devidos sistemas de armazenamento, passos

8 e 9.

O valor de kso? e? armazenado em um sistema de armazenamento dife-

rente do utilizado para os dados dos grupo de operadores. A utilizac?a?o do N XD garante

uma caracter??stica importante ao protocolo do OpenHSM, a rastreabilidade das chaves

gerenciadas. Durante o procedimento de backup do HSM, coberto no cap??tulo 7, o N XD

na?o e? copiado, resultando que, uma vez recuperado o backup, N XD permanec?a vazio.

Sem a existe?ncia do ponto de confianc?a dos operadores em relac?a?o aos administradores,

na?o se pode realizar operac?o?es administrativas sobre os mesmos.

Por isso que, logo apo?s a recuperac?a?o do backup, o grupo de adminis-

tradores, juntamente com cada grupo de operadores, devera?o realizar o procedimento de

re-criac?a?o do ponto de confianc?a entre os mesmos (sec?a?o 6.9). Uma vez obrigato?ria a

intervenc?a?o do grupo de operadores, garante-se que uma chave gerenciada nunca sera?

utilizada ou tera? seu responsa?vel trocado sem pre?vio conhecimento.



69

6.5 Criac?a?o de Chave Gerenciada

A criac?a?o de chaves gerenciadas e? uma das operac?o?es mais importante

em um HSM e pode ser executada logo apo?s a criac?a?o do primeiro grupo de operadores.

O grupo de administradores precisa ser autenticado e deve existir o ponto de confianc?a

entre os administradores e o grupo de operadores que sera? responsa?vel pela nova chave.

As chaves, como acontece nos grupos de operadores e auditores, pos-

suem um identificador u?nico dentro no conjunto de chaves gerenciadas, representado por

idk. Este identificador sera? utilizado posteriormente quando o grupo de operadores car-

regar a chave para uso ou quando uma aplicac?a?o externa realizar operac?a?o criptogra?ficas

com a chave.

Ale?m do identificador a ser atribu??do a nova chave, o algoritmo de

criac?a?o de chaves gerenciadas precisa do identificador do grupo de operadores que sera?

responsa?vel pela chave ido e, tambe?m, as caracter??sticas da nova chave, tais como algo-

ritmo e tamanho.

Algoritmo createManagedKey(idk, key params, ido)
Cria um par de chaves, identificada por idk, para ser gerenciada pelo HSM. Essa nova
chave tera? as caracter??sticas definidas por key params (algoritmo e tamanho) e sera?
associada ao grupo de operadores identificado por ido.
1: ksad ? authenticateGroup( ADS, ADM )
2: ch, ekrh ? load( ADS )
3: krh ? decrypt( ekrh, ksad )
4: eksao ? load( ADS, ido )
5: ksao ? decrypt( eksao, krh )
6: kso? ? load( N XD, ido )
7: kso ? xor( ksao, kso? )
8: kr, ku ? genKeyPair( keyparams )
9: ekr ? encrypt( kr, kso )
10: store( KDS, idk, ekr, ku, ido )
11: return ku

O algoritmo inicia autenticando o grupo de administradores, com o ob-

jetivo de obter acesso ao certificado e chave privada do HSM nos tre?s primeiros passos.

Estes passos ja? foram descritos na criac?a?o de grupo de auditores (vide sec?a?o 6.3).

No passo 4, baseado no identificador do grupo de operadores ido,



70

carrega-se o resultado da operac?a?o XOR cifrada do sistema de armazenamento dos ad-

ministradores. Com a chave privada do HSM ja? aberta, pode-se decifrar eksao para ter

acesso a ksao. Logo apo?s carrega-se a segunda chave sime?trica do grupo de operadores,

kso?, identificado por ido. Lembrando que kso? estabelece o ponto de confianc?a entre o

grupo de adminitradores e o grupo de operadores.

No passo 7, se faz uso da propriedade de reversibilidade da operac?a?o

XOR e recupera-se a chave sime?trica do grupo de operadores kso. Esta e? a chave que sera?

utilizada no passo 9 para cifrar a nova chave gerenciada. O par de chaves assime?tricas e?

gerado no passo 8 e enta?o armazenado no KDS no passo 10, juntamente com idk e ido.

Finalmente, a chave pu?blica rece?m criada e? retornada como resultado do algoritmo.

6.6 Liberando uma Chave Gerenciada para Uso

O gerenciamento do ciclo de vida de chaves privadas deve permitir

em algum momento a utilizac?a?o destas chaves. A partir do algoritmo detalhado nesta

sec?a?o, e? poss??vel ao grupo de operadores responsa?vel por uma chave libera?-la para uso

por aplicac?o?es externas.

O HSM autentica o grupo de operadores responsa?vel pela chave,

deixando-a carregada na memo?ria vola?til do sistema sob uma pol??tica de uso explicita-

mente definida.

Essa pol??tica pode ser a quantidade ma?xima de usos da chave e/ou um

per??odo de tempo determinado. Por exemplo, pode-se carregar uma chave para 5 usos em

um prazo de 5 minutos, sendo que a chave e? descarregada assim que a primeira restric?a?o

expirar.

O algoritmo para liberac?a?o de uma chave requer o identificador da chave

idkey e a pol??tica sob a qual a chave ira? operar, policy.

O algoritmo carrega no passo 1 os dados da chave idkey do sistema de

armazenamento de chaves KDS. Entre os dados carregados esta?o o identificador do

grupo de operadores responsa?vel pela chave, idoper, e o par de chaves propriamente dito,

ku e ekr, sendo que a chave privada encontra-se cifrada.



71

Algoritmo loadManagedKey( idkey , policy )
Carrega uma chave gerenciada identificada por idkey no HSM. Primeiramente, o
grupo de operadores responsa?vel pela chave e? autenticado. O para?metro policy defi-
nira? a pol??tica de uso da chave.
1: ekr, ku, idoper ? load( KDS, idkey )
2: ks ? authGroup( ODS, idoper )
3: kr ? decrypt( ekr, ks )
4: manageKey( idkey, kr, ku, policy )
5: return( ku )

No passo 2 autentica-se o grupo de operadores, obtendo-se acesso a sua

chave sime?trica ks, que sera? utilizada no passo 3 para decifrar ekr.

A chave privada, kr, e? enta?o submetida ao controlador de chaves carre-

gadas, definindo idkey, a pol??tica definida pelos operadores, ku e kr. Esta chave permane-

cera? dispon??vel enquanto sua pol??tica de uso permitir ou o procedimento de descarga da

mesma for acionado.

6.7 Troca do grupo de Administratores

O grupo de administradores de um HSM pode ser trocado utilizando

o algoritmo coberto nesta sec?a?o. Essa operac?a?o, como qualquer outra de troca de gru-

pos, deve ser realizada sempre que houver comprometimento do grupo. Considera-se um

grupo comprometido quando o uso do mecanismo de compartilhamento de segredo for

inviabilizado.

As chaves sime?tricas dos grupos sa?o compartilhadas utilizando os limi-

ares k e n, sendo k o nu?mero m??nimo de membros presentes para autenticar o grupo e n o

nu?mero total de membros. Sabendo disso, para um grupo de 5 membros onde 3 precisam

estar presentes, a existe?ncia de qualquer 2 membros na?o e? capaz de recuperar nenhum bit

da chave. Portanto, se dois membros do grupo perderem de alguma forma acesso a seus

token criptogra?ficos, e consequ?entemente acesso as suas chaves privadas, o grupo ainda

pode ser autenticado, pore?m, se mais um tiver problema, o grupo esta? comprometido.

Considerando-se que um HSM so? possui um grupo de administradores

va?lido, a sua troca se torna pec?a fundamental para a continuidade do ciclo de vida das



72

chaves gerenciadas do HSM, ja? que o grupo de administradores tambe?m e? utilizado para

recuperac?a?o das co?pias de seguranc?a. Este processo autentica o grupo de administradores

atual e requer os limiares k e n que sera?o utilizados para criac?a?o do novo grupo.

Algoritmo changeAdmGroup( k, n )
Troca o grupo de administradores de um HSM, autenticando o atual e gerando o
novo. Depois de transferida a administrac?a?o do HSM, a chave privada do HSM passa
a ser protegida pela chave sime?trica do novo grupo ks2 e os certificados de todos os
membros do grupo antigo sa?o revogados.
1: ks1 ? authenticateGroup( ADS, ADM )
2: ch, ekrh ? load( ADS )
3: krh ? decrypt( ekrh, ks1 )
4: ks2 ? createGroup( ADS, ADM2, k, n, ch, khh )
5: ekrh ? encrypt( krh, ks2 )
6: store( ADS, ekrh )
7: revokeGroupCerts( ADS, ADM )
8: ADM ? ADM2
9: return ch

O algoritmo changeAdmGroup inicia como qualquer outra operac?a?o

administrativa ja? vista ate? aqui, onde os 3 primeiros passos visam autenticar o grupo de

administradores e liberando acesso a chave privada do HSM, krh.

No passo 4, o novo grupo de administradores e? criado, referenciado

pelo identificador tempora?rio ADM2. Esse identificador sera? posteriormente atribu??do a

ADM , que sempre aponta para o grupo de administradores corrente do HSM.

A chave privada do HSM e? enta?o cifrada utilizando a chave sime?trica

do novo grupo de administradores ks2 no passo 5 e logo apo?s armazenada em ADS.

No passo 7, os certificados de todos os membros do antigo grupo de administradores

sa?o revogados, garantindo que na?o sera?o mais aceitos no HSM. Seguindo, e? atualizado o

identificador do grupo de administradores, ADM , para apontar para o novo grupo ADM2.

Finalmente, com o grupo de administradores trocado, o certificado do

HSM e? retornado no passo 9. Como visto, essa e? uma operac?a?o cr??tica e requer bastante

atenc?a?o, ja? que um HSM possui apenas um grupo de administradores va?lido. Deve-se

garantir atomicidade na execuc?a?o dos passos 6, 7 e 8, ja? que se falharem destes pontos, o

HSM possuira? um grupo de administradores inva?lido.



73

Uma caracter??stica interessante apo?s a execuc?a?o deste algoritmo e? que,

todas as co?pias de seguranc?a criadas antes desta execuc?a?o sa?o apenas recupera?veis com

a autenticac?a?o do antigo grupo de administradores do HSM. A troca proposta por este

algoritmo so? ira? se refletir em novas co?pias de seguranc?a criadas. O grupo de auditores

desempenham um papel fundamental neste processo, controlando as atividades do antigo

grupo de administradores em relac?a?o a recuperac?a?o de co?pias de seguranc?a. Alternativa-

mente, os smartcards na?o mais necessa?rios podem ser destru??dos.

6.8 Alterando os responsa?veis por uma chave gerenciada

A troca dos responsa?veis de uma chave no HSM na?o e? uma operac?a?o

ta?o cr??tica quando a troca de seu grupo de administradores, pore?m, ta?o importante quanto.

Isso porque uma vez que o ponto de confianc?a do grupo atualmente responsa?vel e o grupo

que recebera? a responsabilidade existam, os administradores podem realizar a troca.

Esta operac?a?o pode representar em uma situac?a?o real, a troca da dire-

toria responsa?vel por uma AC em uma instituic?a?o, permitindo que seus novos membros

passem a ser responsa?veis pelo uso de sua chave privada. Como dito anteriormente, so-

mente o grupo de administradores e? necessa?rio para essa troca, desde que os pontos de

confianc?a existam.

Basicamente, o algoritmo autentica o grupo de administradores e

atrave?s do ponto de confianc?a recupera a chave sime?trica dos dois grupos de operado-

res, podendo enta?o decifrar a chave privada com a chave sime?trica de um grupo, poste-

riormente cifrando com a do outro. Para iniciar o processo de troca, sa?o necessa?rios o

identificador da chave que tera? seu grupo responsa?vel trocado, idkey, e o identificador do

grupo de operadores que se tornara? seu novo responsa?vel, ido2.

O algoritmo changeKeyOwner inicia como qualquer outra operac?a?o

administrativa ja? vista ate? aqui, onde os 3 primeiros passos visam autenticar o grupo de

administradores e liberando acesso a chave privada do HSM, krh.

No passo 4, os dados da chave idkey sa?o carregados de KDS, tais como

a chave privada cifrada, ekr, e o identificador do atual responsa?vel pela chave, ido1.



74

Algorithm changeKeyOwner( idkey , ido2 )
Troca o grupo de operadores responsa?vel por uma chave gerenciada no HSM. E?
necessa?ria a autenticac?a?o do grupo de administradores ale?m de existir o ponto de
confianc?a dos dois grupos de operadores envolvidos na operac?a?o.
1: ks ? authGroup( ADS, ADM )
2: ekrh ? load( ADS )
3: krh ? decrypt( ekrh, ks )
4: ekr, ido1 ? load( KDS, idkey )
5: eksao1 ? load( ADS, ido1 )
6: ksao1 ? decrypt( eksao1, krh )
7: kso1? ? load( N XD, idoper1 )
8: kso1 ? xor( ksao, kso1? )
9: kr ? decrypt( ekr, kso1 )
10: eksao2 ? load( ADS, ido2 )
11: ksao2 ? decrypt( eksao2, krh )
12: kso2? ? load( N XD, idoper2 )
13: kso2 ? xor( ksao, kso2? )
14: ekr ? encrypt( kr, kso2 )
15: store( KDS, idkey, ekr, ido2 )

Os passos de 5 a 8, como os passos de 10 a 13, visam recuperar chaves

sime?tricas de grupos de operadores, identificados por ido1 e ido2 respectivamente. Estas

operac?o?es ja? foram cobertas anteriormente (vide sec?a?o 6.5). Ao final do passo 8, obtem-se

acesso a kso1 e pode-se decifrar a chave privada gerenciada no passo 9. E ao final do passo

13, obte?m-se acesso a kso2, que e? utilizada no passo 14 para cifrar a chave gerenciada.

Finalmente, a chave kr cifrada pode ser armazenada juntamente com o

identificador do seu novo responsa?vel no passo 15, concluindo o algoritmo de troca do

grupo responsa?vel por uma chave gerenciada.

6.9 Criando o ponto de confianc?a de um grupo de Ope-

radores em relac?a?o aos Administradores

O ponto de confianc?a do grupo de operadores em relac?a?o ao grupo de

administradores garante que operac?o?es administrativas sejam realizadas sobre o primeiro.

Este ponto de confianc?a deixa de existir quando os administradores recuperam o backup



75

de um HSM, estabelecendo outro ambiente operacional.

O algoritmo activatesAdmT asksOverOperGroup autentica o grupo

de administradores e o grupo de operadores a ser ”ativado”, regerando a segunda chave

do grupo de operadores e aplicando a operac?a?o XOR a? chave principal do grupo. O

idenficador do grupo de operadores e? o u?nico requisito para disparar a execuc?a?o deste

algoritmo.

Algoritmo activatesAdmTasksOverOperGroup( idoper )
Estabelece o ponto de confianc?a de um grupo de operadores identificado por idoper,
em relac?a?o ao grupo de administradores. A existe?ncia deste ponto possibilita que
o u?ltimo, utilizando a propriedade de reversibilidade do XOR, possa recuperar a
chave sime?trica do grupo de operadores kso, permitindo assim, a associac?a?o e/ou
desassociac?a?o de chaves gerenciadas.
1: kso ? authGroup( ODS, idoper )
2: kso? ? genSessionKey()
3: ksao ? xor( kso, kso? )
4: ch ? load( ADS )
5: eksao ? encrypt( ksao, ch )
6: store( ADS, idoper, eksao )
7: store( N XD, idoper, kso? )

O algoritmo inicia autenticando o grupo de operadores identificado por

idoper, obtendo acesso sua chave sime?trica, kso. No passo 2, uma nova chave sime?trica

secunda?ria do grupo, kso?, e? gerada, permitindo a realizac?a?o da operac?a?o XOR no passo

3, que resultara? em ksao.

No passo 4, o certificado do HSM e? carregado do ADS e posterior-

mente utilizado para cifrar ksao, resultado em eksao. Nos passos 6 e 7, os dados gerados

durante a execuc?a?o do algoritmo, eksao e kso?, sa?o gravados nos devidos sistemas de

armazenamento, ADS e N XD respectivamente, reestabelecendo o ponto de confianc?a.

6.10 Exportac?a?o dos Registros de Atividades

O protocolo do OpenHSM define que todas as operac?o?es realizadas em

um HSM devem ser registradas de forma sequencial para posterior ana?lise por grupos de

auditores, permitindo que seja reconstru??do toda a trilha das operac?o?es realizadas.



76

Apenas grupos de auditores podem exportar os registros de atividades

do HSM, sempre assinados, devendo fazer isso informando seu identificador id e, opcio-

nalmente, especificar um per??odo de tempo para exportac?a?o. Se na?o especificado, todos

os registros existentes sa?o exportados.

Algoritmo exportLog( id [, rangeDate] )
Permite um grupo de auditores exportar os registros de atividade do HSM assinados,
podendo ou na?o definir o per??odo de tempo para os mesmos
1: ks ? authGroup( AudDS, id )
2: ekr ? load( AudDS, id )
3: kr ? decrypt( ekr, ks )
4: L ? load( LDS, rangeDate )
5: sL ? sign( L, kr )
6: return( sL )

O algoritmo exportLog inicia autenticando o grupo de auditores iden-

tificado por id, resultando na sua chave sime?trica, ks. No passo 2, carrega-se a chave

privada cifrada do grupo, ekr, que, no passo seguinte, e? decifrada, resultando em kr.

No passo 4, o HSM carrega os registros, L, do sistema de armazena-

mento de registros, LDS, respeitando o per??odo de tempo especificado, rangeDate. O

HSM enta?o assina L para garantir a integridade destes registros. Os registros assinados

sa?o retornados como resultado do algoritmo.

6.11 Limpeza dos Registros de Atividades

O ciclo de vida de um HSM dura va?rios anos e considerando o fato do

mesmo rodar em ambiente embarcado, com recursos de armazenamento limitado, definiu-

se um operac?a?o administrativa para apagar os registros do sistema.

Este procedimento de limpeza dos registros de atividades do HSM en-

globa o algoritmo para exportar registros tambe?m, garantindo que qualquer registro que

for apagado do HSM, ja? tenha sido exportado pelo menos uma vez, permitindo assim que

a criac?a?o da trilha de auditoria cubra todas as operac?o?es realizadas em todo o tempo de

vida de um HSM.



77

O algoritmo autentica o grupo de administradores e um grupo de audi-

tores, identificado por id. Opcionalmente, pode-se informar um per??odo de tempo no qual

os registros sera?o exportados e apagados.

Algoritmo eraseLog( id [, rangeDate] )
Apaga os registros de atividades do HSM, autenticando o grupo de adminitradores e
um grupo de auditores. Este u?ltimo, recebe uma co?pia assinada dos registros apaga-
dos.
1: authGroup( ADS, ADM )
2: sL ? exportLog( id, rangeDate )
3: delete( LDS, rangeDate )
4: return( sL )

O algoritmo eraseLog inicia autenticando o grupo de administradores

do HSM no passo 1. Essa autenticac?a?o e? requirida apenas por questa?o de seguranc?a, ja?

que o conjunto dos registros do sistema e? parte fundamental para o controle do ciclo de

vida das chaves gerenciadas.

No passo 2 executa-se o algoritmo exportLog visto anteriormente,

que ira? resultar nos registros assinado do HSM, sL, referente ao tempo especificado,

rangeDate. No passo seguinte, os registros rece?m exportados podem ser apagados. O

HSM retorna sL como resultado da execuc?a?o.

Os protocolos do OpenHSM abordados ate? aqui descrevem a construc?a?o

de um ambiente seguro para gerenciamento de chaves criptogra?ficas de um HSM. Pore?m,

a continuidade do ciclo de vida das chaves gerenciadas esta? comprometida em caso de

falha de hardware ou de desastres, o que pode causar danos irrepara?veis a uma infra-

estrutura de chaves pu?blicas. Essa lacuna sera? coberta na pro?xima sec?a?o, que abordara? a

criac?a?o e restaurac?a?o de co?pias de seguranc?a de um HSM de forma segura e confia?vel.

6.12 Conclusa?o

Este cap??tulo apresentou todos os sub-protocolos do OpenHSM usados

na operacionalizac?a?o de um HSM. Atrave?s deles e? poss??vel a realizac?a?o de dois das prin-

cipais operac?o?es em um HSM: criac?a?o e utilizac?a?o de chaves criptogra?ficas.



78

Entretanto, duas etapas essencial para o completo ciclo de vida de

chaves criptogra?ficas ainda na?o foram cobertos, a criac?a?o e recuperac?a?o de co?pias de

seguranc?a (co?pias das chaves gerenciadas). Os sub-protocolos responsa?veis por estas eta-

pas sera?o abordados no pro?ximo cap??tulo.



Cap??tulo 7

OpenHSM - Co?pias de Seguranc?a

Os protocolos de criac?a?o de co?pias de seguranc?a do conteu?do de um

HSM de forma segura e confia?vel, devem permitir sua posterior recuperac?a?o, de forma a

restaurar todo o ambiente operacional que existia no momento que a co?pia de seguranc?a

foi criada.

Figura 7.1: Processo de criac?a?o de um HSM de backup

A criac?a?o destas co?pias, como pode ser visto na figura 7.1, requer a

utilizac?a?o de um segundo mo?dulo, que devera? ser configurado como uma unidade de

backup (sec?a?o 7.1), na?o podendo ser utilizado para nenhum outro fim, a na?o ser restaurar

uma co?pia de seguranc?a de um HSM. Entretanto, uma unidade de backup pode servir de

receptor de backup para va?rios HSM ao mesmo tempo.



80

Apo?s a preparac?a?o de um HSM para backup, o certificado cbkp deve

ser importado no HSM operacional (sec?a?o 7.2). Este processo permitira? que co?pias de

seguranc?a sejam criadas (sec?a?o 7.3) para posterior recuperac?a?o em caso de algum pro-

blema acontecer com o HSM operacional (sec?a?o 7.4).

Por fim, a sec?a?o 7.5 discute a questa?o do controle de ciclo de vida de

mu?ltiplas co?pias da mesma chave criptogra?fica em hardware criptogra?ficos diferentes.

7.1 Preparando um HSM para ser uma unidade de

backup

O primeiro passo para criac?a?o de co?pias de seguranc?a de um mo?dulo de

seguranc?a criptogra?fico e? preparar um HSM adicional para ser uma unidade de backup,

sendo que qualquer HSM que na?o tenha sido inicializado pode ser utilizado neste pro-

cesso.

Nenhuma informac?a?o dos mo?dulos criptogra?ficos ativos e? necessa?ria

para a criac?a?o de uma unidade de backup, que pode ser criado antes mesmo de existir um

HSM operacional.

O algoritmo prepareBkpU nit implementa o protocolo que prepara um

HSM para ser uma unidade de backup, requerendo como para?metro o identificador idbkp

que sera? utilizado como nome comum do certificado desta unidade.

Algoritmo prepareBkpUnit( idbkp )
Prepara um HSM para ser uma unidade de backup, gerando um par de chaves as-
sime?tricas krbkp e kubkp e emitindo um certificado auto-assinado a partir deste par
de chaves e o identificador do HSM idbkp passado como para?metro. O certificado do
HSM de backup e? exportado como resultado do algoritmo.
1: krbkp, kubkp ? genKeyPair()
2: cbkp ? genSelfSignedCert( krbkp, kubkp, idbkp )
3: store( BDS, krbkp, cbkp )
4: return cbkp

O processo de preparac?a?o de uma unidade de backup inicia com a

criac?a?o de um par de chaves criptogra?ficas de backup (krbkp e kubkp). No passo 2, um



81

certificado auto-assinado cbkp e? gerado a partir do identificador idbkp e o par de chaves

rece?m criado.

No passo 3, o certificado e a chave privada de backup sa?o armazenados

no sistema de armazenamento de dados de backup para que possam ser carregados pos-

teriormente no processo de recuperac?a?o de uma co?pia de seguranc?a. O algoritmo termina

exportando cbkp, que devera? ser importado nos HSM operacionais para iniciar o processo

de gerac?a?o de co?pias de seguranc?a.

A chave privada de backup krbkp e? armazenada em texto claro com

protec?a?o do per??metro criptogra?fico do HSM, que e? capaz de detectar, com a utilizac?a?o de

sensores, e responder a uma tentativa de invasa?o, apagando dados sens??veis a seguranc?a

do mo?dulo.

Uma vez preparado para ser um receptor de co?pias de seguranc?a, o HSM

deve ser armazenado em local seguro, aguardando a necessidade de recuperac?a?o de um

backup.

7.2 Importando o Certificado de Backup em HSM Ope-

racional

Como visto na sec?a?o anterior, a preparac?a?o de um HSM receptores de

backup inclui a exportac?a?o de um certificado. Este certificado deve ser enta?o importado

nos HSM operacionais, possibilitando a criac?a?o de co?pias de seguranc?a do mesmo.

O processo de importac?a?o de certificados de backup em um HSM e?

simples, mas requer muito cuidado. Por se tratar de um certificado X.509 auto-assinado,

que pode ser gerado em qualquer lugar, o grupo de administradores deve estar ciente da

sua procede?ncia, cabendo aos grupos de auditores a ana?lise dos registros de atividades do

HSM, a fim de descobrir eventuais falhas de gerenciamento.

Um HSM pode importar va?rios certificados de backup, aumentando o

nu?mero de unidades onde uma co?pia de seguranc?a pode ser recuperada. O algoritmo

importBkpCert implementa o protocolo de importac?a?o destes certificados, autenticando



82

o grupo de administradores do HSM para isso.

Algoritmo importBkpCert( cbkp )
Importa o certificado exportado no processo de criac?a?o de uma unidade de backup.
O grupo de administrador e? autenticado na execuc?a?o deste algoritmo.
1: ks ? authenticateGroup( ADS, ADM )
2: ekrh ? load( ADS )
3: krh ? decrypt( ekrh, ks )
4: scbkp ? sign( cbkp, krh )
5: store( BDS, scbkp )

O algoritmo importBkpCert inicia realizando a autenticac?a?o do grupo

de adminitradores, possibilitando a liberac?a?o da chave privada do HSM no passo 3. No

passo 4, o certificado de backup passado como para?metro e? reassinado com krh e poste-

riormente armazenado no sistema de armazenamento de backup.

Apo?s a importac?a?o do primeiro certificado de backup, co?pias de

seguranc?a do ambiente operacional do HSM podem ser criadas. Este e? o assunto da

pro?xima sec?a?o.

7.3 Backup

A gerac?a?o de co?pias de seguranc?a do ambiente operacional de um HSM

e? uma atividade essencial para continuidade do ciclo de vida das chaves gerenciadas e

deve ser executada regularmente, ja? que qualquer operac?a?o executada apo?s a criac?a?o do

backup sera? completamente perdida em caso de falha do HSM. As declarac?o?es de pra?ticas

de certificac?a?o das ICPs devem estabelecer a regularidade na qual as co?pias de seguranc?a

devem ser geradas.

Todas as chaves gerenciadas pelo mo?dulo sa?o exportadas de forma ci-

frada, garantindo que, mesmo fora do per??metro criptogra?fico do HSM, elas estejam se-

guras, seguindo os requisitos existentes nas normas FIPS PUB 140-2 e MCT-7.

O algoritmo bkpHsm, que implementa o protocolo de criac?a?o de uma

co?pia de seguranc?a de um HSM, autentica o grupo de administradores, por se tratar de

uma operac?a?o administrativa. Ale?m disso, o HSM deve possuir pelo menos um grupo



83

de auditores, que sera?o autenticados durante a recuperac?a?o da co?pia de seguranc?a, garan-

tindo que na?o existam co?pias paralelas do HSM sem pre?vio conhecimento da equipe de

auditoria.

Algoritmo bkpHsm()
Cria um co?pia de seguranc?a de um HSM operacional, autenticando seu grupo de
admistradores. A co?pia de seguranc?a podera? ser recuperada em todos as unidades de
backup que tiveram seu certificado importado no HSM. Lembrando que o sistema de
armazenamento de dados na?o exporta?veis N XD, como o nome ja? diz, na?o e? copiado.
1: ks ? authenticateGroup( ADS, ADM )
2: ekrh, ch ? load( ADS )
3: krh ? decrypt( ekrh, ks )
4: store( BP F , load( CT L ) )
5: store( BP F , load( ADS ) )
6: store( BP F , load( AudDS ) )
7: store( BP F , load( ODS ) )
8: store( BP F , load( KDS ) )
9: store( BP F , load( BDS ) )
10: Cbkp ? load( BDS ) )
11: ksbkp ? genSessionKey()
12: eBP F ? encrypt( BP F , ksbkp )
13: seBP K ? sign( eBP K, krh )
14: for cbkpi in Cbkp do
15: eksbkp ? encrypt( ksbkp, cbkpi )
16: end for
17: return seBKP , EKsbkp

O algoritmo inicia com os tre?s passos comuns para uma operac?a?o ad-

ministrativa, autenticando os administradores e obtendo acesso a chave privada e o certi-

ficado do HSM, krh e ch respectivamente.

Nos passos de 4 a 9, todos os dados relevantes ao ambiente operacional

do HSM sa?o copiados para o pacote do backup BP F , incluindo os sistemas de arma-

zenamento de dados dos grupos (ADS, ODS, AudDS), de chaves gerenciadas KDS,

de certificados confia?veis CT L e de dados de backup BDS. O u?ltimo e? necessa?rio por-

que mais de uma certificado de backup pode ter sido importado no HSM, permitindo que

mesmo apo?s recuperac?a?o da co?pia de seguranc?a, novos backups possam ser criados.

O sistema de armazenamento de dados na?o exporta?veis na?o e? copiado

durante este algoritmo, desabilitando operac?o?es administrativas sobre chaves gerenciadas



84

enquanto seu grupo de operadores responsa?vel na?o tenha conhecimento de sua existe?ncia.

O BP F enta?o precisa ser cifrado utilizando todos os certificados de

backup previamente importados no HSM, permitindo que a co?pia possa ser recuperada

em qualquer um deles. No passo 10, o conjunto de certificados de backup e? carregado.

Logo apo?s, gera-se uma chave sime?trica, ksbkp, que, no passo 12, sera? utilizada para cifrar

BP F . O passo 13 visa garantir a integridade do co?pia de seguranc?a, assinando eBP F

com a chave privada do HSM krbkp.

Nos passos 14 a 16, realiza-se uma iterac?a?o por todos os certificados

de backup existentes dentro do HSM, utilizando cada um deles para cifrar ksbkp, que ira?

resultar em um conjunto de chaves sime?tricas cifradas com diferentes chaves pu?blicas,

EKsbkp.

O processo de criac?a?o do backup esta? completo ao final do passo 16,

retornando a co?pia de seguranc?a do ambiente operacional cifrado e assinado e o conjunto

de chaves sime?tricas cifradas pelos certificados de backup, seBKP e EKsbkp respectiva-

mente.

7.4 Recuperac?a?o do Backup

A recuperac?a?o de co?pias de seguranc?a e? u?ltimo passo para permitir o

completo ciclo de vida de chaves criptogra?ficas gerenciadas em um HSM, incluindo os

casos de falhas de hardware ou desastres. Os certificados de backup existentes na co?pia

de seguranc?a delimitam o conjunto de unidades de backup que podem ser utilizadas para

recuperac?a?o.

Esta recuperac?a?o, ale?m de ser um operac?a?o administrativa, requer a

autenticac?a?o de um grupo de auditores, permitindo o conhecimento da equipe de auditoria

que uma nova insta?ncia do HSM esta? operacional, diminuindo a carga de responsabilidade

do grupo de administradores.

O algoritmo recoverBkp requer como para?metros de entrada o identi-

ficador do grupo de auditores que sera? autenticado durante o processo e os dados retorna-

dos do algoritmo de criac?a?o do backup, seBKP e EKsbkp, respectivamente o pacote de



85

backup cifrado e assinado e a chave sime?trica que cifra o pacote de backup cifrada com

cada um dos certificados de backup importados no HSM.

Algoritmo recoverBkp(seBKP , EKsbkp, idaudit)
Restaura o ambiente operacional de um HSM em um mo?dulo previamente preparado
para backup. O grupo de administradores e pelo menos um grupo de auditores sa?o au-
tenticados neste processo, sendo estas autenticac?o?es somente requeridas por questa?o
de seguranc?a, isto e?, na?o te?m objetivos criptogra?ficos.
1: krbkp ? load( BDS )
2: ksbkp ? decrypt( eksbkp, krbkp )
3: BP F ? decrypt( seBP F , ksbkp )
4: store( CT L, load( BP F ) )
5: store( ADS, load( BP F ) )
6: ch ? load( ADS )
7: verify(seBKP , ch)
8: ksadm ? authenticateGroup( ADS, ADM )
9: store( AudDS, load( BP F ) )
10: ksaudit ? authenticateGroup( AudDS, idaudit )
11: store( ODS, load( BP F ) )
12: store( KDS, load( BP F ) )
13: store( BDS, load( BP F ) )

O processo de recuperac?a?o de backup inicia carregando a chave privada

de backup krbkp do sistema de armazenamento de dados de backup BDS. Logo apo?s, a

chave sime?trica que cifra o backup, ksbkp e? decifrada. A chave liberada no passo 2 permite

que o pacote de backup seja decifrado no passo 3.

Os passos 4 e 5 restauram, respectivamente, o sistema de armazena-

mento de certificados confia?veis CT L e de administradores ADS. Este e? o conjunto

m??nimo de dados necessa?rio para verificar a integridade de seBKP no passo 7 e autenti-

car o grupo de administradores no passo 8.

O passo 9 restaura o sistema de armazenamento de auditores, que per-

mite a autenticac?a?o do grupo de auditores identificado por idaudit no passo 10.

E finalmente, nos passos 11, 12 e 13, os sistemas de armazenamento

restantes sa?o restaurados, respectivamente, os sistemas de armazenamento de dados de

operadores, chaves e backup.

O ambiente operacional do HSM, uma vez restaurado, sera? exatamente

igual ao momento em que a co?pia de seguranc?a foi criada, com excec?a?o do sistema de ar-



86

mazenamento de dados na?o exportados, N XD, que precisa ser recriado com o algoritmo

apresentado na sec?a?o 6.9.

7.5 Utilizac?a?o de Mu?ltiplos Ambientes Operacionais

A? medida que o nu?mero de insta?ncias de chaves criptogra?ficas operaci-

onais aumenta, maior e? a dificuldade para gerencia?-las, tornando mais complexo tambe?m

o processo de auditoria, ja? que, esta paralelizac?a?o das operac?o?es, difunde os usos de uma

chave criptogra?fica em va?rios ambientes.

Apesar disso, alguns situac?o?es requerem este tipo de abordagem, isto

e?, a criac?a?o de va?rios ambientes operacionais, com o objetivo de rapidez no processo de

retomada das atividades em caso de falha do ambiente principal ou em ambiente de alta

demanda, com necessidade de balanceamento de carga.

Muitas vezes, a realizac?a?o de uma cerimo?nia implica em custos finan-

ceiros e/ou log??sticos elevados em algumas organizac?o?es, se considerar a quantidade de

pessoas envolvidas e a dificuldade de reun??-las para uma nova tentativa. Por isso, para

garantir rapidez em caso de falha do ambiente operacional principal, pode-se configurar

um segundo ambiente ide?ntico ao primeiro, diminuindo assim os riscos de falha de todo

o processo, evitando que uma nova cerimo?nia seja necessa?ria.

A criac?a?o de uma ambiente operacional ide?ntico pode ser realizado uti-

lizando os mecanismos de criac?a?o e recuperac?a?o de co?pias de seguranc?a do HSM. O novo

HSM, uma vez restaurado, tera? os mesmos grupos e chaves gerenciadas que existiam no

primeiro. Assim, no caso de uma autoridade certificadora por exemplo, duas co?pias da

sua chave privada esta?o operacionais, bastando que o grupo de operadores responsa?vel a

libere para uso.

Entretando, como forma de diminuir ainda mais os riscos de falhas que

resultem no cancelamento de uma cerimo?nia, pode-se criar ambientes totalmente indepen-

dentes, isto e?, com a troca dos grupos de administradores e operadores do mo?dulo, sendo

que os novos grupos podem ser compostos dos mesmos membros e possuir a mesma

configurac?a?o dos grupos originais. Desta forma, e? poss??vel contornar ate? falhas nos smart-



87

cards dos membros dos grupos. Esta abordagem tambe?m se aplica em casos onde deseja-

se ambientes operacionais paralelos em localizac?o?es completamente diferentes umas das

outras.

A impote?ncia dos grupos de administradores e operadores em relac?a?o

aos grupos de auditores de um HSM permite que estes u?ltimos realizem auditoria de

qualquer uma das insta?ncias dos mo?dulos operacionais, desde que tenham sido criados

durante a preparac?a?o da primeira insta?ncia do HSM. Se novos grupos de auditores forem

criados apo?s a existe?ncia de mu?ltiplas insta?ncias, estes so? podem auditar o HSM em que

foram criados e as novas insta?ncias que foram recuperadas de co?pias de seguranc?a criadas

posteriormente a sua criac?a?o.

Ale?m disso, digamos que um HSM operacional possua um grupo de

administradores, um de operadores, um de auditores e gerencia uma chave criptogra?fica.

O processo de criac?a?o de co?pias de seguranc?a deste ambiente requer a autenticac?a?o do

grupo de administradores. A sua posterior restaurac?a?o para estabelecimento de um se-

gundo ambiente operacional requer a autenticac?a?o do grupo de administradores e de pelo

menos um grupo de auditores, portanto, a equipe de auditoria sempre vai saber quando

uma nova insta?ncia do HSM for estabelecida. Nessa nova insta?ncia, a utilizac?a?o da chave

gerenciada esta? limitada ao grupo de operadores que possui a responsabilidade por seu

uso, ja? que a propriedade de rastreabilidade das chaves gerenciadas do OpenHSM desfaz

o ponto de confianc?a dos grupos de operadores em relac?a?o ao grupo de administradores

em todas as co?pias de seguranc?a recuperadas. Este exemplo procura demostrar todos os

recursos providos pelos protocolos do OpenHSM de modo a estabelecer um controle ri-

goroso sobre o controle do ciclo de vida das chaves gerenciadas, mesmo nos processos de

criac?a?o e restaurac?a?o de co?pias de seguranc?a.

A utilizac?a?o de mu?ltiplos ambientes operacionais tambe?m se aplica no

balanceamento de carga para aplicac?o?es com alta demanda, se aplicando nestes casos o

uso de ambientes operacionais ide?nticos. Um exemplo de aplicabilidade desta arquitetura

e? a paralelizac?a?o da emissa?o de certificados e lista de certificados revogados por uma AC.



88

7.6 Conclusa?o

O protocolo do OpenHSM, utilizado para o gerenciamento do ciclo de

vida das chaves criptogra?ficas gerenciadas pelo ASI-HSM, foi publicado em eventos in-

ternacionais da a?rea para apreciac?a?o do mundo acade?mico, com sua versa?o mais atual

apresentada nestes dois u?ltimos cap??tulos, utilizando uma nova forma de representac?a?o.

Deu-se especial atenc?a?o aos protocolos de criac?a?o e recuperac?a?o de

co?pias de seguranc?a do material criptogra?fico, de forma a cobrir as lacunas em caso de

falhas de hardware ou desastres. Ale?m disso, extende-se essa funcionalidade de co?pias de

seguranc?a para o estabelecimento de mu?ltiplas insta?ncias de uma chave gerenciada.

Desta forma, tanto o OpenHSM quanto o ASI-HSM sa?o uma realidade

hoje, ja? estando instalado em 7 instituic?o?es de ensino brasileiras, aonde um projeto piloto

de avaliac?a?o da ICPEDU esta? em curso.



Cap??tulo 8

Conclusa?o

O suporte ao controle do ciclo de vida de mu?ltiplas co?pias de uma chave

em mo?dulos criptogra?ficos de mercado no contexto de uma infra-estrutura de chaves

pu?blicas praticamente inexiste e quando existe, o esquema e? proprieta?rio e restritivo a?

mesma fam??lia de produtos do fabricante. Mesmo assim, o controle e? ineficaz no sentido

de que na?o se consegue uma forte amarrac?a?o entre cada uma das co?pias das chaves, o que

dificulta sobremaneira a auditoria.

O problema e? maior quanto e? preciso manter as chaves por longo

per??odo de tempo, como e? o caso de uma autoridade certificadora. Normalmente, o tempo

de manutenc?a?o de uma chave de uma AC Raiz e? superior a 10 anos, o que e? muito maior

que o tempo me?dio esperado de vida u?til de um HSM de mercado. E? imperativo, portanto,

a possibilidade de criac?a?o e recuperac?a?o de co?pias de seguranc?a, com total controle, em

equipamento de diferentes fabricantes. Contudo, esta na?o e? a praxe de mercado.

Foi realizado um estudo das principais normas e recomendac?o?es naci-

onais e internacionais que regem a construc?a?o de mo?dulos criptogra?ficos. Percebeu-se

que nessas normas, o tratamento de mu?ltiplas co?pias do material criptogra?fico e? pouco

explorado. Aproveitou-se tal estudo para avaliar os protocolos do OpenHSM em relac?a?o

ao requisitos apostos nestas normas.

Este trabalho tem como maior contribuic?a?o o aprimoramento do

OpenHSM neste contexto, ou seja, como realizar uma co?pia de seguranc?a das cha-



90

ves criptogra?ficas, realizar sua restaurac?a?o e manter a rastreabilidade de cada uma das

co?pias. Todos os protocolos do OpenHSM foram analisados e onde necessa?rio foram

feitas modificac?o?es para se alcanc?ar esta rastreabilidade.

8.1 Resumo das Contribuic?o?es

O presente trabalho apresentou diversas contribuic?o?es de cara?ter te?cnico

e teo?rico-cient??fico, atingindo seus objetivos geral e espec??ficos, tais como os sumarizados

a seguir:

• revisou-se os hardware criptogra?ficos de mercado utilizados no gerenciamento do
ciclo de vida de chaves criptogra?ficas, com e?nfase nos smartcards e HSMs;

• detalhou-se da ferramenta criptogra?fica OpenSSL, com a apresentac?a?o de sua infra-
estrutura de suporte para usua?rios e desenvolvedores, focando-se particularmente no

desenvolvimento de engines, que permitem a integrac?a?o de aplicativos a hardware

criptogra?ficos;

• analisou-se os requisitos das normas FIPS 140-2 e MCT-7, utilizados na certificac?a?o
de HSMs. Esta ana?lise identificou pontos de extrema releva?ncia em relac?a?o ao uso

de HSMs no a?mbito de ICPs que na?o sa?o cobertos por estas normas, como um

forte sistema de auditoria e um r??gido controle das co?pias de seguranc?a do material

sens??vel;

• apresentou-se a arquitetura e as aplicac?o?es adicionais de um HSM como alvo para o
embarcamento do OpenHSM. Entres estas aplicac?o?es esta?o as interfaces de geren-

ciamento remoto e a engine que prove? integrac?a?o entre o HSM e outros aplicativos;

• revisou-se os protocolos de gerenciamento de chaves criptogra?ficas do OpenHSM,
propondo-se uma nova forma de representac?a?o. Essa revisa?o detalhou em particular

o esquema de criac?a?o e recuperac?a?o de co?pias de seguranc?a;



91

• apresentou-se formas de utilizac?a?o de mu?ltiplas insta?ncias de uma chave gerenciada
pelos protocolos do OpenHSM em diferentes ambientes operacionais. Esta abor-

dagem possibilita, entre outras, a ra?pida retomada das operac?o?es em caso de falha

do ambiente operacional principal ou visa suprir as necessidades de ambientes com

alta demanda de processamento;

• publicac?a?o de dois artigos em eventos internacionais, apresentando os protocolos
de gerenciamento de chaves criptogra?ficas do OpenHSM;

• preparac?a?o de um artigo de evento introduzindo te?cnicas iniciais de modelagem e
validac?a?o de cerimo?nias (ainda na?o submetido);

• preparac?a?o de um artigo de perio?dico que visa consolidar todo o conhecimento
adquirido no projeto dos protocolos do OpenHSM (ainda na?o submetido).

8.2 Trabalhos Futuros

As a?reas a se explorar com os protocolos de gerenciamento do ciclo de

vida de chaves criptogra?ficas do OpenHSM sa?o inu?meras, servindo de tema para va?rios

trabalhos futuros.

Uma destas a?reas e? o estudo detalhado para modelar e analisar ce-

rimo?nias, que desempenham papel fundamental na operacionalizac?a?o de um HSM, pre-

enchendo lacunas que hardware e software na?o sa?o capazes de resolver. Adicionalmente,

elas podem ser extendidas, integrando procedimentos de manipulac?a?o de outros sistemas,

como no caso de uma autoridade certificadora, onde o software de gesta?o de certificados

tambe?m requer atenc?a?o especial.

Outra a?rea importante de estudo e? a ana?lise formal dos protocolos do

OpenHSM, com o intuito de comprovar formalmente a efetividade dos mesmos no geren-

ciamento do ciclo vida das chaves criptogra?ficas gerenciadas em um HSM.

Finalmente, espera-se o aprimoramento dos HSMs comerciais, de

forma que estes passem a suportar funcionalidades de r??gido controle de suas co?pias de

seguranc?a e de utilizac?a?o de mu?ltiplas insta?ncias operacionais da mesma chave.



Refere?ncias Bibliogra?ficas

[1] REDE Nacional de Ensino e Pesquisa RNP. Dispon??vel em:&amp;lt;http://www.rnp.br/&gt;.

[2] SCHILLER, J. Protecting a Private Key in a CA Context. out. 2000. Dispon??vel em:

&lt;http://www.cren.net/crenca/pkirscpages/private key.html&gt;.

[3] SOUZA, T. C. S. Aplicac?o?es embarcadas para gerenciamento de chaves crip-

togra?ficas. [S.l.], 2005.

[4] MARTINA, J. E. Project of a Hardware Security Module focused on Public Key In-

frastructures and its Applications. Dissertac?a?o (Mestrado) — Federal University of

Santa Catarina, March 2005.

[5] MARTINA, J. E.; SOUZA, T. C. S. de; CUSTO?DIO, R. F. OpenHSM: An open

key life cycle protocol for public key infrastructure’s hardware security modules. In:

LOPEZ, J.; SAMARATI, P.; FERRER, J. L. (Ed.). EuroPKI. [S.l.]: Springer, 2007.

(Lecture Notes in Computer Science, v. 4582), p. 220–235. ISBN 978-3-540-73407-9.

[6] SOUZA, T. C. S. de; MARTINA, J. E.; CUSTO?DIO, R. F. Audit and backup

procedures for hardware security modules. In: SEAMONS, K. E.; MCBUR-

NETT, N.; POLK, T. (Ed.). IDtrust ’08: Proceedings of the 7th symposium on

Identity and trust on the Internet. ACM, 2008. (ACM International Conference

Proceeding Series, v. 283), p. 89–97. ISBN 978-1-60558-066-1. Dispon??vel em:

&lt;http://doi.acm.org/10.1145/1373290.1373302&gt;.

[7] RANKL, W. W.; EFFING, W. Smart Card Handbook. Third. pub-WILEY:adr: John

Wiley and Sons, Inc., 2004. xxviii + 1120 p. ISBN 0-470-85668-8.



93

[8] USB 2.0 TECHNICAL WORKING GROUPS. Universal Serial Bus Revision 2.0

specification. [S.l.], abr. 2000. Http://www.usb.org/developers/data/usb 20.zip.

[9] RIVEST, R. L.; SHAMIR, A.; ADLEMAN, L. A method for obtaining digital sig-

natures and public-key cryptosystems. Commun. ACM, ACM, New York, NY, USA,

v. 21, n. 2, p. 120–126, 1978. ISSN 0001-0782.

[10] COOPER, D. et al. Internet X.509 Public Key Infrastructure Certificate and Certifi-

cate Revocation List (CRL) Profile. abr. 2008. Internet RFC 5280.

[11] ISO 7816 - Smart Card Standards Overview. ISO Standards, 1998. Dispon??vel em:

&lt;http://www.iso.org/&gt;.

[12] RSA Laboratories. PKCS #15 v1.1: Cryptographic Token Informa-

tion Syntax Standard. pub-RSA:adr, jun. 2000. 81 p. Dispon??vel em:

&lt;http://www.rsasecurity.com/rsalabs/pkcs/pkcs-15/index.html&gt;.

[13] LEE, A.; BARKER, E. B.; BARKER, W. C. Guideline for Implementing Crypto-

graphy in the Federal Government. [S.l.], dez. 2005.

[14] MENEZES, A. J.; OORSCHOT, P. C. van; VANSTONE, S. A. Hand-

book of Applied Cryptography. CRC Press, 1997. (CRC Press series on dis-

crete mathematics and its applications). ISBN 0-8493-8523-7. Dispon??vel em:

&lt;http://www.cacr.math.uwaterloo.ca/hac/index.html&gt;.

[15] ISO/IEC STANDARD 15408. Common Criteria for Information Tech-

nology Security Evaluation. version 3.1. [S.l.], set. 2006. Dispon??vel em:

&lt;http://www.commoncriteriaportal.org/files/ccfiles/CCPART1V3.1R1.pdf&gt;.

[16] National Institute of Standards and Technology (NIST). Security Require-

ments for Cryptographic Modules. maio 2001. Federal Information Proces-

sing Standards Publication (FIPS PUB) 140-2. Updated 2002-12-03. Dis-

pon??vel em:&amp;lt;http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf,

http://csrc.nist.gov/cryptval/140-2.htm&gt;.



94

[17] National Institute of Standards and Technology (NIST). Security Requirements for

Cryptographic Modules. jan. 1994. Federal Information Processing Standards Publi-

cation (FIPS PUB) 140-1. Dispon??vel em:&amp;lt;http://csrc.ncsl.nist.gov/fips/fips1401.pdf,

http://csrc.ncsl.nist.gov/fips/fips1401.htm&gt;.

[18] FEDERAL COMMUNICATIONS COMMISSION. Code of Fede-

ral Regulations, Title 47, Part 15, Subpart B, Unintentional Radia-

tors, Digital Devices, v. 1. http://frwebgate.access.gpo.gov/cgi-bin/get-

cfr.cgi?TITLE=47&amp;amp;PART=15&amp;amp;SECTION=101&amp;amp;YEAR=1998&amp;amp;TYPE=TEXT:

FEDERAL COMMUNICATIONS COMMISSION, 1998.

[19] Instituto Nacional de Tecnologia da Informac?a?o (ITI). Requisitos, Materiais e

Documentos Te?cnicos para Homologac?a?o de Mo?dulos de Seguranc?a Criptogra?fica

(MSC) no A?mbito da ICP-Brasil. nov. 2007. Manual de Condutas Te?cnicas (MCT)

7. Dispon??vel em:&amp;lt;http://www.iti.br/twiki/pub/Homologacao/Documentos/MCT7 -

Vol.I.pdf&gt;.

[20] INSTITUTO Nacional de Tecnologia da Informac?a?o ITI. Dispon??vel em:

&lt;http://www.iti.br/&gt;.

[21] BRASIL. Medida Proviso?ria No 2.200-2. 2001. Medida Proviso?ria. Dispon??vel em:

&lt;http://www.iti.br/twiki/bin/view/Certificacao/MedidaProvisoria&gt;.

[22] National Institute of Standards and Technology. Data Encryption Standard (DES).

out. 1999. FIPS Publication 46-3.

[23] DAEMEN, J.; RIJMEN, V. Rijndael for AES. In: AES Candidate Conference. [S.l.:

s.n.], 2000. p. 343–348.

[24] RSA Laboratories. PKCS #1 v2.1: RSA Cryptography Standard. pub-RSA:adr,

jun. 2002. 61 p. Dispon??vel em:&amp;lt;http://www.rsasecurity.com/rsalabs/pkcs/pkcs-

1/index.html&gt;.



95

[25] PROCESSING Standards Publication 180-2. fev. 29 2004. Dispon??vel em:

&lt;http://citeseer.ist.psu.edu/641912.html; http://csrc.nist.gov/publications/fips/fips180-

2/fips180-2withchangenotice.pdf&gt;.

[26] MICROSOFT CryptoAPI and Cryptographic Service Providers.

[27] RSA. PKCS #11: Cryptographic Token Interface Standard. [S.l.], abr.

1997. Version 2.0. Dispon??vel em:&amp;lt;ftp://www.rsa.com/pub/pkcs/ps/pkcs-11.ps,

ftp://www.rsa.com/pub/pkcs/ascii/pkcs-11.asc&gt;.

[28] EUROPEAN UNION. Directive 2002/95/EC of the European Parliamente and of

the Council. [S.l.], jan. 2003.

[29] EUROPEAN UNION. DIRECTIVE 2002/96/EC OF THE EUROPEAN PARLIA-

MENT AND OF THE COUNCIL. [S.l.], jan. 2003.

[30] THE OpenSSL Project. Dispon??vel em:&amp;lt;http://www.openssl.org/&gt;.

[31] FREIER, A. O.; KARLTON, P.; KOCHER, P. C. The SSL Protocol — Version 3.0.

nov. 1996. Internet Draft, Transport Layer Security Working Group.

[32] DIERKS, T.; ALLEN, C. The TLS Protocol Version 1.0. nov. 1997. Internet Draft,

TLS working group.

[33] APACHE HTTP Server Project. Dispon??vel em:&amp;lt;http://httpd.apache.org/&gt;.

[34] RSA Laboratories. PKCS #10 v1.7: Certification Request Syn-

tax Standard. pub-RSA:adr, maio 2000. 10 p. Dispon??vel em:

&lt;http://www.rsasecurity.com/rsalabs/pkcs/pkcs-10/index.html&gt;.

[35] GORA, W. ASN.1 - Abstract Syntax Notation One. Bergheim: Datacom-Verlag,

1992. ISBN 3-89238-062-7.

[36] VIEGA, J.; MESSIER, M.; CHANDRA, P. Network Security with OpenSSL:

Cryptography for Secure Communications. pub-ORA:adr: O’Reilly &amp;amp; As-

sociates, Inc., 2002. xiv + 367 p. ISBN 0-596-00270-X. Dispon??vel em:

&lt;http://safari.oreilly.com/059600270X; http://www.oreilly.com/catalog/openssl&gt;.



96

[37] OPEN Source Software Institute. [S.l.]. Dispon??vel em:&amp;lt;http://www.oss-

institute.org/&gt;.

[38] AUTHORITIES, F. .-. C. M. V. FIPS 140-2 Validation Certificate #642.

Marc?o 2006. Dispon??vel em:&amp;lt;http://csrc.nist.gov/groups/STM/cmvp/documents/140-

1/140crt/140crt642.pdf&gt;.

[39] KELLAR, S. S. NIST-Recommended Random Number Generator

Based on ANSI X9.31 Appendix A.2.4 Using the 3-Key Triple DES

and AES Algorithms. pub-NIST:adr, jan. 2005. 4 p. Dispon??vel em:

&lt;http://csrc.nist.gov/groups/STM/cavp/documents/rng/931rngext.pdf&gt;.

[40] AUTHORITIES, F. .-. C. M. V. FIPS 140-2 Validation Certificate #733. Feve-

reiro 2007. Dispon??vel em:&amp;lt;http://csrc.nist.gov/groups/STM/cmvp/documents/140-

1/140crt/140crt733.pdf&gt;.

[41] AUTHORITIES, F. .-. C. M. V. FIPS 140-2 Validation Certificate #918. Feve-

reiro 2008. Dispon??vel em:&amp;lt;http://csrc.nist.gov/groups/STM/cmvp/documents/140-

1/140crt/140crt918.pdf&gt;.

[42] SHAMIR, A. How to share a secret. Commun. ACM, ACM Press, New York, NY,

USA, v. 22, n. 11, p. 612–613, 1979. ISSN 0001-0782.

[43] DOLEV, D.; YAO, A. C. On the security of public key protocols. IEEE Transactions

on Information Theory, v. 29, n. 2, p. 198–208, 1983.



Ape?ndice A

Convenc?o?es

Esta sec?a?o apresenta as convenc?o?es usadas nos cap??tulos 6 e 7 para des-

crever os algoritmos que implementam os protocolos do OpenHSM, com a tabela A.1

listando todos os sistemas de armazenamento de dados utilizadas.

Tabela A.1: Sistemas de armazenamento de dados utilizados no OpenHSM

Entidade Descric?a?o
ADS sistema de armazenamento de dados de administradores
AudDS sistema de armazenamento de dados de auditores
BDS sistema de armazenamento de dados de backup
BP F pacote do backup
CT L lista de Certificados Confia?veis
KDS sistema de armazenamento de dados de chaves
LDS sistema de armazenamento de registro de atividades do sistema
N XD sistema de armazenamento de dados na?o exporta?veis
ODS sistema de armazenamento de dados de operadores

Adicionalmente, apresenta-se a descric?a?o de todas as func?o?es utilizadas

nos algoritmos dos protocolos do OpenHSM, explicando seu objetivo e seus para?metros:

ctDecrypt( ct, edata, eu ) Envia para o smartcard ct os valores de edata e eu. Estes

dados sera?o enta?o decifrados utilizando a chave privada dentro do smartcard, resul-

tando, respectivamente, em data e u. O valor retornado do smartcard no final da

operac?a?o sera? data cifrado com u.



98

decrypt( edata, k ) Decifra edata utilizando a chave criptogra?fica k (sime?trica ou as-

sime?trica).

encrypt( data, k ) Cifra data utilizando a chave criptogra?fica k (sime?trica ou as-

sime?trica). Se k e? um certificado, sua chave pu?blica e? extra??da e utilizada.

deleteLog( LDS, rangeDate ) Apaga os registros do sistema armazenados em LDS

dentro do periodo de tempo especificado por rangeDate.

genCert( id, ku, cca, krca ) Emite um certificado utilizando ku como chave pu?blica e id

como nome comum. cca e krca sa?o respectivamente o certificado e a chave privada

da autoridade certificadora que emitira? o novo certificado.

genKeyPair() Gera um par de chaves assime?tricas.

genSelfSignedCert( kr, ku, id ) Emite um certificado auto-assinado contendo a chave

pu?blica ku e o nome comum id. A assinatura e? realizada com a chave privada kr.

genSessionKey() Gera uma chave sime?trica.

joinSecret( Ks ) Utiliza o conjunto de partes Ks para reconstruc?a?o do segredo. Entre-

tanto, Ks deve conter o nu?mero m??nimo de partes configuradas durante o compar-

tilhamento.

load ( DS[, id )] Carrega informac?o?es do sistema de armazenamento DS. (DS tambe?m

pode representar o computador utilizado na manipulac?a?o do HSM). Opcional-

mente, pode ser adicionado um identificador, id, que ira? restringir o conjunto de

informac?o?es resultantes.

manageKey( id, kr, ku, policy ) Submete o par de chaves gerenciadas ku e kr, identifi-

cada por id, ao controlador de chaves carregadas, ficando dispon??vel para uso por

aplicac?o?es externas ao HSM. A chave respeitara? a pol??tica de uso policy.

revokeGroupCerts( DS, id ) Revoga os certificados de todos os membros de um grupo

identificado por id. Os dados dos membros e seus certificados sa?o carregados de

DS.



99

sign( data, kr ) Assina os dados contidos em data utilizando a chave privada kr.

splitSecret( ks, k, n ) Compartilha ks utilizando o mecanismo de compartilhamento de

segredo, utilizando os limiares k e n, respectivamente, a quantidade de partes resul-

tantes do compartilhamento e o nu?mero m??nimo de partes necessa?rias para recons-

truir ks.

store ( DS, ... ) Armazena todos os dados passados por para?metro no sistema de arma-

zenamento DS.

xor ( ks1, ks2 ) Realiza a operac?a?o ou-exclusivo entre o conteu?do de ks1 e ks2.


</field>
	</doc>
</add>